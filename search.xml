<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACID</title>
    <url>/2018/11/24/ACID/</url>
    <content><![CDATA[<p>ACID 是指数据库管理系统（DBMS）在写入或者更新数据的过程中，为保证事务的正确可靠所具备的四个特征：原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。  </p>
<span id="more"></span>  

<h1 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h1><p>原子性是指，在一个事务中所有的操作，要么全部完成，要么全部不完成，不会结束在中间的某个环节。如果事务在执行过程中发生错误，会被回滚（rollback）到事务开始之前的状态，就像事务从来没有执行过一样。  </p>
<h1 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h1><p>一致性是指在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的数据完全符合所有预设的约束（唯一性约束、外键约束等）、触发器等。一个经典的例子就是银行转账，不管有几个账户参与转账，也不管事务是否成功，事务结束后总金额必须保持不变。  </p>
<h1 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h1><p>隔离性是指多个事务并发对数据进行读写和修改时，事务之间相互隔离，一个事务不应该影响其他事务的正确执行。隔离确保事务并发执行与按顺序执行后数据库的状态相同。SQL 标准根据事务之间影响的程度定义了四种隔离级别，不同的隔离级别下数据库事务的隔离程度不同，只有在使用最严格的隔离级别时，数据库的并发事务才不会出现任何问题，但是考虑到性能问题一般情况下不使用最高级别的隔离。  </p>
<h2 id="并发事务的影响"><a href="#并发事务的影响" class="headerlink" title="并发事务的影响"></a>并发事务的影响</h2><p>并发事务可能出现的影响主要分为：<strong>脏读、不可重复读、幻读</strong>以及<strong>丢失更新</strong>。脏读、不可重复读和幻读都是一个事务在读取，另一个事务在做更新或者添加、删除，而丢失更新是两个事务都在做更新操作。  </p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读可能发生在并发的读和写事务中，就是一个事务读到了另一个事务未提交的数据，而这个数据后来被回滚了。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>将余额改为 1500 元</td>
</tr>
<tr>
<td>T4</td>
<td>查询余额为 1500 元（脏读）</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>回滚事务，余额恢复为 1000 元</td>
</tr>
</tbody></table>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读可能发生在并发的读和写事务中，多次执行相同的查询却得到了不同的结果，这是因为在某次查询前后，事务 B 对符合事务 A 查询条件的数据进行了修改并提交。  </p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>查询余额为 1000 元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>更新余额改为 900 元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T6</td>
<td>查询余额为 900 元（与第一次读不一致）</td>
<td></td>
</tr>
</tbody></table>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读可能发生在并发的读和写事务中，多次执行相同的查询却得到了不同的结果，这个不同并不是列值不同，而是记录数不同。原因是在某次查询前后，事务 B 添加（删除不算）了符合事务 A 查询条件的记录。这里主要参考 <a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">ANSI SQL-92 规范中的定义</a>。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>统计所有存款超过 10000 元的用户</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>新增一个用户，存款为 20000 元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T6</td>
<td>再次统计所有存款超过 10000 元的用户，发现多了（幻读）</td>
<td></td>
</tr>
</tbody></table>
<h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><p>脏写可能发生在并发的写写事务中，两个未提交的事务同时修改同一数据，其中一个事务回滚导致另一个事务的修改被意外撤销。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>将余额改为 1100 元</td>
</tr>
<tr>
<td>T4</td>
<td>将余额改为 900 元（修改了另一个事务未提交的数据）</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>回滚事务</td>
</tr>
</tbody></table>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新可能发生在并发的写写事务中，一个事务修改了另一个未提交事务修改过的数据，最终先提交的事务修改过的数据被后提交的事务覆盖了。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>将余额改为 1100 元</td>
</tr>
<tr>
<td>T4</td>
<td>将余额改为 900 元（修改了另一个事务未提交的数据）</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
</tbody></table>
<h3 id="关于脏写和丢失更新"><a href="#关于脏写和丢失更新" class="headerlink" title="关于脏写和丢失更新"></a>关于脏写和丢失更新</h3><p>我个人的理解是：它们都是在一个事务中修改了另一个未提交事务修改过的数据。在任何隔离级别中，都不会允许出现一个事务修改别人还未提交的数据的情况，因为在写数据的时候会加排他锁，这样该事务的修改操作会等待另一个事务提交之后才能继续进行，此时再修改数据就不叫丢失更新了，这就是正常的更新操作，只不过这会导致咱们的业务层面产生数据不一致的问题。这类情况一般是在更新之前先查询了数据，并且之后的更新需要依赖该查询结果。看下面的这个例子：</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务 A</th>
<th>事务 B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额为 1000 元</td>
</tr>
<tr>
<td>T4</td>
<td>查询余额为 1000 元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出 100 元，余额改为 900 元</td>
</tr>
<tr>
<td>T6</td>
<td>存入 100 元，余额改为 1100 元</td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T8</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody></table>
<p>从结果来看，最终的余额变成了 1100 元，而实际上的余额应该是 1000 元。从逻辑上看，取出 100 元又存入了 100 元，余额的总量应该保持不变，这其实并不是数据库的问题，而是逻辑上的问题，需要我们从应用层面去解决。一般有两种解决方法，一种是在查询时加入排他锁，也就是使用 <code>SELECT ... FOR UPDATE</code> 语句；另一种就是使用乐观锁，即添加一个版本号字段，在查询数据时将版本号一同查出，在更新时通过 where 条件判断版本号与之前查询得出的是否一致，只有一致时才会更新。</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>数据库的并发控制用来避免或减小并发事务可能产生的影响，主要的并发控制方式有：乐观并发控制、悲观并发控制和 MVCC（多版本并发控制）。  </p>
<h3 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h3><p>为了避免并发事务产生的上述影响，就需要在执行可能引发问题的操作之前通过锁将该操作阻塞，在锁释放时恢复执行。  </p>
<h4 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h4><p>封锁使用的两种基本类型的锁包括：<strong>共享锁</strong>和<strong>排它锁</strong>。  </p>
<ul>
<li>共享锁又叫 S 锁，如果事务 T 对数据对象 R 加上了 S 锁后，其他事务只能对 R 再加共享锁，不能加排它锁。获得共享锁的事务只能读取数据，不能修改数据。  </li>
<li>排它锁又叫 X 锁，如果事务 T 对数据对象 R 加上了 X 锁后，其他事务不能再对 R 加任何类型的锁，<strong>但是可以不加锁地去读取 R</strong>。获得排它锁的事务既能读取数据，也能修改数据。</li>
</ul>
<h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><p>封锁的对象可以很大也可以很小，大的对象可以是整个表，甚至是整个数据库，小的对象可以是某一行数据或者是某一列字段等等，封锁对象的大小称为封锁的粒度。封锁的粒度越大，并发度也就越小（冲突的可能性也就越大），但是相对的系统开销也就越小；封锁的粒度越小，并发度也就越高（冲突的可能性也就越小），但是相对的开销也就越大。  </p>
<h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><p>在使用锁对数据对象加锁时，还需要定义一些规则。例如在何时申请锁，何时释放锁等。为此，数据库理论中提出了封锁协议的概念。  </p>
<ul>
<li><strong>一级封锁协议</strong><br>如果事务中对数据对象 R 有修改操作，则必须在该事务第一个读取数据对象 R 之前对其加 X 锁，直到事务结束才释放，事务结束包括正常结束（commit）和非正常结束（rollback）。在一级封锁协议中，如果仅仅是读取数据，并不对其进行修改，是不需要加锁的，因此它不能避免脏读和不可重复读，但是它可以避免丢失更新。  </li>
<li><strong>二级封锁协议</strong><br>在一级封锁协议的基础上，事务在读取数据对象 R 之前必须先对其加 S 锁，读取完毕后才能释放。二级封锁协议除了能够避免丢失更新以外，还可以避免脏读。但是由于读取完数据即可释放 S 锁，所以没有办法避免不可重复读。  </li>
<li><strong>三级封锁协议</strong><br>在一级封锁协议的基础上，事务在读取数据对象 R 之前必须先对其加 S 锁，直到事务结束才能释放。三级封锁协议除了能够避免丢失更新和脏读外，还进一步避免了不可重复读。</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离级别可以看作是三级封锁协议的具体应用和实现。在 SQL 标准规范中定义了四种隔离级别，包括：读未提交、读提交、可重复读和串行化。    </p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>可以避免的情况</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED（读未提交）</td>
<td>丢失更新</td>
<td>最低级别的隔离</td>
</tr>
<tr>
<td>READ COMMITTED（读提交）</td>
<td>丢失更新、脏读</td>
<td>只有在事务提交后，其更新的结果才能被其他事务看见</td>
</tr>
<tr>
<td>REPETABLE READ（可重复读）</td>
<td>丢失更新、脏读、不可重复读</td>
<td>在同一个事务中，对于同一份数据的读取结果总是相同的</td>
</tr>
<tr>
<td>SERIALIZABLE（串行化）</td>
<td>丢失更新、脏读、不可重复读和幻读</td>
<td>所有的事务串行化执行，隔离级别最高，可以解决所有的并发事务问题，但是性能最差</td>
</tr>
</tbody></table>
<p>在<strong>读未提交级别</strong>下，数据库遵循一级封锁协议，只对修改数据的并发操作做限制，即一个事务不能修改其他事务正在修改的数据，但是可以读取到（不加锁的读）其他事务中尚未提交的修改，如果这些修改被回滚，将会成为脏数据。  </p>
<p>在<strong>读提交级别</strong>下，数据库遵循二级封锁协议，只允许读取已经被提交的数据，即如果一个事务正在修改数据并且没有提交，其他事务不能读取该数据。在 MySQL 的 InnoDB 引擎中，这种操作虽然不被允许，但是 MySQL 不会阻塞这种读取操作，而是会查询出数据被修改之前的快照，这种机制被称为 MVCC（多版本并发控制）。MVCC 会在事务并发过程中对数据维护多个版本，不同的事务操作的是不同的数据版本。这种机制反映在应用中就是，在任何时候对数据的查询操作总是可以得到最近提交的数据，未被提交的数据会被隔离起来，无法查询到，从而防止脏读。  </p>
<p>在<strong>可重复读级别</strong>下，理论上数据库遵循的是三级封锁协议，但是出于性能考虑，MySQL 的 InnoDB 引擎还是遵循的二级封锁协议，但是在读取的过程中更多的依赖 MVCC。依靠 MVCC，在同一个事务中的查询只能查到版本号（时间戳或事务 ID）不高于当前事务的数据，即在事务中只能看到该事务开始前或者被该事务影响的数据。反过来说，即不允许事务读取在该事务开始之后新提交的数据，这样也就避免了不可重复读。  </p>
<p>依靠上面的机制，已经做到了在事务内数据的内容不变，但是不能保证多次查询得到的数据数量一致。因为在一个事务 T 执行的过程中别的事务完全可以执行数据的插入或删除，当插入或删除了刚好符合事务 T 查询条件的数据时，就会引发查询结果集的变化，导致幻读。InnoDB 提供的间隙锁机制可以在一定程度上避免幻读。  </p>
<p>在<strong>串行化级别</strong>下，所有的事务必须一个接一个地执行，这样虽然解决了并发事务的所有问题，但是会造成大量的事务等待、阻塞，系统性能最差。  </p>
<p>大多数的数据库管理系统默认使用的隔离级别就是 READ COMMITTED（读提交），比如 Oracle、SQL Server、PostgreSQL 和 Db2，而 MySQL 的 InnoDB 引擎默认使用的隔离级别是 REPETABLE READ（可重复读）。理论上可重复读只能避免脏读和不可重复读的问题，但是 MySQL 默认的隔离级别又通过 MVCC（多版本并发控制）避免了部分幻读的情况。至于为什么说是部分避免，可以参考<a href="https://segmentfault.com/a/1190000012669504">这篇文章</a>。  </p>
<blockquote>
<p>理论上，在任何隔离级别下，都不允许一个事务删除或者修改另一个事务影响但没有提交的数据。因为事务在增删或者修改数据时，会对数据对象加上排它锁，在该事务结束前，其他事务无法修改该数据，也就避免了丢失更新。  </p>
</blockquote>
<h3 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h3><p>乐观并发控制又被称为乐观锁，虽然它的名称中带有锁，但它依赖的是程序逻辑，并不依赖数据库的锁机制（<strong>这里有的说法是乐观锁在数据检查时会加锁，但是时间会很短，具体请参考知乎的<a href="https://www.zhihu.com/question/58687632">这篇问答</a></strong>）。乐观锁的一般做法是在数据库表中添加一个整型字段，通常叫做 version（版本号）。在读取数据时，连同该版本号一同读出。之后更新时，将提交数据的版本号和数据库表中的当前版本号对比，如果版本号相同，则予以更新；否则，说明已经该记录已经被其他事务更新过了，不予更新。在更新其他字段的同时，版本号字段要递增。逻辑类似如下：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询记录</span></span><br><span class="line"><span class="keyword">select</span> status, version <span class="keyword">from</span> goods <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新记录</span></span><br><span class="line"><span class="keyword">update</span> goods </span><br><span class="line"><span class="keyword">set</span> status <span class="operator">=</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125; <span class="keyword">and</span> version <span class="operator">=</span> #&#123;oldVersion&#125;</span><br></pre></td></tr></table></figure>

<p>乐观锁适用于读多写少的情况，即更新冲突很少发生的情况，因为如果冲突很严重，更新经常是失败的，上层应用可能就需要不断重试，这会导致很多次请求使用的资源被白白浪费。在并发冲突很严重的情况下，一般采用悲观锁，即数据库加锁的方式。  </p>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种并发控制的方式。并发控制最简单的方式就是加锁，但是这种方式性能很差。MVCC 使用了另一种思路，即每个数据库连接，在某个瞬间看到的数据只是数据库的一个快照，一个事务的写操作造成的影响在事务结束之前对于其他事务是不可见的。  </p>
<p>当一个事务需要更新一条数据记录时，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据，这样数据库就会存储多个版本的数据，但是只有一个是最新的。这种方式允许一个事务读取在它读之前就已经存在的数据，即使在读取的过程中这个数据已经被其他事务修改或者删除过了，对当前正在读的事务也没有任何影响。  </p>
<p>MVCC 并发控制下的读事务一般使用时间戳或者单向增长的事务 ID 去标记当前读的数据库的状态（或者叫做版本），读、写事务互相隔离，不需要加锁，写操作会根据当前数据库的版本，创建一个新的版本，并发的读事务依旧访问旧版本的数据。  </p>
<h1 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h1><p>持久性是指事务结束后，对数据的修改就会永久的保存在数据库中，即使设备发生了故障，如断电等。  </p>
<p>数据库的持久化一般都是通过 WAL（write-ahead logging）技术来实现的。在使用 WAL 技术的系统中，所有的修改在提交之前都要先写入到 log 文件中，log 文件通常包括 redo 和 undo 信息。这样我们就不用每次提交事务的时候把数据页冲刷到磁盘，因为我们知道在出现崩溃的情况下，可以通过日志来恢复数据库，任何尚未被附加到数据页的记录都将从日志记录中重做（向前滚动恢复，也叫作 redo），而那些未提交的事务做的修改都将从数据页中删除（向后滚动恢复，也叫作 undo）。在使用了 WAL 机制之后，磁盘写操作只有传统的回滚日志的一半左右，大大提高了数据库磁盘 I&#x2F;O 操作的效率，从而提高了数据库的性能。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">The SQL-92 standard</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_30531261/article/details/79479895">对数据库事务、隔离级别、锁、封锁协议的理解及其关系的理解</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/deliver/p/5730616.html">mysql 的锁–行锁，表锁，乐观锁，悲观锁</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/27876575">乐观锁和 MVCC 的区别？</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/YFYkuner/p/5178684.html">关于 MVCC 的基础</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>BF 算法与 KMP 算法</title>
    <url>/2019/03/19/BF%20%E7%AE%97%E6%B3%95%E4%B8%8E%20KMP%20%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>有两个字符串，求其中一个字符串在另一个字符串中出现的位置。我们将其中一个字符串称为主字符串，另一个字符串称为模式字符串，那么该问题可以描述为求模式字符串在主字符串中的位置。  </p>
<span id="more"></span>  

<h1 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h1><p>常规思路也就是两个字符串从左往右逐个字符比较，当字符不匹配时，主字符串从上一次开始比较的下一个位置开始，与模式字符串重新开始比较。这种方式也被称为<strong>朴素字符串匹配算法或者 BF（Brute Force）算法</strong>，在最坏情况下它的时间复杂度为 <code>O(n*m)</code>，其中 n 和 m 分别代表主串和模式串的长度。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 暴力查找</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ts 主字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ps 模式字符串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 模式字符串在主字符串中的位置，其中 &lt;tt&gt;-1&lt;/tt&gt; 表示无法匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">violentSearch</span><span class="params">(String ts, String ps)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] t = ts.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] p = ps.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == p[j]) &#123;</span><br><span class="line">            <span class="comment">// 匹配下标就加一</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配时，i 回退，j 直接归零</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示整个子串完全匹配，直接返回位置</span></span><br><span class="line">    <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个小难点就是如何计算上一次开始比较的下一个位置，即我们是如何得到 <code>i = i - j + 1</code> 这个逻辑的。</p>
<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><p>KMP 算法是一种改进的字符串模式匹配的算法，它的时间复杂度为 <code>O(n+m)</code>，其核心思想是<strong>当出现不匹配的字符时，不需要回溯主串的指针，而是利用已经得到的“部分匹配”，将模式字符串尽可能多地向右移动，然后重新比较。</strong>  </p>
<p>KMP 算法的核心是一个被称为部分匹配表（Partial Match Table）的数组。比如字符串 <code>abababca</code>，它的 PMT 如下：  </p>
<table>
<thead>
<tr>
<th>char</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>pmt</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>在解释这个表之前，首先需要解释一下字符串的前缀和后缀。比如字符串 <code>Saber</code>，它的前缀包括 <code>S</code>、<code>Sa</code>、<code>Sab</code> 和 <code>Sabe</code>，它的后缀包括 <code>r</code>、<code>er</code>、<code>ber</code> 和 <code>aber</code>。字符串本身不是自己的前缀或后缀。  </p>
<p>有了前缀和后缀的定义，就可以说明 PMT 中每个值的意义了。**PMT 中的值是字符串的前缀集合和后缀集合的交集中最长元素的长度。**比如，字符串 <code>aba</code>，它的前缀集合为 <code>a</code> 和 <code>ab</code>，它的后缀集合为 <code>a</code>、<code>ba</code>，两个集合的交集为 <code>a</code>，那么最长的元素的长度也就是 1。那么对于字符串 <code>abababca</code>，也就是在上表中，pmt[0] 的值为 0，pmt[1] 的值也是 0，pmt[2] 的值为 1，以此类推。  </p>
<p>比如要在字符串 <code>ababababca</code> 中查找字符串 <code>abababca</code>，如果在指针 j（或者 i）处字符不匹配，那么主串 i 指针之前的 PMT[j - 1] 位就一定与模式字符串的第 0 位到第 PMT[j - 1] 位是相同的。具体来说，因为在指针 j（或者 i）处不匹配，所以主串从 i - j 到 i 之前这段与模式字符串的 0 到 j 之前这段是完全相同的，在这个例子中就是 <code>ababab</code> 这段，它的前缀集合和后缀集合的交集的最长元素为 <code>abab</code>，长度为 4。所以可以说，主串 i 指针之前的 4 位与模式字符串的第 0 位到第 4 位是相同的，这样我们就可以省略掉这些字符的比较，保持 i 指针不动，将 j 指针指向模式字符串的 PMT[j - 1] 位（也就是第 4 位）即可。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/Qlw.png" alt="KMP 算法"></p>
<p>从上面可以看出，如果在 j 位置失配，那么 j 指针回溯的位置其实是第 j - 1 位置的 PMT 的值。为了编程方便（没有其他意义），我们将 PMT 数组整体向右偏移一位（其中第一位始终为 -1），我们把新得到的数组称为 next 数组。  </p>
<table>
<thead>
<tr>
<th>char</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>pmt</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>0</td>
</tr>
</tbody></table>
<p>此时，KMP 算法的主体部分我们很容易就能写出来了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* KMP 算法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ts 主串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ps 模式串</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String ts, String ps)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] t = ts.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] p = ps.toCharArray();</span><br><span class="line">    <span class="type">int</span>[] next = getNext(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || t[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是如何通过编码求得 next 数组了。求 next 数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主串，以模式字符串的前缀为目标字符串，从模式字符串的第一位（不包括第 0 位）开始对自身进行匹配，在任一位置，能匹配的最长长度就是当前位置的 next 值。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/qKM.png" alt="next2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/vGY.png" alt="next3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/DYk.png" alt="next4"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/7Om.png" alt="next6"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/jN4.png" alt="next7"></p>
<blockquote>
<p>之所以错开一位进行匹配，也就是用从 0 开始的模式字符串与从 1 开始的模式字符串匹配，是因为从 0 开始的 p 串对应的是字符串的前缀，而从 1 开始的 p 串对应的是字符串的后缀，之后双方都匹配的部分就是公共前后缀，也就是 PMT 数组的值。  </p>
</blockquote>
<p>明白了上面的逻辑，代码也就比较容易编写了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取 next 数组</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> p 模式字符串的字符数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] getNext(<span class="type">char</span>[] p) &#123;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[p.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || p[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/21923021">如何更好的理解和掌握 KMP 算法?</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BeanFactory 和 FactoryBean</title>
    <url>/2019/03/15/BeanFactory%20%E5%92%8C%20FactoryBean/</url>
    <content><![CDATA[<p>BeanFactory 和 FactoryBean 的区别面试经常会被问到，这里简单总结一下两者的区别，并结合具体的代码说明。  </p>
<span id="more"></span>  

<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>BeanFactory 是 Spring Framework 中一个很重要的接口，从接口名称我们应该能大概猜到它的作用：bean 的工厂。它提供最基本的从工厂获取 bean 实例的方法，我们日常使用的从各种 ApplicationContext 获取 bean 实例的方法都是实现自该接口。可以说，该接口是 Spring 容器最基本的形式，在它的基础上添加了一些更加高级的功能，包括国际化的消息访问、AOP 支持、Web 支持、事件传播等，才形成了我们日常使用的各种 ApplicationContext。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/kvA.png" alt="BeanFactory"></p>
<h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><p>一般情况下，Spring 是根据 bean 的配置信息，然后通过反射机制来实例化 bean 并放入容器中的，但是有时 bean 的实例化过程比较复杂，如果按照之前的方式，则需要大量的 bean 的配置信息，这时采用编码的方式来获得 bean 实例会更加简单直接。  Spring 就提供了这样一个接口：<code>org.springframework.beans.factory.FactoryBean</code>。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/dlM.png" alt="FactoryBean"></p>
<p>用户可以通过实现该接口来定制实例化 bean 的逻辑。Spring 会在实例化该 bean 时检查是否实现了该接口，如果实现了该接口则会通过 getObject() 方法获取实例对象。为了验证这个结论，我们可以从我们常用的 getBean() 方法入手。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">    <span class="comment">// 尝试从缓存中获取单例 bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略以下代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">        Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 bean 不是 FactoryBean，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 FactoryBean，则会根据用户传入的 name 来决定是返回 FactoryBean 实例</span></span><br><span class="line">    <span class="comment">// 还是通过 FactoryBean 的 getObject 方法返回实例。如果不是 FactoryBean 则会原样返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        <span class="comment">// 通过 FactoryBean 的 getObject 方法获取实例对象</span></span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">                object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">                <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">                    object = alreadyThere;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                            <span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">                            <span class="keyword">return</span> object;</span><br><span class="line">                        &#125;</span><br><span class="line">                        beforeSingletonCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                                    <span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterSingletonCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">        <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> getAccessControlContext();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 getObject 方法</span></span><br><span class="line">                object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用 getObject 方法</span></span><br><span class="line">            object = factory.getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName, ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line">    <span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(</span><br><span class="line">                    beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        object = <span class="keyword">new</span> <span class="title class_">NullBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP 原则与 BASE 理论</title>
    <url>/2018/11/25/CAP%20%E5%8E%9F%E5%88%99%E4%B8%8E%20BASE%20%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>分布式系统有一个重要的定理：布鲁尔定理（Brewer’s theorem），也被称为 CAP 定理。该理论由 Eric Brewer 在 2000 年的 PODC 会议上提出，后被证明从而成为一个定理。  </p>
<span id="more"></span>  

<h1 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h1><p>分布式系统中有三个要素，一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）。<strong>CAP 定理指出，一个分布式系统不能同时满足这三个要素，最多只能同时满足其中的两个</strong>。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性要求在任意时刻所有节点的数据完全一致，也就是说读操作总能返回最新的数据。对于调用者而言，数据具有<strong>强一致性，也可以叫做原子一致性（Atomic Consistency）或者线性一致性（Linearizable Consistency）。</strong></p>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>可用性是指对分布式系统的每个请求都可以在一定的时间内得到非错的响应，但是不保证获取到的数据是最新的。  </p>
<h2 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h2><p>分区容错性是指在网络分区的情况下，被分隔的节点仍能正常对外提供服务。比如：分布式系统的一个节点部署在东京，另一个节点部署在上海，它们本来能够互相通信并对外提供服务，但是可能由于海底光缆中断或者其他原因导致两个节点不能互相通信从而形成网络分区，网络分区单从字面上可以理解为系统被分隔成多个单独的部分，但是看回 CAP 的证明中对 P 的定义为：  </p>
<blockquote>
<p>In order to model partition tolerance, the network will be allowed to lose arbitrarily many messages sent from one node to another.  </p>
</blockquote>
<p>可以发现，网络分区符合该定义，但是网络丢包也同样符合，另外节点宕机造成的通信失败也符合该定义。在实际的效果上，分区相当于对通信有时限要求，分布式系统如果不能在时限内达成数据一致性，也就意味着发生了分区的情况。因此，基本上我们可以认为分区的问题无法避免，CAP 理论可以描述成：在满足分区容错的前提下，无法同时满足一致性和可用性。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/12/06/KJz.png" alt="CAP">  </p>
<h2 id="对-CAP-的误解"><a href="#对-CAP-的误解" class="headerlink" title="对 CAP 的误解"></a>对 CAP 的误解</h2><p>由于分布式系统天生就要满足分区容错性，所以 CAP 理论通常被简单理解成满足分区容错下的二选一，然而实际上一致性和可用性都有不同的程度和等级，比如一致性就分为<strong>强一致性、顺序一致性（Sequential Consistency）和弱一致性</strong>。很多时候可以根据实际情况放宽约束来兼顾一致性和可用性，这就引出了 BASE 理论。</p>
<h1 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h1><p>BASE 理论是 Basically available（基本可用）、Soft state（软状态）和 Eventual consistency（最终一致性）的缩写。BASE 是对 CAP 中一致性和可用性权衡的结果，它强调系统基本可用，即使无法做到强一致性，也可以通过适当的方式达到最终一致性。  </p>
<h2 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h2><p>基本可用是指系统在发生了不可预知的故障时，允许损失部分可用性。比如：响应时间延长、部分功能不可用等。  </p>
<h2 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h2><p>软状态是指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体的可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。  </p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>最终一致性是指系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。在实际的工程实践中，最终一致性根据更新数据后各进程访问到数据的时间和方式的不同大致又可以分为以下五类变种：  </p>
<ul>
<li>因果一致性（Causal consistency）<br>如果进程 A 通知进程 B 它更新了数据，那么进程 B 后续的读取操作则读取 A 更新的最新数据，更新操作也必须基于最新数据，而与进程 A 没有因果关系的其他进程则没有这种限制。  </li>
<li>读己所写一致性（Read your writes consistency）<br>如果进程 A 更新了数据，那么进程 A 的后续操作都会基于最新的数据，但是其他进程可以等待数据同步后获取到最新数据。  </li>
<li>会话一致性（Session consistency）<br>在客户端与服务端交互的整个会话阶段保证读己所写一致性。  </li>
<li>单调读一致性（Monotonic read consistency）<br>如果进程 A 已经读取了一个数据项的某个值后，那么后续该进程不会读到该数据项的更早的值。  </li>
<li>单调写一致性（Monotonic write consistency）<br>保证系统对于来自同一个进程的写操作会被顺序的执行。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/bangerlee/p/5328888.html">分布式系统理论基础 - CAP</a>  </p>
<p><a href="https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed">CAP 理论十二年回顾：”规则”变了</a>  </p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitmap</title>
    <url>/2019/08/27/Bitmap/</url>
    <content><![CDATA[<p>先考虑一个问题：有 40 亿个不重复且无序的无符号整数，如何判断一个整数是否在这 40 亿个整数中，要求使用的内存不超过 2GB。</p>
<span id="more"></span>

<p>假设使用 Java 语言，由于一个 int 类型的整数占用 4 个字节，如果使用 int 类型来存储这些数据，40 亿个整数占用大概 14.9GB（<code>40 亿 * 4/1024/1024/1024</code>）的内存，很明显这是不符合要求的。一个常规的思路就是将 40 亿个整数分片，每次读取一个分片到内存中进行判断。如果我们一定要一次性将这些数据存放到不超过 2GB 的内存中呢？这时我们就需要用到一个特殊的算法，这就是 Bitmap 算法。</p>
<h1 id="Bitmap-概述"><a href="#Bitmap-概述" class="headerlink" title="Bitmap 概述"></a>Bitmap 概述</h1><p>在《编程珠玑》中提到，所谓的 Bitmap 就是使用一个 bit 位来标记（使用 1 或 0 来标记）某个元素对应的 value，而 key 就是该元素。由于数据使用 bit 为单位来存储，因此需要的存储空间可以被大幅度地压缩。</p>
<p>从字面上好像不太好理解这个定义，下面通过一个例子来详细说明。假如我们需要对 0 到 7 之间的五个整数 <code>5 3 7 6 4</code> 进行排序，这五个整数没有重复。根据定义，要表示 0 到 7 之间的数就需要 8 bit 的存储空间。我们首先开辟 1byte 的空间，然后将这个空间中所有的 bit 位都置为 0。接下来遍历整数集合，第一个元素为 5 ，则将 5 对应的位置置为 1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/27/RRl.png" alt="第一次遍历"></p>
<p>以此类推，最终遍历的结果为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/28/mQB.png" alt="最终结果"></p>
<p>所有的数都落到了对应的位置上，接下来根据排序规则，将值为 1 的位置输出即可。</p>
<p>从上面的例子可以看出，使用 Bitmap 算法进行排序时，优点是运算效率相对较高，不需要进行比较和移位，并且通常内存占用极少。缺点是所有的数据不能重复，且只能对整数进行排序。当样本数据分布极度不均匀时，空间浪费严重。比如需要对 <code>3 4 2 7 99999</code> 这五个数进行排序时，就需要开辟 99999bit 的空间，而其中大部分空间永远不会被用到，浪费严重。</p>
<h1 id="快速查询"><a href="#快速查询" class="headerlink" title="快速查询"></a>快速查询</h1><p>我们回到一开始的题目上。在思考这个问题时，我就陷入了一个误区，我的思路是：这 40 亿个整数，我该如何通过 Bitmap 来存储呢？类似上面的排序过程，每个整数本身就是 key，通过这个 key 找到 Bitmap 上对应的位置，将值置为 1。按照这个思路，我需要知道这 40 亿个整数中最大的那个整数值是多少，只有这样我才能知道该分配多少 bit 的内存。</p>
<p>其实完全没有必要将这 40 亿个**整数本身（这是关键）**存放到 Bitmap 中，只需要通过某种方式将这 40 亿个整数映射到 Bitmap 中即可。所以此时我需要的内存容量其实为 40 亿 bit，每个 bit 位标记某一个整数是否存在（1 或 0），总共需要约 (40 亿 &#x2F;8&#x2F;1024&#x2F;1024) 476 MB 的内存，占用的空间缩小为原来使用 int 类型的 1&#x2F;32。</p>
<p>接下来需要做的就是，设计一个足够好的 Hash 算法，将这 40 亿个整数唯一映射到 Bitmap 上。假设已经找到了这么一个 Hash 函数，将需要判断是否存在的那个整数进行一次 Hash 运算，然后在 Bitmap 上查找该位置的值是否为 1 即可。如果是 1，则表示该整数已经存在；如果是 0，则表示不存在该整数。当然这都是理想状态下，实际能不能设计出这么一个 Hash 算法还不清楚，但是起码思路是正确的。</p>
<h1 id="快速去重"><a href="#快速去重" class="headerlink" title="快速去重"></a>快速去重</h1><p>尽量用少的内存，如何在 20 亿个整数中找出不重复的（或者重复的）整数个数？</p>
<p>像这一类问题，首先能够想到的是使用 Bitmap 算法。在之前的问题中，我们都是使用一个 bit 来表示数字是否存在，在该问题中显然不适用。在这里我们可以使用两个 bit 来表示数字的状态：00 表示不存在，01 表示存在一次，11 表示存在重复。接下来就是遍历这 20 亿个整数，将这些整数映射到 Bitmap 上。在映射的过程中，如果对应的状态位为 00，则置为 01；如果为 01，则置为 11；如果为 11，则不变。最终根据要求统计状态位的个数即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 Bitmap 可以对海量不重复的整数进行排序，也可以对海量的整数进行快速查询和快速去重。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS 初探</title>
    <url>/2021/03/29/CAS%20%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>CAS（中央身份认证服务，Central Authentication Service）是由耶鲁大学发起的一个企业级开源项目，目的是帮助 Web 应用系统构建一种可靠的单点登录解决方案。</p>
<span id="more"></span>

<h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><p>CAS 主要包含两大组件：CAS Server 和 CAS Client，它们之间可以通过各种协议进行通信。在使用 CAS 之前，除了 CAS Server 和 CAS Client，还需要了解 TGT、TGC 以及 ST。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104011547/2021/03/31/qNO.png" alt="CAS 的架构"></p>
<h2 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h2><p>CAS Server 的主要职责就是通过签发和验证 Ticket 来认证用户并授予其对 CAS Client 的访问权限。当用户成功登录后，CAS Server 会给用户签发一个 Ticket，同时还会创建一个 SSO 会话（该 Ticket 在这里被称为 TGT，TGT 会以 Cookie 的形式保存在浏览器中）。当用户访问某个服务时，CAS Server 会根据用户提供的 TGT 来签发一个 Ticket 作为令牌（该 Ticket 在这里被称为 ST），并通过浏览器重定向的形式返回。此时，该服务会拿着重定向 URL 中携带的 Ticket，向 CAS Server 验证有效性，以判断是否放行。</p>
<p>CAS Server 是通过 Spring Framework 搭建的一个 Java Servlet 应用，在较新的版本中，则使用了 Spring Boot 框架，因此可以直接使用内置容器。CAS Server 一般都是独立部署的。可以通过<a href="https://github.com/apereo/cas-overlay-template">该项目</a>快速部署一个 CAS Server。</p>
<h2 id="CAS-Client"><a href="#CAS-Client" class="headerlink" title="CAS Client"></a>CAS Client</h2><p>CAS Client 的主要职责就是保护 CAS 应用（可以理解为各种应用和服务，只不过它们都通过各种方式包装成了 CAS Client），并通过各种协议与 CAS Server 通信，以验证用户是否具有访问权限。</p>
<p>CAS Client 支持的软件平台和产品有很多，比如 Java、.NET、PHP 等等，不过与 Java 平台相比，其他平台的活跃性一般。</p>
<h2 id="TGT"><a href="#TGT" class="headerlink" title="TGT"></a>TGT</h2><p>TGT 全称为 Ticket-Granting Ticket，当用户登录成功后，用户的基本信息，登录有效期等信息都存储在这里。我们可以先简单地把用户登录后 CAS Server 为用户创建的 SSO 会话理解为我们之前使用的 HttpSession。在以前，我们的 Session 中会保存用户的一些信息，比如用户名。TGT 就是这些信息的一个封装。</p>
<h2 id="TGC"><a href="#TGC" class="headerlink" title="TGC"></a>TGC</h2><p>TGC 全称为 Ticket-Granting Cookie，TGT 会以 Cookie 的形式保存在浏览器中，用来维持与用户的会话。</p>
<h2 id="ST"><a href="#ST" class="headerlink" title="ST"></a>ST</h2><p>ST 全称为 Service Ticket，它是 CAS Sever 通过 TGT 给用户发放的一张 Ticket，用户在访问其他服务时，如果发现没有 Cookie 或者 ST ，那么就会 302 到 CAS Server 去获取 ST，然后再携带着 ST 回来，接着 CAS Client 会通过 ST 去 CAS Server 上获取用户的登录状态。</p>
<h1 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h1><p>下面通过官方给出的流程图来看下 CAS 单点登录的一般流程是怎样的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104011547/2021/03/31/4w6.png" alt="CAS 登录授权的一般过程"></p>
<p>首先用户通过浏览器访问受保护的 APP1，APP1 发现用户没有登录，所以返回 302，让用户到 CAS Server 的地址去登录，同时地址中还会包含一个 service 参数，对应的是 APP1 的地址。</p>
<p>接着浏览器会自动重定向到 CAS Server 的地址，由于用户没有与 CAS Server 建立 SSO 会话，所以用户需要登录。当用户登录成功后，CAS Server 会要求浏览器设置 TGC 并返回 302，让用户访问之前 service 参数指定的地址，同时地址中还会包含一个 ticket 参数，对应的就是 ST。</p>
<p>接着浏览器自动重定向到 APP1 的地址，并带有 ticket 参数。APP1 检测到 ticket 参数，会带着该参数去 CAS Server 验证 ticket 的有效性，验证成功后，APP1 会要求浏览器设置 session cookie 并返回 302，让用户重定向到 APP1 的地址（该地址不带 ticket 参数，目的是让浏览器地址栏隐藏 ST）。此时浏览器自动重定向，并带着 session cookie 访问 APP1，APP1 只需要验证 session cookie 即可确认是否放行。如果用户再次访问 APP1，只要 APP1 的 session cookie 还在，用户就可以一直访问 APP1。</p>
<p>当用户通过浏览器访问 APP2 时，同样 APP2 会返回 302，让用户到 CAS Server 去登录，地址中还会包含一个 service 参数，对应的是 APP2 的地址。由于用户的浏览器中带有 CAS Server 的 cookie（TGC），所以 CAS Server 会验证 TGT 的有效性，验证成功后会返回 302，让用户访问之前 service 参数指定的地址，同时地址中会包含一个 ticket 参数，对应的是 ST。接下来重复上述步骤，用户不需要再次登录就可以访问 APP2。</p>
<h1 id="CAS-Server-部署"><a href="#CAS-Server-部署" class="headerlink" title="CAS Server 部署"></a>CAS Server 部署</h1><p>CAS Server 一般不需要从头编写并部署，使用官方提供的一个起始项目 <a href="https://github.com/apereo/cas-overlay-template">cas-overlay-template</a>，通过少量的代码修改就可以快速部署。</p>
<blockquote>
<p>在写这篇文章时，CAS 的最新稳定版为 v6.3.3，它要求 JDK 的版本为 JDK 11，由于 Oracle JDK 协议的修改，我们最好安装一个 OpenJDK 11。</p>
</blockquote>
<p>首先将项目克隆下来，需要注意的是，该项目通过 Gradle 来构建，由于众所周知的原因，首先修改 <code>build.gradle</code> 配置文件中的 maven 地址为阿里云的镜像仓库地址 <code>maven &#123; url &quot;http://maven.aliyun.com/nexus/content/groups/public/&quot; &#125;</code>。</p>
<p>接着我们需要通过 <code>./gradlew.bat clean build</code> 命令来清理并构建项目，第一次构建的时候比较慢。在构建完成后，会在项目中生成一个 build 目录，其中 libs 目录下的 cas.war 就是整个 CAS Server 的部署文件。接着我们使用 <code>./gradlew.bat explodeWar</code> 命令可以将该 war 文件解压，解压后的文件位于 build 目录下的 cas-resources 目录，此时我们需要在 src&#x2F;main 目录下新建一个 resources 目录，并将 cas-resources 目录下的文件复制到该目录下。</p>
<p>CAS Server 从版本 4 开始，要求使用 HTTPS 进行通信，所以我们得提前准备 HTTPS 证书。如果是公司里的项目，可能需要购买 HTTPS 证书，自己玩的话可以申请一个免费的 HTTPS 证书，或者使用 <a href="https://github.com/FiloSottile/mkcert">mkcert</a> 来生成一个本地的 HTTPS 证书。</p>
<blockquote>
<p>在本地开发中，我们经常需要模拟 HTTPS 环境，比如 PWA 应用就要求必须使用 https 访问。在传统的解决方案中，我们需要使用自签证书，然后在 http server 中使用自签证书。由于自签证书浏览器不信任，所以我们需要将自签证书使用的 CA 证书添加到系统或浏览器的可信 CA 证书中来规避这个问题。以前完成这些操作需要执行一系列繁琐的 openssl 命令，现在可以直接使用 mkcert 这个工具来简化这一过程，生成本地的 https 证书，并且信任自签 CA。</p>
</blockquote>
<p>这里为了方便，我们就使用 mkcert 来生成一个本地的 HTTPS 证书。首先执行 <code>mkcert -install</code> 命令将 CA 证书添加到本地可信 CA 中，以后由该 CA 签发的证书在本地都是可信的。</p>
<p>接着使用 <code>mkcert -pkcs12 -p12-file filepath\localhost.p12 localhost 127.0.0.1</code> 命令生成一个 PKCS#12 文件格式的 HTTPS 证书（一般 PKCS#12 证书都需要一个加密口令，这里生成的默认口令是 changeit）。</p>
<p>最后我们需要通过 keytool 工具将该证书转换成 Java 特有的证书格式（KeyStore），以便 Tomcat 等容器识别。使用 <code>keytool -importkeystore -srckeystore &#39;filepath\localhost.p12&#39; -destkeystore &#39;filepath\localhost.keystore&#39;</code> 进行转换，转换过程中需要输入密码（changeit）。</p>
<p>我们将 keytool 转换后的证书文件放到 <code>src/main/resources</code> 目录下，然后修改 application.properties 文件内容：<code>server.ssl.key-store=classpath:localhost.keystore</code> 即可。</p>
<p>接下来我们可以使用 <code>./gradlew.bat run</code> 命令运行项目，也可以通过 <code>./gradlew.bat clean build</code> 命令构建新的 war 包后使用 <code>java -jar cas.war</code> 命令直接运行 war 包，然后通过地址：<code>https://localhost:8443/cas/login</code> 访问。</p>
<p>在不修改配置文件的情况下，默认的登录用户名和密码分别为：casuser 和 Mellon，这是通过 application.properties 文件配置的：<code>cas.authn.accept.users=casuser::Mellon</code>。一般后续会修改为通过数据库查询的方式验证，此时会注释掉该部分代码，并添加类似下面的代码：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># CAS Authentication Credentials</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">cas.authn.accept.enabled</span>=<span class="literal">false</span></span><br><span class="line"><span class="comment">#cas.authn.accept.users=casuser::Mellon</span></span><br><span class="line"><span class="comment">#cas.authn.accept.name=Static Credentials</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Common properties</span></span><br><span class="line"><span class="comment"># more info: https://apereo.github.io/cas/6.3.x/configuration/Configuration-Properties-Common.html#database-settings</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">user</span>=root</span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">password</span>=root</span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">driver-class</span>=com.mysql.jdbc.Driver</span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">url</span>=jdbc:mysql://localhost:<span class="number">3306</span>/cas?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-<span class="number">8</span>&amp;useSSL=<span class="literal">false</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">dialect</span>=org.hibernate.dialect.MySQL57Dialect</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Password Encoding</span></span><br><span class="line"><span class="comment"># more info: https://apereo.github.io/cas/6.3.x/configuration/Configuration-Properties-Common.html#password-encoding</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @See PasswordEncoderProperties</span></span><br><span class="line"><span class="comment"># 使用 Bcrypt 算法，Spring Security&#x27;s BCryptPasswordEncoder</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">password-encoder.type</span>=BCRYPT</span><br><span class="line"><span class="comment"># The encoding algorithm to use such as &#x27;UTF-8&#x27;. Relevant when the type used is &#x27;DEFAULT&#x27;</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].password-encoder.character-encoding=UTF-8</span></span><br><span class="line"><span class="comment"># The encoding algorithm to use such as &#x27;MD5&#x27;. Relevant when the type used is &#x27;DEFAULT&#x27; or &#x27;GLIBC_CRYPT&#x27;.</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].password-encoder.encoding-algorithm=MD5</span></span><br><span class="line"><span class="comment"># Secret to use with STANDARD, PBKDF2, BCRYPT, GLIBC_CRYPT password encoders. Secret usually is an optional setting.</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].password-encoder.secret=</span></span><br><span class="line"><span class="comment"># 表示 hash 杂凑次数，可选值为 4 到 31，数值越高越安全，默认 10 次</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">password-encoder.strength</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Query Database Authentication</span></span><br><span class="line"><span class="comment"># more info: https://apereo.github.io/cas/6.3.x/configuration/Configuration-Properties.html#query-database-authentication</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @See BaseJdbcAuthenticationProperties</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].credential-criteria=</span></span><br><span class="line"><span class="comment"># Name of the authentication handler</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].name=</span></span><br><span class="line"><span class="comment"># Order of the authentication handler in the chain</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].order=</span></span><br><span class="line"><span class="comment"># 用户登录时的查询语句</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">sql</span>=SELECT * FROM user WHERE username=?</span><br><span class="line"><span class="comment"># 匹配的密码属性列</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">field-password</span>=password</span><br><span class="line"><span class="comment"># 指定过期字段，tinyint(1) 类型，字段值为 1 表示过期，过期账号需要修改密码；值为 0 表示没有过期</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].field-expired=expired</span></span><br><span class="line"><span class="comment"># 指定禁用字段，tinyint(1) 类型，字段值为 1 表示禁用；值为 0 表示没有正常</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].field-disabled=disabled</span></span><br><span class="line"><span class="comment"># List of column names to fetch as user attributes</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].principal-attribute-list=uid,cn:commonName,age,id_card_num:idcardnum</span></span><br></pre></td></tr></table></figure>

<p>由于开启 Database Authentication 需要依赖 <code>cas-server-support-jdbc</code> 库，因此修改 build.gradle 文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Add modules in format compatible with overlay casModules property</span></span><br><span class="line">    <span class="keyword">if</span> (project.hasProperty(<span class="string">&quot;casModules&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">def</span> dependencies = project.getProperty(<span class="string">&quot;casModules&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        dependencies.each &#123;</span><br><span class="line">            <span class="keyword">def</span> projectsToAdd = rootProject.subprojects.findAll &#123;project -&gt;</span><br><span class="line">                project.name == <span class="string">&quot;cas-server-core-$&#123;it&#125;&quot;</span> || project.name == <span class="string">&quot;cas-server-support-$&#123;it&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            projectsToAdd.each &#123;implementation it&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS dependencies/modules may be listed here statically...</span></span><br><span class="line">    implementation <span class="string">&quot;org.apereo.cas:cas-server-webapp-init:$&#123;casServerVersion&#125;&quot;</span></span><br><span class="line">    <span class="comment">// 由于该库依赖的 MySQL 驱动版本过高，所以需要排除掉后自行设置</span></span><br><span class="line">    implementation (<span class="string">&quot;org.apereo.cas:cas-server-support-jdbc:$&#123;casServerVersion&#125;&quot;</span>) &#123;</span><br><span class="line">        exclude <span class="attr">group:</span> <span class="string">&quot;mysql&quot;</span>, <span class="attr">module:</span> <span class="string">&quot;mysql-connector-java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    implementation <span class="string">&quot;mysql:mysql-connector-java:5.1.49&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU Cache 与缓存一致性</title>
    <url>/2022/02/07/CPU%20Cache%20%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<p>在计算机中，存储体系是一个典型的金字塔结构，按照速度排列从上到下依次是：CPU 寄存器、CPU Cache（L1&#x2F;L2&#x2F;L3）、内存、SSD 固态硬盘以及 HDD 传统机械硬盘。越上层的存储设备速度越快，当然价格也更贵，容量也越小。</p>
<span id="more"></span>

<p>从广义上讲，上一级的存储器都是下一级存储器的缓存。当然这里我们只关注 CPU Cache。现代 CPU 缓存通常都有三个等级，分为 L1、L2 和 L3，其中 L1 和 L2 在每个 CPU 核心中都有，而 L3 则是所有核心共享的。在 L1 高速缓存中，指令和数据是分开存储的；而在 L2 和 L3 中则不区分，称为统一缓存（unified cache）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/07/wEP.png" alt="CPU Cache"></p>
<p>在 Linux 系统中，我们可以通过以下命令来查看 L1&#x2F;L2&#x2F;L3 的大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># L1 数据缓存</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/size</span><br><span class="line">32K</span><br><span class="line"></span><br><span class="line"><span class="comment"># L1 指令缓存</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index1/size</span><br><span class="line">32K</span><br><span class="line"></span><br><span class="line"><span class="comment"># L2</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index2/size</span><br><span class="line">256K</span><br><span class="line"></span><br><span class="line"><span class="comment"># L3</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index3/size</span><br><span class="line">3072K</span><br></pre></td></tr></table></figure>

<h1 id="CPU-Cache-映射策略"><a href="#CPU-Cache-映射策略" class="headerlink" title="CPU Cache 映射策略"></a>CPU Cache 映射策略</h1><p>CPU Cache 从内存读取到的数据是一块一块存储的，这一块可以理解为 CPU Cache 的最小缓存单位，它有一个专门的名字：Cache Line，一般它的大小为 64 Byte。在 Linux 中可以通过以下命令来查看它的大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<p>由于 CPU Cache 与内存容量上的差异，必然需要某种映射规则，来确定 Cache Line 与内存地址的关系，这种关系就是我们所说的映射策略，一般常见的策略有：直接映射、全相联和组相联。</p>
<h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p>直接映射是一种多对一的映射，这种方式下，主存中的每个内存块只能有一个 Cache Line 与之对应，因此它也叫做“单路组相联”。具体来说就是使用内存块地址对 Cache Line 的个数取模。比如内存共被划分了 32 个内存块，而 CPU Cache 共有 8 个 Cache Line，假如 CPU 想要访问第 15 号内存块，如果该内存块的数据已经缓存在了 Cache Line 中，那么一定是映射在了 7 号 Cache Line 中。一般来说，缓存的索引号可以通过以下公式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I = (Am / B) mod N</span><br></pre></td></tr></table></figure>

<p>其中 I 为缓存索引，Am 为内存地址，B 为 Cache Line 的大小，N 为 Cache Line 的个数。Am 除以 B 是内存块的个数。</p>
<img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/mgx.png" alt="直接映射" style="width: 60%" />

<p>直接映射的优点就是结构简单，易于实现，但是存在显著的冲突问题。由于多个不同的内存块会共享同一个缓存块，一旦缓存失效则必须将缓存块当前的数据清除，这在频繁更换缓存内容时会造成大量的延迟，并且也无法有效利用程序运行期间所具有的时间局部性特征（近期访问的地址在不久的将来很有可能被再次访问）。</p>
<h2 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h2><p>组相联是把缓存划分为多个组，每个组有若干个 Cache Line。用一句话来概括就是：组间直接映射，组内全相联。以下是一个 2 路组相联的例子：</p>
<img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/nOA.png" alt="2 路组相联" style="width: 60%" />

<p>上图将缓存分成了 s 组，每组 2 个 Cache Line，即 2 路（2 ways），主存中的每个数据块只能位于分组中的某一个，但是可以在指定分组中的任意一个 Cache Line 中。一般来说，组相联的缓存索引可以通过以下公式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I = (Am / Nw / Na) mod N</span><br></pre></td></tr></table></figure>

<p>其中，I 为缓存索引，Am 为内存地址，Nw 为缓存块内字数（也可以认为是 Cache Line 的大小），Na 为相联路数，N 为分组个数。</p>
<h2 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h2><p>全相联是指主存中的数据块可能出现在任意一个 Cache Line 中，这种方式使得替换具有最大的灵活性（可以使用 LFU 或者 LRU 等算法），同时也意味着有最低的 miss 率。但是由于没有索引可以使用，检查一个 cache 是否命中需要在整个 cache 范围内搜索，这带来了查找电路的大量延时。因此只有在缓存极小的情况才有可能使用这种方式。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实上面的三种映射方式，其实都可以看作是组相联，直接映射是单路组相联，而全映射则只有一个分组。因此，一个主存地址映射到高速缓存大体上有三个步骤：组选择（查找 Cache Set），行匹配（查找 Cache Line）和字抽取（查找 Cache Line 中一个字的起始字节）。</p>
<p>比如一个 32 位系统的内存地址映射到 4 MB 高速缓存中。首先是组选择，对于直接映射来说，分组数等于 Cache Line 的个数：65536，也就意味着需要中间 16 bit 来表示 Cache Line 的编号。接下来是行匹配，对于直接映射来说，一个分组只有一个 Cache Line，不用选择。最后是字抽取，由于一般 Cache Line 的大小是 64 Byte，同时现代处理器中，存储单元一般是以字节为单位的，也是最小的寻址单元，这也就意味着一个 Cache Line 可以存储 64 个存储单元，因此内存地址的低位 6 个 bit 用于表示在 Cache Line 中的偏移量（数据从第几个字节开始）。剩余的高位 10 bit 作为内存地址的一部分，同样也会映射到 Cache Line 中，作为标记位。</p>
<img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/677.png" alt="组映射" style="width: 90%" />

<p>上图是组映射的一般表示，对于一个 E 路组相联来说，缓存被划分为了 2^s 组，即通过内存地址的中间 s 位即可找到目标 Cache Line 的对应分组。找到分组后，遍历分组中所有的 Cache Line，检查 Cache Line 中的有效位，以及对比 Cache Line 中的标记位与内存地址的高位 t bit 是否一致。当 tag 和 valid 校验成功，我们称为缓存命中，此时只需要根据内存地址的低位 b bit 计算出 Cache Line 中数据的起始字节，向后读取一个字放入 CPU 寄存器即可。</p>
<img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/31e.png" alt="内存地址的一般表示" style="width: 90%" />

<blockquote>
<p>计算机各个硬件之间进行信息传递是通过贯穿整个系统的一组电子管道，称做总线，它携带信息字节并负责在各个部件间传递。硬件之间进行信息交流需要有一个统一的标准，也就是二进制信息传递规则，为了高效考虑，通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，在各个系统中的情况都不尽相同。操作系统中的 32 位（4 个字节）或 64 （8 个字节）位就叫总线的字长单位。</p>
</blockquote>
<h1 id="写回和写直达"><a href="#写回和写直达" class="headerlink" title="写回和写直达"></a>写回和写直达</h1><p>既然有缓存，那必然会出现缓存与主存数据不一致的情况，此时就需要将最新的数据更新到对应的内存当中。通常有两种更新方式：写直达（Write Through）和写回（Write Back）。写直达要求 CPU 在写数据的时候，同时更新缓存和内存，这样缓存和内存的数据就会始终保持一致，但是对性能影响较大。而写回则要求 CPU 在写数据的时候，仅修改缓存，只有当缓存需要被替换时才会去更新内存，这样就大大减少了写内存的操作，提高了性能。关于写回，我们详细展开描述。</p>
<p>如果发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个标记代表 CPU Cache 里的这个 Cache Block 的数据和内存是不一致的，此时不需要把数据写到内存里。</p>
<p>如果发生写操作时，数据对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的，如果是脏的话，就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Block 里，同时也把它标记为脏的；如果 Cache Block 里面的数据没有被标记为脏，则直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的即可。</p>
<h1 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h1><p>在多核 CPU 中，由于每个核心都有自己的 L1 和 L2 缓存，因此必然存在核心之间的缓存一致性问题，MESI 协议就是为解决这个问题而存在的。在 MESI 协议中，Cache Line 有 4 种不同的状态：</p>
<p>已修改（Modified），表示缓存行是脏的，与主存的值不一致，如果别的 CPU 核心要读取主存中的这块数据，该缓存行必须写回主存，然后缓存行的状态变为共享。</p>
<p>独占的（Exclusive），表示缓存行只在当前缓存中，与已修改不同的是，该缓存行是干净的，即没有发生修改。CPU 可以直接对其进行修改，然后状态变为已修改。</p>
<p>共享的（Shared），表示缓存行也存在于其他缓存中且都是干净的。处于该状态的缓存行不能直接被修改，需要该 CPU 核心向其他核心广播一个消息，要求其他拥有相同数据的核心把各自对应的缓存行标记为无效。</p>
<p>无效的（Invalid），表示缓存行是无效的，不可以再读取该状态的缓存行数据。另外，一般的 Cache 会优先填充 Invalid 状态的缓存行。</p>
<p>缓存行的状态转换可以通过一个有限状态机来描述，触发状态转换的场景有两种：缓存所在处理器的读写，其他处理器的读写。有时一个处理器对于缓存的请求可能需要通过总线来发送，而总线请求会被总线窥探器监听。以下是<strong>某个 CPU 操作时，当前缓存行的状态转换表：</strong></p>
<table>
<thead>
<tr>
<th>初始状态</th>
<th>操作</th>
<th>响应</th>
</tr>
</thead>
<tbody><tr>
<td>Invalid</td>
<td>读</td>
<td>此时向总线发送读缓存的请求，其他处理器监听到该请求后，会检查自己是否有有效的数据副本。如果有，则通过总线发送该数据副本，此时该缓存行状态变为 Shared；如果没有，则会请求主存获取数据，缓存行状态变为 Exclusive</td>
</tr>
<tr>
<td>Invalid</td>
<td>写</td>
<td>此时向总线发送写缓存的请求，其他处理器监听到该请求后，会检查自己是否有有效的数据副本。如果有，则其中一个通过总线发送该数据副本，同时这些拥有有效副本的缓存都将设置为 Invalid；如果没有，则会请求主存获取数据。为什么要获取最新的值？答案是因为此前没有该缓存，获取是为了独占缓存。之后该处理器会向缓存块中写入修改后的值</td>
</tr>
<tr>
<td>Exclusive</td>
<td>读</td>
<td>只有当前处理器拥有该缓存，因此不会发送总线请求，状态保持不变</td>
</tr>
<tr>
<td>Exclusive</td>
<td>写</td>
<td>只有当前处理器拥有该缓存，因此不会发送总线请求，此时直接写入修改后的值，缓存行状态变为 Modified</td>
</tr>
<tr>
<td>Shared</td>
<td>读</td>
<td>没有总线请求产生，状态保持不变</td>
</tr>
<tr>
<td>Shared</td>
<td>写</td>
<td>其他处理器拥有该缓存，因此需要发送总线请求，其他处理器监听到该请求后，会将自己的有效副本标记为 Invalid，然后当前缓存行的状态变为 Modified</td>
</tr>
<tr>
<td>Modified</td>
<td>读</td>
<td>此时没有总线请求产生，直接读取缓存，状态保持不变</td>
</tr>
<tr>
<td>Modified</td>
<td>写</td>
<td>同样没有总线请求产生，同时状态保持不变，直接修改缓存为新值即可</td>
</tr>
</tbody></table>
<p>写操作仅在缓存行是已修改或者独占状态时可以自由执行，如果在共享状态，其他处理器的缓存都需要先设置为无效，这种广播操作称为 RFO（Request For Ownership）。对于已修改状态的缓存行，要监听各处理器对其的读请求，发送其数据到总线的同时还要写回主存。对于共享状态的缓存行，要监听使其无效或请求拥有的广播，当匹配时把该缓存行置为无效。</p>
<h1 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h1><p>当某个处理器尝试修改其他处理器的 Cache Line 中的数据时，MESI 的广播操作带来的延迟对于处理器来说是难以忍受的。为了解决这个问题，在 CPU 和 Cache 中间又引入了 Store Buffer。这是一个容量比高速缓存还小的私有部件，当处理器需要修改数据时，会先将数据写入写缓冲器中，然后继续处理其他事情，当收到其他处理器的响应时，才将数据从写缓冲器转移到 Cache Line 中。</p>
<img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202203041757/2022/03/04/ova.png" alt="Store Buffer" style="width: 70%" />

<h1 id="Store-Forwarding"><a href="#Store-Forwarding" class="headerlink" title="Store Forwarding"></a>Store Forwarding</h1><p>在同一个处理器中，写缓冲器的引入必然会带来一个问题，即异步操作引发的数据滞后性。自处理器的写操作将最新的数据放入写缓冲器时起，高速缓存中的数据就已经过时，此后所有的加载操作看到的都是旧的数据，直到写缓冲器将数据同步到高速缓存。</p>
<p>为了解决这个问题，硬件工程师实现了 Store Forwarding 技术，这个技术可以使 CPU 直接从 Store Buffer 加载数据，即支持将 CPU 放入 Store Buffer 的数据传递给后续的加载操作而不经过高速缓存。</p>
<img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202203041757/2022/03/04/Bwe.png" alt="Store Forwarding" style="width: 70%" />

<p>需要注意的是，虽然处理器可以直接读取其 Store Buffer 中自己以前的写操作，但是在将这些操作从写缓冲区刷新到高速缓存之前，其他处理器是无法看到这些写操作的。这就意味着，Store Forwarding 技术只能解决单个处理器中的缓存滞后问题，无法解决多核处理器的此类问题。</p>
<h1 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h1><p>由于 Store Buffer 的容量很小，因此它很容易就会被填满，此时处理器必须等待它发出的使缓存无效的广播请求得到响应，才可以将 Store Buffer 中的数据转移到高速缓存，从而释放空间。</p>
<p>为了解决这个同步操作带来的延迟问题，硬件工程师又为每个处理器添加了一个无效队列。处理器在监听到使缓存无效的消息后，直接将消息放入无效队列中排队，然后立即发送回复消息，这就大大降低了响应的延迟。</p>
<blockquote>
<p>有些处理器并没有实现 Invalid Queue。</p>
</blockquote>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>内存屏障（memory barrier）又叫内存栅栏（memory fence），其目的是用来阻止 CPU 对指令的重排序（有些编译器也会对指令进行重排序）。根据 CPU 对于变量的操作读（load）和写（store），两两组合可以有四种内存屏障：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad 屏障</td>
<td>保证屏障前的 load 操作一定在屏障后的 load 操作之前完成</td>
</tr>
<tr>
<td>StoreStore 屏障</td>
<td>保证屏障前的 store 操作一定在屏障后的 store 操作之前完成</td>
</tr>
<tr>
<td>LoadStore 屏障</td>
<td>保证屏障前的 load 操作一定在屏障后的 store 操作之前完成</td>
</tr>
<tr>
<td>StoreLoad 屏障</td>
<td>保证屏障前的 store 操作一定在屏障后的 load 操作之前完成</td>
</tr>
</tbody></table>
<p>内存屏障除了有阻止指令重排序的作用，还与 MESI 协议有关。我们知道 MESI 为了优化性能，引入了 Store Buffer 和 Invalid Queue，因此写类型的内存屏障还能触发内存的强制更新，让 Store Buffer 中的数据立刻写回到高速缓存中。读类型的内存屏障会让 Invalid Queue 中的缓存行在后面的 load 操作之前全部标记为失效。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/">关于CPU Cache – 程序猿需要知道的那些事</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/296949412/answer/760347883">既然 CPU 有缓存一致性协议（MESI），为什么 JMM 还需要 volatile 关键字？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM 加载与脚本执行</title>
    <url>/2017/06/09/DOM%20%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>在写这篇文章之前，还在感慨前端变化之快，各种前端框架层出不穷，四年前（大一）在我刚接触 jQuery 时，觉得这就是神器啊，而现在 jQuery 在一些场景似乎已经被替代。		<br>		<br>收回思绪，回到这篇文章，首先回顾一下 DOM 文档加载的步骤。  </p>
<span id="more"></span>		

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 解析 HTML 结构</span><br><span class="line">2. 加载外部脚本和样式表文件</span><br><span class="line">3. 解析并执行脚本代码</span><br><span class="line">4. DOM 树构建完成 // DOMContentLoaded</span><br><span class="line">5. 加载图片等外部资源</span><br><span class="line">6. 页面加载完毕 // window.onload		</span><br></pre></td></tr></table></figure>
<p>从加载顺序可以看出，JavaScript 脚本会在 DOM 树构建完成之前执行，但是如果我们的脚本在执行时使用了还未加载完毕的 DOM 对象，就会出错，所以我们一般将脚本放到 body 结束之后，html 结束之前执行，这样做是因为，一般的页面在 body 结束时，基本上 DOM 解析也就结束了，这样相当于将我们的脚本放在了上述的步骤 4 之后，步骤 5 之前来处理。或者更靠谱的是，根据两个重要步骤点及对应的事件： <code>DOMContentLoaded</code> 和 <code>window.onload</code> 来处理我们将要执行的脚本。当然，在实际的使用中，我们更多的是针对步骤 4 进行处理，因为如果针对步骤 6 来处理，需要等到外部资源加载完毕才能响应我们的脚本。  </p>
<h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p>addEventListener() 不兼容 IE9 以前的浏览器  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">load</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入门</title>
    <url>/2017/07/23/Docker%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h2><p>直接贴上官网的一句介绍：</p>
<blockquote>
<p>Docker is the world’s leading software container platform		</p>
<p>Docker 是世界领先的软件容器平台。</p>
</blockquote>
<span id="more"></span>

<p>我们知道，如果想发布一个应用，需要将应用部署到服务器上。如果部署多个应用，应用依赖的环境可能会有所不同，不同的应用共用同一台服务器可能会出现冲突的现象，这个时候就需要隔离应用，最简单粗暴的方式就是使用虚拟机，但是虚拟机的开销比较大，这时 Docker 就派上用场了。</p>
<p>Docker 与虚拟机不同，但是可以看做是一种轻量化的虚拟机。我们将在本地运行的应用和依赖的环境打包成 Docker 镜像，然后就可以在别的平台使用这个镜像的应用而不用担心环境部署等问题。但是使用虚拟机可以在一个 OS 中运行出多个不同或相同的 OS，而使用 Docker 只能在一个 OS 中模拟出多个相同的该 OS。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/zj.png" alt="virtual machines"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/kx.png" alt="docker"></p>
<h2 id="Docker-解决了什么？"><a href="#Docker-解决了什么？" class="headerlink" title="Docker 解决了什么？"></a>Docker 解决了什么？</h2><ul>
<li><p><strong>解决环境不一致问题</strong><br>开发一个应用，开发环境与部署环境很可能是不一致的。开发者在本地运行正常的应用，交给运维实施人员部署时，可能会出现各种错误。而使用了 Docker 后，开发人员可以将应用连同开发环境一起打包到 Docker 镜像，运维实施人员只需要直接部署 Docker 即可。  </p>
</li>
<li><p><strong>环境隔离</strong><br>很多时候，我们的应用很有可能是和别的应用一起运行在一台服务器上，因此不可避免的会出现应用间相互影响的情况。一个应用将内存占满，另一个应用因内存不足挂掉。Docker 的隔离虽然不如虚拟机的隔离彻底，但是能够限制容器对系统资源的使用，并使容器间环境隔离，避免了应用间的互相影响。  </p>
</li>
<li><p><strong>弹性伸缩、快速扩展</strong><br>Docker 的这种将应用和环境一起打包的方式使得部署应用方便快捷，不用再为应用部署到多台服务器而头疼，通过标准统一的操作，能够迅速为几十台、上百台服务器部署应用。同时容器的销毁也很方便快捷，能够更好的应对弹性需求。</p>
</li>
</ul>
<h2 id="关于-Docker-的一些概念"><a href="#关于-Docker-的一些概念" class="headerlink" title="关于 Docker 的一些概念"></a>关于 Docker 的一些概念</h2><p><strong>LXC（Linux Container）</strong><br>Linux 中的一种内核虚拟化技术，提供轻量级的虚拟化，以便隔离进程和资源。Docker 就是基于 LXC 的高级容器引擎。Docker 从 0.9 版本开始使用 libcontainer 替代 lxc。  </p>
<p><strong>UFS（Union File System 联合文件系统）</strong><br>它是实现 Docker 镜像的技术基础，是一种轻量级的高性能分层文件系统，支持将文件系统中的修改进行提交和层层叠加，这个特性使得镜像可以通过分层实现和继承。同时支持将不同目录挂载到同一个虚拟文件系统下。  </p>
<p><strong>AUFS（Another Union File System）</strong><br>也是一种联合文件系统，支持将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）的文件系统形成一层 layer，更进一步地，AUFS 支持为每一个成员目录 (AKA branch) 设定只读 readonly，读写 readwrite 和写出 whiteout-able 权限，对 read-only 目录只能读，而写操作只能在 read-write 目录中。写操作是在 read-only 上的一种增量操作，不影响 read-only 目录。当挂载目录的时候要严格按照各目录之间的这种增量关系，将被增量操作的目录优先于在它基础上增量操作的目录挂载，待所有目录挂载结束了，继续挂载一个 read-write 目录，如此便形成了一种层次结构。  </p>
<p>Docker 在启动容器的时候，需要创建文件系统，为 rootfs 提供挂载点。最初 Docker 仅能在支持 Aufs 文件系统的 Linux 发行版上运行，但是由于 Aufs 未能加入 Linux 内核，为了寻求兼容性、扩展性，Docker 在内部通过 graphdriver 机制这种可扩展的方式来实现对不同文件系统的支持。Docker 支持 AUFS、Device mapper、Btrfs、ZFS、ZFS 和 OverlayFS。  </p>
<p>典型的 Linux 文件系统由 bootfs 和 rootfs 两部分组成，bootfs（boot file system）主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel，当 kernel 被加载到内存中后 bootfs 就被 umount 了。 rootfs（root file system）包含的就是典型的 Linux 系统中的 &#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件。	</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/Ob.png" alt="unionfs"></p>
<p>对于不同的 Linux 发行版，bootfs 基本是一致的，rootfs 会有差别，因此不同的发行版可以公用 bootfs。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/rd.jpg" alt="unionfs_bootjs"></p>
<p><strong>Docker Client</strong><br>Docker 提供给用户的一个终端，用户输入 Docker 命令管理本地或者远程的服务器。  </p>
<p><strong>Docker Daemon</strong><br>Docker 服务的守护进程。每台服务器（物理机或虚拟机）上只要安装了 Docker 的环境，基本上就跑了一个后台程序 Docker Daemon，Docker Daemon 接收 Docker Client 发过来的指令来对服务器进行具体操作。  </p>
<p><strong>Docker Images</strong><br>Docker 镜像（Docker 容器的基础）。说白了镜像就是一系列的文件，只不过 Docker 的镜像使用的是联合文件系统。  </p>
<p>Docker 镜像的典型结构如下图。传统的 Linux 加载 bootfs 时会先将 rootfs 设为 read-only，然后在系统自检之后将 rootfs 从 read-only 改为 read-write，然后我们就可以在 rootfs 上进行写和读的操作了。但 Docker 的镜像却不是这样，它在 bootfs 自检完毕之后并不会把 rootfs 的 read-only 改为 read-write。而是利用 union mount（UFS 的一种挂载机制）将一个或多个 read-only 的 rootfs 加载到之前的 read-only 的 rootfs 层之上。在加载了这么多层的 rootfs 之后，仍然让它看起来只像是一个文件系统，在 Docker 的体系里把 union mount 的这些 read-only 的 rootfs 叫做 Docker 的镜像。但是，此时的每一层 rootfs 都是 read-only 的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将 Docker 镜像进行实例化，系统会在一层或是多层 read-only 的 rootfs 之上分配一层空的 read-write 的 rootfs。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/Kl.png" alt="docker_image"></p>
<p>一组 Readonly 和一个 Readwrite 的结构构成一个 Container 的运行目录。得益于 AUFS 的特性，每一个对 readonly 层文件&#x2F;目录的修改都只会存在于上层的 writeable 层中。这样由于不存在竞争，多个 container 可以共享 readonly 的 layer。所以 docker 将 readonly 的层称作“image”，对于 container 而言整个 rootfs 都是 read-write 的，但事实上所有的修改都写入最上层的 writeable 层中。</p>
<p><strong>Image 可以通过分层来继承，基于 Base Image（无父镜像）可以制作各种具体的应用镜像。Image 不保存用户状态，可以用于模板、重建和复制。</strong>  </p>
<p><strong>Docker Registry</strong><br>Docker Registry Server 就像 git 的仓库一样，提供镜像的存储和管理服务，它提供了 Docker 镜像的上传、下载和浏览等功能，并且提供安全的账号管理可以管理只有自己可见的私人 image。  </p>
<blockquote>
<p>Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com</a>（官方 Registry）</p>
</blockquote>
<p><strong>Docker Container</strong><br>Docker 的容器。Docker Container 是真正跑项目程序、消耗机器资源、提供服务的地方，Docker Container 通过 Docker Images 启动，在 Docker Images 的基础上运行你需要的代码。  </p>
<p>在 Docker 中，上层的 Image 依赖下层的 Image，因此 Docker 中把下层的 Image 称作父 Image，没有父 Image 的 Image 称作 Base Image。因此，想要从一个 Image 启动一个 Container，Docker 会逐次加载其父 Image 直到 Base Image，用户的进程运行在 Writeable 的层中。所有父 Image 中的数据信息以及 ID、网络和 LXC 管理的资源限制、具体 container 的配置等，构成一个 Docker 概念上的 Container。  </p>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>Docker 提供 CE 和 EE 版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/26/Wqk.png" alt="docker_ce_ee"></p>
<p>Docker 的安装非常简单，官方提供了详尽的安装方法，桌面系统只提供了 Docker CE 版。</p>
<ul>
<li>Windows</li>
</ul>
<p><a href="https://docs.docker.com/docker-for-windows/install/">https://docs.docker.com/docker-for-windows/install/</a></p>
<ul>
<li>Mac OS</li>
</ul>
<p><a href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></p>
<ul>
<li>CE for Ubuntu</li>
</ul>
<p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>
<ul>
<li>EE for Ubuntu</li>
</ul>
<p><a href="https://docs.docker.com/install/linux/docker-ee/ubuntu/">https://docs.docker.com/install/linux/docker-ee/ubuntu/</a></p>
<ul>
<li>其他系统和具体信息参考</li>
</ul>
<p><a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a></p>
<h3 id="Ubuntu-下安装-Docker"><a href="#Ubuntu-下安装-Docker" class="headerlink" title="Ubuntu 下安装 Docker"></a>Ubuntu 下安装 Docker</h3><p>以 Ubuntu 16.04 安装 Docker CE 为例：</p>
<p>最简单的安装方式就是直接通过包管理工具安装，使用这种方式安装的是系统自带的 Docker 安装包，可能不是最新版的 Docker。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install -y docker.io</span><br></pre></td></tr></table></figure>

<p>或者使用官方提供的自动化脚本安装。  </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ sudo curl -s https://get.docker.com | sh</span><br></pre></td></tr></table></figure>

<h3 id="免-sudo-使用-docker-命令"><a href="#免-sudo-使用-docker-命令" class="headerlink" title="免 sudo 使用 docker 命令"></a>免 sudo 使用 docker 命令</h3><p>我们在安装 docker 时是使用 sudo 安装的，因此在使用普通用户使用 docker 时，会有提示：		</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at UNIX:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.30/version: dial UNIX /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure>

<p>docker 守护进程绑定到 UNIX 套接字而不是 TCP 端口。默认情况下，UNIX 套接字由用户 root 拥有，其他用户只能使用 sudo 访问它。docker 守护进程始终以 root 用户身份运行。  </p>
<p>如果不想在使用 docker 命令时使用 sudo，需要创建名为 docker 的 UNIX 组，并将用户添加到该组。当 docker 守护进程启动时，它会使 docker 组的 UNIX 套接字具有读&#x2F;写权限。  </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: 创建名为 docker 的用户组</span><br><span class="line">$ sudo groupadd docker</span><br><span class="line"></span><br><span class="line">:: 添加当前用户到该组</span><br><span class="line">$ sudo usermod -aG docker $USER</span><br><span class="line"></span><br><span class="line">:: 注销登录并重启以重新评估组成员资格，如果使用虚拟机，则重启虚拟机。</span><br><span class="line"></span><br><span class="line">:: 验证不使用 sudo 使用 docker 命令</span><br><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure>

<h3 id="加速镜像"><a href="#加速镜像" class="headerlink" title="加速镜像"></a>加速镜像</h3><p>使用 Docker 在拉取官方镜像时，显然网络是个问题。因此我们可以使用一些镜像加速器或者直接从国内的镜像平台（阿里、网易等）拉取。</p>
<blockquote>
<p>DaoCloud 镜像加速：<a href="https://www.daocloud.io/mirror">https://www.daocloud.io/mirror</a>		</p>
</blockquote>
<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/G7.png" alt="architecture"></p>
<h2 id="Docker-体验"><a href="#Docker-体验" class="headerlink" title="Docker 体验"></a>Docker 体验</h2><p>首先从远程仓库拉取一个镜像，使用 <code>docker pull [OPTIONS] name[:TAG]</code>。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: 从远程仓库拉取 hello-world 镜像，不加参数默认获取最新版本</span><br><span class="line">:: 相当于 docker pull hello-world:latest</span><br><span class="line">$ docker pull hello-world</span><br></pre></td></tr></table></figure>
<p>拉取之后，可以使用 <code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code> 命令查看本地仓库中的镜像。		</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: 列出仓库中的镜像</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<p>运行镜像使用命令 <code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code>。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure>
<p>运行后停止容器，使用命令 <code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code>。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ docker stop hello-world</span><br></pre></td></tr></table></figure>

<p>如果想删除镜像，使用命令 <code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code>。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ docker rmi hello-world</span><br></pre></td></tr></table></figure>
<p>如果 image 被某个容器引用，则需要先销毁容器 <code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code>。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: 删除某个容器，需要指定容器 ID</span><br><span class="line">$ docker rm &lt;Container ID&gt;</span><br><span class="line"></span><br><span class="line">:: 接着删除 image，指定 image 名称或 ID</span><br><span class="line">$ docker rmi &lt;Image ID or Image Name&gt;</span><br></pre></td></tr></table></figure>

<p>刚才运行 hello-world 镜像是在前台运行的。如果想运行像 Nginx 这样的镜像，最好在后台运行。从后台运行 nginx，需要加一个参数，使用 <code>docker run --help 查看参数</code>。  </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: 后台运行 nginx，返回容器 ID</span><br><span class="line">$ docker run -d nginx</span><br></pre></td></tr></table></figure>

<p>容器运行之后，我们可以使用命令 <code>docker exec</code> 进入到容器的内部，查看容器的相关信息，如日志等。		</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: -i 即使没有附加也保持 STDIN 打开</span><br><span class="line">:: -t 分配一个伪终端</span><br><span class="line">:: 有时容器很少，可以不用写全 ID</span><br><span class="line">:: command 为 bash，开启一个交互模式的终端</span><br><span class="line">$ docker exec -it <span class="number">0774</span>be6e1c0c bash</span><br></pre></td></tr></table></figure>

<p>我们知道，Linux 通过命名空间来隔离资源，如 network namespace 就是用来隔离网络的，每一个 network namespace 都提供了一个独立的网络环境。  </p>
<p>Docker 默认情况下会分配一个独立的 network namespace，也就是 Bridge 网络类型。由于与宿主机使用不同的网络环境，因此会涉及到<strong>端口映射</strong>，使通过宿主机能够访问 Docker 上的端口。Docker 能够将容器端口和宿主机端口做一个映射。		</p>
<p>如果指定 Docker 的网络类型为 Host，则不会分配一个独立的 network namespace，而是与宿主机使用同一命名空间。  </p>
<p>如果指定 Docker 的网络类型为 Null，则 Docker 不会获得网络资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/0J.jpg" alt="docker_network"><br>		<br>上图中，eth0 是宿主机的网卡，在 Host 模式下，Docker 容器使用的网卡与宿主机相同。在 Bridge 模式下，Docker 首先创建一个 docker0 这样的网桥与宿主机的网卡连接，同时自己会虚拟出一个网卡（因此容器中会有自己的 IP、端口等），这个网卡与网桥相连，这样 Docker 就可以与宿主机进行通信了。		
		</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: 开放一个端口到宿主机，前一个为主机端口，后一个为容器端口</span><br><span class="line">$ docker run -d -p <span class="number">8080</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure>

<p>映射完之后，就可以使用浏览器访问宿主机的 8080 端口来访问容器的 80 端口了。</p>
<p>更多 Docker 命令：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo SPI 机制</title>
    <url>/2020/06/17/Dubbo%20SPI%20%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Dubbo 良好的扩展性得益于它的 SPI 机制，在 Dubbo 中，几乎所有的功能组件都是基于 SPI 机制实现的。由于 Java SPI 机制存在一些问题，且无法满足 Dubbo 的需求，于是 Dubbo SPI 就在 Java SPI 的思想上做了改进，形成了一套自己的配置规范和特性。</p>
<span id="more"></span>

<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>Java SPI 在加载插件的时候，会一次性地<strong>加载并实例化</strong>扩展点所有的实现类，因此这个过程可能很耗时，同时可能有的类并没有用到，这也会造成浪费。而 Dubbo SPI 在加载插件的时候会缓存加载过的类和实例化后的对象，同时缓存的 Class 并不会全部实例化，而是按需实例化并缓存，因此性能更好。</p>
<p>当 Java SPI 加载插件失败时，可能会因为各种原因导致异常信息被“吞掉”，而 Dubbo SPI 在扩展加载失败的时候会先抛出真实的异常并打印日志。扩展点在被动加载的时候，即使有部分扩展加载失败也不会影响其他扩展点和整个框架的使用。</p>
<p>Dubbo SPI 还增加了对扩展的 IoC 和 AOP 的支持，一个扩展可以通过 setter 直接注入其他扩展。同时 Dubbo 还支持包装扩展类，它推荐把通用的抽象逻辑放到包装类中，用于实现扩展点的 AOP 特性。比如 ProtocolFilterWrapper 类就是一个包装类，它包装了一个 Protocol，将一些通用的判断逻辑全部放在了 export 方法中，但最终它还是会调用 Protocol#export 方法。这类似于代理模式，在被代理的类前后插入逻辑，以组合的方式实现功能增强。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (UrlUtils.isRegistry(invoker.getUrl())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置规范"><a href="#配置规范" class="headerlink" title="配置规范"></a>配置规范</h1><table>
<thead>
<tr>
<th>规范</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SPI 配置文件路径</td>
<td>META-INF&#x2F;services&#x2F;、META-INF&#x2F;dubbo&#x2F;、META-INF&#x2F;dubbo&#x2F;internal&#x2F;</td>
</tr>
<tr>
<td>SPI 配置文件名称</td>
<td>接口的全限定名</td>
</tr>
<tr>
<td>SPI 配置文件内容</td>
<td>key&#x3D;value 形式，多个实现类使用换行符分隔</td>
</tr>
</tbody></table>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Dubbo 的扩展类一共包含四种特性：自动包装、自动加载、自适应和自动激活。</p>
<h2 id="自动包装"><a href="#自动包装" class="headerlink" title="自动包装"></a>自动包装</h2><p>在使用 ExtensionLoader 加载扩展类时，如果发现这个扩展类<strong>包含其他扩展点作为构造函数的参数</strong>，则这个扩展类会被认为是一个 Wrapper 类。典型的比如 ProtocolFilterWrapper 扩展类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title class_">Protocol</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;protocol == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProtocolFilterWrapper 虽然实现了 Protocol 接口，但是其构造函数又注入了一个 Protocol 类型的参数，因此它会被认为是一个 Wrapper 类，类似于装饰器模式，把通用的抽象逻辑进行封装或对子类进行增强，让子类可以更加专注于具体的实现。</p>
<h2 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h2><p>除了在构造函数中传入其他扩展实例，我们还经常使用 setter 方法来设置属性值。如果某个扩展类是另外一个扩展点类的成员属性，并且该属性还拥有 setter 方法，那么 Dubbo 会自动注入对应的扩展点实例。ExtensionLoader 在执行扩展点初始化的时候，会自动通过 setter 方法注入对应的实例，这里有一个问题，如果扩展类属性是一个接口，他有多种实现，那么应该注入哪个呢？这就涉及到了 Dubbo SPI 扩展类的第三个特性——自适应。</p>
<h2 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h2><p>使用 <code>@Adaptive</code> 注解，可以动态地通过 URL 中的参数来确定要使用哪个具体的实现类，从而解决自动加载中的实例注入问题。比如在 Transporter 接口中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;netty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span></span><br><span class="line">    RemotingServer <span class="title function_">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span></span><br><span class="line">    Client <span class="title function_">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>@Adaptive</code> 注解中传入了两个参数，分别为 server 和 transporter，在外部调用 Transporter#bind 方法时，会动态地从传入的参数 URL 中提取 key 为 server 的 value 值，如果无法匹配则会继续提取 key 为 transporter 的 value 值。只有在都没有匹配时，才会使用 <code>@SPI</code> 注解中的默认值去匹配，此时如果无法匹配就会抛出异常。</p>
<h2 id="自动激活"><a href="#自动激活" class="headerlink" title="自动激活"></a>自动激活</h2><p>通过自适应的方式来寻找实现类会比较灵活，但是只能激活一个具体的实现类，如果需要激活多个实现类，或者需要根据不同的条件同时激活多个实现类，这就需要使用自动激活特性。使用 <code>@Activate</code> 注解，可以标记对应的扩展点默认被激活启用，该注解可以通过传入不同的参数，设置扩展点在不同的条件下被自动激活。</p>
<h1 id="扩展点注解"><a href="#扩展点注解" class="headerlink" title="扩展点注解"></a>扩展点注解</h1><p>目前能够使用的扩展点注解有三种：<code>@SPI</code>、<code>@Adaptive</code> 和 <code>@Activate</code>。</p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="@SPI"></a><code>@SPI</code></h2><p><code>@SPI</code> 注解一般用在接口上，它的主要作用就是标记这个接口是一个 Dubbo SPI 接口，即是一个扩展点，可以有多个不同的内置或者用户自定义的实现。该注解可以传入一个 String 类型的参数，表示该接口的默认实现类，比如 Transporter 接口的传入的参数为 netty，对应的配置为：<code>netty=org.apache.dubbo.remoting.transport.netty4.NettyTransporter</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;netty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Adaptive"><a href="#Adaptive" class="headerlink" title="@Adaptive"></a><code>@Adaptive</code></h2><p><code>@Adaptive</code> 注解可以标记在类、接口、枚举类和方法上，但是整个 Dubbo 框架中，只有很少的几个地方使用在类上，比如 AdaptiveExtensionFactory 和 AdaptiveCompiler，其余都标注在方法上。方法级别的注解在第一次使用 ExtensionLoader#getExtension 方法时，<strong>会自动生成和编译一个动态的 Adaptive 类</strong>，从而达到动态指定实现类的效果。</p>
<p>比如 Transporter 接口在 bind 和 connect 方法上都使用了该注解，在初始化扩展点时，会生成一个 Transporter$Adaptive 类，其中会实现这两个方法，方法中会通过 URL 找到并调用真正的实现类。下面的源代码可以使用阿里开源的 Java 诊断工具 <a href="https://github.com/alibaba/arthas">Arthas</a> 在 Dubbo 服务运行时通过反编译获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transporter$Adaptive</span> <span class="keyword">implements</span> <span class="title class_">Transporter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Client <span class="title function_">connect</span><span class="params">(URL uRL, ChannelHandler channelHandler)</span> <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (uRL == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">uRL2</span> <span class="operator">=</span> uRL;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> uRL2.getParameter(<span class="string">&quot;client&quot;</span>, uRL2.getParameter(<span class="string">&quot;transporter&quot;</span>, <span class="string">&quot;netty&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (string == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(<span class="string">&quot;Failed to get extension (org.apache.dubbo.remoting.Transporter) name from url (&quot;</span>).append(uRL2.toString()).append(<span class="string">&quot;) use keys([client, transporter])&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">transporter</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Transporter.class).getExtension(string);</span><br><span class="line">        <span class="keyword">return</span> transporter.connect(uRL, channelHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RemotingServer <span class="title function_">bind</span><span class="params">(URL uRL, ChannelHandler channelHandler)</span> <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (uRL == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">uRL2</span> <span class="operator">=</span> uRL;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> uRL2.getParameter(<span class="string">&quot;server&quot;</span>, uRL2.getParameter(<span class="string">&quot;transporter&quot;</span>, <span class="string">&quot;netty&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (string == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(<span class="string">&quot;Failed to get extension (org.apache.dubbo.remoting.Transporter) name from url (&quot;</span>).append(uRL2.toString()).append(<span class="string">&quot;) use keys([server, transporter])&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Transporter</span> <span class="variable">transporter</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Transporter.class).getExtension(string);</span><br><span class="line">        <span class="keyword">return</span> transporter.bind(uRL, channelHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>@Adaptive</code> 注解放在实现类上，则整个实现类会直接作为默认实现，不会再自动生成 Adaptive 类。在扩展点初始化时，如果发现实现类上有 <code>@Adaptive</code> 注解，那么会将该类直接赋值给 <code>cachedAdaptiveClass</code>，后续实例化的时候，就不会再动态生成代码，而是直接实例化并缓存到 <code>cachedAdaptiveInstance</code> 中。在扩展点接口的多个实现类中，只能有一个实现类上可以添加 <code>@Adaptive</code> 注解。</p>
<p>另外，如果包装类没有使用 <code>@Adaptive</code> 注解指定 key 值，也没有填写 <code>@SPI</code> 注解的默认值，那么 Dubbo 会自动把接口名称根据驼峰分开，并用 <code>.</code> 符号连接，以此来作为默认实现类的名称，比如 <code>org.apache.dubbo.xxx.YyyInvokerWrapper</code> 中的 YyyInvokerWrapper 会被转换成 <code>yyy.invoker.wrapper</code>。</p>
<h2 id="Activate"><a href="#Activate" class="headerlink" title="@Activate"></a><code>@Activate</code></h2><p><code>@Activate</code> 注解可以标记在类、接口、枚举类和方法上，主要用在有多个扩展点实现、需要根据不同条件激活多个实现的场景，比如 Filter。<code>@Activate</code> 注解可以传入的参数有很多。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String[] group()</td>
<td>URL 中的分组，如果匹配则激活，可以设置多个</td>
</tr>
<tr>
<td>String[] value()</td>
<td>URL 中含有该 key 则激活</td>
</tr>
<tr>
<td>String[] before()</td>
<td>扩展点列表，表示哪些扩展点要在本扩展点之前</td>
</tr>
<tr>
<td>String[] after()</td>
<td>扩展点列表，表示哪些扩展点要在本扩展点之后</td>
</tr>
<tr>
<td>int order()</td>
<td>排序</td>
</tr>
</tbody></table>
<h1 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h1><p>ExtensionLoader 是整个扩展机制的主要逻辑类，通过它可以实现配置（META-INF 目录下的配置文件）的加载、扩展类和实例的缓存、自适应对象的生成等。</p>
<p>ExtensionLoader 的逻辑入口可以分为三个：getExtension、getAdaptiveExtension 和 getActivateExtension，分别用来获取普通的扩展类实例、自适应扩展类实例和自动激活的扩展类实例列表。</p>
<h2 id="getExtension"><a href="#getExtension" class="headerlink" title="getExtension"></a>getExtension</h2><p>大概的流程就是先从 cachedInstances 缓存中获取类实例，如果缓存中没有就先通过配置文件加载扩展类，然后实例化对应的扩展类并放入缓存，然后再处理 setter 依赖注入和 Wrapper 的构造器注入，最后根据是否实现了 LifeCycle 接口决定是否调用扩展类的 initialize 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果扩展名称为 true，则使用 SPI 注解上默认的扩展</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先从普通扩展类实例缓存 cachedInstances 中获取</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    <span class="comment">// 缓存中没有则需要创建扩展类实例</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建扩展类实例</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                <span class="comment">// 设置缓存</span></span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 先从普通扩展类缓存 cachedClasses 中获取</span></span><br><span class="line">    <span class="comment">// 这里的 getExtensionClasses 方法会在初次调用时通过配置文件加载扩展类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从缓存中获取类实例</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="comment">// 缓存为空则直接实例化后放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依赖注入（setter 注入）</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="comment">// 通过构造器注入，并实例化 Wrapper 类</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化扩展类实例，如果扩展类实现了 org.apache.dubbo.common.context.LifeCycle 接口，</span></span><br><span class="line">        <span class="comment">// 则调用 initialize 初始化方法 </span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="comment">// 返回实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getAdaptiveExtension"><a href="#getAdaptiveExtension" class="headerlink" title="getAdaptiveExtension"></a>getAdaptiveExtension</h2><p>大概的流程就是先从 cachedAdaptiveInstance 缓存中获取实例，如果缓存中没有就先通过配置文件加载扩展类，如果扩展类上使用了 <code>@Adaptive</code> 注解则该扩展类为默认实现，否则就使用代码生成器生成类似 Transporter$Adaptive 这种的自适应扩展类，拿到 Class 之后就进行实例化，然后进行依赖注入，最终放入缓存并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="comment">// 缓存中没有则创建自适应扩展类实例</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建自适应扩展类实例</span></span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    <span class="comment">// 放入缓存</span></span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1 getAdaptiveExtensionClass 用来获取或者生成自适应扩展类</span></span><br><span class="line">        <span class="comment">// 2 实例化</span></span><br><span class="line">        <span class="comment">// 3 进行依赖注入</span></span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 在初次调用时通过配置文件加载扩展类</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 如果在加载扩展类的时候，扩展类上使用了 @Adaptive 注解，</span></span><br><span class="line">    <span class="comment">// 则该扩展类为默认实现类，会缓存到 cachedAdaptiveClass 中</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建自适应扩展类</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 使用代码生成器生成 type$Adaptive 类的代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveClassCodeGenerator</span>(type, cachedDefaultName).generate();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">    <span class="comment">// 获取 AdaptiveCompiler 扩展类</span></span><br><span class="line">    org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">// 编译代码，默认使用 JavassistCompiler 编译</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getActivateExtension"><a href="#getActivateExtension" class="headerlink" title="getActivateExtension"></a>getActivateExtension</h2><p>该方法有多个重载方法，我们关注参数最多的那个即可，大体上就是将缓存过的 <code>@Activate</code> 集合根据传入的条件进行筛选，最终使用获取普通扩展类实例的 getExtension 方法获取符合条件的扩展类实例即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> &#123;</span><br><span class="line">    List&lt;T&gt; activateExtensions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; names = values == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">0</span>) : asList(values);</span><br><span class="line">    <span class="keyword">if</span> (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">activate</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">            String[] activateGroup, activateValue;</span><br><span class="line">            <span class="comment">// 获取注解的参数</span></span><br><span class="line">            <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> Activate) &#123;</span><br><span class="line">                activateGroup = ((Activate) activate).group();</span><br><span class="line">                activateValue = ((Activate) activate).value();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> com.alibaba.dubbo.common.extension.Activate) &#123;</span><br><span class="line">                activateGroup = ((com.alibaba.dubbo.common.extension.Activate) activate).group();</span><br><span class="line">                activateValue = ((com.alibaba.dubbo.common.extension.Activate) activate).value();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 筛选</span></span><br><span class="line">            <span class="keyword">if</span> (isMatchGroup(group, activateGroup)</span><br><span class="line">                    &amp;&amp; !names.contains(name)</span><br><span class="line">                    &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)</span><br><span class="line">                    &amp;&amp; isActive(activateValue, url)) &#123;</span><br><span class="line">                <span class="comment">// getExtension 方法用来获取普通的扩展类实例</span></span><br><span class="line">                activateExtensions.add(getExtension(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activateExtensions.sort(ActivateComparator.COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下省略部分代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> activateExtensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ExtensionFactory"><a href="#ExtensionFactory" class="headerlink" title="ExtensionFactory"></a>ExtensionFactory</h2><p>如果我们单独使用 Dubbo 的 SPI 机制，可以先定义接口，然后添加配置文件（META-INF 目录下的配置文件），最后通过 ExtensionLoader 加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(UserService.class)</span><br><span class="line">                .getDefaultExtension();</span><br><span class="line">        userService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在使用 ExtensionLoader 的时候，需要先通过 getExtensionLoader 方法获取 ExtensionLoader，在这个方法中会对 ExtensionLoader 进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 type 是否是接口</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type + <span class="string">&quot;) is not an interface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有 @SPI 注解</span></span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中获取</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓存中没有就 new 一个</span></span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有化的构造函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="literal">null</span> :</span><br><span class="line">            ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 ExtensionLoader 中有一个比较关键的属性：objectFactory，它在 ExtensionLoader 实例化的时候会通过 getAdaptiveExtension 方法获取 ExtensionFactory 接口的实现类。ExtensionFactory 有三个实现类：SpiExtensionFactory、SpringExtensionFactory 和 AdaptiveExtensionFactory，其中 AdaptiveExtensionFactory 类上使用了 <code>@Adaptive</code> 注解，因此它是默认的实现类。那么 ExtensionFactory 到底是干什么用的呢？我们可以全局搜索一下，发现它在 injectExtension 方法中被使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (objectFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="comment">// 不是 setter 方法就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取 setter 方法第一个参数的类型</span></span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 setter 方法对应的属性名称，比如 setVersion，那么属性就是 version</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> getSetterProperty(method);</span><br><span class="line">                <span class="comment">// 通过 ExtensionFactory 获取对应的实例</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">                <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用 setter 方法注入属性</span></span><br><span class="line">                    method.invoke(instance, object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to inject via method &quot;</span> + method.getName()</span><br><span class="line">                        + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取扩展类实例时，如果扩展类实例的属性包含其他扩展类实例，那么就会通过 ExtensionFactory#getExtension 方法加载，加载的范围包括 <strong>Dubbo 自身缓存的扩展类实例以及 Spring 容器实例</strong>，这也就意味着，我们可以在 Dubbo 的扩展类实例中使用其他扩展类实例和 Spring 容器中的实例。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>FastDFS 集群部署</title>
    <url>/2018/10/27/FastDFS%20%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>关于 FastDFS 的介绍就先不说了，直接上干货。  </p>
<span id="more"></span>  

<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>两台 Tracker（10.170.0.6,10.170.0.7），四台 Storage（10.170.0.2,10.170.0.3,10.170.0.4,10.170.0.5）  </li>
<li>统一系统环境为 CentOS Linux release 7.5.1804</li>
</ul>
<h1 id="架构示意图"><a href="#架构示意图" class="headerlink" title="架构示意图"></a>架构示意图</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/28/Y7P.png" alt="架构图"></p>
<h1 id="安装-FastDFS"><a href="#安装-FastDFS" class="headerlink" title="安装 FastDFS"></a>安装 FastDFS</h1><p>需要在所有的环境上都安装 FastDFS。  </p>
<p>首先需要安装依赖包。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ libstdc++-devel pcre-devel zlib-devel wget make</span><br><span class="line">yum -y groupinstall &#x27;Development Tools&#x27;</span><br></pre></td></tr></table></figure>

<p>安装 libfastcommon。FastDFS 5.x 取消了对 libevent 的依赖，添加了对 libfastcommon 的依赖。这里选择直接克隆源代码项目，保证使用的代码都是最新的。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/happyfish100/libfastcommon.git /app/libfastcommon</span><br><span class="line">cd /app/libfastcommon</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure>

<p>安装 FastDFS。这里同样克隆最新的源代码编译安装。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/happyfish100/fastdfs.git /app/fastdfs</span><br><span class="line">cd /app/fastdfs</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure>

<p>安装完成之后，可以在 &#x2F;usr&#x2F;bin&#x2F; 下看到一些以 fdfs 开头的命令。  </p>
<h1 id="配置-Tracker"><a href="#配置-Tracker" class="headerlink" title="配置 Tracker"></a>配置 Tracker</h1><p>两台 Tracker 的配置过程相同，首先修改 tracker.conf 配置文件。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 首先创建存储日志和数据的根目录</span><br><span class="line">mkdir -p /app/nekolr/fastdfs</span><br><span class="line"></span><br><span class="line">vi /app/fastdfs/conf/tracker.conf</span><br></pre></td></tr></table></figure>

<p>这里重点只需要修改 base_path （创建存储日志和数据的根目录）即可。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_path=/app/nekolr/fastdfs</span><br></pre></td></tr></table></figure>

<p>同时配置文件中还有几个参数，可以根据需要调整。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 是否启用配置文件，false 表示启用</span><br><span class="line">disabled=false</span><br><span class="line"># tracker 的端口号</span><br><span class="line">port=22122</span><br><span class="line"># tracker 的数据文件和日志目录，这个目录需要手动创建</span><br><span class="line">base_path=/app/nekolr/fastdfs</span><br><span class="line"># http 服务端口号</span><br><span class="line">http.server_port=9090</span><br></pre></td></tr></table></figure>

<p>配置完毕后，就可以通过配置文件来启动 tracker 了。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/fdfs_trackerd /app/fastdfs/conf/tracker.conf start</span><br></pre></td></tr></table></figure>

<p>如果没有报错，则可以查看 22122 端口是否被监听来确认启动成功。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ps -ef|grep fdfs</span><br><span class="line"></span><br><span class="line">root     14395     1  0 05:40 ?        00:00:00 /usr/bin/fdfs_trackerd /app/fastdfs/conf/tracker.conf start</span><br><span class="line">root     14411  1438  0 05:41 pts/0    00:00:00 grep --color=auto fdfs</span><br><span class="line"></span><br><span class="line"># netstat -tunlp|grep fdfs</span><br><span class="line"></span><br><span class="line">tcp        0      0 0.0.0.0:22122           0.0.0.0:*               LISTEN      14395/fdfs_trackerd</span><br></pre></td></tr></table></figure>

<p>也可以通过日志查看启动是否成功。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /app/nekolr/fastdfs/logs/trackerd.log</span><br><span class="line"></span><br><span class="line">INFO - FastDFS v5.11, base_path=/app/nekolr/fastdfs, run_by_group=,...</span><br></pre></td></tr></table></figure>

<h1 id="配置-Storage"><a href="#配置-Storage" class="headerlink" title="配置 Storage"></a>配置 Storage</h1><p>将四台存储节点分成两组，其中 group1 为 10.170.0.2 和 10.170.0.3，group2 为 10.170.0.4 和 10.170.0.5。  </p>
<p>四台 Storage 的配置也是类似的，首先修改 storage.conf 配置文件。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 首先创建存储日志和数据的根目录</span><br><span class="line">mkdir -p /app/nekolr/fastdfs</span><br><span class="line"></span><br><span class="line">vi /app/fastdfs/conf/storage.conf</span><br></pre></td></tr></table></figure>

<p>主要修改 base_path、store_path、group_name 和 tracker_server。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 组名（第一组为 group1，第二组为 group2，依次类推）</span><br><span class="line">group_name=group1</span><br><span class="line"># 数据和日志文件存储根目录</span><br><span class="line">base_path=/app/nekolr/fastdfs</span><br><span class="line"># 第一个存储目录，第二个存储目录起名为：store_path1=xxx，其它存储目录名依次类推</span><br><span class="line">store_path0=/app/nekolr/fastdfs</span><br><span class="line"># 存储路径个数，需要和 store_path 个数匹配</span><br><span class="line">store_path_count=1</span><br><span class="line"># tracker 服务器 IP 和端口，有几个 tracker 就要配置几个</span><br><span class="line">tracker_server=10.170.0.6:22122</span><br><span class="line">tracker_server=10.170.0.7:22122</span><br></pre></td></tr></table></figure>

<p>配置完成后，就可以通过配置来启动了。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/fdfs_storaged /app/fastdfs/conf/storage.conf start</span><br></pre></td></tr></table></figure>

<p>与 tracker 相同，可以通过查看端口监听或者日志来确认启动是否成功。如果启动成功，可以验证一下 storage 是否登记到了 tracker 上。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 该命令可以在任意一台 Storage 上使用</span><br><span class="line"># /usr/bin/fdfs_monitor /app/fastdfs/conf/storage.conf</span><br><span class="line"></span><br><span class="line">server_count=2, server_index=1</span><br><span class="line">tracker server is 10.170.0.7:22122</span><br><span class="line">group count: 1</span><br><span class="line"></span><br><span class="line">Group 1:</span><br><span class="line">group name = group1</span><br><span class="line">disk total space = 10229 MB</span><br><span class="line">disk free space = 7712 MB</span><br><span class="line">trunk free space = 0 MB</span><br><span class="line">storage server count = 1</span><br><span class="line">active server count = 1</span><br><span class="line">storage server port = 23000</span><br><span class="line">storage HTTP port = 8888</span><br><span class="line">store path count = 1</span><br><span class="line">subdir count per path = 256</span><br><span class="line">current write server index = 0</span><br><span class="line">current trunk file id = 0</span><br><span class="line"></span><br><span class="line">        Storage 1:</span><br><span class="line">                id = 10.170.0.2</span><br><span class="line">                ip_addr = 10.170.0.2 (common1.c.avalon-192611.internal)  ACTIVE</span><br><span class="line">                http domain =</span><br><span class="line">                version = 5.12</span><br><span class="line">                join time = 2018-10-26 07:40:54</span><br><span class="line">                up time = 2018-10-27 06:08:42</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure>

<p>可以看到 Storage 的状态为 active，说明 Storage 服务器已经成功登记到 Tracker 服务器上了。  </p>
<h1 id="在-Storage-上安装-nginx"><a href="#在-Storage-上安装-nginx" class="headerlink" title="在 Storage 上安装 nginx"></a>在 Storage 上安装 nginx</h1><blockquote>
<p>注意：需要在所有的 Storage 上都按照下面的步骤操作。  </p>
</blockquote>
<p>FastDFS 将 Storage 服务器分组，相同组下的存储服务器之间需要进行文件的同步，这会有同步延迟的问题。假如客户端向 Tracker 服务器发送上传文件指令，Tracker 服务器经过选择，将文件上传到了 10.170.0.2，上传成功后将文件的 ID 返回给了客户端，此时 FastDFS 会将这个文件同步到同组的 10.170.0.3，在文件还没有复制完成的情况下，客户端如果使用这个 ID 在 10.170.0.3 上取文件就会出现无法访问的错误。fastdfs-nginx-module 模块就是为了解决这个问题的，它可以将文件链接重定向到源服务器，避免由于复制延迟导致的客户端无法访问文件的错误。  </p>
<p>首先获取 fastdfs-nginx-module 和 nginx，如果要开启 https，nginx 需要依赖 openssl 库。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/happyfish100/fastdfs-nginx-module.git /app/fastdfs-nginx-module</span><br><span class="line"></span><br><span class="line">wget -P /app http://nginx.org/download/nginx-1.15.5.tar.gz</span><br><span class="line">wget -P /app https://www.openssl.org/source/openssl-1.1.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf /app/nginx-1.15.5.tar.gz -C /app</span><br><span class="line">tar -zxvf /app/openssl-1.1.1.tar.gz -C /app</span><br></pre></td></tr></table></figure>

<p>接下来开始安装 nginx，需要添加 fastdfs-nginx-module 模块。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /app/nginx-1.15.5</span><br><span class="line">./configure --add-module=../fastdfs-nginx-module/src</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>nginx 安装完成后，查看版本以及模块安装情况。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx -V</span><br><span class="line"></span><br><span class="line">nginx version: nginx/1.15.5</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)</span><br><span class="line">configure arguments: --add-module=../fastdfs-nginx-module/src</span><br></pre></td></tr></table></figure>

<p>接下来需要配置 fastdfs-nginx-module，修改 md_fastdfs.conf 文件。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 将 mod_fastdfs.conf 配置文件复制到 /etc/fdfs/ 下</span><br><span class="line"># cp /app/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/</span><br><span class="line"></span><br><span class="line">:: 编辑配置文件</span><br><span class="line"># vi /etc/fdfs/mod_fastdfs.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 保存日志的目录</span><br><span class="line">base_path=/app/nekolr/fastdfs</span><br><span class="line"># tracker 服务器</span><br><span class="line">tracker_server=10.170.0.6:22122</span><br><span class="line">tracker_server=10.170.0.7:22122</span><br><span class="line"># storage 服务器的端口号</span><br><span class="line">storage_server_port=23000</span><br><span class="line"># 当前服务器的 group 名</span><br><span class="line">group_name=group1</span><br><span class="line"># 文件 url 中是否有 group 名</span><br><span class="line">url_have_group_name = true</span><br><span class="line"># 存储路径个数，需要和 store_path 个数匹配</span><br><span class="line">store_path_count=1</span><br><span class="line"># 存储路径</span><br><span class="line">store_path0=/app/nekolr/fastdfs</span><br><span class="line"># 设置组的个数</span><br><span class="line">group_count = 2</span><br></pre></td></tr></table></figure>

<p>再在配置文件的末尾增加两个组的具体信息。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[group1]</span><br><span class="line">group_name=group1</span><br><span class="line">storage_server_port=23000</span><br><span class="line">store_path_count=1</span><br><span class="line">store_path0=/app/nekolr/fastdfs</span><br><span class="line"></span><br><span class="line">[group2]</span><br><span class="line">group_name=group2</span><br><span class="line">storage_server_port=23000</span><br><span class="line">store_path_count=1</span><br><span class="line">store_path0=/app/nekolr/fastdfs</span><br></pre></td></tr></table></figure>

<p>建立 M00 至存储目录的符号连接。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /app/nekolr/fastdfs/data /app/nekolr/fastdfs/data/M00</span><br><span class="line">ll /app/nekolr/fastdfs/data/M00</span><br></pre></td></tr></table></figure>

<p>接下来再配置 nginx，修改 nginx.conf 配置文件。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 修改配置文件</span><br><span class="line"># vi /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">:: 下面是需要修改的地方的配置</span><br><span class="line">user root;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    location ~/group[1-2]/M00 &#123;</span><br><span class="line">        root /app/nekolr/fastdfs/data;</span><br><span class="line">        ngx_fastdfs_module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 复制 fastdfs 中的 http.conf、mime.types 文件到 /etc/fdfs</span><br><span class="line">cp /app/fastdfs/conf/http.conf /app/fastdfs/conf/mime.types  /etc/fdfs</span><br></pre></td></tr></table></figure>

<p>配置完成后，接下来将添加防火墙的放行策略，启动 nginx。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<h1 id="在-Tracker-上安装-nginx"><a href="#在-Tracker-上安装-nginx" class="headerlink" title="在 Tracker 上安装 nginx"></a>在 Tracker 上安装 nginx</h1><blockquote>
<p>注意：需要在所有的 Tracker 上都按照下面的步骤操作。  </p>
</blockquote>
<p>在 Tracker 上安装 nginx 主要是为了提供 http 访问的反向代理、负载均衡以及缓存服务。  </p>
<p>首先安装 nginx。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -P /app http://nginx.org/download/nginx-1.15.5.tar.gz</span><br><span class="line">wget -P /app https://www.openssl.org/source/openssl-1.1.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf /app/nginx-1.15.5.tar.gz -C /app</span><br><span class="line">tar -zxvf /app/openssl-1.1.1.tar.gz -C /app</span><br><span class="line"></span><br><span class="line">cd /app/nginx-1.15.5</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">:: 修改配置文件</span><br><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>配置反向代理、负载均衡。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    # 最大连接数</span><br><span class="line">    worker_connections  65535;</span><br><span class="line">    # 新版本的 Linux 可使用 epoll 加快处理性能</span><br><span class="line">    use epoll;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    # 设置 group1 的服务器</span><br><span class="line">    upstream fdfs_group1 &#123;</span><br><span class="line">        server 10.170.0.2:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">        server 10.170.0.3:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    &#125;</span><br><span class="line">    # 设置 group2 的服务器</span><br><span class="line">    upstream fdfs_group2 &#123;</span><br><span class="line">        server 10.170.0.4:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">        server 10.170.0.5:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        # 设置服务器端口</span><br><span class="line">        listen       8080;</span><br><span class="line">        # 设置 group1 的负载均衡参数</span><br><span class="line">        location /group1/M00 &#123;</span><br><span class="line">            proxy_pass http://fdfs_group1;</span><br><span class="line">        &#125;</span><br><span class="line">        # 设置 group2 的负载均衡参数</span><br><span class="line">        location /group2/M00 &#123;</span><br><span class="line">            proxy_pass http://fdfs_group2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后，启动 nginx。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/nginx/sbin/nginx</span><br><span class="line"></span><br><span class="line">:: 查看监听</span><br><span class="line"># netstat -tunlp | grep nginx</span><br><span class="line"></span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      7328/nginx: master</span><br></pre></td></tr></table></figure>

<h1 id="上传测试"><a href="#上传测试" class="headerlink" title="上传测试"></a>上传测试</h1><p>配置完成后，集群的情况可以在任意一台 Storage 上使用命令查看。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/bin/fdfs_monitor /app/fastdfs/conf/storage.conf</span><br><span class="line"></span><br><span class="line">server_count=2, server_index=1</span><br><span class="line">tracker server is 10.170.0.7:22122</span><br><span class="line">group count: 2</span><br><span class="line"></span><br><span class="line">Group 1:</span><br><span class="line">group name = group1</span><br><span class="line">disk total space = 10229 MB</span><br><span class="line">disk free space = 7711 MB</span><br><span class="line">trunk free space = 0 MB</span><br><span class="line">storage server count = 2</span><br><span class="line">active server count = 2</span><br><span class="line">storage server port = 23000</span><br><span class="line">storage HTTP port = 8888</span><br><span class="line">store path count = 1</span><br><span class="line">subdir count per path = 256</span><br><span class="line">current write server index = 0</span><br><span class="line">current trunk file id = 0</span><br><span class="line"></span><br><span class="line">        Storage 1:</span><br><span class="line">                id = 10.170.0.2</span><br><span class="line">                ip_addr = 10.170.0.2 (common1.c.avalon-192611.internal)  ACTIVE</span><br><span class="line">                http domain =</span><br><span class="line">                version = 5.12</span><br><span class="line">                ...</span><br><span class="line">        Storage 2:</span><br><span class="line">                id = 10.170.0.3</span><br><span class="line">                ip_addr = 10.170.0.3 (common2.c.avalon-192611.internal)  ACTIVE</span><br><span class="line">                http domain =</span><br><span class="line">                version = 5.12</span><br><span class="line">                ...</span><br><span class="line">Group 2:</span><br><span class="line">group name = group2</span><br><span class="line">disk total space = 10229 MB</span><br><span class="line">disk free space = 8164 MB</span><br><span class="line">trunk free space = 0 MB</span><br><span class="line">storage server count = 2</span><br><span class="line">active server count = 1</span><br><span class="line">storage server port = 23000</span><br><span class="line">storage HTTP port = 8888</span><br><span class="line">store path count = 1</span><br><span class="line">subdir count per path = 256</span><br><span class="line">current write server index = 0</span><br><span class="line">current trunk file id = 0</span><br><span class="line"></span><br><span class="line">        Storage 1:</span><br><span class="line">                id = 10.170.0.4</span><br><span class="line">                ip_addr = 10.170.0.4 (common3.c.avalon-192611.internal)  ACTIVE</span><br><span class="line">                http domain =</span><br><span class="line">                version = 5.12</span><br><span class="line">                ...</span><br><span class="line">        Storage 2:</span><br><span class="line">                id = 10.170.0.5</span><br><span class="line">                ip_addr = 10.170.0.5 (common4.c.avalon-192611.internal)  ACTIVE</span><br><span class="line">                http domain =</span><br><span class="line">                version = 5.12</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure>

<p>此时可以通过修改某个 Tracker 上的客户端 client.conf 配置，然后再通过上传文件命令来测试。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /app/fastdfs/conf/client.conf  /etc/fdfs</span><br><span class="line"></span><br><span class="line">:: 修改客户端配置</span><br><span class="line"># vi /etc/fdfs/client.conf</span><br><span class="line"></span><br><span class="line"># 日志存放路径</span><br><span class="line">base_path=/app/nekolr/fastdfs</span><br><span class="line"># tracker 服务器</span><br><span class="line">tracker_server=192.168.53.85:22122         </span><br><span class="line">tracker_server=192.168.53.86:22122 </span><br><span class="line">http.tracker_server_port=8080</span><br></pre></td></tr></table></figure>

<p>使用命令上传文件。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 上传文件</span><br><span class="line"># /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /app/favicon.png</span><br><span class="line"></span><br><span class="line">:: 返回的地址</span><br><span class="line">group2/M00/00/00/CqoABFvUnLmAAhVgAAGMpR-vGEI079.png</span><br></pre></td></tr></table></figure>

<p>接下来就可以通过任意一台 Tracker 来访问该文件了。这里使用 <code>10.170.0.6</code> 这台来访问：<a href="http://10.170.0.6:8080/group2/M00/00/00/CqoABFvUnLmAAhVgAAGMpR-vGEI079.png">http://10.170.0.6:8080/group2/M00/00/00/CqoABFvUnLmAAhVgAAGMpR-vGEI079.png</a>  </p>
<blockquote>
<p>这里直接使用内网地址来访问的，如果有公网地址，可以在任意能够连接互联网的地方通过 Tracker 的公网 IP 来访问。  </p>
</blockquote>
<p>除了在 Tracker 上直接使用指令上传文件，还可以通过 FastDFS 提供的客户端来上传文件，目前支持 PHP 和 Java。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://www.ityouknow.com/fastdfs/2017/10/10/cluster-building-fastdfs.html">FastDFS 集群 安装 配置</a></p>
</blockquote>
]]></content>
      <categories>
        <category>FastDFS</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>GOPATH 与 GOROOT</title>
    <url>/2019/04/15/GOPATH%20%E4%B8%8E%20GOROOT/</url>
    <content><![CDATA[<p>在 Windows 平台下，我一般会下载软件的 archive 文件然后解压使用，这次在初学 Golang 时就遇到了一个小坑。  </p>
<span id="more"></span>

<p>Golang 的环境变量中有几个比较重要的：GOROOT 和 GOPATH，其中 GOROOT 其实就是 Golang 的安装路径，而 GOPATH 是 Golang 的工作目录，也就是平常开发使用的所有项目的根目录，默认情况下该值为 <code>%USERPROFILE%\go</code>。在设置环境变量时，新建 <code>$GOROOT</code> 和 <code>$GOPATH</code> 环境变量，值分别为 <code>D:\go</code> 和 <code>D:\goworkspace</code>，同时添加一条 <code>$PATH</code> 值为 <code>%GOROOT%\bin</code>，这样就可以使用 go 命令了。  </p>
<p>接下来将 Golang 官方的包管理工具 dep 安装到 <code>%$GOROOT%\bin</code> 中，此时就可以开始编程惯例 Hello World 了。  </p>
<p>在 <code>$GOPATH</code> 下新建 src 目录，然后在 src 目录下新建一个项目目录为 example，同时使用 <code>dep init</code> 命令初始化，这会在该目录中生成一个 vendor 目录，一个 Gopkg.lock 文件和一个 Gopkg.toml 文件。在项目目录下新建一个 helloworld.go 文件，代码如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来一定要在项目目录 <code>example</code> 下使用 <code>go install</code> 命令，这样才会将编译生成的 exe 二进制文件复制到 <code>$GOPATH\bin</code> 目录中。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 内部原理</title>
    <url>/2021/06/10/Git%20%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>这篇博文主要用于记录博主在学习 Git 官方教程时的整个过程和一些心得体会，具体学习的章节是《Git 内部原理》。</p>
<span id="more"></span>

<h1 id="底层命令与上层命令"><a href="#底层命令与上层命令" class="headerlink" title="底层命令与上层命令"></a>底层命令与上层命令</h1><p>我们平常使用的 git 命令一般都是对用户友好的上层（porcelain）命令，然而，由于 Git 最初只是一套面向版本控制系统的工具集，所以它还包含了一部分用于完成底层工作的子命令，这部分命令一般称为底层（plumbing）命令。</p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>当在一个新目录或已有目录执行 <code>git init</code> 时，Git 会创建一个 <code>.git</code> 目录。 这个目录包含了几乎所有 Git 存储和操作的东西。如果想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。新初始化的 <code>.git</code> 目录的典型结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure>

<p>description 文件仅供 GitWeb 程序使用，我们无需关心。config 文件包含项目特有的配置选项。info 目录包含一个全局性的排除（global exclude）文件，用于放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns）。hooks 目录包含客户端或服务端的钩子脚本（hook scripts）。</p>
<p>剩下的四个条目很重要：HEAD 文件、（尚未创建的）index 文件，和 objects 目录、refs 目录。它们都是 Git 的核心组成部分。objects 目录存储所有的数据内容；refs 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针；HEAD 文件指向目前被检出的分支；index 文件保存暂存区信息。</p>
<h1 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h1><p>Git 的核心部分是一个简单的键值对数据库。我们可以向 Git 仓库中插入任意类型的内容（文本或文件），它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。底层命令 <code>git hash-object</code> 可以实现该效果：将任意数据保存到 <code>objects</code> 目录，并返回指向该数据对象的唯一的键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init test</span><br><span class="line">Initialized empty Git repository in /tmp/test/.git/</span><br><span class="line">$ cd test</span><br><span class="line">$ find .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure>

<p>可以看到，Git 对 objects 目录进行了初始化，并创建了 pack 和 info 子目录，但均为空。接着，我们用 <code>git hash-object</code> 创建一个新的数据对象并将它手动存入 Git 数据库中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;test content&#x27; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p>其中，<code>-w</code> 选项指示该命令不光要返回键，还要将该对象写入数据库中。<code>--stdin</code> 选项则指示该命令从标准输入读取内容，如果不指定此选项，则须在命令尾部给出需要存储的文件的路径。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;test content&#x27; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p>该命令输出的是一个长度为 40 个字符的哈希值，该校验和通过将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算得到。现在我们可以查看 Git 是如何存储数据的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p>再次查看 objects 目录，可以在其中找到一个与新内容对应的文件。这就是 Git 存储内容的方式：一个文件对应一条内容，以该内容加上特定头部信息一起做 SHA-1 校验和来为文件命名。校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>
<p>一旦将内容存储在了对象数据库中，那么就可以通过 <code>cat-file</code> 命令从 Git 仓库取回数据（如果直接使用 cat 命令查看写入的内容，会发现全是乱码，这是因为写入的东西是经过压缩的）。指定 <code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure>

<p>接下来我们尝试对一个文件进行简单的版本控制。首先，创建一个新文件并将其内容存入数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;version 1&#x27; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure>

<p>接着，向文件里写入新内容，并再次将其存入数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;version 2&#x27; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br></pre></td></tr></table></figure>

<p>对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p>接下来我们可以删除该文件，同时只需要通过 <code>cat-file</code> 传入不同的键，就可以取回该文件的第一个版本和第二个版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">version 1</span><br><span class="line">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">version 2</span><br></pre></td></tr></table></figure>

<p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存。上述类型的对象我们称之为数据对象（blob object）。利用 <code>git cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">blob</span><br></pre></td></tr></table></figure>

<h2 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h2><p>Git 以一种类似于 UNIX 文件系统的方式存储内容，所有内容均以树对象和数据对象的形式存储。其中树对象对应 UNIX 中的目录，数据对象则大致对应 inodes 或文件内容。一个树对象包含一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或子树对象的 SHA-1 指针，以及相应的模式、类型和文件名信息。例如，某个项目当前对应的最新树对象可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>master^&#123;tree&#125;</code> 语法表示 master 分支上最新的提交所指向的树对象。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107182129/2021/07/18/Y2E.png" alt="树对象"></p>
<p>通常，Git 根据某一时刻暂存区（index 文件）所表示的状态创建并记录一个对应的树对象，如此重复便可以依次记录（某个时间段内）一系列的树对象。因此，为了创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。可以通过底层命令 <code>git update-index</code> 为一个单独文件（之前 test.txt 文件的首个版本）创建一个暂存区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure>

<p>使用该命令，可以将 test.txt 的首个版本人为地加入到一个新的暂存区，<code>--add</code> 选项表示此前该文件并不在暂存区中（我们甚至都没有创建过一个暂存区）。<code>--cacheinfo</code> 选项表示该文件位于 Git 数据库中，而不是当前目录下。同时还需要指定文件模式、SHA-1（Git 数据库对象的键）和文件名。</p>
<blockquote>
<p>Git 中的文件模式参考了 UNIX 的文件模式，但远没有那么灵活。数据对象只有三种文件模式：普通文件 100644、可执行文件 100755、符号链接 120000。还有一些其他的文件模式用于目录项和子模块。</p>
</blockquote>
<p>接下来可以通过 <code>git write-tree</code> 命令将暂存区的内容写入到一个树对象。这里不用指定 <code>-w</code> 选项，如果某个树对象此前并不存在的话，调用此命令会根据当前暂存区的状态自动创建一个新的树对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"></span><br><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</span><br><span class="line"></span><br><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">tree</span><br></pre></td></tr></table></figure>

<p>接下来我们创建一个新的数对象，它包含 test.txt 文件的第二个版本，以及一个新的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;new file&#x27; &gt; new.txt</span><br><span class="line"></span><br><span class="line">$ git update-index --add --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line"></span><br><span class="line">$ git update-index --add new.txt</span><br></pre></td></tr></table></figure>

<p>暂存区现在包含了 test.txt 文件的新版本和一个新文件：new.txt。记录下这个目录树（将当前暂存区的状态记录为一个树对象）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure>

<p>我们发现新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值就是之前该文件的第二个版本。我们还可以将第一个树对象加入到第二个树对象中，使其成为新树对象的一个子目录。使用 <code>git read-tree</code> 命令可以将一个树对象读入暂存区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"></span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579    bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a    test.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107252029/2021/07/25/MMg.png" alt="树对象"></p>
<h2 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h2><p>现在我们已经有了三个树对象，它们代表我们想要跟踪的不同项目的快照。然而我们要想重用这些快照，还是需要提供它们的 SHA-1 值，并且我们也不知道是谁保存了这些快照，在什么时候保存的，以及为什么保存这些快照。而以上这些信息，都可以通过提交对象（commit object）来保存。</p>
<p>可以通过 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。我们先从之前创建的第一个树对象开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;first commit&#x27; | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">444dd711ed72fa1fbc5f3004d0d2ba43adf126fb</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 444dd711ed72fa1fbc5f3004d0d2ba43adf126fb</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author nekolr &lt;excalibll@163.com&gt; 1627202862 +0800</span><br><span class="line">committer nekolr &lt;excalibll@163.com&gt; 1627202862 +0800</span><br><span class="line"></span><br><span class="line">first commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于创建时间和作者数据不同，现在及之后的散列值都有可能不同。</p>
</blockquote>
<p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照。然后是可能存在的父提交，之后是作者和提交者信息（外加时间戳），接着留空一行，最后是提交注释。</p>
<p>接着，我们将创建另外两个提交对象，它们分别引用各自的上一个提交作为其父提交对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;second commit&#x27; | git commit-tree 0155eb -p 444dd71</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line"></span><br><span class="line">$ echo &#x27;third commit&#x27;  | git commit-tree 3c4e9c -p 5dd3923</span><br><span class="line">1dd880144c02a460642d6d00c204a86289c23fe7</span><br></pre></td></tr></table></figure>

<p>现在，如果对最后一个提交的 SHA-1 值运行 git log 命令，你会发现已经有一个货真价实的、可由 git log 查看的 Git 提交历史了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --stat 1dd880</span><br><span class="line">commit 1dd880144c02a460642d6d00c204a86289c23fe7</span><br><span class="line">Author: nekolr &lt;excalibll@163.com&gt;</span><br><span class="line">Date:   Sun Jul 25 16:50:24 2021 +0800</span><br><span class="line"></span><br><span class="line">    third commit</span><br><span class="line"></span><br><span class="line"> bak/test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit 5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line">Author: nekolr &lt;excalibll@163.com&gt;</span><br><span class="line">Date:   Sun Jul 25 16:50:00 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line"> new.txt  | 1 +</span><br><span class="line"> test.txt | 2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 444dd711ed72fa1fbc5f3004d0d2ba43adf126fb</span><br><span class="line">Author: nekolr &lt;excalibll@163.com&gt;</span><br><span class="line">Date:   Sun Jul 25 16:47:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们没有借助任何上层命令，仅凭几个底层操作便完成了 Git 提交历史的创建。这就是我们在执行 <code>git add</code> 和 <code>git commit</code> 命令时，Git 所做的工作：将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。如果跟踪所有的内部指针，可以得到类似下面的对象关系图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107252029/2021/07/25/vvp.png" alt="对象关系（原图中的 SHA-1 值与本地并不一致）"></p>
<h1 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h1><p>如果想查看一个提交（比如 <code>1dd880</code>）之前的历史，可以运行 <code>git log 1dd880</code> 命令，但是这样我们需要记住 <code>1dd880</code> 是我们查看历史的起点提交。如果我们能有一个文件来保存这个 SHA-1 值，同时该文件又有一个简单的名字，使用这个名字指针替代原始的 SHA-1 值会使查看日志变得更加简单。</p>
<p>在 Git 中，这个简单的名字被称为引用（references，简写为 refs），可以在 <code>.git/refs</code> 目录下找到它们。在当前的项目中，这个目录下并没有任何文件，但它包含了一个简单的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br></pre></td></tr></table></figure>

<p>如果要创建一个新的引用来帮助记录最新提交所在的位置，从原理上讲，只需要执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo 1dd880144c02a460642d6d00c204a86289c23fe7 &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure>

<p>接下来就可以使用这个刚创建的新引用来替代 SHA-1 值查看 log 记录了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline master</span><br><span class="line">1dd880144c02a460642d6d00c204a86289c23fe7 (HEAD -&gt; master) third commit</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b second commit</span><br><span class="line">444dd711ed72fa1fbc5f3004d0d2ba43adf126fb first commit</span><br></pre></td></tr></table></figure>

<p>不过 Git 并不提倡直接编辑引用文件，如果想更新某个引用，Git 提供了一个更加安全的命令 <code>update-ref</code> 来完成这项工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/heads/master 1dd880144c02a460642d6d00c204a86289c23fe7</span><br></pre></td></tr></table></figure>

<p>这基本上就是 Git 分支的本质：<strong>一个指向某一系列提交之首的指针或引用</strong>。当运行类似于 <code>git branch &lt;branch_name&gt;</code> 这样的命令时，Git 实际上执行的是 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值。如果想在第二个提交上创建一个新分支，可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/heads/test 5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line"></span><br><span class="line">$ git log --pretty=oneline test</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b (test) second commit</span><br><span class="line">444dd711ed72fa1fbc5f3004d0d2ba43adf126fb first commit</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107312345/2021/07/31/RxK.png" alt="引用（原图中的 SHA-1 值与本地并不一致）"></p>
<h2 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h2><p>那么 Git 在执行 <code>git branch &lt;branch_name&gt;</code> 时，又是如何得知当前分支最新提交的 SHA-1 值的呢？答案是 HEAD 文件。HEAD 文件通常是一个符号引用（symbolic reference），它是一个指向其他引用的指针，指向当前所在的分支。在你检出一个标签、提交或远程分支时，HEAD 文件可能会包含一个 git 对象的 SHA-1 值，这是因为此时仓库处于<strong>分离 HEAD</strong>状态。</p>
<p>直接查看 HEAD 文件内容，通常是：<code>ref: refs/heads/master</code>，如果执行 <code>git checkout test</code>，Git 会更新这个值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br><span class="line"></span><br><span class="line">$ git checkout test</span><br><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure>

<p>当我们执行 <code>git commit</code> 时，该命令会创建一个提交对象，并用 HEAD 文件中的那个引用所指向的 SHA-1 值设置其父提交字段。我们可以手动编辑该文件，当然 Git 同样提供了一个更安全的命令 <code>git symbolic-ref</code> 来完成这件事。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看 HEAD 引用的值</span><br><span class="line">$ git symbolic-ref HEAD</span><br><span class="line"></span><br><span class="line"># 设置 HEAD 引用的值</span><br><span class="line">$ git symbolic-ref HEAD refs/heads/test</span><br></pre></td></tr></table></figure>

<h2 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h2><p>Git 中除了数据对象、树对象和提交对象，实际上还有一种对象：标签对象（tag object），它非常类似于提交对象，包含一个标签创建者信息，一个日期，一段注释，以及一个指针。标签对象与提交对象的主要区别在于，标签对象的指针指向的通常是一个提交对象，而不是一个树对象。它就像一个永不移动的分支引用，永远指向同一个提交对象，只不过是给这个提交对象指定了一个更加友好的名字罢了。</p>
<p>Git 中存在两种类型的标签：附注标签和轻量标签。轻量标签可以直接通过指定一个固定的引用，也就是提交对象来创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/tags/v1.0</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br></pre></td></tr></table></figure>

<p>而若要创建一个附注标签，Git 会创建一个标签对象，然后记录一个引用来指向该标签对象。也就是说：标签引用中存储的并不是某个提交对象，而是一个指向该标签对象的引用。我们可以通过创建一个附注标签来验证这一过程（使用 <code>-a</code> 选项）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.1 1dd880144c02a460642d6d00c204a86289c23fe7 -m &#x27;test tag&#x27;</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/tags/v1.1</span><br><span class="line">3a62c1d03f5e77c307ed4a9176e3dce46369f01e</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 3a62c1d03f5e77c307ed4a9176e3dce46369f01e</span><br><span class="line">object 1dd880144c02a460642d6d00c204a86289c23fe7</span><br><span class="line">type commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger nekolr &lt;excalibll@163.com&gt; 1627745037 +0800</span><br><span class="line"></span><br><span class="line">test tag</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要注意的是，标签对象并非必须指向某个提交对象，我们可以对任意类型的 Git 对象打标签。例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。可以克隆一个 Git 版本库，然后通过执行下面的命令在这个版本库中查看上述公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file blob junio-gpg-pub</span><br></pre></td></tr></table></figure>

<h2 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h2><p>如果我们添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs&#x2F;remotes 目录下。例如，你可以添加一个叫做 origin 的远程版本库，然后把 master 分支推送上去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:nekolr/simplegit-progit.git</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>此时查看 <code>refs/remotes/origin/master</code> 文件，可以发现 origin 远程版本库的 master 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 master 分支所对应的 SHA-1 值。</p>
<p>远程引用和分支（位于 refs&#x2F;heads 目录下的引用）之间最主要的区别在于：远程引用是只读的。虽然可以 <code>git checkout</code> 某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 commit 命令来更新远程引用。Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GC 日志分析</title>
    <url>/2020/09/03/GC%20%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>阅读和分析 GC 日志是处理 Java 虚拟机内存问题的一项基础手段，GC 日志是一些人为定义的规则，每一种收集器的日志形式可能都不太相同，但是虚拟机的设计者为了方便用户阅读，将各个收集器的日志都维持了一定的共性。本文是日志分析的一般流程描述。</p>
<span id="more"></span>

<p>遇到 Java 虚拟机进程的 CPU 占用率很高甚至达到百分之百，一般有两种情况：一种是大量地创建对象，导致频繁触发 GC，比如 OOM 导致频繁地 Full GC。另一种就是代码中有死循环或者接近死循环的操作。此时首先要拿到 Java 进程的进程号，我们可以 JDK 提供的工具，比如运行 <code>jps -l</code> 或者 <code>jcmd -l</code> 命令，也可以使用系统自带的命令，比如 <code>ps -ef | grep java</code>。</p>
<p>在拿到进程号以后，接下来就需要找出进程内占用 CPU 时间最多的线程，能够达到这个目的的命令有很多，比如使用 <code>top -Hp pid</code>，找到占用最多的那一条对应的 PID 即为线程 ID。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/znY.png" alt="top"></p>
<p>或者利用 ps 命令，比如使用 <code>ps -mp pid -o THREAD,tid,lwp,time</code>，查看占用 CPU 时间最多的线程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/VAW.png" alt="ps"></p>
<p>接下来我们要使用 jstack 查看线程快照，这里需要注意的是，jstack 输出的线程信息包含一个 tid 和一个 nid，其中 tid 代表的是 Java 中的线程 ID，通过 <code>Thread.getId()</code> 可以得到。nid 意为 Native Thread Id，它在不同平台中的含义会有所不同，在 Linux 系统中，它代表的是线程的 pid，即 light-weight process id。由于 jstack 中的 ID 使用的是十六进制，因此我们使用 <code>printf &quot;%x\n&quot; pid</code> 将该线程号转换成十六进制，比如这里 13165 会被转换成 336d，然后使用 <code>jstack -l pid &gt; jstack.txt</code> 命令将线程快照输出到文件中，接着查找 tid 为 336d 的线程信息即可。</p>
<p>一般到这里，基本就可以判断出是 GC 线程繁忙还是业务线程繁忙，如果是业务线程繁忙，那么就需要定位具体的代码查找原因；如果是 GC 线程繁忙，此时就可以进入下一个环节，即 GC 日志分析。</p>
<p>Java 虚拟机提供的关于 GC 日志的参数有很多，常用的包括：<code>-XX:+PrintGC</code>（输出 GC 日志）、<code>-XX:+PrintGCDetails</code>（输出 GC 详细日志）、<code>-XX:+PrintGCTimeStamps</code>（输出 GC 的时间戳）、<code>-Xloggc:./gc.log</code>（输出 GC 日志到 gc.log 文件）。一般出现问题的 Java 进程并没有开启输出 GC 日志，此时需要不停机的设置参数，具体来说就是通过 <code>jinfo</code> 命令来动态添加参数，比如 <code>jinfo -flag +PrintGCDetails pid</code>。</p>
<p>这里使用 <code>-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</code> 参数，可以看到具体的 GC 内容如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/AN5.png" alt="GC 日志"></p>
<p>最前面的是虚拟机自启动以来到当前的秒数，对应的是 GC 发生的时间。GC 日志开头的“[ GC ”说明了此次垃圾收集的停顿类型，如果有“Full”，则表示此次发生了 Stop The World。接下来的 PSYoungGen 是与 Parallel Scavenge 收集器配套的新生代的称呼。接下来方括号内，箭头前代表的是 GC 前该内存区域已使用的容量，箭头后代表的是 GC 后该内存区域已使用的容量，圆括号中代表的是该内存区域的总容量。方括号之外的，180892K-&gt;64366K(210944K) 表示“GC 前 Java 堆已经使用的容量 -&gt; GC 后 Java 堆已使用的容量（Java 堆的总容量）”。再往后的 0.0032464 secs 表示此次 GC 的耗时，单位是秒。后面的 Times 中给出了更具体的时间信息，其中 user、sys 和 real 分别代表用户态消耗的 CPU 时间、内核态消耗的 CPU 时间、以及操作从开始到结束经过的墙上时间（Wall Clock Time）。</p>
<p>图中的例子可以看出，新生代在进行频繁的 GC 活动，我们也可以通过 <code>jstat -gc pid interval count</code> 命令来查看各个区的占用以及垃圾回收情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/1ko.png" alt="jstat"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5 WebSocket API</title>
    <url>/2018/01/06/HTML5%20WebSocket%20API/</url>
    <content><![CDATA[<p>HTML5 规范提供了 WebSocket API，使 Web 页面能够使用 WebSocket 协议与远程主机进行双向通信。</p>
<span id="more"></span>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">WebSocket</span> <span class="title class_">WebSocket</span>(<span class="keyword">in</span> <span class="title class_">DOMString</span> url, <span class="keyword">in</span> optional <span class="title class_">DOMString</span> protocols);</span><br><span class="line"><span class="title class_">WebSocket</span> <span class="title class_">WebSocket</span>(<span class="keyword">in</span> <span class="title class_">DOMString</span> url,<span class="keyword">in</span> optional <span class="title class_">DOMString</span>[] protocols);</span><br></pre></td></tr></table></figure>

<ul>
<li>url<br>表示要连接的响应 WebSocket 的地址。</li>
<li>protocols<br>[可选 ] 这些字符串用来表示子协议，这样做可以让一个服务器实现多种 WebSocket 子协议。默认为空。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://example.com:80/test&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h1><table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>DOMString</td>
<td>[只读 ] 传入构造器的 URL。它必须是一个绝对地址的 URL。</td>
</tr>
<tr>
<td>binaryType</td>
<td>DOMString</td>
<td>表示被传输二进制的内容的类型。创建 WebSocket 对象时，默认赋值为 blob；在获取该属性值时，会返回最后设置的一个值，可能是 blob 或 arraybuffer。</td>
</tr>
<tr>
<td>readyState</td>
<td>unsigned short</td>
<td>[只读 ] 连接的当前状态。取值是 Ready state constants 之一。</td>
</tr>
<tr>
<td>onopen</td>
<td>EventListener</td>
<td>连接打开事件的事件监听器。当 readyState 的值变为 OPEN 的时候会触发该事件。该事件表明这个连接已经准备好接受和发送数据。这个监听器会接受一个名为”open”的事件对象。</td>
</tr>
<tr>
<td>onmessage</td>
<td>EventListener</td>
<td>消息事件的事件监听器，当有消息到达的时候该事件会触发。这个 Listener 会被传入一个名为”message”的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent">MessageEvent</a> 对象。</td>
</tr>
<tr>
<td>onerror</td>
<td>EventListener</td>
<td>错误发生时监听 error 事件的事件监听器。会接受一个名为“error”的 event 对象。</td>
</tr>
<tr>
<td>onclose</td>
<td>EventListener</td>
<td>连接关闭事件监听器。当 WebSocket 对象的 readyState 状态变为 CLOSED 时会触发该事件。这个监听器会接收一个叫 close 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent">CloseEvent</a> 对象。</td>
</tr>
</tbody></table>
<p>onopen、onmessage、onerror 和 onclose 属性，除了直接给属性赋值外，还可以通过给 WebSocket 添加监听事件的方式来使用。	</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">	<span class="comment">// logic</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&quot;open&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">	<span class="comment">// logic</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Ready-state-常量"><a href="#Ready-state-常量" class="headerlink" title="Ready state 常量"></a>Ready state 常量</h1><table>
<thead>
<tr>
<th>常量</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONNECTING</td>
<td>0</td>
<td>连接还没建立</td>
</tr>
<tr>
<td>OPEN</td>
<td>1</td>
<td>连接已经建立并准备好数据传输</td>
</tr>
<tr>
<td>CLOSING</td>
<td>2</td>
<td>连接正在关闭，或已调用 close() 方法</td>
</tr>
<tr>
<td>CLOSED</td>
<td>3</td>
<td>连接已经关闭</td>
</tr>
</tbody></table>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="send-data"><a href="#send-data" class="headerlink" title="send(data)"></a>send(data)</h2><ul>
<li>data<br>要发送的数据。参数类型可能是 DOMString、ArrayBuffer、Blob 或 ArrayBufferView。</li>
</ul>
<h2 id="close-code-reason"><a href="#close-code-reason" class="headerlink" title="close([code],[reason])"></a>close([code],[reason])</h2><ul>
<li><p>code<br>[可选 ] 一个 unsigned short 数字值表示关闭连接的状态号，表示连接被关闭的原因。如果这个参数没有被指定，默认的取值是 1000 （表示正常连接关闭）。具体取值请看 CloseEvent 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes">code 属性取值</a>。</p>
</li>
<li><p>reason<br>[可选 ] 一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于 123 字节的 UTF-8 文本（不是字符）。</p>
</li>
</ul>
<h1 id="扩展实现"><a href="#扩展实现" class="headerlink" title="扩展实现"></a>扩展实现</h1><ul>
<li><p><a href="https://github.com/joewalnes/reconnecting-websocket">reconnecting-websocket</a><br>基于 WebSocket API 封装，支持自动重连。</p>
</li>
<li><p><a href="https://github.com/sockjs/sockjs-client">SockJS-client</a><br>由于 WebSocket API 有浏览器版本限制（IE 10+），SockJS 为了解决这个问题，底层首先使用 WebSocket API 尝试建立连接，如果失败，会根据不同浏览器的特点选择流传输或者轮询的方式。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">MDN WebSocket</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.w3.org/TR/websockets/">The WebSocket API</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent">MDN Message​Event</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent">MDN Close​Event</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.zhangxinxu.com/wordpress/2013/10/understand-domstring-document-formdata-blob-file-arraybuffer">理解 DOMString、Document、FormData、Blob、File、ArrayBuffer</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">Comparison of WebSocket implementations</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 协议的发展概述</title>
    <url>/2021/02/24/HTTP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%91%E5%B1%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>1969 年诞生于美国的因特网（Internet），现如今已经发展为覆盖五大洲 150 多个国家和地区的开放型全球计算机网络系统，我们普通用户只需要一根网线，一个调制解调器与因特网服务提供商相连，便可以进入其中。当然，因特网并不是全球唯一的互联网络，比如在欧洲就存在欧盟网（Euronet），在美国也还有国际学术网（BITNET）等。一般来说，我们会将因特网看作是互联网（internet），但是严格来说互联网泛指由多个计算机网络互相连接而组成的一个大型网络，因此因特网只是互联网的一种。</p>
<span id="more"></span>

<p>万维网（World Wide Web）作为因特网最主要的组成部分，由无数个网络站点和网页组成，而负责传输这些超文本信息的就是 HTTP 协议（HyperText Transfer Protocol）。HTTP 协议建立在 TCP&#x2F;IP 协议簇之上，从早期的单行协议，到如今的 QUIC，总体上看还是保持着一些基本的特征。</p>
<p>首先 HTTP 是简单的，虽然 HTTP&#x2F;2 协议将 HTTP 消息封装到了帧（frames）中，但是 HTTP 从大体上看还是简单易读的。HTTP 是可扩展的，在 HTTP&#x2F;1.0 协议中添加的 HTTP headers 让协议的扩展变得非常容易，只需要服务端与客户端就新 header 的语义达成一致，新功能就可以很轻松的添加进来。HTTP 是无状态的，这意味着请求之间是没有关系的，这就带来一个问题，即用户无法在一个网站中进行连续的交互，所幸我们可以通过 HTTP 的头部扩展，也就是 HTTP Cookies 来解决这个问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103022303/2021/03/02/r7m.png" alt="HTTP 的发展"></p>
<h1 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h1><p>最初的 HTTP 协议并没有版本号，后来它的版本号被定为 0.9 是为了区分在它之后的版本，即 HTTP&#x2F;1.0。HTTP&#x2F;0.9 极其简单，请求由单行指令构成，只能使用 GET 方法，后面跟着目标资源的路径，比如：<code>GET /index.html</code>，响应则只包含文档本身。由于没有头部信息，所以无法传输其他类型的文件。在此协议中，连接会在单个请求和响应完成之后关闭。关于 HTTP&#x2F;0.9 的详细信息，可以查看<a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html">这份文档</a>。</p>
<h1 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h1><p>在 20 世纪 90 年代初的互联网热潮中，不断增长的 Web 需求很快就暴露了 HTTP&#x2F;0.9 的种种缺陷，于是浏览器和服务器纷纷扩展内容使其用途更广。在 1991 年到 1995 年，这些新的扩展并没有被引入到标准中以促进协议的完善，而是仅仅作为一些尝试，在这之中，也出现了一些最佳实践和常见模式。直到 1996 年 5 月，网络工作组（Network Working Group）才发布了 <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a>，也就是 HTTP&#x2F;1.0 协议的规范。它记录了许多已经被广泛使用的 HTTP&#x2F;1.0 的“常见用法”，由于这只是一个偏向信息性质的 RFC，因此不能算作是一个正式的规范或 Internet 标准。</p>
<p>在 HTTP&#x2F;1.0 中，请求和响应的消息格式得到了规范。一个完整的请求消息包含请求行（Request Line）、请求头、空行（CRLF）和请求实体（Entity Body）四个部分，请求行新增了 HTTP 版本号，同时请求方法也扩展出了 HEAD 和 POST。一个完整的响应消息则包含状态行（Status Line）、响应头、空行和响应实体（Entity Body）四个部分。HTTP Header 的引入让协议变得非常灵活，得益于 Content-Type 头的出现，新的 HTTP 协议具备了能够传输除纯文本 HTTP 文件以外其他类型文件的能力。新增的响应状态码会在响应开始时发送，使浏览器能够了解请求执行的情况，并作出相应的调整行为。</p>
<p>需要注意的是，在 HTTP&#x2F;1.0 中，连接默认是不持久的，这就意味着每次请求都需要开启一个新的连接，而开启连接是一个很耗时的操作，同时连接过多也会造成大量的资源消耗，因此一般浏览器都会有针对每个服务端的最大连接数限制。下表是各个浏览器的单个 host 的最大连接数限制，数据来源于 <a href="https://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">Roundup on Parallel Connections</a> 这篇文章。</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>HTTP&#x2F;1.1</th>
<th>HTTP&#x2F;1.0</th>
</tr>
</thead>
<tbody><tr>
<td>IE 6,7</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>IE 8</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>Firefox 2</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>Firefox 3</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>Safari 3,4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>Chrome 1,2</td>
<td>6</td>
<td>?</td>
</tr>
<tr>
<td>Chrome 3</td>
<td>4</td>
<td>4</td>
</tr>
</tbody></table>
<blockquote>
<p>虽然 HTTP&#x2F;1.0 中没有关于 keepalive 操作的正式规范，但是有一些客户端和服务端已经实现了该功能。在这些实现中，请求或响应的头部中可以使用 <code>Connection: keep-alive</code>，表示连接不会在请求和响应结束后立即断开，而是保持连接。一般情况下，此时还会带有一个类似 <code>Keep-Alive: timeout=5, max=100</code> 的头部信息，用来描述连接保持的时间和最多支持的请求数。</p>
</blockquote>
<h1 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h1><p>HTTP&#x2F;1.0 的多种不同的实现方式在实际运用中显得有些混乱，所以在 1997 年初，HTTP 的第一个标准化版本 <a href="https://tools.ietf.org/html/rfc2068">RFC 2068</a>，也就是针对 HTTP&#x2F;1.0 规范的修订版 HTTP&#x2F;1.1 标准正式发布。1999 年 6 月，HTTP&#x2F;1.1 的第一个修订版 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 发布。2014 年 6 月，IETF 废弃了 RFC 2616 并将它拆分到了六个单独的协议中，同时重点对原来语义模糊的部分进行了解释。</p>
<p>HTTP&#x2F;1.1 消除了大量具有歧义的内容，并引入了多项改进，比如默认使用连接复用，支持管线化技术（Pipelining），支持响应分块传输，增加了额外的缓存控制机制，内容协商机制等等。</p>
<h2 id="连接复用"><a href="#连接复用" class="headerlink" title="连接复用"></a>连接复用</h2><p>HTTP&#x2F;1.1 默认使用持久化连接机制，因此多个请求和响应可以共用一个 TCP 连接，这样可以明显减少请求延迟，因为在发送第一个请求之后，客户端不再需要重新与服务端进行 TCP 的三次握手来建立连接。</p>
<p>连接复用的好处有很多，但是随之而来的一个问题就是：客户端在请求得到响应后，又该如何得知服务端响应的数据已经全部传输完毕了呢？在没有使用连接复用的时候，服务端在发送完所有的响应内容之后就会关闭连接，客户端读取数据时就会返回 EOF（-1），这样就能够得知数据已经全部接收完毕了；而使用了连接复用后，当客户端发送第一个请求时就与服务端建立了连接，这个连接会在一段时间内保持，此时客户端无法得知响应的数据是否已经全部传输完毕，比如客户端可能会在接收到部分数据后，短时间内一直没有再次收到响应的数据，但是我们无法确定是不是由于网络延迟等原因导致响应没有及时到达。</p>
<p>为了解决这个问题，可以使用 <code>Content-Length</code> 头，用来指明 Entity Body 的大小。这个标志在 GET 请求中不能使用，在 POST 请求中需要使用，同时也经常出现在响应头中。比如，当响应头中带有 <code>Content-Length: 700</code>，则表示该响应体的内容共有 700 字节，浏览器在接收到 700 个字节的响应体数据之后就知道响应已经完成了。</p>
<h2 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h2><p>有时响应体的大小并不容易确定，比如由动态语言生成的响应体，此时就需要用到 <code>Transfer-Encoding: chunked</code> 消息头，它表示响应体的内容会采用分块传输。如果一个 HTTP 消息的头信息包含该字段和值，那么之后的消息体则会由数量未定的块组成，每一个非空的块都以该块所包含的数据长度（十六进制的字节数）开始，跟随一个 CRLF，之后是数据本身，最后以 CRLF 结尾。最后一个块则不包含任何数据，由块大小为 0，一些可选的填充空白格以及 CRLF 结尾，代表分块内容结束。如果还有额外的数据，可以在结束之后，使用 Trailer 进行拖挂传输额外的数据。</p>
<h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p>默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到响应之后才会被发出，由于受到网络延迟和带宽的限制，在下一个请求被发送之前，可能需要等待很长一段时间。管线化（Pipelining）的出现使得客户端在同一条连接上可以发送多个连续的请求，而不用等待响应返回，但是服务端需要按照客户端发送请求的顺序来返回响应。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103022303/2021/03/02/LKm.png" alt="管线化"></p>
<p>管线化实际上是将多个 HTTP 请求同时输出到一个连接中（更确切的说是输出到一个 TCP 连接中，或者说是放到一个 TCP 分组中），然后等待响应。这在浏览器需要大批量提交请求时可以大幅度缩短页面的加载时间，特别是在传输延迟较高的情况下（比如使用卫星网络）会更加明显。</p>
<p>使用管线化的请求方法需要是幂等的，非幂等的方法，例如 POST 将不会被管线化。连续的 GET 和 HEAD 请求总是可以管线化的，其他的幂等方法，如 PUT 和 DELETE 是否可以被管线化取决于一连串请求是否依赖于其他请求的响应。在初次创建连接时，不应启动管线化机制，因为对方（服务器或代理服务器）不一定支持该机制。支持管线化的服务端并不一定需要提供管线化的回复，只要求在收到管线化请求时不会失败即可。</p>
<p>管线化看起来很美好，然而很多现代的浏览器都没有进行支持或者默认关闭了该功能（在目前 HTTP&#x2F;2 的大背景下，浏览器大都选择了支持多路复用）。导致这一现象的原因主要有：很多 HTTP 代理服务器可能不支持或者不通过管线化传输请求。正确的实现管线化是复杂的，传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，管线化带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局，因此 HTTP 管线化在大多数情况下带来的改善并不明显。最后一个关键性的原因就是管线化会导致队首阻塞（Head-of-line blocking, HOL）。</p>
<p>从本质上讲，发生 HOL 的根本原因是由于 HTTP 请求和响应使用的是 FIFO 的队列机制，因此不管是 HTTP&#x2F;1.0 还是 HTTP&#x2F;1.1，都会发生 HOL。在 HTTP&#x2F;1.1 中，我们假设客户端在一个连接上发送了几个连续的请求，按照规定，服务端应该按照收到请求的顺序返回结果，如果服务端在处理某个请求时花费了大量的时间，那么后面所有的请求都需要等待这个请求处理结束后才能进行。为了避免或者减少该问题，一般常见的处理方式有两种：一种是减少请求数量，这间接地催生出了很多网页设计的技巧，比如合并脚本和样式表，使用精灵图，以及将图片嵌入样式（将图片转换成 Base64 编码的形式）等等。另一种是同时打开多个持久连接，也就是所谓的域名分片。假设网站域名为 <code>www.example.com</code>，我们可以将它拆分成好几个域名，比如： <code>www1.example.com</code>、<code>www2.example.com</code> 等等，所有的域名都指向同一台服务器，这样浏览器访问网站时就可以同时开启多个 TCP 连接了。当然，这些都是无奈之举，如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h1><p>说起 HTTP&#x2F;2，就不得不提 SPDY。它是 Google 开发的一个基于 TCP 传输控制协议的应用层协议，也是 HTTP&#x2F;2 的前身。Google 最早是在 Chromium 中提出的 SPDY 协议，并于 2009 年 11 月发布了 SPDY 协议的第一份草案。</p>
<p>SPDY 设计之初就是为了解决 HTTP&#x2F;1.1 效率不高的问题。如果以提高效率为目的，那么不光应用层的 HTTP 协议，甚至传输层的 TCP 协议都有调整的空间，但是由于 TCP 作为更底层的协议已经存在了长达几十年之久，其实现已根植于全球网络的基础设施当中，可谓是牵一发而动全身，业界响应的积极性必然不高，所以 SPDY 一开始瞄准的就是 HTTP。</p>
<p>为了兼容现有的协议，减少甚至避免服务端升级带来的改动，SPDY 只是修改了 HTTP 请求和响应在网络上传输的方式，这就意味着只需在 HTTP 之下，TCP 和 SSL 之上增加一个 SPDY 传输层，这样就可以轻松兼容老版本的 HTTP 协议（将 HTTP&#x2F;1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能，现有的服务端应用几乎不用做任何修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/KKA.png" alt="SPDY"></p>
<p>2015 年 5 月，作为 HTTP 协议的第二个主要版本，HTTP&#x2F;2 标准的 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 规范发布，SPDY 协议最终只成为了一个<a href="https://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00">互联网草案</a>，但是 SPDY 开发组的成员全程参与了 HTTP&#x2F;2 的制定，HTTP&#x2F;2 的很多关键功能都来自于 SPDY，也就是说，SPDY 的成果被采纳并最终演变成了 HTTP&#x2F;2。</p>
<h2 id="消息帧"><a href="#消息帧" class="headerlink" title="消息帧"></a>消息帧</h2><p>HTTP&#x2F;2 与 HTTP&#x2F;1.1 相比，其中一个最大的变化就是：HTTP&#x2F;2 变成了一个二进制协议，消息头和消息体都被封装为更小的采用二进制编码的帧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>在 HTTP&#x2F;1.x 中，报文不是基于帧的，而是以文本分隔的，比如这样一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1 &lt;crlf&gt;</span><br><span class="line">Host: www.example.com &lt;crlf&gt; </span><br><span class="line">Connection: keep-alive &lt;crlf&gt; </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9... &lt;crlf&gt; </span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4)... &lt;crlf&gt; </span><br><span class="line">Accept-Encoding: gzip, deflate, sdch &lt;crlf&gt; </span><br><span class="line">Accept-Language: en-US,en;q=0.8 &lt;crlf&gt; </span><br><span class="line">Cookie: pfy_cbc_lb=p-browse-w; customerZipCode=99912|N; ltc=%20;...&lt;crlf&gt; </span><br><span class="line">&lt;crlf&gt;</span><br></pre></td></tr></table></figure>

<p>解析这种数据只需不断读入字节，直到遇到分隔符为止。由于一次只能处理一个请求或响应，并且解析在完成之前不能停止，所以往往速度慢且容易出错，同时也无法预测解析需要多少内存。这就带来了一系列的问题：该把一行读到多大的缓冲区里？如果行太长会发生什么，是应该增加并重新分配内存，还是返回 400 错误？</p>
<p>比较 HTTP&#x2F;1.x，你会发现 HTTP&#x2F;2 的帧格式定义更接近 TCP 层的方式。其中 length 是帧载荷的大小，type 是当前帧的类型（一共 10 种），flags 是具体帧类型的标识，stream id 作为每个流的唯一 ID，用于流控制，payload 是消息的正文，长度在 length 中设定。因为规范严格且明确，所以解析的逻辑可以像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop </span><br><span class="line"> Read 9 bytes off the wire // 读前 9 字节</span><br><span class="line"> Length = the first three bytes // 长度值为前 3 字节 </span><br><span class="line"> Read the payload based on the length. // 基于长度读载荷</span><br><span class="line"> Take the appropriate action based on the frame type. // 根据帧类型采取对应操作</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure>

<p>这样一来，实现和维护都会简单很多。虽然看上去协议的格式完全不同了，但是实际上 HTTP&#x2F;2 并没有改变 HTTP&#x2F;1.x 的语义，只是把原来 HTTP&#x2F;1.x 的 header 和 body 部分用 frame 重新封装了一层而已。调试的时候浏览器甚至会把 HTTP&#x2F;2 的 frame 自动还原成 HTTP&#x2F;1.x 的格式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/gkw.png" alt="帧"></p>
<p>值得一提的是，HTTP&#x2F;2 将 HTTP&#x2F;1.x 中的请求行变成了魔法伪首部，即所谓的<strong>一切都是 Header</strong>。举个例子，HTTP&#x2F;1.1 的请求和响应可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1 </span><br><span class="line">Host: www.example.com </span><br><span class="line">User-agent: Next-Great-h2-browser-1.0.0 </span><br><span class="line">Accept-Encoding: compress, gzip</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Content-type: text/plain </span><br><span class="line">Content-length: 2</span><br></pre></td></tr></table></figure>

<p>在 HTTP&#x2F;2 中，它等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:scheme: https </span><br><span class="line">:method: GET </span><br><span class="line">:path: / </span><br><span class="line">:authority: www.example.com </span><br><span class="line">User-agent: Next-Great-h2-browser-1.0.0 </span><br><span class="line">Accept-Encoding: compress, gzip</span><br><span class="line"></span><br><span class="line">:status: 200 </span><br><span class="line">content-type: text/plain</span><br></pre></td></tr></table></figure>

<p>同时 HTTP&#x2F;2 也没有了分块编码（chunked encoding），在基于帧的世界里，谁还需要分块？只有在无法预知数据长度的情况下向对方发送数据时，才会用到分块。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP&#x2F;2 中，一个 TCP 连接可以存在若干个双向字节流，每个流可以承载若干条消息，每条消息都是一条逻辑 HTTP 消息，由若干最小的二进制帧（Frame）组成。帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 头、消息载荷等等。下图是流的逻辑结构，图中的流作为一种逻辑通道被划分，而实际上应该将流理解成在连接上的一系列帧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/Qle.png" alt="流的逻辑结构"></p>
<p>HTTP&#x2F;2 实现了完整的请求和响应复用，用户的每个请求都分配了一个流编号（Stream Id），客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后在另一端根据流编号将它们重新组装起来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/aEb.png" alt="多路复用"></p>
<p>如上图，客户端正在向服务端发送一个 DATA 帧（数据流 5），与此同时，服务端正向客户端交错发送数据流 1 和数据流 3 的一系列帧。此时一个连接上同时有三个并行的数据流。</p>
<p>有了多路复用，客户端就可以一次性发出所有资源的请求，服务端也可以立即着手处理这些请求。但是因此也带来了一个问题，我们假设服务端同时接收到了 100 个请求，但是请求没有标识哪个更重要，那么它将几乎同时发送每个资源，次要资源可能就会影响到关键资源的传输。因此，HTTP&#x2F;2 提供了优先级（Priority）和依赖（Dependency）的功能，每个流都可以设置优先级和依赖。依赖为客户端提供了一种能力，通过指明某些对象对另一些对象有依赖，告知服务端这些对象应该优先传输，而优先级则能够让客户端告知服务端如何确定具有共同依赖关系的对象的传输顺序。优先级和依赖都是可以动态调整的。动态调整在有些场景下很有用，比如用户在浏览商品的时候，快速的滑动到了商品列表的底部，但前面的请求先发出，如果不把后面请求的优先级调高，用户当前浏览的图片要到最后才能加载完成，体验就要差一些。</p>
<h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>HTTP 无状态的特性导致报文的头部一般都会携带大量的字段，有些字段是固定出现的，比如 <code>User-Agent</code>、<code>Accept</code>、<code>Host</code> 等，有些则是自定义的。这些字段有时能够多达成百上千字节，但是 Body 部分却常常只有几十字节。过大的 Header 在一定程度上增加了传输的成本，更要命的是，大量报文中的很多字段都是重复的。</p>
<p>为了减少此类开销和提升性能，HTTP&#x2F;2 使用了专门设计的 HPACK 算法来压缩请求和响应头的元数据，具体来说主要有两点：其一是客户端和服务端会根据 <a href="https://tools.ietf.org/html/rfc7541">RFC 7541</a> 的附录 B 中的哈夫曼编码（Huffman Coding）表，对传输的头字段和值进行编码，从而减小传输数据的大小。其二是客户端和服务端还会同时维护一份包含之前见过的头字段的索引列表。这份列表包含一个静态表和一个动态表：静态表由 RFC 7541 的附录 A 定义，其中包含常见头部名称以及常见头部名称与值的组合。动态表最初为空，根据先入先出的原则，在客户端与服务端进行数据交换时进行更新。</p>
<p>利用哈夫曼编码，我们可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码。<strong>对于相同的数据，不再通过每次的请求和响应发送</strong>。比如下图中的两个请求，请求一发送了所有的头部字段，请求二则只需要发送差异数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/pZv.png" alt="头部压缩"></p>
<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>提升单个对象性能的最佳方式，就是在它被用到之前就已经放到浏览器缓存当中，这也正是 HTTP&#x2F;2 服务端推送的目的，说白了就是<strong>提前发送响应</strong>。当然，服务端也不能随意就发送对象给客户端，这会带来性能和安全问题，因此它需要解决推什么、何时推以及怎么推的问题。</p>
<p>首先，被推送的对象必须是可被缓存的，不能被缓存也就失去了推送的意义。如果服务端决定要推送一个对象（在 RFC 中被称为“推送响应”），就会先构造一个 PUSH_PROMISE 帧。在这个帧中，流 ID 一定会对应到客户端某个已发送的请求。举个例子：假设浏览器请求一个 HTML 页面，页面中有一些 JavaScript 对象，如果要推送此页面使用的某个 JavaScript 对象，服务端就会使用请求对应的流 ID 来构造 PUSH_PROMISE 帧，与此同时，PUSH_PROMISE 帧还会指示将要发送的响应所使用的流 ID。</p>
<p>在理想情况下，PUSH_PROMISE 帧应该更早发送，最起码应该早于客户端可能接收到承载着推送对象的 DATA 帧之前发送。如果客户端对 PUSH_PROMISE 中的任何元素不满，都可以按照拒收原因选择重置这个流（使用 RST_STREAM），或者发送 PROTOCOL_ERROR。一般当浏览器缓存中已经有了该对象时，会选择重置流。当 PUSH_PROMISE 涉及的协议层面有问题时，比如方法不安全（不是幂等的方法），或者客户端已经在 SETTINGS 帧中表明自己不接受推送时，仍然进行了推送，此时客户端会发送 PROTOCOL_ERROR。</p>
<p>假如客户端不拒收推送，服务端就会继续进行推送流程，用 PUSH_PROMISE 中指明的流来发送对象。需要注意的是，客户端会从 1 开始设置流 ID，之后每新开启一个流就会增加 2，即一直使用奇数。服务端开启在 PUSH_PROMISE 中标明的流时，设置的流 ID 从 2 开始，之后一直使用偶数。这种设计避免了客户端和服务端之间的流 ID 冲突，也可以轻松地判断哪些对象是由服务端推送的。0 是保留数字，用于连接级控制消息，不能用于创建新的流。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104071621/2021/04/07/xnq.png" alt="服务端推送"></p>
<p>对于不同的应用，选择要推送哪些资源的逻辑可能也有很大不同，有些逻辑可能很简单，有些则有可能异常复杂。如果服务端的选择正确，那么确实会有助于提升页面的整体性能，反之则会损耗页面性能。尽管 SPDY 在很早之前就已经引入了服务端推送的特性，但是直到如今，通用的服务端推送解决方案还是很少。</p>
<h2 id="关于-TLS"><a href="#关于-TLS" class="headerlink" title="关于 TLS"></a>关于 TLS</h2><p>在 HTTP&#x2F;2 的规范中并没有明确要求必须使用 TLS，也就是说 HTTP&#x2F;2 其实是支持明文通信的，但是实际上主流的浏览器都不支持基于非 TLS 的 HTTP&#x2F;2，所以从“事实上”来看，可以认为 HTTP&#x2F;2 就是加密通信的。这背后主要有两个原因。一个非常现实的原因是，从之前对 WebSocket 和 SPDY 的实验看来，使用 Upgrade 首部，通过 80 端口（明文的 HTTP 端口）通信时，通信链路上代理服务器的中断等因素会导致非常高的错误率。如果基于 443 端口（HTTPS 端口）上的 TLS 发起请求，错误率会显著降低，并且协议通信也更简洁。还有一个原因是，人们越来越相信，考虑到安全和隐私，一切都应该被加密。HTTP&#x2F;2 被视为一次推动全网加密通信发展的机会。</p>
<h2 id="关于-HOL"><a href="#关于-HOL" class="headerlink" title="关于 HOL"></a>关于 HOL</h2><p>我们前面说过，由于 HTTP 请求和响应使用的是 FIFO 的队列机制，因此不管是 HTTP&#x2F;1.0 还是 HTTP&#x2F;1.1，都会发生 HOL。而 HTTP&#x2F;2 引入的双向多路复用流，则直接消除了 HTTP&#x2F;1.x 请求的阻塞性质，相当于引入了一个更好的，功能完备的，完全支持的管线化机制（Pipelining）。</p>
<p>应当注意的是，虽然 HTTP&#x2F;2 解决了 HTTP HOL 的问题，但是由于它还是构建在 TCP 之上，所以仍然面临着 TCP 层面的 HOL 问题，并且该问题在 HTTP&#x2F;2 下会引发更严重的后果。我们知道，TCP 为了保证可靠传输，有一个“丢包重传”的机制，发生丢包时必须等待重新传输确认。由于 HTTP&#x2F;2 只有一条 TCP 连接，如果单个 TCP 数据包丢失，则 TCP 连接必须请求重新发送该数据包，并等待该数据包成功传输，然后才能处理后续的 TCP 数据包，即使这些数据包是用于其他 HTTP&#x2F;2 流的，这就导致了整个 TCP 连接中的请求都被阻塞。而在 HTTP&#x2F;1.x 中，由于可以开启多个 TCP 连接，出现这种情况时反倒只会影响其中的某个或某些连接，其他连接还可以正常传输数据。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x">HTTP&#x2F;1.x 的连接管理</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/143464334">HTTP&#x2F;3 原理实战</a></p>
</blockquote>
<blockquote>
<p><a href="https://hpbn.co/http2/">HTTP&#x2F;2</a></p>
</blockquote>
<blockquote>
<p>《HTTP&#x2F;2 基础教程》</p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA 导出可执行 jar</title>
    <url>/2017/07/26/IDEA%20%E5%AF%BC%E5%87%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%20jar/</url>
    <content><![CDATA[<p>第一步：File -&gt; Project Structure -&gt; Artifacts</p>
<span id="more"></span>

<p>第二步：Add -&gt; JAR -&gt; From modules with dependencies</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/V9.png" alt="add"></p>
<p>第三步：设置 Main Class，设置 MANIFEST.MF 目录。这里注意 META-INF&#x2F;MANIFEST.MF 目录不要使用默认的，而是选择项目目录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/2w.png" alt="manifest.mf"></p>
<p>第四步：Build -&gt; Build Artifacts</p>
]]></content>
      <categories>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Java</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 数据页结构</title>
    <url>/2020/07/06/InnoDB%20%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>InnoDB 有很多页类型，数据页的页类型为 B-tree Node，存放的是表中行的实际数据。InnoDB 的数据页由 7 部分组成，其中文件头（File Header）、页头（Page Header）和文件尾（File Trailer）的大小是固定的，分别为 38、56 和 8 个字节，这些空间用来标记该页的一些信息。行记录（User Records）、Free Space（空闲空间）和页目录（Page Directory）的大小是动态的，这些空间为实际的行记录存储空间。</p>
<span id="more"></span>

<img width="65%" src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007062005/2020/07/06/Bxe.png" alt="数据页">

<p>在页的 7 个组成部分中，行记录会按照我们指定的行格式存储到 User Records 中。但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records，当 Free Space 的空间全部被 User Records 使用后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007062005/2020/07/06/l39.png" alt="行记录在页中的分配"></p>
<h1 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h1><p>File Header 用来记录页的一些头信息，共由 8 个部分组成，共占用 38 个字节。不同类型的页的第一个部分都是文件头。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4</td>
<td>MySQL 4.0.14 之前为 0，之后的版本中该值代表页的 checksum 值（总和检验码）</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4</td>
<td>页号，表空间中页的偏移值，起始值为 0。如果某独立表空间 a.ibd 的大小为 1 GB，如果页的大小为 16 KB，那么总共有 65536 个页。偏移值代表该页在所有页中的位置。同时通过该部分的长度 4 个字节可以算出一个表空间最大支持 <code>2^32 * 16 KB = 64 TB</code></td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4</td>
<td>上一页的页号，B+Tree 的特性决定了叶子节点必须是双向列表</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4</td>
<td>下一页的页号，B+Tree 的特性决定了叶子节点必须是双向列表</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8</td>
<td>最后被修改的日志序列的 LSN（Log Sequence Number）</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2</td>
<td>页的类型，数据页对应的类型为 FIL_PAGE_INDEX，值为 0x45BF</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8</td>
<td>仅在系统表空间的一个页中定义，代表文件成功刷新到磁盘的 LSN。独立表空间中该值都是 0</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4</td>
<td>从 MySQL 4.1 开始，该值代表页属于哪个表空间（存放的是表空间 ID）</td>
</tr>
</tbody></table>
<p>InnoDB 是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大，InnoDB 可能不会一次性为这么多数据分配一块非常大的存储空间，如果分散到多个不连续的页中存储的话就需要把这些页关联起来，使用 FIL_PAGE_PREV 和 FIL_PAGE_NEXT 就可以建立一个双向链表把许许多多的页就串联起来，而无需它们在物理上真正连续。需要注意的是，并不是所有类型的页都有这两个属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007062005/2020/07/06/z1Y.png" alt="上一页和下一页"></p>
<h1 id="页头"><a href="#页头" class="headerlink" title="页头"></a>页头</h1><p>Page Header 用来记录数据页的状态信息，由 14 个部分组成，共占用 56 个字节。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2</td>
<td>在 Page Directory 中 Slot 的数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2</td>
<td>堆中第一个记录的指针（<strong>记录在页中是以堆的形式存放的</strong>），该地址之后就是 Free Space</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2</td>
<td>堆中的记录数（包括最小记录和最大记录以及标记为删除的记录），但是第 15 位表示行记录格式</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2</td>
<td>指向可重用空间的首指针，即第一个标记为删除的记录的地址（已删除的记录通过 next_record 组成一个链表），如果这个页上有记录要插入，可以先从这里分配空间，如果空间不够，再从 Free Space 分配。</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2</td>
<td>已删除的字节数，即行记录中 delete_mask 为 1 的记录大小的总和</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2</td>
<td>最后插入记录的位置（指向最近一个被插入的记录，主要用来方便后续的插入操作）</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2</td>
<td>最后一个记录插入的方向。假如新插入的一条记录的主键值比上一条记录的主键值大，那么这条记录的插入方向是从右插入，反之则是从左插入。</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2</td>
<td>一个方向连续插入的记录个数，如果最后一条记录的插入方向发生了改变，那么这个该值会被清零重新统计</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2</td>
<td>该页中记录的数量（不包括最小记录和最大记录以及标记为删除的记录)</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8</td>
<td>修改当前页的最大事务 ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2</td>
<td>当前页在索引树中的位置，0x00 代表叶子节点，即叶子节点总是在第 0 层</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8</td>
<td>索引 ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10</td>
<td>B+树数据页非叶子节点所在段的 segment header。该值仅在 B+树的 Root 页中定义</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td>10</td>
<td>B+树数据页所在段的 segment header。该值仅在 B+树的 Root 页中定义</td>
</tr>
</tbody></table>
<h1 id="最小记录和最大记录"><a href="#最小记录和最大记录" class="headerlink" title="最小记录和最大记录"></a>最小记录和最大记录</h1><p>在 InnoDB 中，每个数据页中都有两个虚拟的行记录，用来限定记录的边界。Infimum 记录比该页中任何记录都要小（对比主键值），而 Supremum 记录则比该页中任何可能大的记录都要大。这两个记录在页创建的时候建立，且在任何情况下都不会被删除。在 Compact 行格式和 Redundant 行格式中，两者占用的字节数不同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007062005/2020/07/06/jrL.png" alt="最小记录和最大记录"></p>
<p>这里需要提到行记录中的 next_record。它表示从当前记录的真实数据到下一条记录的真实数据的地址（即记录头信息和列数据的中间位置）偏移量。比如第一条记录的 next_record 为 32，那么就表示从第一条记录的真实数据的地址处向后找 32 个字节就是下一条记录的真实数据地址。同时需要注意的是，下一条记录并不是按照插入顺序，而是按照主键值由小到大的顺序，Infimum 记录的下一条就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条就是 Supremum 记录。为了展示清楚，这里先创建一张表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demo (</span><br><span class="line">    c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">INT</span>,</span><br><span class="line">    c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (c1)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007062005/2020/07/06/dvn.png" alt="next_record"></p>
<h1 id="用户记录和空闲空间"><a href="#用户记录和空闲空间" class="headerlink" title="用户记录和空闲空间"></a>用户记录和空闲空间</h1><p>User Records 就是实际存储行记录的部分，Free Space 指的是空闲空间，它是一个链表结构。在一条记录被删除后，该记录的空间会加入到空闲链表中（与其说是加入，不如说是先从可重用链表中分配空间，空间不足再从空闲空间分配）。</p>
<h1 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h1><p>我们知道记录在页中是按照主键值从小到大的顺序组成了一个单链表，如果我们想根据主键值查找页中的某条记录，那么最笨的办法就是从 Infimum 记录开始，沿着链表向后查找（next_record）。这种线性查找的方式在页中存储了很多条记录时性能较差，InnoDB 的设计者们实现了一种更好的查询方式。</p>
<p>他们将页中所有的记录（包括最大和最小记录，但不包括标记为已删除的记录）划分为几个组。每个组的最后一条记录，也就是组内最大的那条记录的头信息中的 n_owned 属性表示组内一共有几条记录。最后将每个组的最后一条记录的地址偏移量（页面从 0 开始数，到该记录时的字节数）单独提取出来按照顺序存储到页目录中，页目录中的这些地址偏移量也被称为槽（Slot）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007062005/2020/07/06/Aa5.png" alt="页目录"></p>
<p>在这个页目录中有两个槽，0 号槽的值为 99，代表最小记录的地址偏移量，1 号槽的值为 112，代表最大记录的地址偏移量。在最小记录的头信息中，n_owned 的值为 1，表示该分组中只有 1 条记录，也就是最小记录本身。最大记录的头信息中，n_owned 的值为 5，表示该分组中有 5 条记录。</p>
<p>InnoDB 中规定，对于最小记录所在的分组只能有 1 条记录，对于最大记录所在的分组拥有的记录数只能在 1 到 8 条之间，剩下的分组中记录的条数只能在 4 到 8 条之间。即在初始情况下，数据页中只有最小和最大两条记录，它们分为两个组。之后每插入一条记录，都会从页目录中找到主键值比插入记录的主键值大且差值最小的槽（确定该记录应该处于哪个分组中），然后把该槽对应记录的 n_owned 值加 1，直到该组中的记录数等于 8 个。接下来再插入记录时，会将最大记录所在的组拆分成两个，新分离出来的组中有 4 条记录，最大记录所在的组中有 5 条记录。接着上面的例子，我们再插入多条数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007062005/2020/07/06/1qo.png" alt="页目录分组"></p>
<p>接下来我们再看一开始提出的问题，在页中查找指定主键值对应的记录。由于各个槽对应的记录的主键值都是按照从小到大的顺序排列的，因此我们可以用二分法进行快速查找。有 0 到 4 共五个槽，初始情况下最小的槽 low &#x3D; 0，最大的槽 high &#x3D; 4，假设需要查找的主键值为 6。那么首先计算中间槽的位置：(0 + 4) &#x2F; 2 &#x3D; 2，查看 2 号槽中对应的主键值为 8，而 6 又小于 8，所以设置 high &#x3D; 2，low 保持不变。然后重新计算中间槽的位置为 1，查看槽位对应的主键值为 4，所以设置 low &#x3D; 1，high 保持不变。由于此时 high 与 low 的差值为 1，所以可以确定主键值为 6 的记录在 2 号槽对应的分组中。此时可以从 1 号槽最大的记录向后查找，该条记录的下一条就是 2 号槽的最小记录，直到找到为止。</p>
<p>所以在一个数据页中查找指定主键值的记录可以分为两个步骤：<strong>首先通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。接下来就可以通过该记录的 next_record 属性遍历所在分组的各个记录，直到找到为止</strong>。同时需要牢记的是，B+树索引本身并不能找到具体的一条记录，能找到的只是该记录所在的页。数据库把页载入内存，然后通过 Page Directory 再进行二叉查找。而在内存进行二分查找是很快的，通常会忽略这部分查找的时间开销。</p>
<h1 id="文件尾"><a href="#文件尾" class="headerlink" title="文件尾"></a>文件尾</h1><p>数据在内存中被修改后再同步回磁盘，这个同步的过程相对较慢。如果在同步过程中出现了异常情况，比如机器宕机、断电、磁盘损坏等，数据就有可能会丢失。因此为了检测页的完整性，InnoDB 在页中设置了 File Trailer。文件尾中只有一个 FIL_PAGE_END_LSN，占用 8 个字节。前 4 个字节代表该页的 checksum 值，后 4 个字节与 File Header 中的 FIL_PAGE_LSN 相同。InnoDB 通过将这两个值与 File Header 中的 FIL_PAGE_SPACE_OR_CHKSUM 和 FIL_PAGE_LSN 进行比较（checksum 的比较需要使用 checksum 函数，不是简单的等值比较），看是否一致，以此来保证页的完整性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《MySQL 技术内幕：InnoDB 存储引擎》</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O 模型</title>
    <url>/2018/11/12/IO%20%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>我们知道，I&#x2F;O 主要指的是磁盘或者网络 I&#x2F;O（Socket I&#x2F;O），平常我们讲的 I&#x2F;O 模型其实说的是 UNIX&#x2F;Linux 环境下的网络 I&#x2F;O 模型，这方面讲解比较详细的是 Stevens 的《UNIX Network Programming, Volume 1: The Sockets Networking API, Third Edition》。但是在 POSIX 的标准中，其实只有同步 I&#x2F;O 和异步 I&#x2F;O 两种 I&#x2F;O 模型，它俩的区别就是在整个 I&#x2F;O 操作完成之前，是否会导致请求进程阻塞。  </p>
<span id="more"></span>  

<h1 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h1><p>在学习 I&#x2F;O 模型之前，需要先了解一些 Linux 下的基本概念，如用户空间与内核空间、内核态与用户态、进程与线程的上下文切换、文件描述符、缓存 I&#x2F;O 等。  </p>
<h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>现代的操作系统一般都使用虚拟内存，要使用虚拟内存就要使用虚拟地址，进程使用的虚拟内存地址会由操作系统与相关硬件协作，转换成真正的物理内存地址。  </p>
<p>对于 32 位的操作系统而言，它的寻址空间（虚拟内存空间）为 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，同时也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟内存空间划分为了两部分。虚拟内存地址较高的 1GB（从 0xC0000000 到 0xFFFFFFFF）为内核空间，给操作系统内核使用；地址较低的 3GB（0x00000000 到 0xBFFFFFFF）为用户空间，给各个进程使用。  </p>
<h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><p>用户态与内核态是操作系统的两种运行级别。Intel x86 架构提供了 Ring0 到 Ring 3 共四种运行级别，Ring0 权限最高，Ring3 权限最低。Linux 使用 Ring0 作为内核态，Ring3 作为用户态。处于用户态的进程只能访问用户空间，而处于内核态的进程可以访问内核空间和用户空间。当一个进程需要使用操作系统提供的服务时，需要主动调用操作系统提供的系统调用接口，通过中断的方式将进程的运行由用户态切换到内核态。  </p>
<h2 id="用户栈与内核栈"><a href="#用户栈与内核栈" class="headerlink" title="用户栈与内核栈"></a>用户栈与内核栈</h2><p>内核在创建进程时，除了创建 task_struct 结构，还会为进程创建相应的堆栈。每个进程都会有两个栈，一个用户栈，存在于用户空间；一个内核栈，存在于内核空间。当进程运行在用户态时，CPU 的堆栈指针寄存器存放的是用户栈的地址，程序使用的是用户栈和用户空间；当进程运行在内核态时，CPU 的堆栈指针寄存器存放的是内核栈的地址，使用的是内核栈和内核空间。  </p>
<h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><p>为了控制进程的执行，内核有能力将一个正在运行的进程挂起并恢复以前某个被挂起的进程的执行。进程上下文的切换需要执行一些额外的操作，包括：  </p>
<ol>
<li>保存将要被挂起的进程的处理器上下文，包括程序计数器和其他寄存器。</li>
<li>更新 PCB 信息。</li>
<li>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其 PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复将要执行的进程的处理器上下文。</li>
</ol>
<p>总之，这是一个很耗资源的过程。  </p>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>进程的切换需要切换页目录以使用新的地址空间，同时还需要切换内核栈、保存和切换硬件上下文。而在同一个进程下，线程的切换不需要切换页目录（因为在同一个进程下，各个线程共享进程的资源，包括地址空间），只需要保存和切换程序计数器、一些寄存器的内容和栈。  </p>
<p>由于现代的操作系统大多使用线程作为任务的实际执行单位，所以不同进程下的线程切换其实就是进程切换。  </p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符（File descriptor）的概念往往出现在 UNIX&#x2F;Linux 环境中，它是一个用于描述指向文件的引用的抽象化概念。  </p>
<p>文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指向内核为每个进程所维护的该进程打开的文件的记录表。当程序打开或新建一个文件时，内核向进程返回一个文件描述符。  </p>
<h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I&#x2F;O"></a>缓存 I&#x2F;O</h2><p>大多数的文件系统默认的 I&#x2F;O 操作都是缓存 I&#x2F;O。在 Linux 中，以 write 为例，数据会先被拷贝到进程缓存区中，再拷贝到操作系统内核的缓存区中，最后才写入到存储设备中。  </p>
<p>有时为了保证数据的安全性，避免断电等极端情况下导致写入缓冲区的数据丢失，操作系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 来强制将缓冲区中的数据立即写入到存储设备。  </p>
<h1 id="五种-I-O-模型"><a href="#五种-I-O-模型" class="headerlink" title="五种 I&#x2F;O 模型"></a>五种 I&#x2F;O 模型</h1><p>通常来说，I&#x2F;O 操作包括对磁盘的读写、对 Socket 的读写以及对外设的读写。  </p>
<p>当用户线程发起一个 I&#x2F;O 请求（此处以读请求为例）时，内核会先查看要读取的数据是否就绪，即数据是否已经从目标设备拷贝到内核缓冲区中。对于阻塞 I&#x2F;O 来说，如果数据没有就绪，则会一直在那等待，直到数据准备完毕；对于非阻塞 I&#x2F;O 来说，如果数据没有就绪，则会返回一个标志信息来告知 CPU 数据还没就绪。当数据准备完毕时，CPU 再将数据从内核缓冲区拷贝到用户线程，这样就完成了一次完整的 I&#x2F;O 读操作。可以看到一次完整的 I&#x2F;O 读操作包含两个阶段：  </p>
<ol>
<li>检查数据是否已经拷贝到内核缓冲区中。</li>
<li>将数据从内核缓冲区拷贝到用户空间。</li>
</ol>
<h2 id="阻塞-I-O（blocking-I-O）"><a href="#阻塞-I-O（blocking-I-O）" class="headerlink" title="阻塞 I&#x2F;O（blocking I&#x2F;O）"></a>阻塞 I&#x2F;O（blocking I&#x2F;O）</h2><img alt="blocking io" src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/15/bXl.png" style="width: 80%" />

<p>recvfrom 函数是一个系统调用，用来接收指定的 Socket 传来的数据。当用户进程调用了这个函数时，就陷入了内核代码中，此时处理器处于特权级中，可以使用内核的内存空间，准备数据的阶段也就开始了（对于网络 I&#x2F;O 来说，很多时候数据在一开始还没有到达。比如，由于还没有收到一个完整的 UDP 包，这个时候内核就需要等待足够的数据到来）。在用户进程这边，整个进程就会被阻塞，当数据准备就绪时，第二个阶段开始进行，CPU 会将数据从内核缓冲区拷贝到用户内存空间，这个过程也会一直阻塞，直到数据拷贝结束，recvfrom 函数返回，用户进程才会解除阻塞状态，继续向下执行。</p>
<blockquote>
<p>阻塞 I&#x2F;O 的特点就是在 IO 操作的两个阶段都发生了阻塞。  </p>
</blockquote>
<h2 id="非阻塞-I-O（non-blocking-I-O）"><a href="#非阻塞-I-O（non-blocking-I-O）" class="headerlink" title="非阻塞 I&#x2F;O（non-blocking I&#x2F;O）"></a>非阻塞 I&#x2F;O（non-blocking I&#x2F;O）</h2><img alt="non-blocking io" src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/17/aDj.png" style="width: 80%" />

<p>recvfrom 函数有一个参数，可以设置以非阻塞的方式检查内核数据是否准备就绪。当好数据还没就绪时，recvfrom 函数直接返回一个错误值 EWOULDBLOCK；当内核中的数据准备就绪并且用户进程再次调用 recfrom 时，CPU 会马上进行 I&#x2F;O 读操作的第二个阶段，将内核缓冲区的数据拷贝到用户内存空间中。</p>
<blockquote>
<p>非阻塞 I&#x2F;O 的特点就是在等待数据就绪阶段不会阻塞，而在数据拷贝阶段才会阻塞。</p>
</blockquote>
<h2 id="I-O-多路复用（I-O-multiplexing）"><a href="#I-O-多路复用（I-O-multiplexing）" class="headerlink" title="I&#x2F;O 多路复用（I&#x2F;O multiplexing）"></a>I&#x2F;O 多路复用（I&#x2F;O multiplexing）</h2><img alt="io multiplexing" src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/17/OYo.png" style="width: 80%" />

<p>在用户进程中调用 <code>select</code> 来监听多个 Socket 对象，该函数会阻塞当前进程，直到当某个 Socket 中有数据准备就绪，<code>select</code> 函数就会返回，此时用户进程再调用 <code>recvfrom</code> 将内核缓冲区中的数据拷贝到用户内存空间中。  </p>
<p>非阻塞 I&#x2F;O 需要在用户进程中不断主动轮询，而轮询会消耗大量的 CPU 时间。与其只轮询一个任务查看内核数据的准备状态，不如轮询多个任务，只要有任何一个任务的内核数据准备就绪就进行处理。UNIX&#x2F;Linux 下的 <code>select</code> 和 <code>poll</code> 这两个函数所做的工作与之类似，也是通过不断轮询来查看内核数据的准备情况，与非阻塞 I&#x2F;O 相同的是它们都是内核级别的系统调用，并且它们都会阻塞用户进程，但是它们不会像非阻塞 I&#x2F;O 那样因为用户进程轮询调用 <code>recvfrom</code> 而频繁从用户态切换到内核态。  </p>
<blockquote>
<p>I&#x2F;O 多路复用在数据准备阶段和数据拷贝阶段都会阻塞用户进程，但是在数据准备阶段并不是阻塞在 recvfrom 这样的系统调用上，而是阻塞在 select、poll 这样的系统调用上。与阻塞 I&#x2F;O 不同的是，I&#x2F;O 多路复用可以同时监听和处理多个 Socket。所以，如果 Web 服务器处理的连接数不是很多时，使用 select 或者 poll 并不一定比使用多线程阻塞 I&#x2F;O 性能更好，还有可能延迟更高。select&#x2F;poll 的优势并不是单个连接能够处理得更快，而是能够处理更多的连接。  </p>
</blockquote>
<h2 id="信号驱动式-I-O（signal-driven-I-O）"><a href="#信号驱动式-I-O（signal-driven-I-O）" class="headerlink" title="信号驱动式 I&#x2F;O（signal-driven I&#x2F;O）"></a>信号驱动式 I&#x2F;O（signal-driven I&#x2F;O）</h2><p>由于很少使用，可以不了解。  </p>
<h2 id="异步-I-O（asynchronous-I-O）"><a href="#异步-I-O（asynchronous-I-O）" class="headerlink" title="异步 I&#x2F;O（asynchronous I&#x2F;O）"></a>异步 I&#x2F;O（asynchronous I&#x2F;O）</h2><img alt="asynchronous io" src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/19/GxK.png" style="width: 80%" />

<p>当用户进程发起 I&#x2F;O 读请求后，aio_read 函数会立刻返回，用户进程可以去做其他事情，内核会等待数据准备就绪后，主动将数据拷贝到用户内存空间中，然后再向用户进程发送一个 signal，通知用户进程操作完成。  </p>
<p>在 Linux 中主要有两种异步 I&#x2F;O 的底层实现，一个是 glibc 库，另一个是 Linux 的原生内核实现，并由 libaio 库封装调用接口。但是它们都存在一些问题，因此通常我们直接使用的是一些第三方的异步事件库，主流的有 libevent、libev 和 libuv。对于应用程序而言，这些库封装了跟操作系统底层的交互，异步事件库在不同的操作系统上会使用操作系统提供的最优处理机制来实现某一种事件。在 Windows 平台下，异步 I&#x2F;O 的底层实现是 IOCP，与 Linux 平台相比，该技术比较成熟。  </p>
<h1 id="总结和延伸"><a href="#总结和延伸" class="headerlink" title="总结和延伸"></a>总结和延伸</h1><p>按照 POSIX 的标准，阻塞 I&#x2F;O、非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用都属于同步 I&#x2F;O。</p>
<p>select 和 poll 函数是通过不断轮询的方式来监听多个 Socket。不同的是，select 能够监听的 Socket 有数量限制，一般是 1024 个；而 poll 能够监听的 Socket 没有数量限制。还有一个 epoll 函数，它比前面两个函数的效率要高，它并不采用轮询的方式监听 Socket，而是当 Socket 有变化时通过回调的方式主动通知。</p>
<p><strong>广义上讲，同步和异步关注的是消息通知机制。同步即在调用没有得到结果之前会一直等待，换句话说，就是调用者主动等待调用的结果；异步即在调用发出后就立马返回了，当结果计算完毕后会主动通知调用者（通过回调等方式）。而阻塞与非阻塞关注的是程序在等待调用结果（消息或返回值等）时的状态。</strong>  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/">Linux 源代码</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://elixir.bootlin.com/linux/v2.6.11/">Linux 在线源代码</a>  </p>
</blockquote>
<blockquote>
<p><a href="http://man7.org/linux/man-pages/dir_section_2.html">Linux 系统调用列表</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://my.oschina.net/xianggao/blog/662803">聊聊 Linux 五种 IO 模型</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/56673416">为什么 NIO 被称为同步非阻塞？</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/26943558">linux下的异步 IO（AIO）是否已成熟？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 索引结构</title>
    <url>/2020/07/07/InnoDB%20%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>根据 InnoDB 的行记录格式和数据页结构，我们已经知道了数据页之间组成了一个双向链表，而每个数据页中的行记录又会按照主键值从小到大的顺序组成一个单向链表。在某一页中查找指定主键值的记录可以根据页目录使用二分法快速定位到行记录所在分组的槽，然后遍历该分组的行记录即可。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/ZoA.png" alt="数据页组成的双向链表"></p>
<h1 id="没有索引的查找"><a href="#没有索引的查找" class="headerlink" title="没有索引的查找"></a>没有索引的查找</h1><p>我们先看一下在没有索引时是如何查找记录的。为了方便说明，这里只列举对某个列精确匹配的情况，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>

<p>在没有索引的情况下，由于我们无法快速定位到记录所在的页，因此只能从第一个数据页开始，沿着双向链表一直向后找。在每个页中，如果以主键作为搜索条件，则可以直接通过页目录使用二分法快速找到记录所在分组，然后遍历分组即可；如果使用其他列作为搜索条件，那么就无法借助于页目录，只能使用最笨的方式，也就是从最小记录开始沿着 next_record 向后遍历。</p>
<h1 id="InnoDB-的索引结构"><a href="#InnoDB-的索引结构" class="headerlink" title="InnoDB 的索引结构"></a>InnoDB 的索引结构</h1><p>为了方便说明，我们首先创建一张表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo (</span><br><span class="line">    c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">INT</span>,</span><br><span class="line">    c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>这里简化了行记录的结构，记录头只保留了 record_type 和 next_record。同时为了方便，这里限制了一页只能存放 3 条记录（实际可以存放很多条记录）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/NEV.png" alt="简化的行记录结构"></p>
<p>InnoDB 为数据页也建立了类似页目录那样的目录项，即选择每页中最小行记录（不是 Infimum 行记录）的主键值和页号来作为一个目录项，然后将这些目录项作为行记录也存放在一页中。这些行记录的 record_type 的值为 1，表示这是一个 B+树非叶子节点，也就意味着这是一个目录项，同时目录项记录<strong>只有主键值和页号这两个列</strong>。除了这些，目录项记录与普通的行记录就没有太大差别了。它们使用的都是数据页（FIL_PAGE_TYPE 的值为 0x45BF），都会为主键值生成 Page Directory，从而可以使用二分法加速主键记录的查找。</p>
<blockquote>
<p>目录项和目录项记录都是为了表达清楚而杜撰的，并不代表真实名称。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/bRl.png" alt="索引结构1"></p>
<p>如果数据页有很多，那么只用一个数据页来存放目录项就有可能不够，此时就会再申请一个数据页，同时该数据页与第一个数据页通过指针进行关联，从而形成一个双向链表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/Dao.png" alt="索引结构2"></p>
<p>当行记录继续增多，存放目录项的数据页也持续增多，那么此时又该如何根据主键值快速定位到某个存储目录项记录的页呢？答案就是为这些存储目录项记录的页再生成一个更高级别的目录，如此往复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/7wv.png" alt="索引结构3"></p>
<p>那么此时根据主键值查找对应行记录就分为以下几步：假设要查找的主键值为 20，那么首先需要确定目录项所在的页。从最高层开始，根据页目录（Page Directory）用二分法快速找到页号为 30 的目录项记录，然后对页号为 30 的数据页重复上述步骤，找到页号为 9 的目录项记录，最后到 9 号数据页中同样重复上述步骤，最终找到对应的行记录。</p>
<h1 id="根页"><a href="#根页" class="headerlink" title="根页"></a>根页</h1><p>每当为一个表创建一个 B+树索引（聚集索引非手工创建）时，InnoDB 都会为这个索引创建一个根节点（根页）。随后向表中插入记录，这些记录会先存储在这个根页中。当根页中的可用空间不足时，会将根页中的所有记录复制到一个新分配的数据页中，假设为页 a，然后对这个新页进行页分裂的操作，得到另一个新的页，假设为页 b。接下来新插入的记录会根据键值（聚集索引是主键值，辅助索引是索引列的值）的大小被分配到页 a 或者页 b 中，而根页则升级为存储目录项记录的页。</p>
<p><strong>一个 B+树索引的根节点自诞生之日起，便不会再移动</strong>。只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，之后只要用到这个索引的时候，都会从这个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<h1 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h1><p>当一个页（假设页号为 10）快要填满或者已经填满，新记录无法填充到本页时，会到当前页的下一页（假设页号为 11）进行填充。如果下一页也没有足够的空间容纳新记录，那么 InnoDB 会创建一个新的页（页号可能为 12），然后判断从当前页的哪行记录开始进行页分裂，接下来需要移动行记录，然后重新确定页之间的关系。此时 10 号页的前一页为 9 号页，下一页为 12 号页，而 12 号页的下一页则为 11 号页。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/JE6.png" alt="页分裂1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/Wdr.png" alt="页分裂2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/LEm.png" alt="页分裂3"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/rxm.png" alt="页分裂4"></p>
<p>此时 B+树从逻辑上来说仍然满足按照主键大小顺序排序，但是从物理存储上讲数据页是乱序的，并且有很大的概率会落到不同的区。</p>
<h1 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h1><p>像上面这样的，B+树本身就是一个目录，或者说本身就是一个索引，它有两个特点：其一是行记录和页都是通过主键值的大小进行排序的，即页内记录按照主键值由小到大形成一条单向链表，各个存放用户记录的数据页也是根据页中用户数据的主键值由小到大形成一条双向链表，存放目录项记录的数据页分为不同的层级，同一层级的数据页也是根据页中目录项记录的主键值由小到大形成一条双向链表。其二是 B+树的叶子节点存储的是完整的用户记录。</p>
<p>满足这些条件的索引结构就是聚簇索引，同时在 InnoDB 中，聚簇索引就是数据的存储方式，也就是所谓的索引即数据，数据即索引。</p>
<h1 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h1><p>辅助索引也就是二级索引，通过 INDEX 语句创建。在聚集索引中，B+树中的数据都是按照主键值进行排序的，对于非主键的查询条件只能通过最笨的方式，也就是我们常说的全表扫描来查找。有时候为了优化查询性能，我们会选择一些列来建立二级索引，这样我们就有了好几颗 B+树，不过二级索引的树结构与聚集索引有些不同。还是以上表为例子，我们在 c2 列上建立辅助索引。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/KEA.png" alt="辅助索引"></p>
<p>辅助索引中的行记录与数据页会按照 c2 列的大小进行排序，与聚集索引不同的是，此时 B+树的叶子节点存储的并不是完整的用户记录，而只是 c2 和主键这两列，目录项记录中也不再是主键和页号，而是 c2 和页号。同时在使用辅助索引进行查询时，前面的查询步骤与聚集索引相同，但是如果没有覆盖索引，在拿到了行记录之后，还需要使用行记录中的主键到聚集索引中查找主键值对应的完整用户记录，这也就是我们俗称的回表。</p>
<p>需要注意的是，我们把辅助索引中的内节点，也就是存储目录项记录的数据页中的行记录内容说成是“<strong>索引列和页号</strong>”的搭配其实是不严谨的。因为建立辅助索引的列很大可能是没有唯一约束的，因此很有可能会出现索引列的值重复的情况，如果此时新插入记录的索引列值与目录项记录中的两条记录相同，那么新记录应该插入哪一页呢（如下图的例子）？</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/gvw.png" alt="辅助索引目录项记录页"></p>
<p>因此我们需要保证在 B+树的内节点中，目录项记录除了页号以外也是具有唯一性的，所以内节点的目录项记录实际上由三部分构成：索引列的值、主键值和页号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/07/Qme.png" alt="真正的辅助索引"></p>
<h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>联合索引也是二级索引，只不过索引列会有多个。比如我们通过 c2 和 c3 这两列建立联合索引，那么 B+树就会按照 c2 和 c3 这两列的大小进行排序。具体来说就是，先通过 c2 列进行排序，在 c2 列相同的情况下再使用 c3 列进行排序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007081107/2020/07/08/OE2.png" alt="联合索引"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《MySQL 技术内幕：InnoDB 存储引擎》</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 行记录格式</title>
    <url>/2020/07/03/InnoDB%20%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>InnoDB 中最小的存储单位为页，默认每页的大小为 16 KB。页中的数据是按行进行存放的，每页中存放的行记录最少为 2 行，最多为 <code>16 KB / 2 - 200</code> 行，也就是 7992 行。</p>
<span id="more"></span>

<p>MySQL 目前有四种行记录格式：Redundant、Compact、Dynamic 和 Compressed。其中 Redundant 是以前使用的旧格式，为了兼容性还一直保留。自 MySQL 5.1 开始，默认的行记录格式为 Compact，而从 MySQL 5.7 开始，默认的行记录格式为 Dynamic。使用 <code>SHOW TABLE STATUS LIKE &#39;table_name&#39;</code> 可以查看指定表的行格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLE STATUS LIKE &#x27;test&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: test</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Compact</span><br><span class="line">           Rows: 3</span><br><span class="line"> Avg_row_length: 5461</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2020-07-03 22:10:01</span><br><span class="line">    Update_time: 2020-07-03 22:11:09</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: ascii_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: row_format=COMPACT</span><br><span class="line">        Comment:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="Compact-行格式"><a href="#Compact-行格式" class="headerlink" title="Compact 行格式"></a>Compact 行格式</h1><p>Compact 行记录格式是在 MySQL 5.0 引入的，其设计目标是高效的存储数据。简单来说就是：一个页中存放的行数据越多，其性能就越高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007052146/2020/07/03/7we.png" alt="Compact"></p>
<h2 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h2><p>MySQL 支持一些变长的数据类型，比如 VARCHAR(M)、各种 TEXT、各种 BLOB 等类型，使用这些数据类型的列可以称为变长字段。由于变长字段存储多少字节的数据是不固定的，因此我们需要在存储真实数据的时候顺便将这些数据占用的字节数也存储起来。在 Compact 行格式中，会把所有的变长字段的真实数据（非 NULL）占用的字节长度都存放在记录的开头，从而形成一个长度列表，各个变长字段的长度<strong>按照列的顺序逆序存放</strong>。至于变长字段长度列表中每个列长度使用多少字节来表示是有一套规则的。</p>
<p>首先需要说明 W、M 和 L 的含义：其中 W 为某个字符集中表示一个字符最多需要使用的字节数，这个值可以通过 <code>SHOW CHARSET</code> 命令查看，对应 <code>Maxlen</code> 列的值。比如 utf8 字符集中 W 就是 3，ascii 字符集中的 W 就是 1。对于变长类型 VARCHAR(M) 来说，M 代表该类型能够最多存储的<strong>字符个数</strong>，再结合使用的字符集，可以得出该类型最多占用的字节数就是 <code>M*W</code>。而 L 代表的是该类型实际存储的字符串占用的字节数。因此有如下规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 M*W &lt;= 255，那么使用 1 个字节来表示长度</span><br><span class="line">如果 M*W &gt; 255，并且 L &lt;= 127，那么使用 1 个字节来表示长度</span><br><span class="line">如果 M*W &gt; 255，并且 L &gt; 127，那么使用 2 个字节来表示长度</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变长字段的长度最大不会使用超过 2 个字节来表示，原因是在 MySQL 中，对于一条记录占用的最大存储空间是有限制的，除了 BLOB、TEXT 类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。假如创建的表只有一列，那么这也就意味着该列最多占用 65535 个字节，使用二进制位来表示最多需要 16 位，也就是 2 个字节即可。</p>
</blockquote>
<p>还有一个特别需要注意的点就是：如果使用定长字符集，比如 ASCII 字符集，那么 CHAR(M) 这种的类型占用的字节数就是固定的；如果使用变长字符集，比如使用 UTF8（表示一个字符需要 1 到 3 个字节），那么 CHAR(M) 这种类型所占用的字节数也是不确定的，此时该列的长度也会被存储到变长字段长度列表中。</p>
<h2 id="NULL-标志位"><a href="#NULL-标志位" class="headerlink" title="NULL 标志位"></a>NULL 标志位</h2><p>变长字段之后的第二个部分是 NULL 标志位，该部分将每个允许为 NULL 的列都对应一个二进制位，二进制位同样按照列的顺序逆序存放，二进制位为 1 表示列的值为 NULL；为 0 则表示列的值不为 NULL。该部分一般占用 1 个字节，如果允许为 NULL 的字段超过了 8 个，那么就需要 2 个字节。</p>
<h2 id="记录头"><a href="#记录头" class="headerlink" title="记录头"></a>记录头</h2><p>记录头信息固定占用 5 个字节，每位的含义如下表：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td>预留，未使用</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>预留，未使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>记录在索引堆的排序信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录的类型，0 表示普通记录，1 表示 B+树非叶子节点，2 表示最小记录 Infimum，3 表示最大记录 Supremum</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<h2 id="列值部分"><a href="#列值部分" class="headerlink" title="列值部分"></a>列值部分</h2><p>最后的部分就是实际存储的每列的数据。<strong>需要注意的是，NULL 值只占用 NULL 标志位，不占用该部分的任何空间</strong>。同时每行记录除了用户定义的列外，还有三个隐藏的列，分别是 row_id、transaction_id 和 roll_pointer，对应的真实名称分别为 DB_ROW_ID、DB_TRX_ID 和 DB_ROLL_PTR。其中 row_id 不是一定存在的，只有用户没有定义主键，同时也没有定义一个不能为空的 Unique 键时，InnoDB 才会为表默认添加一个 row_id 隐藏列作为主键。</p>
<table>
<thead>
<tr>
<th>隐藏列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6 个字节</td>
<td>行 ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6 个字节</td>
<td>事务 ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7 个字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里创建一张表来具体验证 Compact 行格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test (</span><br><span class="line">    t1 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">null</span>,</span><br><span class="line">    t2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">null</span>,</span><br><span class="line">    t3 <span class="type">char</span>(<span class="number">10</span>)    <span class="keyword">null</span>,</span><br><span class="line">    t4 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">null</span></span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (t1, t2, t3, t4) <span class="keyword">VALUES</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (t1, t2, t3, t4) <span class="keyword">VALUES</span> (<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;ee&#x27;</span>, <span class="string">&#x27;ee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test (t1, t2, t3, t4) <span class="keyword">VALUES</span> (<span class="string">&#x27;d&#x27;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&#x27;fff&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个表中，有三个变长字段，我们可以通过 <code>hexdump -C -v test.ibd &gt; test.txt</code> 命令将表空间文件重定向至 test.txt 文件后直接打开，找到第一行记录开始的位置：<code>0000c078</code>，发现接下来有三个字节的值分别为：<code>03</code>、<code>02</code>、<code>01</code>，与我们的预期相符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000c070: 73 75 70 72 65 6D 75 6D 03 02 01 00 00 00 10 00    supremum........</span><br><span class="line">0000c080: 2C 00 00 00 00 03 00 00 00 00 00 0B 35 A6 00 00    ,...........5&amp;..</span><br><span class="line">0000c090: 01 1A 01 10 61 62 62 62 62 20 20 20 20 20 20 20    ....abbbb.......</span><br><span class="line">0000c0a0: 20 63 63 63 03 02 01 00 00 00 18 00 2B 00 00 00    .ccc........+...</span><br><span class="line">0000c0b0: 00 03 01 00 00 00 00 0B 35 A6 00 00 01 1A 01 1E    ........5&amp;......</span><br><span class="line">0000c0c0: 64 65 65 65 65 20 20 20 20 20 20 20 20 66 66 66    deeee........fff</span><br><span class="line">0000c0d0: 03 01 06 00 00 20 FF 98 00 00 00 00 03 02 00 00    ................</span><br><span class="line">0000c0e0: 00 00 0B 35 A6 00 00 01 1A 01 2C 64 66 66 66 00    ...5&amp;.....,dfff.</span><br></pre></td></tr></table></figure>

<p>接下来我们查看整条记录的值，发现都符合预期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变长字段长度列表</span></span><br><span class="line">03 02 01</span><br><span class="line"><span class="comment"># NULL 标志位</span></span><br><span class="line">00</span><br><span class="line"><span class="comment"># 记录头，固定 5 个字节</span></span><br><span class="line">00 00 10 00 2C</span><br><span class="line"><span class="comment"># row_id</span></span><br><span class="line">00 00 00 00 03 00</span><br><span class="line"><span class="comment"># transaction_id</span></span><br><span class="line">00 00 00 00 0B 35</span><br><span class="line"><span class="comment"># roll_pointer</span></span><br><span class="line">A6 00 00 01 1A 01 10</span><br><span class="line"><span class="comment"># 列 1 的数据：a</span></span><br><span class="line">61</span><br><span class="line"><span class="comment"># 列 2 的数据：bb</span></span><br><span class="line">62 62</span><br><span class="line"><span class="comment"># 列 3 的数据：bb，固定 10 个字节</span></span><br><span class="line">62 62 20 20 20 20 20 20 20 20</span><br><span class="line"><span class="comment"># 列 4 的数据：ccc</span></span><br><span class="line">63 63 63</span><br></pre></td></tr></table></figure>

<p>同样，查看最后一行记录的值，发现也都符合预期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变长字段长度列表</span></span><br><span class="line">03 01</span><br><span class="line"><span class="comment"># NULL 标志位，对应 0110</span></span><br><span class="line">06</span><br><span class="line"><span class="comment"># 记录头，固定 5 个字节</span></span><br><span class="line">00 00 20 FF 98</span><br><span class="line"><span class="comment"># row_id</span></span><br><span class="line">00 00 00 00 03 02</span><br><span class="line"><span class="comment"># transaction_id</span></span><br><span class="line">00 00 00 00 0B 35</span><br><span class="line"><span class="comment"># roll_pointer</span></span><br><span class="line">A6 00 00 01 1A 01 2</span><br><span class="line"><span class="comment"># 列 1 的数据：d</span></span><br><span class="line">64</span><br><span class="line"><span class="comment"># 列 4 的数据：fff</span></span><br><span class="line">66 66 66</span><br></pre></td></tr></table></figure>

<h2 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h2><p>我们已经知道了行记录占用的空间大小最多为 65535 字节，也可以认为是列占用的空间大小不能超过 65535 字节。但是由于一页的大小默认为 16 KB，也就是 16384 字节，并且还有一个限制条件是每页需要至少存储 2 行记录（否则就失去了 B+Tree 的意义，变成链表了），因此很有可能会出现一页中连一条记录都存不下的情况。对于一个页中只能存储一条记录甚至连一条记录都存不下的情况，InnoDB 会将占用存储空间非常大的列拆开，在当前列中只存储该列的前 768 个字节的数据和一个指向溢出页（Uncompressed BLOB Page 类型）的地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007052146/2020/07/04/bRg.png" alt="行溢出"></p>
<p>如果可以在一个页中至少放入两行记录，那么 VARCHAR 等类型（TEXT、BLOB 等类型也有可能出现行溢出）的列数据就不会放到 BLOB 页中，MySQL 技术内幕一书中提到长度阈值为 8098，也就是说当一个表只有一列，且该列的定义为：VARCHAR(8098) 时，正好可以存放两条记录而不会出现行溢出的情况。<strong>其实我们可以不用关注这个临界点是多少，我们只需要知道如果一条记录占用的字节数过多时，就有可能出现行溢出。</strong></p>
<h1 id="Dynamic-和-Compressed-行格式"><a href="#Dynamic-和-Compressed-行格式" class="headerlink" title="Dynamic 和 Compressed 行格式"></a>Dynamic 和 Compressed 行格式</h1><p>InnoDB 1.0.x 版本开始引入了新的文件格式（可以理解为新的页格式），以前支持的 Compact 和 Redundant 格式称为 Antelope 文件格式，新的文件格式称为 Barracuda，该文件格式下拥有两种新的行记录格式：Dynamic 和 Compressed。</p>
<p>新的两种行记录格式对于存放在 BLOB 中的数据采用了完全行溢出的方式，即连 768 个字节的数据也被移到了溢出页中，数据页（B-Tree Node）中只存放了 20 个字节的溢出页地址。同时 Compressed 行记录格式会对行数据使用 zlib 算法进行压缩，因此在存储 BLOB、TEXT、VARCHAR 这类大长度类型的数据时比较有优势。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《MySQL 技术内幕：InnoDB 存储引擎》</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 之 Optional</title>
    <url>/2020/03/19/Java%208%20%E4%B9%8B%20Optional/</url>
    <content><![CDATA[<p>在 Java 中，空指针异常（NullPointerException）是非常讨厌的。在 JDK 8 以前，我们通常只能通过主动防御式的检查来减少它的出现，但是在 JDK 8 之后我们可以使用 Optional 更优雅地处理这类问题。</p>
<span id="more"></span>

<h1 id="为缺失值建模"><a href="#为缺失值建模" class="headerlink" title="为缺失值建模"></a>为缺失值建模</h1><p>Java 一直试图让我们意识不到指针的存在，但是由于历史的原因，有一个例外就是 null 指针。其实 null 自身没有任何语义，它代表的是在静态类型语言中对缺失变量值的一种错误的建模方式。因为它的存在，我们不得不在可能出现空指针异常的地方添加检测的代码，这会得我们的代码膨胀，同时可读性下降。</p>
<p>近几年出现的很多语言都尝试去解决这个问题，比如 Groovy 通过引入安全导航操作符使得我们可以安全地访问可能为 null 的变量，但是这种处理方式并不值得被提倡，原因是在遇到变量为 null 时我们应该结合当前的算法和数据模型来考虑是否需要先返回一个 null，如果一碰到空指针就加 if 条件判断，那么其实并没有真正的解决问题，这只是暂时的掩盖了问题。</p>
<p>有一些函数式编程语言，比如 Haskell、Scala 等则试图从另一个角度来解决这个问题。比如在 Haskell 中有一个 Maybe 类型，它的变量可以是任意类型，也可以什么都不是。Java 8 就是从 Haskell 和 Scala 中汲取的灵感，引入了 <code>java.util.Optional&lt;T&gt;</code> 类。当变量存在时，Optional 只是对类进行简单封装；当变量不存在时，缺失的值会被建模成一个“空”的 Optional 对象，由 Optional.empty() 方法返回。从语义上来讲，我们可以把 null 和 Optional.empty() 当作一回事，而使用 Optional 建模的优势就是：如果我们尝试解引用一个 null 则会抛出空指针异常，而 Optional.empty() 则不会，因为它本身就是一个 Optional 类的有效对象。与此同时，使用 Optional 还可以丰富我们模型的语义，当系统出现问题时更容易排查，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Car&gt; car;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Car&gt; <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Insurance&gt; insurance;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title function_">getInsurance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insurance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 Person 的 car 字段声明为 Optional，这可以非常清晰地表达一个人可能有车，也可能没车的情况，同理汽车的保险也是这样。但是保险一定会有保险公司，所以公司名称没有使用 Optional，这就非常清楚地表明了保险必须提供公司的名称。这样在解引用保险公司名称时，如果发生空指针异常，我们就可以非常确定地知道出错的原因，不再需要为其添加非空的检查，这种检查只会掩盖问题，并不能真正地修复问题。</p>
<blockquote>
<p>需要强调的是，引入 Optional 的意图并不是要消除每一个 null 引用，与此相反，它的目标是帮助我们更好地设计出普适的 API，让编程人员在看到方法签名时就能了解到它是否接受一个 Optional 的值，这样会让我们更积极地将变量从 Optional 中解包出来，直面缺失的变量值。</p>
</blockquote>
<p>虽然使用 Optional 作为类字段的类型是一个不错的做法，但是 Optional 类的设计者的初衷仅仅是要支持能返回 Optional 对象的语法，因此它并没有实现 Serializable 接口。如果我们在域模型中使用 Optional，同时又使用了某些要求序列化的库，那么很有可能会出现问题，折中的方案是提供一个能访问声明为 Optional、变量值可能缺失的接口，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Car&gt; <span class="title function_">getCarAsOptional</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-Optional-的几种模式"><a href="#使用-Optional-的几种模式" class="headerlink" title="使用 Optional 的几种模式"></a>使用 Optional 的几种模式</h1><p>我们可以使用 Optional 的 empty 静态工厂方法来创建一个空的 Optional 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Car&gt; car = Optional.empty();</span><br></pre></td></tr></table></figure>

<p>通过一个非空的值创建 Optional 可以使用 Optional 的 of 静态工厂方法，该方法传入的值不能为空，如果为空则会立刻抛出空指针异常，而不会等到我们试图访问时才抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Car&gt; car = Optional.of(car);</span><br></pre></td></tr></table></figure>

<p>如果想创建一个可以接受空值的 Optional 对象，那么可以使用 Optional 的 ofNullable 静态工厂方法，该方法会判断传入的值是否为空，如果为空则会创建一个空的 Optional 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Car&gt; car = Optional.ofNullable(car);</span><br></pre></td></tr></table></figure>

<h2 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前的做法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (insurance != <span class="literal">null</span>) &#123;</span><br><span class="line">    companyName = insurance.getCompanyName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个允许空值的 Optional</span></span><br><span class="line">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance);</span><br><span class="line"><span class="comment">// 使用 map 提取和转换值</span></span><br><span class="line">Optional&lt;String&gt; companyName = optInsurance.map(Insurance::getCompanyName);</span><br></pre></td></tr></table></figure>

<h2 id="使用-flatMap"><a href="#使用-flatMap" class="headerlink" title="使用 flatMap"></a>使用 flatMap</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前的做法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> person.getCar();</span><br><span class="line">    <span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Insurance</span> <span class="variable">insurance</span> <span class="operator">=</span> car.getInsurance();</span><br><span class="line">        <span class="keyword">if</span> (insurance != <span class="literal">null</span>) &#123;</span><br><span class="line">            companyName = insurance.getCompanyName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 flatMap</span></span><br><span class="line">Optional&lt;Person&gt; optPerson = Optional.ofNullable(person);</span><br><span class="line"><span class="comment">// 如果 person 为空，那么 flatMap 会返回一个空的 Optional 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> optPerson.flatMap(Person::getCar)</span><br><span class="line">        .flatMap(Car::getInsurance)</span><br><span class="line">        .map(Insurance::getCompanyName)</span><br><span class="line">        .orElse(<span class="string">&quot;Unknown&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="两个-Optional-的组合"><a href="#两个-Optional-的组合" class="headerlink" title="两个 Optional 的组合"></a>两个 Optional 的组合</h2><p>假设我们有这样一个方法，它接受一个 Person 和一个 Car 对象，并以此为条件进行数据查询，最终返回一个满足该组合的最便宜的保险公司。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Insurance <span class="title function_">findCheapestInsurance</span><span class="params">(Person person, Car car)</span> &#123;</span><br><span class="line">    <span class="comment">// 数据查询业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> cheapestInsurance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想提供一个该方法的“空”安全的版本，它接受两个 Optional 对象为参数，返回值为 Optional&lt;Insurance&gt; 对象，如果传入的任何对象为空，那么它的返回值也为空。我们可以通过 isPresent 方法来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title function_">nullSafeFindCheapestInsurance</span><span class="params">(Optional&lt;Person&gt; person, Optional&lt;Car&gt; car)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (person.isPresent() &amp;&amp; car.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(findCheapestInsurance(person.get(), car.get()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然简单直观，但是和我们空检查的方式很像，这里有一种更好的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title function_">nullSafeFindCheapestInsurance</span><span class="params">(Optional&lt;Person&gt; person, Optional&lt;Car&gt; car)</span> &#123;</span><br><span class="line">    <span class="comment">// 对 person 调用 flatMap 方法，如果 person 的值为空则直接返回空的 Optional 对象</span></span><br><span class="line">    <span class="comment">// 如果不为空，那么会作为参数传递。对 car 调用 map 方法同理</span></span><br><span class="line">    <span class="keyword">return</span> person.flatMap(p -&gt; car.map(c -&gt; findCheapestInsurance(p, c)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-filter"><a href="#使用-filter" class="headerlink" title="使用 filter"></a>使用 filter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (insurance != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;DiegoInsurance&quot;</span>.equals(insurance.getCompanyName())) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;do something...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 filter</span></span><br><span class="line">Optional&lt;Insurance&gt; optInsurance = ...;</span><br><span class="line">optInsurance.filter(insurance -&gt; <span class="string">&quot;DiegoInsurance&quot;</span>.equals(insurance.getCompanyName()))</span><br><span class="line">        .ifPresent(insurance -&gt; System.out.println(<span class="string">&quot;do something...&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map(Function&lt;? super T, ? extends U&gt; f)</td>
<td>如果变量不为空则对该值执行传入的函数，否则返回一个空的 Optional 对象</td>
</tr>
<tr>
<td>flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; f)</td>
<td>与 map 类似，但函数不同</td>
</tr>
<tr>
<td>of(T t)</td>
<td>将指定值封装后返回，如果值为空则会直接抛出空指针异常</td>
</tr>
<tr>
<td>ofNullable(T t)</td>
<td>将指定值封装后返回，如果值为空则会直接返回一个空的 Optional 对象</td>
</tr>
<tr>
<td>get()</td>
<td>变量为空时抛出 NoSuchElementException 异常，在非常确定变量不为空时使用</td>
</tr>
<tr>
<td>orElse(T t)</td>
<td>可以在变量为空时返回指定一个默认值</td>
</tr>
<tr>
<td>orElseGet(Supplier&lt;? extends T&gt; s)</td>
<td>在变量为空时才会调用 Supplier 的 get 方法，可以在创建默认值比较耗时费力时使用</td>
</tr>
<tr>
<td>orElseThrow(Supplier&lt;? extends X&gt; e)</td>
<td>与 get 方法类似，不过可以自定义抛出的异常</td>
</tr>
<tr>
<td>isPresent()</td>
<td>判断变量是否为空</td>
</tr>
<tr>
<td>ifPresent(Consumer&lt;? super T&gt; c)</td>
<td>可以在变量存在时执行作为参数传入的方法，否则不做任何操作</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 函数式编程入门</title>
    <url>/2019/07/25/Java%208%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Java 8 发布至今已经有好长一段时间了，但是在实际工作中使用函数式编程的机会还是太少，对于 Java 的函数式编程了解的还是不够深入，因此借着阅读《Java 8 in Action》的机会将自己的心得体会记录一下。</p>
<span id="more"></span>

<p>我们知道，在 Java 语言层面的值的形式有两种：原始值和引用值。原始值就是那些基本类型的值，包括 int 类型的值，double 类型的值等。引用值就是那些引用类型的值，也就是对象的地址值。这些值能够在程序执行期间作为参数进行传递，因此又被称为<strong>一等值（或者一等公民）</strong>。与此同时，Java 中的类和方法由于无法作为参数传递而被称为<strong>二等公民</strong>。但是很多编程语言的实践证明了让方法作为一等值可以使编程变得更加容易，因此 Java 的设计者们将这个功能加入到了 JDK 8 中，从而使方法可以作为值进行传递。</p>
<h1 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h1><p>行为参数化简单来说就是将一个代码块准备好却不马上执行，这部分代码可以作为参数传递给另一个方法，这意味着我们可以推迟这部分代码的执行。行为参数化是处理频繁的需求变更的一种良好的开发模式。下面使用书上的例子进行详细说明。</p>
<h2 id="用例子引出行为参数化"><a href="#用例子引出行为参数化" class="headerlink" title="用例子引出行为参数化"></a>用例子引出行为参数化</h2><p>给定一个苹果集合，筛选出绿颜色的苹果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterGreenApples</span><span class="params">(List&lt;Apple&gt; list)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;green&quot;</span>.equals(apple.getColor())) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样是可以筛选出绿色的苹果，但是我们可以更进一步，写一个可以筛选任意颜色苹果的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterGreenApples</span><span class="params">(List&lt;Apple&gt; list, String color)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (apple.getColor().equals(color)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正在我们沾沾自喜时，需求又变了，要我们筛选出颜色为绿色，同时重量超过 150g 的苹果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterGreenApples</span><span class="params">(List&lt;Apple&gt; list, String color, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (apple.getColor().equals(color) &amp;&amp; apple.getWeight() &gt; weight) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实到这里，我们差不多已经能够发现这种写法并不能很好地应对需求变更，假如又加入了产地、品牌、形状等筛选条件，我们还需要重新修改方法签名和实现，不够灵活也不方便维护。此时我们可以试着从更高层级的抽象入手，一种可能的方案是对我们选择的标准建模：我们需要根据苹果的某些属性值来返回一个 boolean 值，我们可以把它抽象成一个返回 boolean 值的函数，这个函数很像我们语法中主谓结构的谓词部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以根据不同的选择标准进行不同的实现了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 超过 150g 的苹果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 绿颜色的苹果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时还需要修改一下筛选的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterApples</span><span class="params">(List&lt;Apple&gt; list, ApplePredicate applePredicate)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (applePredicate.test(apple)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来如果需求变更，我们只需要新建一个谓词实现类即可。但是我们很快就会发现新建实现类是很麻烦的，一个很容易想到的方式就是匿名类。我们可以在调用筛选方法时传入一个匿名类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(list, <span class="keyword">new</span> <span class="title class_">ApplePredicate</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从表面上看，我们并没有使用 class 创建类，但是实际上 Java 编译器会为匿名类生成一个 <code>ClassName$1</code> 这种形式的类文件。生成大量的类文件是不利的，因为每个类文件在使用时都需要加载和验证，这会影响应用的启动性能。在 Java 8 中，我们可以使用 Lambda 表达式来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(list, apple -&gt; apple.getWeight() &gt; <span class="number">150</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>我们可以把 Lambda 表达式理解为简洁地表示可传递的匿名函数的一种方式，它没有名称，但是它有参数列表、函数主体和返回类型，可能还有一个可以抛出的异常列表。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Lambda 表达式有三部分组成，参数列表、箭头和 Lambda 主体。基本语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参数列表、箭头和表达式（注意此处的表达式不带分号）</span><br><span class="line">(parameters) -&gt; expression</span><br><span class="line"></span><br><span class="line">// 参数列表、箭头和语句（这里的语句需要用花括号包含，语句需要分号）</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>下面列举几个 Lambda 表达式的正例和反例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它是有效的，没有参数列表，返回值类型为 void，主体为空</span></span><br><span class="line">() -&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它是有效的，没有参数列表，返回 String 作为表达式</span></span><br><span class="line">() -&gt; <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它是有效的，没有参数列表，使用显式的返回语句返回 String</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它是无效的，因为 return 是控制流语句，要使此表达式有效，语句需要用花括号包含</span></span><br><span class="line">(Integer i) -&gt; <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span> + i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它是无效的，因为 &quot;Hello World!&quot; 是一个表达式，不是语句，所以应该把花括号和分号去掉</span></span><br><span class="line">(String s) -&gt; &#123; <span class="string">&quot;Hello World!&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在哪里使用"><a href="#在哪里使用" class="headerlink" title="在哪里使用"></a>在哪里使用</h2><p>在函数式接口上使用 Lambda 表达式，而函数式接口就是<strong>只定义了一个抽象方法的接口</strong>。</p>
<p>一个典型的函数式接口就是 <code>java.lang.Runnable</code>，它只有一个抽象方法 <code>run()</code>，因此我们可以这样使用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(Thread.currentThread());</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;thread-0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接传入 lambda 表达式</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread()), <span class="string">&quot;thread-0&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h2><p>Lambda 表达式有参数列表也有返回类型等，这些一起组成了 Lambda 表达式的签名。实际上函数式接口的抽象方法的签名基本上就是 Lambda 表达式的签名，我们将这个抽象方法叫做<strong>函数描述符（Function Descriptor）</strong>，并且我们使用特殊的表示法来描述 Lambda 表达式和函数描述符的签名。比如：<code>() -&gt; void</code> 代表了参数列表为空，且返回 void 的函数。下面列举几个可以根据函数描述符判断 Lambda 表达式是否有效的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有效，因为 Runnable 的签名为 () -&gt; void</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line">execute(() -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有效，因为 fetch() 方法的签名为 () -&gt; String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;String&gt; <span class="title function_">fetch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效，因为 Predicate 接口 test 方法的签名为 (Apple) -&gt; boolean</span></span><br><span class="line">Predicate&lt;Apple&gt; p = (Apple a) -&gt; a.getWeight();</span><br></pre></td></tr></table></figure>

<h2 id="环绕执行模式"><a href="#环绕执行模式" class="headerlink" title="环绕执行模式"></a>环绕执行模式</h2><p>在资源处理（比如处理文件或数据库）时，一个常见的模式就是打开一个资源，进行一些处理，最后关闭该资源。这就是所谓的环绕执行模式，在该模式中开始和结束部分总是很类似，只有中间执行处理的部分不同，因此中间这一部分就很适合进行行为参数化的操作。比如下面这部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">processFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;data.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bufferedReader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 包裹的资源能够在操作结束时隐式地关闭，此时的中间部分只有从文件中读取一行这一操作，我们将其行为参数化后，使整个方法扩展为能够根据传入参数的不同而执行不同的操作，比如：<code>String r = processFile((Buffered br) -&gt; br.readLine() + br.readLine());</code>，很明显方法的签名为：(BufferedReader) -&gt; String，因此我们需要创建一个函数式接口，然后修改 processFile 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BufferedReaderProcessor</span> &#123;</span><br><span class="line">    String <span class="title function_">process</span><span class="params">(BufferedReader br)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">processFile</span><span class="params">(BufferedReaderProcessor processor)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;data.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> processor.process(bufferedReader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>在 JDK 1.8 中，很多函数式接口都带有 <code>@FunctionalInterface</code> 的注解，这代表该接口是一个函数式接口。我们在设计函数式接口的时候，最好带着该注解，因为它可以使编译器检查接口是否是函数式接口，从而提前发现错误。</p>
<p>除了很多常用的函数式接口，在 <code>java.util.function</code> 包下还引入了几个新的函数式接口，主要包括 <code>Predicate</code>、<code>Consumer</code>、<code>Function</code> 和 <code>Supplier</code> 这几类。</p>
<p><strong>其中 Predicate 可以理解为谓语、断言，我们知道谓词是对主语动作状态或特征的描述，指出做什么（do waht）、是什么（what is this）和怎么样（how）</strong>。<code>java.util.function.Predicate&lt;T&gt;</code> 接口的 test 抽象方法接受一个泛型 T 对象并返回一个布尔类型的值，因此该接口方法的实现描述的应该是传入的 T 对象是否具备某些动作状态或特征。上面筛选苹果的例子也可以使用该接口进行修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterApples</span><span class="params">(List&lt;Apple&gt; list, Predicate&lt;Apple&gt; predicate)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(apple)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.util.function.Consumer&lt;T&gt;</code> 接口定义了一个 accept 抽象方法，该方法接受一个泛型 T 对象，没有返回值，我们可以理解为该方法的实现是对传入的 T 对象进行消费的操作。下面列举一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">        c.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forEach(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>

<p><code>java.util.function.Function&lt;T, R&gt;</code> 接口定义了一个 apply 抽象方法，该方法接受一个泛型 T 对象，返回一个泛型 R 对象，我们可以理解为该方法的实现是将传入的 T 对象转化成 R 对象。下面列举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; List&lt;R&gt; <span class="title function_">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T, R&gt; f)</span> &#123;</span><br><span class="line">    List&lt;R&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">        result.add(f.apply(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map(Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>), (String s) -&gt; s.length());</span><br></pre></td></tr></table></figure>

<p>我们知道，在 Java 中泛型只能绑定到引用类型上，因此 Java 提供了自动拆箱和装箱的操作。但是这种操作需要付出性能代价，因为装箱后的值本质上就是把原始类型包裹起来并保存到堆上，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值。为了避免在使用这些函数式接口时出现自动装箱的操作，JDK 8 专门为这些接口提供了使用原始类型的版本。比如 IntPredicate、IntConsumer、LongToIntFunction 等。下面附上一些总结的使用案例：</p>
<table>
<thead>
<tr>
<th>使用案例</th>
<th>Lambda 的例子</th>
<th>对应的函数式接口</th>
</tr>
</thead>
<tbody><tr>
<td>布尔表达式</td>
<td>(List&lt;String&gt; list) -&gt; list.isEmpty()</td>
<td>Predicate&lt;List&lt;String&gt;&gt;</td>
</tr>
<tr>
<td>消费一个对象</td>
<td>(Apple a) -&gt; <br/>System.out.println(a.getWeight())</td>
<td>Consumer&lt;Apple&gt;</td>
</tr>
<tr>
<td>从一个对象中选择或提取</td>
<td>(String s) -&gt; s.length()</td>
<td>Function&lt;String, Integer&gt; 或 ToIntFunction&lt;String&gt;</td>
</tr>
<tr>
<td>合并两个值</td>
<td>(int a, int b) -&gt; a * b</td>
<td>IntBinaryOperrator</td>
</tr>
<tr>
<td>比较两个对象</td>
<td>(Apple a1, Apple a2) -&gt; <br/>a1.getWeight().compareTo(a2.getWeight())</td>
<td>Comparator&lt;Apple&gt; 或 BiFunction&lt;Apple, Apple, Integer&gt; 或 ToIntBiFunction&lt;Apple, Apple&gt;</td>
</tr>
</tbody></table>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用使得我们可以重复使用现有的方法定义，并像 Lambda 一样传递它们。当我们使用方法引用时，我们需要将目标引用放在分隔符 <code>::</code> 前面，方法名称放在后面，比如 <code>Apple::getWeight</code> 就是一个方法引用。它的基本思想是，如果一个 Lambda 表达式代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。下面列举一些例子来说明：</p>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>等效的方法引用</th>
</tr>
</thead>
<tbody><tr>
<td>(Apple a) -&gt; a.getWeight()</td>
<td>Apple::getWeight</td>
</tr>
<tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread::dumpStack</td>
</tr>
<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>
<tr>
<td>(String s) -&gt; System.out.println(s)</td>
<td>System.out::println</td>
</tr>
</tbody></table>
<p>方法引用主要有三种，一种是指向静态方法的方法引用，比如 Integer 的 parseInt 方法，对应的方法引用为 Integer::parseInt。一种是指向任意类型实例方法的方法引用，这一类方法引用的特点就是当我们在引用一个对象的方法时，这个对象本身又是 Lambda 中的一个参数，比如 (String s) -&gt; s.toUpperCase() 对应的方法引用为 String::toUpperCase。还有一种是指向现有对象的实例方法的方法引用，这一类方法引用的特点是在 Lambda 中调用一个在外部环境已经存在的对象中的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003231726/2020/03/23/2jR.png" alt="方法引用"></p>
<h2 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h2><p>对于一个现有的构造函数，我们可以利用它的名称和关键字 new 来创建一个它的引用：ClassName::new。假如有一个构造函数没有参数，那么它就与 <code>Supplier&lt;T&gt;</code> 接口的方法签名 <code>() -&gt; T</code> 一致，所以我们可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::<span class="keyword">new</span>; <span class="comment">// 构造函数引用指向默认的 Apple() 构造函数</span></span><br><span class="line"><span class="type">Apple</span> <span class="variable">a1</span> <span class="operator">=</span> c1.get(); <span class="comment">// 调用 Supplier 的 get 方法才会真正创建一个 Apple 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就等价于</span></span><br><span class="line"></span><br><span class="line">Supplier&lt;Apple&gt; c2 = () -&gt; <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line"><span class="type">Apple</span> <span class="variable">a2</span> <span class="operator">=</span> c2.get();</span><br></pre></td></tr></table></figure>

<p>如果构造函数的签名是 Apple(Integer weight)，那么它就与 Function 接口的签名 <code>(T, R) -&gt; R</code> 一致，所以可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; f1 = Apple::<span class="keyword">new</span>; <span class="comment">// 指向 Apple(Integer weight) 的构造函数引用</span></span><br><span class="line"><span class="type">Apple</span> <span class="variable">a1</span> <span class="operator">=</span> f1.apply(<span class="number">120</span>); <span class="comment">// 调用该 Function 接口的 apply 方法，并给出要求的重量，产生一个新的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer, Apple&gt; f2 = (Integer weight) -&gt; <span class="keyword">new</span> <span class="title class_">Apple</span>(weight);</span><br><span class="line"><span class="type">Apple</span> <span class="variable">a2</span> <span class="operator">=</span> f2.apply(<span class="number">120</span>);</span><br></pre></td></tr></table></figure>

<p>如果构造函数的签名为 Apple(String color, Integer weight)，那么就与 BiFunction 接口的签名 <code>(T, U, R) -&gt; R</code> 一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;String, Integer, Apple&gt; f1 = Apple::<span class="keyword">new</span>;</span><br><span class="line"><span class="type">Apple</span> <span class="variable">a1</span> <span class="operator">=</span> f1.apply(<span class="string">&quot;red&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">BiFunction&lt;String, Integer, Apple&gt; f2 = (String color, Integer weight) -&gt; <span class="keyword">new</span> <span class="title class_">Apple</span>(color, weight);</span><br><span class="line"><span class="type">Apple</span> <span class="variable">a2</span> <span class="operator">=</span> f2.apply(<span class="string">&quot;red&quot;</span>, <span class="number">120</span>);</span><br></pre></td></tr></table></figure>

<h2 id="引用总结"><a href="#引用总结" class="headerlink" title="引用总结"></a>引用总结</h2><ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例上的实例方法引用：<code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用：<code>super::methodName</code></li>
<li>类型上的实例方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>Class::new</code></li>
<li>数组构造方法引用：<code>TypeName[]::new</code></li>
</ul>
<h2 id="复合方法"><a href="#复合方法" class="headerlink" title="复合方法"></a>复合方法</h2><p>很多函数式接口都提供了进行复合的方法（以默认方法的方式提供），比如用于传递 Lambda 表达式的 Comparator、Function 和 Predicate 接口。允许使用复合的方法意味着我们可以将多个简单的 Lambda 表达式复合成较为复杂的表达式，从而实现更加复杂的需求，比如我们可以让两个谓词进行 or 操作，从而组合成一个更大的谓词。</p>
<h3 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Comparator 的静态方法 comparing，根据提取用于比较的键值的 Function 来返回一个 Comparator</span></span><br><span class="line">Comparator&lt;Apple&gt; c = Comparator.comparing(Apple::getWeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆序</span></span><br><span class="line">Comparator&lt;Apple&gt; c1 = Comparator.comparing(Apple::getWeight).reversed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器链：如果两个苹果重量相同，使用重量无法比较出区别，那么可以继续使用其他的比较器进行比较</span></span><br><span class="line">Comparator&lt;Apple&gt; c2 = Comparator.comparing(Apple::getWeight)</span><br><span class="line">                .reversed()</span><br><span class="line">                .thenComparing(Apple::getColor);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h3><p>and 和 or 方法是按照在表达式链中的位置从左到右确定优先级的，比如 <code>a.or(b).and(c)</code> 可以看作 <code>(a || b) &amp;&amp; c</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 谓语：苹果是红色的</span></span><br><span class="line">Predicate&lt;Apple&gt; p1 = (Apple a) -&gt; <span class="string">&quot;red&quot;</span>.equals(a.getColor());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非：苹果不是红色的</span></span><br><span class="line">Predicate&lt;Apple&gt; p2 = p1.negate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与：苹果既是红色的又大于 110 克</span></span><br><span class="line">Predicate&lt;Apple&gt; p3 = p1.and((Apple a) -&gt; a.getWeight() &gt; <span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或：苹果可能是大于 110 克的红苹果，也可能是绿苹果</span></span><br><span class="line">Predicate&lt;Apple&gt; p4 = p3.or((Apple a) -&gt; <span class="string">&quot;green&quot;</span>.equals(a.getColor()));</span><br></pre></td></tr></table></figure>

<h3 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h3><p>andThen 方法会返回一个 Function，它先对输入应用一个函数，再对输出应用另一个函数。比如，有个函数 f 是给数字加 1，另一个函数是给数字乘 2，我们可以将这两个函数组合起来，先加 1 再乘 2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g); <span class="comment">// 数学上会写作 g(f(x))</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> h.apply(<span class="number">1</span>); <span class="comment">// 结果为 4</span></span><br></pre></td></tr></table></figure>

<p>如果在上面的例子中使用 compose 方法，那就意味着结果为 <code>f(g(x))</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.compose(g); <span class="comment">// 数学上会写作 f(g(x))</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> h.apply(<span class="number">1</span>); <span class="comment">// 结果为 3</span></span><br></pre></td></tr></table></figure>

<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。用户在使用普通的 Iterator 时，只能一个一个显式地遍历元素并对其执行某些操作（外部迭代）；而在使用 Stream 时，用户只需给出对其包含的元素执行什么样的操作即可，比如“过滤出长度大于 10 的字符串”、“获取每个字符串的首字母”等，流会隐式地在内部进行遍历（内部迭代），并做出相应的数据转换。</p>
<p>与迭代器类似，Stream 是单向的，不可往复，即数据只能遍历一次，遍历过一次后就用尽了，就像流水从面前流过，一去不复返。与迭代器不同的是，Stream 可以并行化操作，而迭代器只能命令式地、串行化地操作。当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一段都在不同的线程中处理，最终将结果合并。Stream 的并行操作依赖于 Java 7 中引入的 <code>Fork/Join</code> 框架（<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166y/">JSR 166y</a>）来拆分任务和加速处理过程。</p>
<h2 id="为什么要使用流"><a href="#为什么要使用流" class="headerlink" title="为什么要使用流"></a>为什么要使用流</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，使用并发模式能够充分利用多核处理器的优势。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 Stream 是一个函数式语言 + 多核时代综合影响的产物。</p>
<p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：客户每月平均消费金额、最贵的在售商品、本周完成的有效订单、取十个数据样本作为首页推荐等等这类的操作，但在当今这个数据大爆炸的时代，数据的来源更加多样化，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，很多时候程序员需要用 Iterator 遍历集合并完成相关的聚合应用逻辑。</p>
<h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><p>可以通过集合、值序列、数组、文件或者函数（类似于 Python 中的生成器）等来创建流。在 Java 8 中，Collection 接口被扩展，增加了两个默认方法来获取 stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由集合创建</span></span><br><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;Apple&gt; stream = apples.stream();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由值序列创建流</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由数组创建流</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(numbers);</span><br></pre></td></tr></table></figure>

<p>java.nio.file.Files 中有很多静态方法都会返回一个流。比如 Files.lines 方法会返回一个指定文件中的各行构成的字符串流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由文件创建流</span></span><br><span class="line"><span class="type">long</span> <span class="variable">uniqueWords</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), Charset.defaultCharset())) &#123;</span><br><span class="line">    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>))) <span class="comment">// 生成单词流</span></span><br><span class="line">            .distinct() <span class="comment">// 删除重复项</span></span><br><span class="line">            .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stream API 提供了两个静态方法来从函数生成流，包括 Stream.iterate() 和 Stream.generate()，由于这两个操作产生的流都会用给定的函数按需创建值，因此都可以创造出所谓的无限流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个初始值 0，流的第一个元素为 0，然后为生成的新值 2，以此类推</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契元组序列</span></span><br><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, t -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;t[<span class="number">1</span>], t[<span class="number">0</span>] + t[<span class="number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .forEach(t -&gt; System.out.println(<span class="string">&quot;(&quot;</span> + t[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;)&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>与 iterate 不同，generate 不是依次对每个新生成的值应用函数的，它接受一个 <code>Supplier&lt;T&gt;</code> 类型的参数来提供新的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><p>流操作分为两种：中间操作和终端操作。中间操作包括 filter、map、sorted、limit、distinct 等，这类操作可以连接起来形成一个查询的操作链，并且因为中间操作一般都可以合并起来，所以它们都是惰性化的，只有在遇到终端操作时才会一次性全部处理。终端操作包括 forEach、collect、reduce、count 等，这类操作会执行中间操作链并产生结果。一个流只能有一个终端操作，当这个操作执行后，流就被用“光”了。</p>
<h3 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h3><p>Stream 的筛选主要通过 filter 方法实现，该方法接收一个谓词作为参数，并返回一个包含所有符合谓词的元素的流。当然还有一个 distinct 方法能够返回一个元素各异的流（根据流所生成元素的 hashCode 和 equals 方法实现），这个方法的作用与 SQL 中的 SELECT DISTINCT 语句类似。举个例子，下面的代码会筛选出列表中所有的偶数，并确保没有重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">        .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>Stream 的切片主要通过 limit 方法和 skip 方法来实现。limit(n) 方法会返回一个不超过给定长度的流，而 skip(n) 方法会返回一个扔掉了前 n 个元素的流，如果流中元素不足 n 个，则会返回一个空流。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>流的 map 方法接受一个函数（<code>Function&lt;? super T, ? extends R&gt; mapper</code>）作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = apples.stream()</span><br><span class="line">        .map(Apple::getWeight)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>除了 map 方法，Stream 还有一个将流扁平化的 flatMap 方法，该方法同样接受一个函数，但是这个函数与 map 方法接受的函数不同，它的声明为 <code>Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper</code>，该函数会将流中的每个元素转换为另一个流。flatMap 方法会将流中每个元素都转换为另一个流，然后把所有的流连接起来成为一个新的流。比较 map 方法和 flatMap 方法我们会发现，map 适合一对一映射的场景，而 flatMap 适合一对多映射的场景。flatMap 方法的入参为多个列表，结果可以返回一个列表；而 map 方法如果接受多个列表，那么返回的结果也是多个列表。</p>
<h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><p>很多时候我们需要查看数据集中的某些元素是否匹配一个给定的属性，Stream API 就提供了类似的工具，包括 allMatch、anyMatch、noneMatch、findFirst 和 findAny，这些操作都用到了短路，类似于 Java 中 <code>&amp;&amp;</code> 和 <code>||</code> 运算符的短路。</p>
<blockquote>
<p>有些操作不需要处理整个流就能得到结果。例如，假设你需要对一个用 and 连起来的大布尔表达式求值。不管表达式有多长，你只需找到一个表达式为 false，就可以推断整个表达式将返回 false，所以用不着计算整个表达式。这就是短路。对于流而言，某些操作不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。limit 就是一个短路操作：它只需创建一个给定大小的流。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流。</p>
</blockquote>
<h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><p>规约可以将流中所有的元素反复结合最终得到一个值，比如“计算所有苹果的重量”、“所有苹果中最重的是哪个”等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常外部迭代求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">    sum += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用规约求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"><span class="comment">// 利用 Integer 类的静态方法 sum</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有初始值的求和，在没有初始值时，需要考虑流中没有任何元素的情况，因此返回值为 Optional 类型</span></span><br><span class="line">Optional&lt;Integer&gt; sum3 = numbers.stream().reduce((a, b) -&gt; (a + b));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求乘积</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">1</span>, (a, b) -&gt; a * b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小值</span></span><br><span class="line">Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大值</span></span><br><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 map 和 reduce 求总数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> apples.stream()</span><br><span class="line">        .map(a -&gt; <span class="number">1</span>)</span><br><span class="line">        .reduce(Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用 count 方法求总数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count1</span> <span class="operator">=</span> apples.stream().count();</span><br></pre></td></tr></table></figure>

<p>对于 reduce 方法，如果未定义初始值，那么第一次执行时第一个参数的值就是流的第一个元素，第二个参数就是流的第二个元素；如果定义了初始值，则第一次执行时第一个参数的值就是初始值，第二个参数就是流的第一个元素。下面需要说明一个特殊的 reduce 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity,</span></span><br><span class="line"><span class="params">                 BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数为实例 identity，表示要返回的 U 类型对象的初始化实例，第二个参数为累加器 accumulator，可以使用二元表达式（即二元 Lambda 表达式），声明在 identity 的基础上连续使用的逻辑，第三个参数为组合器 combiner，由于流是支持并发操作的，为了避免竞争，reduce 线程都会有独立的 result，combiner 的作用就是合并每个线程的 result 得到最终结果。这也说明了了第三个函数参数的数据类型必须为方法返回值的类型。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>函数描述符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate&lt;T&gt; p)</td>
<td>中间</td>
<td>T -&gt; boolean</td>
<td>根据谓词筛选</td>
</tr>
<tr>
<td>distinct()</td>
<td>中间（有状态-无界）</td>
<td></td>
<td>返回一个元素各异的流，即去重</td>
</tr>
<tr>
<td>limit(long n)</td>
<td>中间（有状态-有界）</td>
<td></td>
<td>返回一个不超过给定长度的流</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>中间（有状态-有界）</td>
<td></td>
<td>返回一个扔掉了前 n 个元素的流</td>
</tr>
<tr>
<td>map(Function&lt;T, R&gt; f)</td>
<td>中间</td>
<td>T -&gt; R</td>
<td>根据函数将流中的每个元素映射为新的元素</td>
</tr>
<tr>
<td>flatMap(Function&lt;T, Stream&lt;R&gt;&gt; f)</td>
<td>中间</td>
<td>T -&gt; Stream&lt;R&gt;</td>
<td>将流中元素都转成新流并最终合并为一个流</td>
</tr>
<tr>
<td>sorted()</td>
<td>中间（有状态-无界）</td>
<td></td>
<td>产生一个新流，其中按字典顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator&lt;T&gt; c)</td>
<td>中间（有状态-无界）</td>
<td>(T, T) -&gt; int</td>
<td>产生一个新流，其中按比较器排序</td>
</tr>
<tr>
<td>allMatch(Predicate&lt;T&gt; p)</td>
<td>终端</td>
<td>T -&gt; boolean</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate&lt;T&gt; p)</td>
<td>终端</td>
<td>T -&gt; boolean</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate&lt;T&gt; p)</td>
<td>终端</td>
<td>T -&gt; boolean</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>终端</td>
<td></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>终端</td>
<td></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td>forEach(Consumer&lt;T&gt; c)</td>
<td>终端</td>
<td>T -&gt; void</td>
<td>内部迭代</td>
</tr>
<tr>
<td>reduce(BinaryOperator&lt;T&gt; b)</td>
<td>终端（有状态-有界）</td>
<td>(T, T) -&gt; T</td>
<td>将流中所有的元素反复结合最终得到一个值</td>
</tr>
<tr>
<td>count()</td>
<td>终端（有状态-有界）</td>
<td></td>
<td>计算流中元素的个数（<strong>规约操作</strong>）</td>
</tr>
<tr>
<td>min(Comparator&lt;T&gt; c)</td>
<td>终端（有状态-有界）</td>
<td>(T, T) -&gt; int</td>
<td>获取流中最小的元素（<strong>规约操作</strong>）</td>
</tr>
<tr>
<td>max(Comparator&lt;T&gt; c)</td>
<td>终端（有状态-有界）</td>
<td>(T, T) -&gt; int</td>
<td>获取流中最大的元素（<strong>规约操作</strong>）</td>
</tr>
<tr>
<td>collect(Collector&lt;T, A, R&gt; c)</td>
<td>终端</td>
<td></td>
<td>接受各种做法将流中元素汇总成一个（<strong>规约操作</strong>）</td>
</tr>
</tbody></table>
<h2 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h2><p>流的 collect 方法其实也是一个归约操作，就像 reduce 一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果，具体的做法可以使用预定义的 Collector 接口的实现，也就是 Collectors 类提供的一系列的静态方法（工厂方法），这些方法主要提供了三类功能：将流中元素规约汇总为一个值，元素分组以及元素分区。</p>
<h3 id="规约与汇总"><a href="#规约与汇总" class="headerlink" title="规约与汇总"></a>规约与汇总</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找最大值和最小值</span></span><br><span class="line">Comparator&lt;Apple&gt; comparator = Comparator.comparingInt(Apple::getWeight);</span><br><span class="line">Optional&lt;Apple&gt; max = apples.stream().collect(Collectors.maxBy(comparator));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求总数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> apples.stream().collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> apples.stream().collect(Collectors.summingInt(Apple::getWeight));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求平均值</span></span><br><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> apples.stream().collect(Collectors.averagingInt(Apple::getWeight));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接字符串</span></span><br><span class="line"><span class="comment">// joining 方法返回的收集器会把流中每个元素应用 toString 方法得到的所有字符串连成一个</span></span><br><span class="line"><span class="type">String</span> <span class="variable">colors</span> <span class="operator">=</span> apples.stream().collect(Collectors.joining());</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">colors1</span> <span class="operator">=</span> apples.stream().map(Apple::getColor).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br></pre></td></tr></table></figure>

<p>事实上，很多收集器都是可以用 reducing 工厂方法定义的规约过程的特殊情况而已，特化的目的是为了方便编程人员。reducing 方法有两种，一种是单参数方法，另一种是三参数方法。从逻辑上说，reducing 的原理是利用累积函数，把一个初始化为起始值的累加器，和把转换函数应用到流中每个元素上得到的结果不断迭代合并。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> apples.stream()</span><br><span class="line">        .collect(Collectors.reducing(<span class="number">0</span>, <span class="comment">// 初始值</span></span><br><span class="line">                Apple::getWeight, <span class="comment">// 转换函数</span></span><br><span class="line">                Integer::sum)); <span class="comment">// 累积函数</span></span><br></pre></td></tr></table></figure>

<p>我们可以将单参数的 reducing 方法看作三参数方法的特殊情况，它把流中第一个元素作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求最大值</span></span><br><span class="line">Optional&lt;Apple&gt; max = apples.stream()</span><br><span class="line">        .collect(Collectors.reducing((a1, a2) -&gt; a1.getWeight() &gt; a2.getWeight() ? a1 : a2));</span><br></pre></td></tr></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用 groupingBy 时需要提供一个分类函数，通过它将流中的元素划分到不同的组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照颜色分组</span></span><br><span class="line">Map&lt;String, List&lt;Apple&gt;&gt; groups = apples.stream().collect(Collectors.groupingBy(Apple::getColor));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写分组函数</span></span><br><span class="line">Map&lt;String, List&lt;Apple&gt;&gt; groups = apples.stream().collect(Collectors.groupingBy(apple -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (apple.getWeight() &lt; <span class="number">120</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LIGHT&quot;</span>; <span class="comment">// 轻的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HEAVY&quot;</span>; <span class="comment">// 重的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>多级分组可以使用双参数版本的 groupingBy 方法，它除了接受一个分类函数外，还可以接受一个 Collector 类型的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, List&lt;Apple&gt;&gt;&gt; groups = apples.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Apple::getColor, <span class="comment">// 一级分组</span></span><br><span class="line">                Collectors.groupingBy(apple -&gt; &#123; <span class="comment">// 二级分组</span></span><br><span class="line">                    <span class="keyword">if</span> (apple.getWeight() &lt; <span class="number">120</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;LIGHT&quot;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;HEAVY&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)));</span><br></pre></td></tr></table></figure>

<p>多级分组可以由两级扩展到任意层级。一般把 groupingBy 看作“桶”比较容易理解，第一个 groupingBy 给每个键建立了一个桶，然后再用下游的收集器去收集每个桶中的元素，以此得到 n 级分组。进一步的，传递给第一个 groupingBy 的第二个收集器可以是任何类型。实际上单参数的 groupingBy(f) 只是 groupingBy(f, Collectors.toList()) 的简便写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回的 Map 类似：&#123;&quot;green&quot;: 3, &quot;red&quot;: 5&#125;</span></span><br><span class="line">Map&lt;String, Long&gt; groups = apples.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Apple::getColor, Collectors.counting()));</span><br></pre></td></tr></table></figure>

<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>分区是分组的特殊情况，因为在分区中分类函数是一个谓词，这意味着分组 Map 的键是 boolean 类型的，它最多可以分为两组：true 是一组，false 是另一组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;User&gt;&gt; partition = users.stream().collect(Collectors.partitioningBy(User::isVip);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Agent</title>
    <url>/2021/08/15/Java%20Agent/</url>
    <content><![CDATA[<p>说到 Java Agent，有必要提一提 AOP，也就是面向切面编程思想。AOP 作为 OOP（面向对象编程思想）的一个补充，在技术实现上是没有规定和约束的。在 Java 中，最常见的实现方式就是 Filter 的责任链模式和 Spring AOP 的代理模式。</p>
 <span id="more"></span>

<p>当然，AOP 也不一定非得像 Spring AOP 那样，在运行时通过动态生成代理对象来织入增强。一个 Java 类的生命周期，从编码开始，还需要经历编译、加载、连接、初始化、使用和卸载这些阶段。而在使用之前，每个阶段我们都可以对类进行增强。</p>
<h1 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h1><p>在编码阶段，我们可以通过静态代理的方式对目标对象进行增强，但是缺点也很明显，就是不够灵活，属于一锤子买卖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectImpl</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;operation...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectProxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Subject target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubjectProxy</span><span class="params">(Subject target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        target.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h1><p>在编译阶段，我们可以通过使用特殊的编译器，在将源文件编译成字节码的时候进行增强，编译后的字节码本身就包含了增强的内容，这就是编译期织入 CTW（Compile-Time Weaving）。典型的工具库就是：AspectJ。</p>
<p>AspectJ 提供了两种切面的编写方式，其中一种是使用 AspectJ 特有的语法；另一种是使用注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect SubjectAspect &#123;</span><br><span class="line">    <span class="comment">// 切点 pointcut</span></span><br><span class="line">    pointcut <span class="title function_">doBefore</span><span class="params">()</span>:execution(<span class="keyword">void</span> SubjectImpl.operation(..));</span><br><span class="line">    pointcut <span class="title function_">doAfter</span><span class="params">()</span>:execution(<span class="keyword">void</span> SubjectImpl.operation(..));</span><br><span class="line">    pointcut <span class="title function_">doAround</span><span class="params">()</span>:execution(<span class="keyword">void</span> SubjectImpl.operation(..));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 advice</span></span><br><span class="line">    before(): doBefore() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after(): doAfter() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// around 和 before、after 不要同时出现，编译会报错</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>: doAround() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before...&quot;</span>);</span><br><span class="line">        proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* org.example.SubjectImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然使用 AspectJ 的特有语法来描述切面会更加灵活，但是由于它不兼容 java 语法，在 IDE 中需要安装插件来支持它的语法，再加上需要额外的学习成本，因此这种方式实际上使用的并不多，通常还是采用兼容 java 语法的注解来定义切面。</p>
<p>在定义好了切面以后，还需要使用 AspectJ 特定的编译器来编译代码。在 AspectJ 1.9.7 版本中，可以直接通过下载的 jar 包进行安装，安装后的程序包含 <code>ajc</code> 命令。当然也可以通过安装 IDE 插件或者使用构建工具（比如 Maven）的插件来编译。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complianceLevel</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">complianceLevel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">showWeaveInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWeaveInfo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Xlint</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">Xlint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面就是通过 <code>ajc</code> 编译器编译后的代码，可以看到增强的部分直接被织入到了目标方法前后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectImpl</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubjectImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SubjectAspect.aspectOf().doBefore();</span><br><span class="line">            System.out.println(<span class="string">&quot;operation...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">            SubjectAspect.aspectOf().doAfter();</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubjectAspect.aspectOf().doAfter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>aspectjrt.jar 包的主要作用是提供运行时环境，包括一些注解、静态方法等，在使用 AspectJ 时一般都需要引入。aspectjtools.jar 主要提供的是赫赫有名的 <code>ajc</code> 编译器，通常这个包会被封装到 IDE 插件或者自动化构建工具的插件中。aspectjweaver.jar 主要提供了一个 java agent 用于在类加载期间织入切面（LTW）。</p>
</blockquote>
<h1 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h1><p>由于类的加载本质上就是类加载器将从文件、网络或者其他渠道获取的字节流解析成 Class 对象的过程，因此我们只需要通过某种方式修改字节流，就可以实现类的增强。也就是说，在类加载阶段，我们只需要自定义一个类加载器，在类加载器读取字节流之前，利用一些字节码增强工具（比如：ASM、Javassist 等）对类进行增强，最后将增强后的字节流解析为 Class 对象即可。</p>
<p>下面使用 Javassist 简单演示一下在类加载阶段实现类增强的步骤。首先写一个类，添加一个方法 <code>test</code>，方便我们后续对该方法进行增强。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeThing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写一个方法，该方法接收字节流，内部通过 Javassist 的 API 对字节流进行修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhanceMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] printCost(<span class="type">byte</span>[] classBytes) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> ClassPool.getDefault().makeClass(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(classBytes));</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getMethod(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">        ctMethod.addLocalVariable(<span class="string">&quot;cost&quot;</span>, CtClass.longType);</span><br><span class="line">        ctMethod.insertBefore(<span class="string">&quot;cost = System.currentTimeMillis();&quot;</span>);</span><br><span class="line">        ctMethod.insertAfter(<span class="string">&quot;cost = System.currentTimeMillis() - cost; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;System.out.println(\&quot;total cost: \&quot; + cost);&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来自定义一个类加载器，在读到原始类文件的流之后，调用该方法替换流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileUrl</span> <span class="operator">=</span> filePath;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="keyword">new</span> <span class="title class_">URI</span>(fileUrl + name + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line">            bytes = EnhanceMethod.printCost(bytes);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是使用自定义的类加载器加载原始类文件，然后调用对象的 <code>test</code> 方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;file:/d:/code/myAgent/&quot;</span>;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(filePath);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> myClassLoader.loadClass(<span class="string">&quot;SomeThing&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Instrument"><a href="#Instrument" class="headerlink" title="Instrument"></a>Instrument</h1><p>Instrument 是 JDK 5 提供的一个新特性，用一句话来总结它的主要作用就是：实现了 JVM 级别的 AOP。通过这个特性，开发者可以构建一个独立于应用程序的代理程序，用来监测和协助运行在 JVM 上的应用。</p>
<h2 id="JVMTI"><a href="#JVMTI" class="headerlink" title="JVMTI"></a>JVMTI</h2><p>Instrument 的底层实现依赖于 JVMTI（JVM Tool Interface），它是 JVM 暴露出来为了方便用户扩展的接口集合。JVMTI 是基于事件驱动的，具体来说就是，JVM 在执行过程中触发了某些事件就会调用对应事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。</p>
<h2 id="JVMTIAgent"><a href="#JVMTIAgent" class="headerlink" title="JVMTIAgent"></a>JVMTIAgent</h2><p>JVMTIAgent 其实就是一个动态链接库。它利用 JVMTI 暴露出来的接口实现了一些特殊的功能，一般情况下，它会实现如下的一个或者多个接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Agent_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">char</span> *options, <span class="type">void</span> *reserved)</span>;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Agent_OnAttach</span><span class="params">(JavaVM* vm, <span class="type">char</span>* options, <span class="type">void</span>* reserved)</span>;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Agent_OnUnload</span><span class="params">(JavaVM *vm)</span>;</span><br></pre></td></tr></table></figure>

<p>VM 是通过启动函数来启动 agent 的。如果 agent 是在 VM 启动时加载的，也就是说 agent 是在 java 命令中通过 <code>-agentlib</code> 指定的，那么 VM 就会在启动过程中去执行这个 agent 里的 Agent_OnLoad 函数来启动该 agent。如果 agent 不是在 VM 启动时加载的，而是在 VM 处于运行过程中时，先 attach 到目标进程上，然后向目标进程发送 load 命令来加载的，此时 VM 会在加载过程中会调用这个 agent 里的 Agent_OnAttach 函数来启动该 agent。而 Agent_OnUnload 函数会在 agent 卸载时被调用，一般很少实现它。</p>
<blockquote>
<p>这里提到的 agent 程序和 java agent 不是同一概念。我们在使用 IDE 进行开发时，如果仔细观察，在控制台中会发现类似的命令：<code>java.exe -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:62290,suspend=y,server=n</code>，这个动态链接库 jdwp 同样也是一个 JVMTIAgent，它实现了程序调试相关的功能。</p>
</blockquote>
<h2 id="java-agent"><a href="#java-agent" class="headerlink" title="java agent"></a>java agent</h2><p>java agent 的功能则是由一个叫做 instrument 的 JVMTIAgent 实现的，它由 JDK 内置提供，在 Linux 下对应的动态库是 <code>libinstrument.so</code>，在 Windows 下是 <code>instrument.dll</code>。由于它实现了 Agent_OnLoad 和 Agent_OnAttach 函数，因此可以在 JVM 启动时加载，也可以在运行时动态加载。其中，启动时加载还可以通过类似 <code>-javaagent:agent.jar</code> 的方式来间接加载 instrument agent。</p>
<p>对于开发人员来说，如果希望 agent 在目标 JVM 启动时加载，只需要编写一个类，然后实现以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs)</span>;</span><br></pre></td></tr></table></figure>

<p>如果希望目标 JVM 在运行时加载 agent，则需要实现以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs)</span>;</span><br></pre></td></tr></table></figure>

<p>上述方法中，JVM 会先寻找对应的第一个方法，如果没有找到则会去寻找对应的第二个方法。其中 agentArgs 是 premain 函数或 agentmain 函数得到的程序参数，由 <code>-javaagent</code> 指定。inst 是一个 <code>Instrumentation</code> 实例，由 JVM 传入，我们可以通过该参数进行类增强等操作。</p>
<p>接下来需要将这个 agent 打包成一个 jar 文件，同时 jar 文件中还要包含一个 <code>MANIFEST.MF</code> 描述文件，文件中需要指定 Premain-Class 或 Agent-Class 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: org.example.AgentApplication</span><br><span class="line">Agent-Class: org.example.AgentApplication</span><br></pre></td></tr></table></figure>

<h2 id="从源代码解析启动时加载"><a href="#从源代码解析启动时加载" class="headerlink" title="从源代码解析启动时加载"></a>从源代码解析启动时加载</h2><p>在创建 JVM 时，JVM 会进行启动参数的解析，我们这里重点关注 <code>-agentlib</code>、<code>-agentpath</code> 和 <code>-javaagent</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-agentlib:&quot;</span>, &amp;tail) ||</span><br><span class="line">      (is_absolute_path = <span class="built_in">match_option</span>(option, <span class="string">&quot;-agentpath:&quot;</span>, &amp;tail))) &#123;</span><br><span class="line">  <span class="keyword">if</span>(tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pos = <span class="built_in">strchr</span>(tail, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    <span class="type">size_t</span> len = (pos == <span class="literal">NULL</span>) ? <span class="built_in">strlen</span>(tail) : pos - tail;</span><br><span class="line">    <span class="type">char</span>* name = <span class="built_in">strncpy</span>(<span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="type">char</span>, len + <span class="number">1</span>, mtInternal), tail, len);</span><br><span class="line">    name[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *options = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      options = <span class="built_in">strcpy</span>(<span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="type">char</span>, <span class="built_in">strlen</span>(pos + <span class="number">1</span>) + <span class="number">1</span>, mtInternal), pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">valid_hprof_or_jdwp_agent</span>(name, is_absolute_path)) &#123;</span><br><span class="line">      <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">        <span class="string">&quot;Profiling and debugging agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br><span class="line">    <span class="built_in">add_init_agent</span>(name, options, is_absolute_path);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// -javaagent</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-javaagent:&quot;</span>, &amp;tail)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">  <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">    <span class="string">&quot;Instrumentation agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> JNI_ERR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span>(tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *options = <span class="built_in">strcpy</span>(<span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="type">char</span>, <span class="built_in">strlen</span>(tail) + <span class="number">1</span>, mtInternal), tail);</span><br><span class="line">    <span class="built_in">add_init_agent</span>(<span class="string">&quot;instrument&quot;</span>, options, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br><span class="line"><span class="comment">// -Xnoclassgc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ref: hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;arguments.cpp</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath arguments</span></span><br><span class="line"><span class="type">static</span> AgentLibraryList _agentList;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">add_init_agent</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">char</span>* options, <span class="type">bool</span> absolute_path)</span></span></span><br><span class="line"><span class="function">  </span>&#123; _agentList.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">AgentLibrary</span>(name, options, absolute_path, <span class="literal">NULL</span>)); &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ref: hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;arguments.hpp</p>
</blockquote>
<p>这里我们只需要关注 <code>add_init_agent</code> 方法，该方法将解析好的参数放入了一个 <code>AgentLibraryList</code> 类型的链表中，以备后续使用。</p>
<p>接下来我们回到创建 JVM 的方法，在这个方法中，我省略了部分代码，重点关注解析参数后的加载过程即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">Threads::create_vm</span><span class="params">(JavaVMInitArgs* args, <span class="type">bool</span>* canTryAgain)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 解析参数</span></span><br><span class="line">  jint parse_result = Arguments::<span class="built_in">parse</span>(args);</span><br><span class="line">  <span class="keyword">if</span> (parse_result != JNI_OK) <span class="keyword">return</span> parse_result;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Launch -agentlib/-agentpath and converted -Xrun agents</span></span><br><span class="line">  <span class="keyword">if</span> (Arguments::<span class="built_in">init_agents_at_startup</span>()) &#123;</span><br><span class="line">    <span class="built_in">create_vm_init_agents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threads::create_vm_init_agents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">JavaVM_</span> main_vm;</span><br><span class="line">  AgentLibrary* agent;</span><br><span class="line">  JvmtiExport::<span class="built_in">enter_onload_phase</span>();</span><br><span class="line">  <span class="comment">// agents 方法从 _agentList 链表中取出一个元素</span></span><br><span class="line">  <span class="keyword">for</span> (agent = Arguments::<span class="built_in">agents</span>(); agent != <span class="literal">NULL</span>; agent = agent-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">    OnLoadEntry_t  on_load_entry = <span class="built_in">lookup_agent_on_load</span>(agent);</span><br><span class="line">    <span class="keyword">if</span> (on_load_entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// 调用 Agent_OnLoad 方法</span></span><br><span class="line">      jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;<span class="built_in">options</span>(), <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (err != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;agent library failed to init&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;Could not find Agent_OnLoad function in the agent library&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  JvmtiExport::<span class="built_in">enter_primordial_phase</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the Agent_OnLoad entry point</span></span><br><span class="line"><span class="function"><span class="type">static</span> OnLoadEntry_t <span class="title">lookup_agent_on_load</span><span class="params">(AgentLibrary* agent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Agent_OnLoad</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lookup_on_load</span>(agent, on_load_symbols, <span class="built_in">sizeof</span>(on_load_symbols) / <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ref: hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;thread.cpp</p>
</blockquote>
<p>可以看到，在加载过程中，又调用了 <code>lookup_agent_on_load</code> 方法，该方法的主要作用是加载 agent 对应的动态链接文件。我们回忆刚才分析的代码，也就是说，当指定了 <code>-javaagent</code> 参数时，这里会加载 <code>instrument</code> 这个动态链接文件，最终还会调用它的 Agent_OnLoad 方法，因此，我们接下来要分析 Agent_OnLoad 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Agent_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">char</span> *tail, <span class="type">void</span> * reserved)</span> </span>&#123;</span><br><span class="line">    initerror = <span class="built_in">createNewJPLISAgent</span>(vm, &amp;agent);</span><br><span class="line">    <span class="keyword">if</span> ( initerror == JPLIS_INIT_ERROR_NONE ) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Parse &lt;jarfile&gt;[=options] into jarfile and options</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseArgumentTail</span>(tail, &amp;jarfile, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;-javaagent: memory allocation failure.\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        attributes = <span class="built_in">readAttributes</span>(jarfile);</span><br><span class="line">        premainClass = <span class="built_in">getAttribute</span>(attributes, <span class="string">&quot;Premain-Class&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Convert JAR attributes into agent capabilities</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">convertCapabilityAtrributes</span>(attributes, agent);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Track (record) the agent class name and options data</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        initerror = <span class="built_in">recordCommandLineData</span>(agent, premainClass, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ref: jdk&#x2F;src&#x2F;share&#x2F;instrument&#x2F;InvocationAdapter.c</p>
</blockquote>
<p>以上是精简后的代码，大概的流程就是：先创建一个 JPLISAgent，然后将 ManiFest 文件中设定的一些参数解析出来， 比如 Premain-Class 等。在创建了 JPLISAgent 之后，还会调用 initializeJPLISAgent 方法对这个 Agent 进行初始化操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JPLISInitializationError</span></span><br><span class="line"><span class="function"><span class="title">initializeJPLISAgent</span><span class="params">(   JPLISAgent *    agent,</span></span></span><br><span class="line"><span class="params"><span class="function">                        JavaVM *        vm,</span></span></span><br><span class="line"><span class="params"><span class="function">                        jvmtiEnv *      jvmtienv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* now turn on the VMInit event */</span></span><br><span class="line">    <span class="keyword">if</span> ( jvmtierror == JVMTI_ERROR_NONE ) &#123;</span><br><span class="line">        jvmtiEventCallbacks callbacks;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;callbacks, <span class="number">0</span>, <span class="built_in">sizeof</span>(callbacks));</span><br><span class="line">        callbacks.VMInit = &amp;eventHandlerVMInit;</span><br><span class="line"></span><br><span class="line">        jvmtierror = (*jvmtienv)-&gt;<span class="built_in">SetEventCallbacks</span>( jvmtienv,</span><br><span class="line">                                                     &amp;callbacks,</span><br><span class="line">                                                     <span class="built_in">sizeof</span>(callbacks));</span><br><span class="line">        <span class="built_in">check_phase_ret_blob</span>(jvmtierror, JPLIS_INIT_ERROR_FAILURE);</span><br><span class="line">        <span class="built_in">jplis_assert</span>(jvmtierror == JVMTI_ERROR_NONE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，我们只关注 <code>callbacks.VMInit = &amp;eventHandlerVMInit;</code> 这行代码，这里设置了一个 VMInit 事件的回调函数，表示<strong>在 JVM 初始化的时候</strong>会回调 eventHandlerVMInit 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">eventHandlerVMInit</span><span class="params">( jvmtiEnv *      jvmtienv,</span></span></span><br><span class="line"><span class="params"><span class="function">                    JNIEnv *        jnienv,</span></span></span><br><span class="line"><span class="params"><span class="function">                    jthread         thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* process the premain calls on the all the JPL agents */</span></span><br><span class="line">    <span class="keyword">if</span> ( environment != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jthrowable outstandingException = <span class="built_in">preserveThrowable</span>(jnienv);</span><br><span class="line">        success = <span class="built_in">processJavaStart</span>( environment-&gt;mAgent,</span><br><span class="line">                                    jnienv);</span><br><span class="line">        <span class="built_in">restoreThrowable</span>(jnienv, outstandingException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">jboolean</span></span><br><span class="line"><span class="function"><span class="title">processJavaStart</span><span class="params">(   JPLISAgent *    agent,</span></span></span><br><span class="line"><span class="params"><span class="function">                    JNIEnv *        jnienv)</span> </span>&#123;</span><br><span class="line">    jboolean    result;</span><br><span class="line">    result = <span class="built_in">initializeFallbackError</span>(jnienv);</span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 sun.instrument.InstrumentationImpl 实例</span></span><br><span class="line">        result = <span class="built_in">createInstrumentationImpl</span>(jnienv, agent);</span><br><span class="line">        <span class="built_in">jplis_assert</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭 VMInit handler 同时设置 ClassFileLoadHook 事件的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = <span class="built_in">setLivePhaseEventHandlers</span>(agent);</span><br><span class="line">        <span class="built_in">jplis_assert</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载 java agent 同时调用它的 premain 方法</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = <span class="built_in">startJavaAgent</span>(agent, jnienv,</span><br><span class="line">                                agent-&gt;mAgentClassName, agent-&gt;mOptionsString,</span><br><span class="line">                                agent-&gt;mPremainCaller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个 VMInit 事件发生时，虚拟机的主要操作是实例化了一个 <code>sun.instrument.InstrumentationImpl</code>，然后设置了 ClassFileLoadHook 事件的回调函数，最后加载 java agent 同时调用它的 premain 方法。其中，InstrumentationImpl 是 <code>java.lang.instrument.Instrumentation</code> 接口的实现类。此时我们很容易就会想到 premain 方法中的 inst 参数，没错，在调用 premain 方法时，由虚拟机传入的 inst 参数就是它。</p>
<h2 id="从源代码解析运行时加载"><a href="#从源代码解析运行时加载" class="headerlink" title="从源代码解析运行时加载"></a>从源代码解析运行时加载</h2><p>与启动时加载 Agent 相比，运行时加载 Agent 显得更有吸引力，因为运行时加载 Agent 给我们提供了很强的动态性，我们可以在需要的时候加载 Agent 来进行一些工作。<code>tools.jar</code> 中提供了一个 <code>com.sun.tools.attach.VirtualMachine</code> 类，通过它可以实现虚拟机在运行时动态加载 agent。以下代码来自美团技术博客。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attachAgentToTargetJVM</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;VirtualMachineDescriptor&gt; virtualMachineDescriptors = VirtualMachine.list();</span><br><span class="line">    <span class="type">VirtualMachineDescriptor</span> <span class="variable">targetVM</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (VirtualMachineDescriptor descriptor : virtualMachineDescriptors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (descriptor.id().equals(configure.getPid())) &#123;</span><br><span class="line">            targetVM = descriptor;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetVM == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;could not find the target jvm by process id:&quot;</span> </span><br><span class="line">        + configure.getPid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        virtualMachine = VirtualMachine.attach(targetVM);</span><br><span class="line">        virtualMachine.loadAgent(<span class="string">&quot;&#123;agent&#125;&quot;</span>, <span class="string">&quot;&#123;params&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (virtualMachine != <span class="literal">null</span>) &#123;</span><br><span class="line">            virtualMachine.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们回到创建虚拟机的过程，在上面我们分析过了这个过程的部分操作，其中我们忽略了一个操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">Threads::create_vm</span><span class="params">(JavaVMInitArgs* args, <span class="type">bool</span>* canTryAgain)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  os::<span class="built_in">signal_init</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::signal_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReduceSignalUsage) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> thread_name[] = <span class="string">&quot;Signal Dispatcher&quot;</span>;</span><br><span class="line">    Handle string = java_lang_String::<span class="built_in">create_from_str</span>(thread_name, CHECK);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123; <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">      JavaThread* signal_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;signal_thread_entry);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle ^BREAK</span></span><br><span class="line">    os::<span class="built_in">signal</span>(SIGBREAK, os::<span class="built_in">user_handler</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法创建了一个名为：Signal Dispatcher 的线程，这个线程的入口方法为：signal_thread_entry。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">signal_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    &#123;</span><br><span class="line">      sig = os::<span class="built_in">signal_wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sig == os::<span class="built_in">sigexitnum_pd</span>()) &#123;</span><br><span class="line">       <span class="comment">// Terminate the signal thread</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (sig) &#123;</span><br><span class="line">      <span class="keyword">case</span> SIGBREAK: &#123;</span><br><span class="line">        <span class="keyword">if</span> (!DisableAttachMechanism &amp;&amp; AttachListener::<span class="built_in">is_init_trigger</span>()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，如果 Signal Dispatcher 线程接收到 <code>SIGBREAK</code> 信号时，就执行接下来的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AttachListener::is_init_trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">init_at_startup</span>() || <span class="built_in">is_initialized</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> fn[PATH_MAX+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(fn, <span class="string">&quot;.attach_pid%d&quot;</span>, os::<span class="built_in">current_process_id</span>());</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat64</span> st;</span><br><span class="line">  <span class="built_in">RESTARTABLE</span>(::<span class="built_in">stat64</span>(fn, &amp;st), ret);</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(fn, <span class="built_in">sizeof</span>(fn), <span class="string">&quot;%s/.attach_pid%d&quot;</span>,</span><br><span class="line">             os::<span class="built_in">get_temp_directory</span>(), os::<span class="built_in">current_process_id</span>());</span><br><span class="line">    <span class="built_in">RESTARTABLE</span>(::<span class="built_in">stat64</span>(fn, &amp;st), ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// simple check to avoid starting the attach mechanism when</span></span><br><span class="line">    <span class="comment">// a bogus user creates the file</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_uid == <span class="built_in">geteuid</span>()) &#123;</span><br><span class="line">      <span class="built_in">init</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ref: hotspot\src\os\linux\vm\attachListener_linux.cpp</p>
</blockquote>
<p>上面这部分代码是 linux 平台下的实现，可以看到，在该方法中会先检查 JVM 是否已经启动了 Attach Listener，如果没有，会在 <code>/tmp</code> 目录下创建一个叫做 <code>.attach_pid&#123;pid&#125;</code> 的文件，然后执行 AttachListener 的 init 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AttachListener::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> thread_name[] = <span class="string">&quot;Attach Listener&quot;</span>;</span><br><span class="line">  Handle string = java_lang_String::<span class="built_in">create_from_str</span>(thread_name, CHECK);</span><br><span class="line"></span><br><span class="line">  &#123; <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    JavaThread* listener_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;attach_listener_thread_entry);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Signal Dispatcher 线程类似，这里也创建了一个线程：Attach Listener。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    AttachOperation* op = AttachListener::<span class="built_in">dequeue</span>();</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;<span class="built_in">name</span>(), AttachOperation::<span class="built_in">detachall_operation_name</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">      AttachListener::<span class="built_in">detachall</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">strlen</span>(name) &lt;= AttachOperation::name_length_max, <span class="string">&quot;operation &lt;= name_length_max&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;<span class="built_in">name</span>(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st.<span class="built_in">print</span>(<span class="string">&quot;Operation %s not recognized!&quot;</span>, op-&gt;<span class="built_in">name</span>());</span><br><span class="line">        res = JNI_ERR;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个入口函数中，首先通过 dequeue 方法拉取操作，这个拉取的方法在不同的平台有不同的实现，在 linux 下，Attach Listener 线程会监听某个端口，通过 accept 方法来接收一个连接，然后从连接中读取请求并封装成一个 AttachOperation 类型的对象，然后到对应的操作列表中去匹配，最后执行相应的函数。以下是这个操作列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;agentProperties&quot;</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;datadump&quot;</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;dumpheap&quot;</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;load&quot;</span>,             JvmtiExport::load_agent_library &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;properties&quot;</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;threaddump&quot;</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;inspectheap&quot;</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;setflag&quot;</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;printflag&quot;</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;jcmd&quot;</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经过上面的分析，我们应该能够隐约知道 VirtualMachine 的 attach 方法的大概逻辑，下面通过源代码来验证一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> VirtualMachine <span class="title function_">attach</span><span class="params">(String var0)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;id cannot be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">var1</span> <span class="operator">=</span> AttachProvider.providers();</span><br><span class="line">        <span class="keyword">if</span> (var1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(<span class="string">&quot;no providers installed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">AttachNotSupportedException</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> var1.iterator();</span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                <span class="type">AttachProvider</span> <span class="variable">var4</span> <span class="operator">=</span> (AttachProvider)var3.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> var4.attachVirtualMachine(var0);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (AttachNotSupportedException var6) &#123;</span><br><span class="line">                    var2 = var6;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> VirtualMachine <span class="title function_">attachVirtualMachine</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkAttachPermission();</span><br><span class="line">    <span class="built_in">this</span>.testAttachable(var1);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinuxVirtualMachine</span>(<span class="built_in">this</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinuxVirtualMachine(AttachProvider var1, String var2) <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">    <span class="built_in">super</span>(var1, var2);</span><br><span class="line">    <span class="type">int</span> var3;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var3 = Integer.parseInt(var2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException var25) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(<span class="string">&quot;Invalid process identifier&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.path = <span class="built_in">this</span>.findSocketFile(var3);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.path == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.createAttachFile(var3);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> var5;</span><br><span class="line">            <span class="keyword">if</span> (isLinuxThreads) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var5 = getLinuxThreadsManager(var3);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var24) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(var24.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> var5 &gt;= <span class="number">1</span>;</span><br><span class="line">                sendQuitToChildrenOf(var5);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendQuitTo(var3);</span><br><span class="line">            &#125;</span><br><span class="line">            var5 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">200L</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">var8</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="built_in">this</span>.attachTimeout() / var6);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(var6);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException var23) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.path = <span class="built_in">this</span>.findSocketFile(var3);</span><br><span class="line">                ++var5;</span><br><span class="line">            &#125; <span class="keyword">while</span>(var5 &lt;= var8 &amp;&amp; <span class="built_in">this</span>.path == <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.path == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(<span class="string">&quot;Unable to open socket file: target process not responding or HotSpot VM not loaded&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            var4.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkPermissions(<span class="built_in">this</span>.path);</span><br><span class="line">    <span class="type">int</span> <span class="variable">var27</span> <span class="operator">=</span> socket();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connect(var27, <span class="built_in">this</span>.path);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        close(var27);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">findSocketFile</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>, <span class="string">&quot;.java_pid&quot;</span> + var1);</span><br><span class="line">    <span class="keyword">return</span> !var2.exists() ? <span class="literal">null</span> : var2.getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attachVirtualMachine 方法在不同的平台有不同的实现，上面的代码是 linux 平台下的实现。大体逻辑是，首先检查 <code>/tmp</code> 目录下是否存在 <code>java_pid&#123;pid&#125;</code> 文件。如果已经存在了，则说明 Attach 机制已经准备就绪，可以接受客户端的命令了，这个时候客户端就可以通过 connect 方法连接到目标 JVM 进行命令的发送。如果 <code>java_pid&#123;pid&#125;</code> 文件还不存在，则通过 sendQuitTo 方法向目标 JVM 发送一个 <code>SIGBREAK</code> 信号，让它初始化 Attach Listener 线程并准备接受客户端连接。可以看到，发送了信号之后客户端会循环等待 <code>java_pid&#123;pid&#125;</code> 这个文件，之后再通过 connect 连接到目标 JVM 上。</p>
<h2 id="instrument-实例"><a href="#instrument-实例" class="headerlink" title="instrument 实例"></a>instrument 实例</h2><p>在上面我们分析了 agent 技术的实现，在实际使用中，我们只需要编写 premain 或者 agentmain 方法，然后在其中通过 Instrument API 来完成类的动态修改即可。Instrument 接口的 addTransformer 方法可以添加一个类转换器（也就是 ClassFileTransformer 接口），该接口只有一个方法：transform，当类被加载时，虚拟机就会调用它进行类的转换。</p>
<p>下面我们通过 Byte Buddy 这个开源库来写一个简单的实例，这个 java agent 能够实现打印指定包中所有方法的执行耗时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is a java agent&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;arguments: &quot;</span> + agentArgs);</span><br><span class="line"></span><br><span class="line">        AgentBuilder.<span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> (builder, typeDescription, classLoader, javaModule) -&gt; builder</span><br><span class="line">                <span class="comment">// 拦截所有方法</span></span><br><span class="line">                .method(ElementMatchers.any())</span><br><span class="line">                <span class="comment">// 指定拦截器</span></span><br><span class="line">                .intercept(MethodDelegation.to(ExecuteTimeInterceptor.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AgentBuilder</span></span><br><span class="line">                .Default()</span><br><span class="line">                <span class="comment">// 根据包名前缀拦截类</span></span><br><span class="line">                .type(ElementMatchers.nameStartsWith(<span class="string">&quot;org.example.agent.demo&quot;</span>))</span><br><span class="line">                .transform(transformer)</span><br><span class="line">                .installOn(inst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecuteTimeInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@RuntimeType</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">intercept</span><span class="params">(<span class="meta">@Origin</span> Method method, <span class="meta">@SuperCall</span> Callable&lt;?&gt; callable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行原始方法</span></span><br><span class="line">            <span class="keyword">return</span> callable.call();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(method.getName() + <span class="string">&quot;:&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与加载时不同，运行时需要通过 redefineClasses 方法进行类的重定义，同时使用该方法不能添加、删除或者重命名字段和方法，也不能修改方法的签名或者类的继承关系。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">Java 动态调试技术原理及实践</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java BitSet</title>
    <url>/2019/08/28/Java%20BitSet/</url>
    <content><![CDATA[<p>在 Java 中，官方提供了一个 Bitmap 的简单实现，它就是 <code>java.util.BitSet</code>。</p>
<span id="more"></span>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>在 BitSet 中，使用一个 long 类型的数组作为 Bitmap 的数据结构。我们首先查看 BitSet 的两个构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADDRESS_BITS_PER_WORD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BITS_PER_WORD</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; ADDRESS_BITS_PER_WORD;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span>[] words;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 无参构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BitSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1 &lt;&lt; 6，结果是 1</span></span><br><span class="line">    initWords(BITS_PER_WORD);</span><br><span class="line">    <span class="comment">// BitSet 的大小是否是用户指定的</span></span><br><span class="line">    sizeIsSticky = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 指定初始化数组的长度（单位 bit） </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BitSet</span><span class="params">(<span class="type">int</span> nbits)</span> &#123;</span><br><span class="line">    <span class="comment">// nbits can&#x27;t be negative; size 0 is OK</span></span><br><span class="line">    <span class="keyword">if</span> (nbits &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NegativeArraySizeException</span>(<span class="string">&quot;nbits &lt; 0: &quot;</span> + nbits);</span><br><span class="line"></span><br><span class="line">    initWords(nbits);</span><br><span class="line">    <span class="comment">// BitSet 的大小是否是用户指定的</span></span><br><span class="line">    sizeIsSticky = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initWords</span><span class="params">(<span class="type">int</span> nbits)</span> &#123;</span><br><span class="line">    words = <span class="keyword">new</span> <span class="title class_">long</span>[wordIndex(nbits-<span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">wordIndex</span><span class="params">(<span class="type">int</span> bitIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个构造函数默认会初始化一个长度为 1 的 long 型数组。第二个构造函数会根据指定的长度进行初始化。我们知道，Java 是没有 bit 这个基本类型的，而 long 类型的长度为 64 bit，那么如何将指定长度的 bit 数组转化为 long 类型的数组呢？答案就是将指定的长度除以 64，就可以得到 long 型数组的长度，即代码中的 <code>bitIndex/64</code>，换成位运算就是 <code>bitIndex &gt;&gt; 6</code>。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> bitIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitIndex &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;bitIndex &lt; 0: &quot;</span> + bitIndex);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">wordIndex</span> <span class="operator">=</span> wordIndex(bitIndex);</span><br><span class="line">    expandTo(wordIndex);</span><br><span class="line"></span><br><span class="line">    words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex); <span class="comment">// Restores invariants</span></span><br><span class="line"></span><br><span class="line">    checkInvariants();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expandTo</span><span class="params">(<span class="type">int</span> wordIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 long 型数组需要的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">wordsRequired</span> <span class="operator">=</span> wordIndex+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果已经使用过的 long 元素个数小于需要的长度，则需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (wordsInUse &lt; wordsRequired) &#123;</span><br><span class="line">        ensureCapacity(wordsRequired);</span><br><span class="line">        <span class="comment">// 设置已经被使用的数组长度</span></span><br><span class="line">        wordsInUse = wordsRequired;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> wordsRequired)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (words.length &lt; wordsRequired) &#123;</span><br><span class="line">        <span class="comment">// 扩容为需要的长度的两倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">request</span> <span class="operator">=</span> Math.max(<span class="number">2</span> * words.length, wordsRequired);</span><br><span class="line">        <span class="comment">// 数组复制</span></span><br><span class="line">        words = Arrays.copyOf(words, request);</span><br><span class="line">        sizeIsSticky = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BitSet 通过 set 方法放入元素。首先根据元素值计算该元素应该放在哪个 long 型数组元素上，即计算 wordIndex。然后根据 wordIndex 判断 Bitmap 是否需要扩容，如果需要扩容，则扩容为需要的长度的两倍。接下来的这段代码 <code>words[wordIndex] |= (1L &lt;&lt; bitIndex);</code> 比较经典，也不好理解，我们可以先传入几个值来观察结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>左移运算，相当于 <code>1 * 2^bitIndex</code>，我们把它们转换成二进制的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000001</span></span><br><span class="line"><span class="number">00000010</span></span><br><span class="line"><span class="number">00000100</span></span><br><span class="line"><span class="number">00001000</span></span><br><span class="line"><span class="number">00010000</span></span><br><span class="line"><span class="number">00100000</span></span><br><span class="line"><span class="number">01000000</span></span><br><span class="line"><span class="number">10000000</span></span><br></pre></td></tr></table></figure>

<p>可以看到，每个 bitIndex 的值都被转换成了对应的 bit 位表示。BitSet 正是通过这种方式，将所有的整数值对应的位设置为 1。接下来就是将当前计算得出的值与原先数组元素的值使用按位或来进行合并，即：<code>words[wordIndex] |= (1L &lt;&lt; bitIndex);</code>。</p>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> bitIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitIndex &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;bitIndex &lt; 0: &quot;</span> + bitIndex);</span><br><span class="line"></span><br><span class="line">    checkInvariants();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">wordIndex</span> <span class="operator">=</span> wordIndex(bitIndex);</span><br><span class="line">    <span class="keyword">return</span> (wordIndex &lt; wordsInUse)</span><br><span class="line">        &amp;&amp; ((words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 方法用来判断一个元素是否在 BitSet 中。首先同样根据元素值计算该元素应该放在哪个 long 型数组元素上，即计算 wordIndex。如果已经使用的 long 型数组长度小于或等于该元素需要放置的数组索引值，则表示该元素一定不在 BitSet 中。接下来的 <code>1L &lt;&lt; bitIndex</code> 可以计算出该元素在哪个 bit 位上，然后同 long 型数组对应的元素进行与运算，如果结果不等于 0，说明该元素存在。举个例子，假设要查找的元素为 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1L &lt;&lt; bitIndex          00100000</span><br><span class="line">// 如果已经存在元素 5</span><br><span class="line">words[wordIndex]        00100000</span><br><span class="line">// 如果并不存在元素 5（这里存在其它元素：0 1 2 3 4）</span><br><span class="line">words[wordIndex]        00011111</span><br></pre></td></tr></table></figure>

<p>可以看到，原数组元素上是否存在其它元素并不影响该元素本身的判断，因为 <code>1L &lt;&lt; bitIndex</code> 只在指定位置上为 1，其它位置均为 0，进行与运算后，其它位置的结果同样是 0。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.jianshu.com/p/4fbad3a6d253">Java 的 BitSet 原理及应用</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5c4fd2af51882525da267385">漫画：什么是Bitmap算法？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Socket</title>
    <url>/2017/10/05/Java%20Socket/</url>
    <content><![CDATA[<p>打算将 Socket 编程再复习下，为后续学习 netty 做准备。</p>
<span id="more"></span>

<h1 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h1><p>学习 Socket 编程，一些前置知识必不可少。</p>
<ul>
<li><p>OSI 参考模型以及 TCP&#x2F;IP 协议栈。		</p>
</li>
<li><p>网络编程三要素：协议、IP 和端口号。		</p>
</li>
<li><p>端口号是正在运行的程序的标识；有效的端口号范围：0 到 65535，其中 0 到 1024 为系统使用或保留。  </p>
</li>
<li><p>TCP&#x2F;IP 是对一组协议的统称，具体每一层都有很多协议。传输层的协议主要关注 TCP 和 UDP。</p>
</li>
<li><p>UDP 的特点是无连接、速度快、不可靠，需要将数据打包，有大小限制。</p>
</li>
<li><p>TCP 的特点是有连接（三次握手、四次挥手），速度相比 UDP 要慢，但要可靠，数据无限制。	</p>
</li>
<li><p>Socket 编程，即为网络编程，也称为套接字编程。Socket 是网络上具有唯一标识的 IP 地址和端口号组合在一起构成。Socket 通信的两端都有 Socket，网络通信即为 Socket 间的通信，数据在两个 Socket 间在某种协议下通过 IO 流传输。</p>
</li>
</ul>
<h1 id="API-学习"><a href="#API-学习" class="headerlink" title="API 学习"></a>API 学习</h1><p>关于 Java Socket 的源码都在 net 包下，其中有几个比较重要的类 <code>InetAddress</code> 和 <code>URL</code> 等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nekolr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APIDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * InetAddress 类</span></span><br><span class="line"><span class="comment">         * 用于标识网络上的硬件资源，标识网络层 IP 协议地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取本机 InetAddress 实例</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// 获取主机名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> address.getHostName();</span><br><span class="line">        <span class="comment">// 获取主机 IP</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *    byte 与十进制转换：192(10) -&gt; -64(byte)</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *    192(10) -&gt; 11000000(2)</span></span><br><span class="line"><span class="comment">        *    由于 byte 范围为-128 ~ 127，对应二进制表示 11111111 ~ 01111111，11000000 用 byte 表示即为-64</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取主机 IP，如果是 IPV4，则是一个长度为 4 的 byte 数组</span></span><br><span class="line">        <span class="type">byte</span> []bytes = address.getAddress();</span><br><span class="line">        <span class="comment">// 根据主机名或 IP 地址字符串获取 InetAddress 实例</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;avalon&quot;</span>);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.229.1&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据 IP 获取 InetAddress 实例</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address3</span> <span class="operator">=</span> InetAddress.getByAddress(bytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * URL 类</span></span><br><span class="line"><span class="comment">         * 统一资源定位符，标识网络上的某个资源的地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">baidu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(baidu, <span class="string">&quot;/index.html?username=nekolr#test&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取协议，此处 http</span></span><br><span class="line">        url.getProtocol();</span><br><span class="line">        <span class="comment">// 获取主机名，此处 www.baidu.com</span></span><br><span class="line">        url.getHost();</span><br><span class="line">        <span class="comment">// 获取端口号，此处 -1</span></span><br><span class="line">        url.getPort();</span><br><span class="line">        <span class="comment">// 获取资源地址，此处 /index.html</span></span><br><span class="line">        url.getPath();</span><br><span class="line">        <span class="comment">// 获取资源名称，此处 /index.html?username=nekolr</span></span><br><span class="line">        url.getFile();</span><br><span class="line">        <span class="comment">// 获取锚点，此处 test</span></span><br><span class="line">        url.getRef();</span><br><span class="line">        <span class="comment">// 获取参数，此处 username=nekolr</span></span><br><span class="line">        url.getQuery();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 URL 打开资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开获取资源的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> baidu.openStream();</span><br><span class="line">        <span class="comment">// 字节流转字符流</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用缓存</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            line = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        isr.close();</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 URL 打开资源，使用 JDK1.7 新增的 AutoCloseable 接口自动关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(baidu.openStream(), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="简单-Socket-通信练习"><a href="#简单-Socket-通信练习" class="headerlink" title="简单 Socket 通信练习"></a>简单 Socket 通信练习</h1><p>Socket 通信基于 TCP 和 UDP 协议，针对这两个协议有不同的写法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/gm.jpg" alt="socket 通信模型">
		</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TcpServer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TcpServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.port = port;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建服务端 Socket，监听端口</span></span><br><span class="line">                serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="built_in">this</span>.port);</span><br><span class="line">                <span class="comment">// 打开监听，等待客户端的连接（在连接到来之前一直阻塞）</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// 获取输入流</span></span><br><span class="line">                reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                System.out.println(<span class="string">&quot;Client Message：&quot;</span> + reader.readLine());</span><br><span class="line"></span><br><span class="line">                writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">                writer.write(<span class="string">&quot;Hello Client&quot;</span>);</span><br><span class="line">                <span class="comment">// 一定要加上 newLine，不然客户端在 readLine 时会一直阻塞</span></span><br><span class="line">                writer.newLine();</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) serverSocket.close();</span><br><span class="line">                    <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                    <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String host;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TcpClient</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.host = host;</span><br><span class="line">            <span class="built_in">this</span>.port = port;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建客户端 Socket，指定主机名和端口号</span></span><br><span class="line">                socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="built_in">this</span>.host, <span class="built_in">this</span>.port);</span><br><span class="line">                <span class="comment">// 获取输出流（向服务端发送消息）</span></span><br><span class="line">                writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">                writer.write(<span class="string">&quot;Hello Server&quot;</span>);</span><br><span class="line">                <span class="comment">// 一定要加上 newLine，不然服务端在 readLine 时会一直阻塞</span></span><br><span class="line">                writer.newLine();</span><br><span class="line">                writer.flush();</span><br><span class="line">                <span class="comment">// 获取输入流</span></span><br><span class="line">                reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                System.out.println(<span class="string">&quot;Server Message：&quot;</span> + reader.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (socket != <span class="literal">null</span>) socket.close();</span><br><span class="line">                    <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                    <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TcpServer</span> <span class="variable">tcpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpServer</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">TcpClient</span> <span class="variable">tcpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpClient</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1024</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        executor.execute(tcpServer);</span><br><span class="line">        executor.execute(tcpClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpSocket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UdpServer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 客户端 port</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientPort</span> <span class="operator">=</span> <span class="number">10088</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务端 port</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 创建服务端 Socket</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(serverPort)) &#123;</span><br><span class="line">                <span class="comment">// 创建数据报用于发送消息</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="string">&quot;我是服务端，消息为：i&#x27;m server&quot;</span>.getBytes();</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">sendPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(host), clientPort);</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                socket.send(sendPacket);</span><br><span class="line"></span><br><span class="line">                bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">receivePacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">                <span class="comment">// 接收消息（阻塞）</span></span><br><span class="line">                socket.receive(receivePacket);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;服务端接收的消息为：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UdpClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 客户端 port</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientPort</span> <span class="operator">=</span> <span class="number">10088</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务端 port</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端 Socket</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(clientPort)) &#123;</span><br><span class="line">                <span class="comment">// 创建数据报用于发送消息</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="string">&quot;我是客户端，消息为：i&#x27;m client&quot;</span>.getBytes();</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">sendPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(host), serverPort);</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                socket.send(sendPacket);</span><br><span class="line"></span><br><span class="line">                bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">receivePacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">                <span class="comment">// 接收消息（阻塞）</span></span><br><span class="line">                socket.receive(receivePacket);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;客户端接收的消息为：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UdpServer</span> <span class="variable">udpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UdpServer</span>();</span><br><span class="line">        <span class="type">UdpClient</span> <span class="variable">udpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UdpClient</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1024</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        executor.execute(udpServer);</span><br><span class="line">        executor.execute(udpClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 上转型方法调用</title>
    <url>/2017/07/17/Java%20%E4%B8%8A%E8%BD%AC%E5%9E%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>Java 的转型分为上转型和下转型，上转型简单概括即将子类对象转成父类对象。比如：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p>上转型后，不能使用子类新增的成员变量和成员方法。</p>
<p>如果父类和子类存在同名的成员变量，在转型之前，子类对象调用该变量时，调用的就是子类的成员变量；转型之后，调用该变量时，调用的是父类的成员变量。如果子类覆盖了父类的成员方法，在转型之前，子类调用该方法，调用的就是子类的成员方法；在转型之后，调用该方法，调用是子类的成员方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal , Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal , Cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">(OrangeCat orangeCat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal , OrangeCat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat , Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat , Cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrangeCat</span> <span class="keyword">extends</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">//上转型</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">OrangeCat</span> <span class="variable">orangeCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrangeCat</span>();</span><br><span class="line"></span><br><span class="line">        animal.fun1(animal); <span class="comment">// Animal , Animal</span></span><br><span class="line">        animal.fun1(ab); <span class="comment">// Animal , Animal</span></span><br><span class="line">        animal.fun2(cat); <span class="comment">// Animal , Cat</span></span><br><span class="line">        animal.fun3(orangeCat); <span class="comment">// Animal , OrangeCat</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ab.fun1(animal); <span class="comment">// Cat , Animal</span></span><br><span class="line">        ab.fun1(ab); <span class="comment">// Cat , Animal</span></span><br><span class="line">        ab.fun2(cat); <span class="comment">// Cat , Cat</span></span><br><span class="line">        ab.fun3(orangeCat); <span class="comment">// Animal , OrangeCat</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        cat.fun1(animal); <span class="comment">// Cat , Animal</span></span><br><span class="line">        cat.fun1(ab); <span class="comment">// Cat , Animal</span></span><br><span class="line">        cat.fun2(cat); <span class="comment">// Cat , Cat</span></span><br><span class="line">        cat.fun3(orangeCat); <span class="comment">// Animal , OrangeCat</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 之逃逸分析</title>
    <url>/2020/07/09/Java%20%E4%B9%8B%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>一般情况下，Java 源代码需要经过前端编译器（比如 javac）编译成 class 文件，然后再通过解释器解释执行。但是对于一些热点代码（频繁调用的方法或代码块），虚拟机为了提高它们的执行效率，会在运行期将这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器就是即时编译器（Just In Time Compiler，JIT），比如 HotSpot 中的 C1、C2 编译器。</p>
<span id="more"></span>

<p>在 JIT 进行优化的过程中，逃逸分析为这些优化手段提供了重要的依据。逃逸分析的基本行为就是分析对象的动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，比如作为调用参数传递到其他方法中，称为方法逃逸。有的还有可能被外部线程访问到，比如赋值给类变量或者其他线程中的实例变量，这种被称为线程逃逸。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuffer globalVariable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuffer instanceVariable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">globalVariableEscape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 给静态变量赋值后，对象外部可见，发生了逃逸</span></span><br><span class="line">        globalVariable = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceVariableEscape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 给成员变量赋值，对象外部可见，发生了逃逸</span></span><br><span class="line">        instanceVariable = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuffer <span class="title function_">returnEscape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对象返回，外部可见，因此发生了逃逸</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;return&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">noEscape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对象在方法中创建，对象的引用没有传递到外界，因此没有发生逃逸</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;noEscape&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，栈帧是线程私有的。每个方法在执行时都会创建一个栈帧用来存储局部变量表、操作数栈等信息，每个方法从调用到结束的过程，就是一个栈帧在虚拟机从入栈到出栈的过程。方法的参数以及在方法中定义的变量都是局部变量，基本类型的变量存放的是对应类型的值，而引用类型的变量存放的则是对象的引用，也就是地址值，对象本身会在堆中分配。因此，如果局部变量是一个引用类型的变量，那么只要它的引用被传递到了外界，就有可能引发线程安全问题。如果能够证明一个对象不会逃逸到方法或者线程之外，也就是别的方法或者线程无法通过任何途径访问到这个对象，那么就可以对这个变量进行一些高效的优化，比如<strong>栈上分配、同步消除、标量替换</strong>等。</p>
<p>Java 堆上分配对象的内存空间已经成为常识，堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的这个对象的数据。虚拟机的垃圾收集可以回收堆中不再使用的对象，但是无论是筛选可回收对象还是回收、整理内存都需要耗费时间。如果确定一个对象不会逃逸到方法之外，那么就可以让这个对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧出栈而销毁。</p>
<p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸到当前线程之外，无法被其他线程访问到，那么这个变量的读写肯定不会存在竞争，那么对该变量实施的同步就可以消除掉，也就是锁消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">lock_elision</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果开启了逃逸分析，那么会进行锁消除</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(<span class="string">&quot;lock elision&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 虚拟机中的原始数据类型（int、long、reference 等）都是标量（无法再分解成更小的数据来表示）。相对的，如果一个数据可以继续分解，那么它就称作聚合量。Java 中最典型的聚合量就是对象。如果将一个对象拆散，根据程序访问的情况，将其使用到的成员变量恢复成原始类型来访问，这就是标量替换。如果逃逸分析证明一个对象不会被外部访问到，并且这个对象可以拆分，那么程序在真正执行的时候可能并不会创建该对象，而是改为直接创建它的若干个被这个方法使用到的成员变量来替代。将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续的进一步优化创造条件。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《深入理解 Java 虚拟机:JVM 高级特性与最佳实践》</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 垃圾收集</title>
    <url>/2018/12/27/Java%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>在 Java 中，运行时内存区域可以分为：程序计数器、虚拟机栈、本地方法栈、堆和方法区，其中程序计数器、虚拟机栈和本地方法栈是线程私有的，因此这部分划分的内存与线程的生命周期相同：栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少的内存基本上在类结构确定之后就已知了（在概念模型中可以暂时忽略 JIT 编译器的优化），因此这几个区域的内存分配和回收都具有确定性。<span id="more"></span>而 Java 堆和方法区则不一样，一个接口的多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也可能不一样，只有在代码处于运行期间才能知道会创建哪些内存，这部分内存的分配和回收都是动态的，Java 的 GC 关注的就是这部分内存。  </p>
<p>垃圾收集需要完成三件事情：<strong>首先需要确定哪些内存需要回收，然后是何时回收以及怎样回收。</strong>  </p>
<h1 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h1><p>垃圾收集器在对堆进行回收之前，需要先确认哪些对象还“存活”着，哪些已经“死去”。而判断对象是否存活的关键就是引用。  </p>
<h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>在 JDK 1.2 以前，引用的定义很传统，如果变量中存储的是另外一块内存的起始地址，那么这块内存就代表着一个引用。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference）。</p>
<p>强引用就是类似 <code>Object obj = new Object()</code> 这样的引用，只要强引用还在，垃圾收集器就永远不会回收被引用的对象。</p>
<p>软引用用来描述一些有用但非必须的对象。只有在系统将要发生内存溢出异常之前，才会对软引用关联的对象进行回收，如果这次回收后还没有足够的内存，才会抛出 OutOfMemoryError。</p>
<p>弱引用的强度比软引用更弱，被弱引用关联的对象只能生存到下次垃圾收集之前。</p>
<p>虚引用是最弱的一种引用，虚引用顾名思义，就是形同虚设。虚引用并不会影响对象的生命周期，如果一个对象仅关联着虚引用，那么它就和没有任何引用一样，在任何时候都可能会被 GC 回收，我们无法通过虚引用获取它所关联的实例对象。虚引用的唯一作用就是跟踪垃圾收集器的回收活动。并且需要注意的是，虚引用必须和引用队列（ReferenceQueue）配合使用，当垃圾收集器准备回收一个对象时，如果发现它还有虚引用，那么就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用计数法就是给对象添加一个引用计数器，每当有一个地方引用它，计数器就加一；当引用失效时，计数器就减一。当计数器的值为 0 时表示对象没有被任何地方引用，可以进行回收，用下图表示会比较清晰：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008281147/2020/08/28/wnP.png" alt="引用计数法"></p>
<p>引用计数器算法实现简单，效率也很高，但是在主流的 Java 虚拟机里都没有采用这种算法，主要原因是它很难解决对象之间相互循环引用的问题。比如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">        a.b = b;</span><br><span class="line">        b.a = a;</span><br><span class="line"></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然对象 a 和 b 都为 null，但是由于 a 和 b 之间存在循环引用，因此它们的引用计数器都不为 0，GC 也就一直无法回收它们。用一个图展示会比较清晰：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008281147/2020/08/28/mdx.png" alt="引用计数法循环引用"></p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法通过一系列的称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连，就可以说从 GC Roots 到这个对象不可达，也就意味着这个对象是可以被回收的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/12/30/Vpe.png" alt="可达性分析"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008281147/2020/08/28/nAA.png" alt="可达性分析"></p>
<p>在 Java 中，可以作为 GC Roots 的对象包括：<strong>虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象以及本地方法栈中 JNI（即 Native 方法）引用的对象。</strong></p>
<h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>在做可达性分析时首先需要找到所有的 GC Roots 节点，可以作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果逐个检查这方面的引用，那么必然需要耗费大量的时间。另外可达性分析对执行时间的敏感还体现在 GC 停顿（也就是 STW，Stop The World）上，因为在分析期间需要整个执行系统暂停（所有的 Java 执行线程暂停运行，所有 GC 相关的工作交由 VMThread 处理），看起来就像被冻结在某个时间点上，不能出现在分析过程中对象的引用关系还在发生变化的情况，这会导致分析结果不准确。即使是号称几乎不会发生停顿的 CMS 收集器中，枚举根节点也是需要停顿的。</p>
<p>由于目前主流的 Java 虚拟机使用的都是准确式 GC，所以当执行系统停顿后，GC 并不需要一个不漏地检查所有执行上下文和全局的引用位置，虚拟机有办法直接得知哪些地方存放着对象引用。在 HotSpot 的实现中，它使用了一组称为 <code>OopMap</code> 的数据结构来达成这一目的，在类加载完成的时候，HotSpot 就把对象内所有偏移量上的数据类型计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样 GC 在扫描时就可以直接得知这些信息了。</p>
<blockquote>
<p>准确式内存管理意味着虚拟机可以知道内存中某个位置数据的类型，比如内存中有一个 32 位整数 123456，它到底是一个引用类型指向 123456 的内存地址值还是一个数值为 123456 的整数，虚拟机有能力分辨，这样才能在 GC 时准确判断堆上的数据是否还可能被使用。</p>
</blockquote>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在 OopMap 的帮助下，HotSpot 可以快速准确地完成 GC Roots 的枚举，但是一个现实的问题就是：可能引起引用关系变化的指令非常多，如果为每一条这样的指令都生成对应的 OopMap，那么将会需要大量的空间，同时安全点还有可能会影响 JIT 对代码进行优化（deoptimization safepoint），因此 HotSpot 只在特定的位置记录了这些信息，这些位置就是安全点（Safepoint），即程序执行时并非在所有的地方都能停顿下来进行 GC，只有在到达安全点时才可以。安全点的选定既不能太少以致于让 GC 长时间等待，也不能太多以致于虚拟机运行负荷增大，因此一般安全点选定的依据是“程序是否具有长时间运行的特征”，这些特定的位置主要有：uncounted loop（即无界循环）回跳之前、方法返回前、抛出异常的位置等等。JIT 编译器会在这些可能长时间运行的代码之后设置安全点，这样就可以避免出现程序中其他线程都已经到达安全点，而一些线程在长时间运行之后还不能进入安全点的情况。</p>
<blockquote>
<p>counted loop 是指虚拟机认为执行时间会比较短的循环，因此在编译时不会加入安全点检查的代码；而 uncounted loop 则可能会长时间执行，因此会在每次循环中加入安全点检查的代码。</p>
</blockquote>
<p>对于安全点，另一个需要考虑的问题就是如何在 GC 发生时让所有的执行线程（不包括执行 JNI 调用的线程）都“跑”到最近的安全点并停顿下来。这里有两种方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。其中抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时会直接把所有的线程中断，如果发现有线程中断的地方不在安全点，就恢复线程的执行并等待它到达安全点再中断。现在几乎没有虚拟机使用这种方式。而在主动式中断中，JIT 编译器编译的时候会在安全点的位置加入检查的代码（另外在创建对象需要分配内存的地方也会加入），当 GC 需要中断线程的时候并不直接操作线程，而是仅仅设置一个标志，各个线程在执行到安全点时会主动去检查这个标志，如果发现中断标志为真时就自己中断挂起。下面的代码中 test 指令是 HotSpot 生成的轮询指令，当需要暂停线程时，虚拟机会把 0x160100 的内存页设置为不可读，线程执行到 test 指令时就会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程实现等待。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x01b6d627: call   0x01b2b210         ; OopMap&#123;[60]=Oop off=460&#125;      </span><br><span class="line">                                       ;*invokeinterface size      </span><br><span class="line">                                       ; - Client1::main@113 (line 23)      </span><br><span class="line">                                       ;   &#123;virtual_call&#125;      </span><br><span class="line"> 0x01b6d62c: nop                       ; OopMap&#123;[60]=Oop off=461&#125;      </span><br><span class="line">                                       ;*if_icmplt      </span><br><span class="line">                                       ; - Client1::main@118 (line 23)      </span><br><span class="line"> 0x01b6d62d: test   %eax,0x160100      ;   &#123;poll&#125;      </span><br><span class="line"> 0x01b6d633: mov    0x50(%esp),%esi      </span><br><span class="line"> 0x01b6d637: cmp    %eax,%esi     </span><br></pre></td></tr></table></figure>

<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点机制可以保证程序在运行不太长的时间内就会遇到可以进入的 Safepoint，但是当程序不执行时，即程序没有被分配到 CPU 时间，典型的例子就是线程处于 Sleep 或者 Blocked 状态，这个时候线程无法响应虚拟机的中断请求，“走”到安全的地方去中断挂起，虚拟机显然也不大可能等待线程重新被分配 CPU 时间，这种情况就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始 GC 都是安全的。在线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，在这段时间里如果虚拟机要发起 GC，就不用管自己为 Safe Region 状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了 GC Roots 的枚举（或者是整个 GC 过程），如果完成了，那么线程就继续执行，否则它就必须等待直到接收到可以离开安全区域的信号为止。</p>
<h2 id="二次标记"><a href="#二次标记" class="headerlink" title="二次标记"></a>二次标记</h2><p>即使在可达性分析算法中不可达的对象，也并非一定会消亡，要真正回收一个对象，至少要经历两次标记过程。</p>
<p>在可达性分析后发现对象没有与 GC Roots 相连接的引用链，那么它会被进行第一次标记并进行一次筛选，<strong>当对象没有覆盖 <code>finalize()</code> 方法或者该对象的 <code>finalize()</code> 方法已经被虚拟机调用过，则虚拟机将认为该对象可以被回收</strong>；否则这个对象将会被放置在一个叫做 F-Queue 的队列中，稍后虚拟机会对该队列进行第二次小规模的标记：通过建立一个低优先级的 Finalizer 线程去执行队列中各个对象的 <code>finalize()</code> 方法。如果对象想要继续存活，就需要在覆盖的 <code>finalize()</code> 方法中重新与任意一个对象建立关联。</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区也存在垃圾收集，收集的主要内容为<strong>废弃常量</strong>和<strong>无用的类</strong>。  </p>
<p>回收废弃常量与回收 Java 堆中的对象类似，以常量池中的字面量回收为例，当系统中没有任何一个 String 对象引用常量池中的某个常量，也没有其他地方引用了这个字面量，则在必要的时候此字面量就会被回收。  </p>
<p>判断一个类是否是无用的类需要同时满足三个条件：该类所有的实例都已经被回收，加载该类的 ClassLoader 已经被回收，该类对应的 java.lang.Class 对象没有在任何地方被引用（包括反射）。在满足了这三个条件后，还需要虚拟机开启类回收功能，比如 HotSpot 虚拟机就提供了 <code>-Xnoclassgc</code> 参数。  </p>
<p><strong>在大量使用反射、动态代理、CGLIB 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具有类卸载的功能，以保证永久代不会溢出。</strong>  </p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>垃圾收集算法的作用是指导收集器以何种方式回收内存，最基础的算法就是标记-清除算法，其他算法都是在它的基础上发展而来。  </p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>标记-清除（Mark-Sweep）算法是最基础的收集算法，该算法主要分为“标记”和“清除”两个阶段：标记阶段会标记出所有可以回收的对象，标记的过程在<a href="#%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1">生存还是死亡</a>中已经说明了。在标记完成后，虚拟机会统一进行回收。  </p>
<p>该算法主要两个缺陷：一个是标记和清除的效率都不高；二是标记并清除之后会产生大量不连续的内存碎片，当碎片太多时可能会导致以后程序运行过程中需要分配大内存对象时因为无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/01/03/g7P.png" alt="标记清除算法">  </p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法是将内存按照容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上，然后把之前使用的那一块内存空间清理掉。这样每次都是对整个半区进行内存回收，内存分配时也不必考虑碎片问题，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。  </p>
<p>复制算法的缺点也很明显，比较直观的就是可用内存缩小为原来的一半，并且当对象存活率较高时就需要进行较多的复制操作，效率会降低。同时如果另一块内存空间不足以存储所有存活的对象时，还需要依赖其他内存（比如老年代）进行分配担保。    </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/01/03/79m.png" alt="复制算法">  </p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-整理（Mark-Compact）算法的标记过程和标记-清除算法相同，但是后续并不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。这种算法克服了标记-清除算法会产生大量碎片的问题。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/DBg.png" alt="标记整理算法"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前的商业虚拟机的垃圾收集大都采用分代收集算法，这种算法根据对象生存周期的不同将内存划分为几块，一般是分为新生代和老年代。针对不同代的特点采取不同的收集策略。  </p>
<p>在新生代，由于对象存活时间短，所以采用复制算法，每次只需要复制少量存活的对象就可以完成收集。而在老年代，由于对象存活率较高，没有额外空间对它进行分配担保，因此只能采用标记-清除或者标记-整理算法来回收。</p>
<h1 id="内存分代机制"><a href="#内存分代机制" class="headerlink" title="内存分代机制"></a>内存分代机制</h1><p>Java 对象根据存活时间被分为<strong>新生代（Young Generation）<strong>和</strong>老年代（Old&#x2F;Tenured Generation）</strong>，由于**永久代（Permanent Generation）**在 JDK 1.8 已经被完全废弃了，故不再讨论。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/Jra.jpeg" alt="Java 内存分代"></p>
<h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>在对象被创建时，内存的分配首先发生在新生代（大对象直接被创建在老年代）。大部分的对象在创建后很快就不再使用（IBM 的研究表明，98% 的对象在创建后很快就会走向消亡），因此新生代比较适合采用复制算法进行垃圾收集，这种发生在新生代的 GC 机制被称为 Minor GC。由于新生代中的对象大都朝生夕死，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次只使用 Eden 和其中的一块 Survivor。</p>
<p>Eden 区是对象首次分配内存的区域，默认大小为整个新生代的 80%。Eden 区是连续的内存区域，所以分配内存极快，当 Eden 区没有足够的空间分配时，虚拟机将会发起一次 Minor GC。Survivor From 区是对象的存活区，默认大小为整个新生代的 10%。Survivor To 区同样是对象的存活区，默认大小为整个新生代的 10%。</p>
<p>在初次分配内存时，如果 Eden 已满，则虚拟机会发起一次 Minor GC，将剩余存活的对象复制到 Survivor From 区，同时清空 Eden 区。在下次 Eden 区满时，再次执行 Minor GC，将存活的对象复制到 Survivor To，然后清空 Eden 和 Survivor From 区。当一个对象在两个存活区之间切换了几次（HotSpot 中默认为 15 次，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 控制。该值只是一个最大值，并不代表一定是这个值）之后，将被复制到老年代。</p>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>一个对象如果在新生代存活了足够长的时间而没被清理掉，那么将会被复制到老年代。如果对象比较大（比如长字符串或大数组），则会在首次分配内存时被分配到老年代。当老年代内存不够时，将会触发 Major GC。老年代发生 GC 的次数一般要比新生代少。</p>
<h1 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h1><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么可以确保进行 Minor GC 是安全的。如果不成立，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象容量的平均大小。如果大于，那么会尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的。如果小于，或者 HandlePromotionFailure 设置为不允许冒险，那么此时会进行一次 Full GC。</p>
<p>我们知道新生代采用复制算法，但是为了内存利用率，只使用了一个 Survivor 空间作为轮换，因此当大量对象在 Minor GC 后仍然存活时，就需要老年代进行分配担保，把 Survivor 中无法容纳的对象放入老年代。老年代进行担保的前提是老年代本身还有容纳这些对象的空间，由于一共会有多少对象存活下来只能在实际完成内存回收之后才能知道，所以在老年代空间不足以容纳新生代所有对象时，只好取之前每次回收晋升到老年代的对象容量的平均大小作为经验值，与老年代剩余的空间进行比较，以此决定是否进行 Full GC 来让老年代腾出更多空间。取平均值进行比较仍然是一个动态的概率，如果某次 Minor GC 后存活的对象突增，远远高于平均值的话，仍然可能会导致担保失败（Handle Promotion Failure），此时只好在失败后重新发起一次 Full GC。虽然设置 HandlePromotionFailure 为允许冒险时可能绕的圈子是最大的，但是大部分情况下还是会将它开启，避免 Full GC 过于频繁。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《深入理解 Java 虚拟机》</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存模型</title>
    <url>/2017/08/05/Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>当 CPU 是单核心时，同一时间点只能执行一个任务，即只能同时运行一个进程或者说是线程。后来多核心、超线程**（通过特殊的硬件指令将一个物理核心模拟成多个逻辑核心，每个逻辑核心的功能都与物理核心相似，但是由于逻辑核心共享一个物理核心的资源，所以有时会出现冲突，这时就需要某个逻辑核心让出占用。超线程能提高性能，但不等于同等数量的物理核心）**出现，计算机在同一时间可以执行多个任务，即运行多个进程或多个线程。但是多线程的出现并不只是因为硬件的提升，一个重要的原因是计算机的运行速度和它的存储、通信子系统速度差距过大，大量的时间浪费在了磁盘 I&#x2F;O、网络通信上，因此让计算机同时处理多个任务成为压榨计算机性能的重要手段。</p>
<span id="more"></span>

<h1 id="硬件效率一致性"><a href="#硬件效率一致性" class="headerlink" title="硬件效率一致性"></a>硬件效率一致性</h1><p>让计算机同时执行多个任务在硬件实现上也不是那么容易的。因为多数任务不是只靠计算就可以完成的，至少还需要内存参与其中，CPU 需要将数据从内存中读取或写入内存，但是 CPU 的速度要远远超过内存的速度，因此不得不在它们之间加入一层与 CPU 速度相匹配的高速缓存作为缓冲区，使 CPU 减少等待的时间消耗。</p>
<p>这样处理确实能够解决 CPU 与内存处理速度不匹配的问题，但是又会带来新的问题：缓存一致性。</p>
<p>多 CPU 系统中，每个 CPU 都有自己的高速缓存，这些缓存共享同一个主内存（Main Memory），当多个 CPU 的运算都涉及到同一块内存区域时，可能导致各自的高速缓存中的数据不一致。为了解决这个问题，需要各个高速缓存都遵循一些协议，依照这些协议来读写数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/Ybb.png" alt="cpu_cache_memory"></p>
<h1 id="Java-内存模型抽象"><a href="#Java-内存模型抽象" class="headerlink" title="Java 内存模型抽象"></a>Java 内存模型抽象</h1><p>Java 内存模型（JMM）主要是定义各种变量的访问规则，这里的变量主要包括实例字段（成员变量）、静态字段（类变量）和数组元素，不包括局部变量（如果局部变量是引用类型，它引用的对象在堆中被各线程共用，但是引用本身还是保存在 Java 栈的局部变量表中）和方法参数。前者是线程共享的，后者是线程私有的。</p>
<p>Java 内存模型规定所有的变量都存储在主内存中。每个线程都有自己的工作内存（Working Memory，是 JMM 的抽象概念，并不真实存在），类似于处理器的高速缓存，线程的工作内存保存了该线程使用到的在主内存的变量的一份拷贝。线程对变量的读写操作都必须在工作内存中进行，不同线程不能直接访问对方的工作内存，线程间变量值的传递均需要经过主内存来完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/Lny.png" alt="java 内存模型"></p>
<h1 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h1><p>Java 内存模型定义了 8 种操作来完成主内存和工作内存之间的交互，虚拟机在实现这些操作时必须保证每一种操作都是原子的。</p>
<ul>
<li>lock（锁定）<br>作用于主内存的变量，它把一个变量标识为线程独占的状态。  </li>
<li>unlock（解锁）<br>作用于主内存的变量，它把一个处于锁定状态的变量释放。  </li>
<li>read（读取）<br>作用于主内存的变量，它把一个变量的值从主内存传递到线程的工作内存中。  </li>
<li>load（载入）<br>作用于工作内存的变量，它把 read 操作得到的变量值放入工作内存的变量的副本中。  </li>
<li>use（使用）<br>作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时就执行该操作。  </li>
<li>assign（赋值）<br>作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就执行该操作。  </li>
<li>store（存储）<br>作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中。  </li>
<li>write（写入）<br>作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>Java 内存模型规定了一些执行这 8 种操作的规范，比如 read 和 load、store 和 write 必须顺序的、组合的出现，即有 read 必须有 load，且 read 必须在 load 前面，read 和 load 中间可以插入其他指令。利用这些规则可以确定 Java 程序中哪些内存访问操作是线程安全的，但是这些规则十分烦琐，有一种等效的判断原则——先行发生原则（Happens-Before）。  </p>
<blockquote>
<p>在 JSR133 中，已经放弃采用这 8 种操作去定义 Java 内存模型的访问协议了（仅仅是描述方式改变了，内存模型并没有改变）。  </p>
</blockquote>
<h2 id="对于-volatile-型变量的特殊规则"><a href="#对于-volatile-型变量的特殊规则" class="headerlink" title="对于 volatile 型变量的特殊规则"></a>对于 volatile 型变量的特殊规则</h2><ul>
<li>在工作内存中，每次使用变量前都必须先从主内存刷新最新的值，用于保证能够看到其他线程对变量值的修改。  </li>
<li>在工作内存中，每次修改变量的值都必须立刻同步回主内存中，用于保证其他线程可以看到该线程对变量值的修改。  </li>
<li>volatile 修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。</li>
</ul>
<h2 id="对于-long-和-double-型变量的特殊规则"><a href="#对于-long-和-double-型变量的特殊规则" class="headerlink" title="对于 long 和 double 型变量的特殊规则"></a>对于 long 和 double 型变量的特殊规则</h2><h1 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h1><p>Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性来建立的。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>可以大致认为基本类型的访问读写是原子性的（一种几乎不会发生的例外就是 long 和 double 的非原子协定）。如果需要更大范围的原子性保证，Java 内存模型还提供了 lock 和 unlock 操作，尽管虚拟机没有把这两种操作直接开发给用户使用，却提供了更高层次的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>，反映到代码中就是 <code>synchronized</code> 关键字。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性保证当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。无论是普通变量还是 <code>volatile</code> 变量都是在变量修改后将新值同步回主内存，区别在于，<code>volatile</code> 保证变量修改后能够立刻同步回主内存、每次使用变量前都从主内存刷新。</p>
<p>除了 <code>volatile</code> 外，<code>synchronized</code> 和 <code>final</code> 也能够保证可见性。同步块能保证可见性是因为在执行 unlock 之前，会将变量的值同步回主内存中。被 <code>final</code> 修饰的字段在构造器中一旦初始化完成，并且构造器没有把 <code>this</code> 引用传递出去（<code>this</code> 引用逃逸，常出现在构造器中启动线程或注册监听器时，其他线程可以通过该引用访问到还未初始化结束的对象），那么在其他线程中就可以看到 <code>final</code> 字段的值。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>如果在本线程内观察，所有的操作都是有序的、串行的；如果在一个线程内观察另一个线程，因为指令重排序和工作内存与主内存同步延迟的原因，所有的操作都是无序的。Java 提供了 <code>volatile</code> 和 <code>synchronized</code> 来保证线程之间操作的有序性，<code>volatile</code> 禁止了指令重排序，而 <code>synchronized</code> 使得一个变量在同一时刻只允许一条线程对其进行 lock 操作，即持有同一个锁的两个同步块只能串行的进入。</p>
<h1 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h1><p>如果 Java 内存模型中所有的有序性都仅仅依靠 <code>volatile</code> 和 <code>synchronized</code> 来完成，那么一些操作会变得很烦琐，但是我们在编写 Java 并发代码的时候并没有感觉到这一点，这是因为 Java 中有一个先行发生原则（Happens-Before），它是判断数据是否存在竞争、线程是否安全的主要依据。</p>
<ul>
<li>程序次序规则<br>在一个线程内，按照代码的顺序，准确的说是控制流的顺序，书写在前面的操作先行发生于书写在后面的操作。  </li>
<li>管程锁定规则<br>同一个锁，<code>unlock</code> 操作先行发生于 <code>lock</code> 操作，即对于同一个锁，加锁之前必须解锁。  </li>
<li>volatile 变量规则<br>对一个 <code>volatile</code> 变量的写操作先行发生于后面对这个变量的读操作。  </li>
<li>线程启动规则<br>Thread 对象的 <code>start()</code> 方法先行发生于此线程的每一个动作之前。  </li>
<li>线程中断规则<br>线程中断方法 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 <code>Thread.interrupted()</code> 方法检测是否有中断发生。  </li>
<li>线程终止规则<br>线程中的所有操作都先行发生于对此线程的终止检测，可以使用 <code>Thread.join()</code> 方法终止，使用 <code>Thread.isAlive()</code> 方法检测是否已经终止。  </li>
<li>对象终结规则<br>一个对象的初始化完成（构造器执行结束）先行发生于它的<code>finalize()</code>方法的开始。  </li>
<li>传递性<br>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，则操作 A 先行发生于操作 C。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 对象的创建、布局和访问</title>
    <url>/2018/06/09/Java%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>本章主要讨论在 HotSpot 虚拟机的堆内存中，Java 对象的内存分配、内存布局和访问定位的全过程。</p>
<span id="more"></span>

<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>虚拟机在遇到一条创建对象的指令（比如 new）时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么会先执行相应的类加载的过程。</p>
<p>在类加载检查通过后，虚拟机将会为新生对象分配内存。对象所需的内存大小在类加载完成之后便可完全确定，为对象分配内存空间的任务相当于把一块确定大小的内存从 Java 堆中划分出来。假如 Java 堆中的内存是绝对规整的，所有的内存都放到一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就仅仅是把指针向空闲空间那边移动一段与对象大小相等的距离。这种分配方式称为<strong>指针碰撞（Bump the Pointer）</strong>。如果堆中的内存不是规整的，那么虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配内存时从列表中寻找一块足够大的空间划分给对象实例，并更新列表，这种分配方式称为<strong>空闲列表（Free List）</strong>。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带有 Compack 功能的收集器时，系统采用的分配算法是指针碰撞；而使用 CMS 这种基于标记-清除（Mark-Sweep）算法的收集器时，通常采用空闲列表。</p>
<p>在虚拟机中创建对象是很频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理，实际上虚拟机采用的是 CAS 配合失败重试的方式来保证更新操作的原子性。另一种是把内存分配按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有在 TLAB 用完并重新分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过 <code>-XX:+/-UseTLAB</code> 参数来设定。</p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB 则可以将初始化的操作提前至 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，对象的哈希码，对象的 GC 分代年龄等信息，这些信息被存放在对象的对象头（Object Header）中。</p>
<p>在上面的工作都完成后，从虚拟机的角度看，一个新的对象已经产生，但从程序的角度看，对象的创建才刚刚开始，因为 <code>&lt;init&gt;</code> 方法还没有执行，所有的字段都为零。一般来说（由字节码中是否跟随 invokespecial 指令决定），执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，这样一个真正可用的对象才算完全生产出来。</p>
<p>下面是 HotSpot 虚拟机的 <code>bytecodeInterpreter.cpp</code> 中的代码片段（JDK 6），这个解释器实现很少被实际使用，因为大部分平台都使用模板解释器，当代码通过 JIT 编译器执行时差异就更大了，不过通过它可以了解 HotSpot 的运作过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">u2 index = Bytes::<span class="built_in">get_Java_u2</span>(pc+<span class="number">1</span>);</span><br><span class="line">constantPoolOop constants = istate-&gt;<span class="built_in">method</span>()-&gt;<span class="built_in">constants</span>();</span><br><span class="line"><span class="comment">// 确保常量池中存放的是已经解释的类</span></span><br><span class="line"><span class="keyword">if</span> (!constants-&gt;<span class="built_in">tag_at</span>(index).<span class="built_in">is_unresolved_klass</span>()) &#123;</span><br><span class="line">  <span class="comment">// 断言确保是 klassOop 和 instanceKlassOop</span></span><br><span class="line">  oop entry = (klassOop) *constants-&gt;<span class="built_in">obj_at_addr</span>(index);</span><br><span class="line">  <span class="built_in">assert</span>(entry-&gt;<span class="built_in">is_klass</span>(), <span class="string">&quot;Should be resolved klass&quot;</span>);</span><br><span class="line">  klassOop k_entry = (klassOop) entry;</span><br><span class="line">  <span class="built_in">assert</span>(k_entry-&gt;<span class="built_in">klass_part</span>()-&gt;<span class="built_in">oop_is_instance</span>(), <span class="string">&quot;Should be instanceKlass&quot;</span>);</span><br><span class="line">  instanceKlass* ik = (instanceKlass*) k_entry-&gt;<span class="built_in">klass_part</span>();</span><br><span class="line">  <span class="comment">// 确保对象所属类型已经经过初始化阶段</span></span><br><span class="line">  <span class="keyword">if</span> ( ik-&gt;<span class="built_in">is_initialized</span>() &amp;&amp; ik-&gt;<span class="built_in">can_be_fastpath_allocated</span>() ) &#123;</span><br><span class="line">    <span class="comment">// 取对象长度</span></span><br><span class="line">    <span class="type">size_t</span> obj_size = ik-&gt;<span class="built_in">size_helper</span>();</span><br><span class="line">    oop result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 记录是否需要将对象所有字段置为零值</span></span><br><span class="line">    <span class="type">bool</span> need_zero = !ZeroTLAB;</span><br><span class="line">    <span class="comment">// 是否在 TLAB 中分配对象</span></span><br><span class="line">    <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">      result = (oop) THREAD-&gt;<span class="built_in">tlab</span>().<span class="built_in">allocate</span>(obj_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      need_zero = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 直接在 Eden 中分配对象</span></span><br><span class="line">retry:</span><br><span class="line">      HeapWord* compare_to = *Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">top_addr</span>();</span><br><span class="line">      HeapWord* new_top = compare_to + obj_size;</span><br><span class="line">      <span class="comment">// cmpxchg 是 x86 中的 CAS 指令，这里是一个 C++ 方法，通过 CAS 方式分配空间，并发失败的话，</span></span><br><span class="line">      <span class="comment">// 转到 retry 中重试直至成功分配为止</span></span><br><span class="line">      <span class="keyword">if</span> (new_top &lt;= *Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">end_addr</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(new_top, Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">top_addr</span>(), compare_to) != compare_to) &#123;</span><br><span class="line">          <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">        result = (oop) compare_to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果需要，则为对象初始化零值</span></span><br><span class="line">      <span class="keyword">if</span> (need_zero ) &#123;</span><br><span class="line">        HeapWord* to_zero = (HeapWord*) result + <span class="built_in">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">        obj_size -= <span class="built_in">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">        <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">          <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据是否启用偏向锁来设置对象头信息</span></span><br><span class="line">      <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">        result-&gt;<span class="built_in">set_mark</span>(ik-&gt;<span class="built_in">prototype_header</span>());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;<span class="built_in">set_mark</span>(markOopDesc::<span class="built_in">prototype</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      result-&gt;<span class="built_in">set_klass_gap</span>(<span class="number">0</span>);</span><br><span class="line">      result-&gt;<span class="built_in">set_klass</span>(k_entry);</span><br><span class="line">      <span class="comment">// 将对象引用入栈，继续执行下一条指令</span></span><br><span class="line">      <span class="built_in">SET_STACK_OBJECT</span>(result, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h1><p>OOPS 指的是普通对象指针（ordinary object pointers），可以认为是对象的引用。这些对象指针的长度通常跟机器的本地指针是一样的，一般 OOPS 在 32 位机上是 32 位长，在 64 位机上是 64 位长。64 位虚拟机出现后，OOPS 的尺寸也变成了 64 位，比之前大了一倍，这就导致对象的内存占用增加（对象的内存布局中有些区域存放的是内存地址值），更重要的是相同尺寸的 CPU Cache 要少存一倍的 OOPS。</p>
<p>从 JDK 1.6 开始，64 位虚拟机正式支持 <code>-XX:+UseCompressedOops</code> 参数，该参数可以压缩指针，节约对象的内存占用。还有一个 <code>-XX:+UseCompressedClassPointers</code> 参数是用来压缩对象头的类型指针的，在启用指针压缩时默认会开启。</p>
<p>由于 Java 默认是 8 字节对齐的内存，也就是一个对象占用的空间，必须是 8 字节的整数倍，不足的话就会填充到 8 字节的整数倍。因此实际上 Java 对象的内存地址都是 8、16 这种形式，也就是说根本不会定位到之间的比如 1 到 7 这些位置。在实现上，对象的内存地址值还是按照 0x0、0x1、0x2 进行存储，只不过当从堆中读取对象时，JVM 将其左移 3 位，相当于在地址末尾添加 3 个 0。例如内存地址 0x0、0x1、0x2 分别被转换为 0x0、0x8、0x10。这样只需要 32 位的内存地址就可以实际使用 32 GB（4GB x 8）的内存空间。</p>
<p>如果配置的最大堆内存超过 32 GB，那么指针压缩就会失效。当然此时可以通过参数 <code>-XX:ObjectAlignmentInBytes</code> 设置更大的字节对齐大小（8 的倍数，不能超过 128）来解决。比如设置为 24 字节，那么最大堆内存超过 96 GB 的情况下压缩指针才会失效。</p>
<p>使用指针压缩虽然可能会增加内存间隙，但是与开启的收益相比，这部分的损失完全可以接受。</p>
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象在内存中存储的布局分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头通常包含两部分信息：Mark Word 和 Klass Word（类型指针）。</p>
<p>Mark Word 用于存储对象自身的运行时数据，如 HashCode 、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳（epoch）等。这部分数据的长度在 32 位和 64 位虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。由于 Mark Word 的信息与对象自身定义的数据无关，考虑到虚拟机的空间效率，它被设计为非固定的数据结构，它会根据对象的状态复用存储空间。</p>
<p>Klass Word，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象头存储类型指针（Java 程序通过栈上的 reference 数据来操作堆上的具体对象，由于虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该使用何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式取决于虚拟机的实现，主流的访问方式有使用句柄和直接指针两种，而使用句柄的方式不需要在对象头中存储类型指针）。</p>
<p>另外如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004171532/2020/04/17/ppa.png" alt="对象头与锁状态"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 32 位虚拟机对象头（未启用指针压缩）</span><br><span class="line"></span><br><span class="line">|----------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                    Object Header (64 bits)                             |        State       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|                  Mark Word (32 bits)                  |      Klass Word (32 bits)      |                    |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       Normal       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       Biased       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|               ptr_to_lock_record:30          | lock:2 |      OOP to metadata object    | Lightweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|               ptr_to_heavyweight_monitor:30  | lock:2 |      OOP to metadata object    | Heavyweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|                                              | lock:2 |      OOP to metadata object    |    Marked for GC   |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 64 位虚拟机对象头（未启用指针压缩）</span><br><span class="line"></span><br><span class="line">|------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (128 bits)                                        |        State       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                         |    Klass Word (64 bits)     |                    |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                       ptr_to_lock_record:62                         | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor:62                   | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                     | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 64 位虚拟机对象头（启用指针压缩）</span><br><span class="line"></span><br><span class="line">|--------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (96 bits)                                           |        State       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                           |    Klass Word (32 bits)     |                    |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                         ptr_to_lock_record                            | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor                        | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                       | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<p>当对象在无锁状态时，HashCode 会懒初始化，它只会在调用 <code>System#identityHashCode(object)</code> 之后被初始化。而在其他状态时，HashCode 将不在 Mark Word 中存储，它会被存储到 monitor 中。GC 分代年龄长度只有四位，因此最大年龄为 15，超过该年龄对象会被转移到老年代。当对象在轻量级锁状态时，<code>ptr_to_lock_record</code> 指向锁记录，该记录在当前线程的栈帧中存储，锁记录中存储了锁对象的 Mark Word 的拷贝。线程获取轻量级锁的过程为使用 CAS 将对象的 Mark Word 更新为指向锁记录的指针，更新成功则表示获取到了轻量级锁。当对象升级为重量级锁时，<code>ptr_to_heavyweight_monitor</code> 指向 monitor。</p>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据是对象真正存储有效信息的地方，包括程序代码中定义的各种类型的字段内容，无论是从父类继承的还是在子类中定义的都会记录下来，这部分的存储顺序受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在源码中定义的顺序影响。</p>
<p>一个 Java 对象中的实例数据可能是基本类型或者引用类型。如果是 8 种基本类型，那么存储的就是值，并且大小是固定的；如果是引用类型，那么存储的就是地址值，它的大小与虚拟机位数和是否开启指针压缩有关。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小（字节）</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>基本类型</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>基本类型</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>基本类型</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>基本类型</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>基本类型</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>基本类型</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>基本类型</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>基本类型</td>
</tr>
<tr>
<td>reference</td>
<td>4</td>
<td>引用类型，64 位虚拟机开启指针压缩</td>
</tr>
</tbody></table>
<p>为了验证该约定，并且方便接下来的实践，我们可以引入 OpenJDK 提供的 Java Object Layout 工具。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们首先查看当前环境的一些信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(VM.current().details());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VM mode: 64 bits</span><br><span class="line"># Compressed references (oops): 3-bit shift</span><br><span class="line"># Compressed class pointers: 0-bit shift and 0x800000000 base</span><br><span class="line"># Object alignment: 8 bytes</span><br><span class="line">#                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl</span><br><span class="line"># Field sizes:            4,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array element sizes:    4,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16</span><br></pre></td></tr></table></figure>

<p>可以看到，当前环境是一个 64 位的虚拟机并且开启了指针压缩，我们使用参数 <code>-XX:-UseCompressedOops</code> 来取消指针压缩：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VM mode: 64 bits</span><br><span class="line"># Compressed references (oops): disabled</span><br><span class="line"># Compressed class pointers: disabled</span><br><span class="line"># Object alignment: 8 bytes</span><br><span class="line">#                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl</span><br><span class="line"># Field sizes:            8,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array element sizes:    8,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array base offsets:    24,   24,   24,   24,   24,   24,   24,   24,   24</span><br></pre></td></tr></table></figure>

<p>可以看到，引用类型的大小变为了 8 字节，同时 Array base offsets 也发生了变化。该数据表示的是数组的第一个元素的地址偏移量，在下面会详细解释。</p>
<p>创建一个自定义类 MyClass 并编写测试代码，运行时开启指针压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> bool;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">short</span> st;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> l;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> f;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> arr[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(myClass).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   4                    (object header: class)    0x000d54b0</span><br><span class="line"> 12   4                int MyClass.i                 0</span><br><span class="line"> 16   8               long MyClass.l                 0</span><br><span class="line"> 24   8             double MyClass.d                 0.0</span><br><span class="line"> 32   4              float MyClass.f                 0.0</span><br><span class="line"> 36   2              short MyClass.st                0</span><br><span class="line"> 38   2               char MyClass.c                  </span><br><span class="line"> 40   1            boolean MyClass.bool              false</span><br><span class="line"> 41   1               byte MyClass.b                 0</span><br><span class="line"> 42   2                    (alignment/padding gap)   </span><br><span class="line"> 44   4   java.lang.String MyClass.s                 null</span><br><span class="line"> 48   4              int[] MyClass.arr               null</span><br><span class="line"> 52   4                    (object alignment gap)    </span><br><span class="line">Instance size: 56 bytes</span><br><span class="line">Space losses: 2 bytes internal + 4 bytes external = 6 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看到 Mark Word 的大小为 8 字节，Klass Word 的大小为 4 字节，引用的地址值大小为 4 个字节，同时对齐填充浪费了 6 个字节。接下来我们使用 <code>-XX:-UseCompressedClassPointers</code> 取消类型指针压缩：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8                    (object header: class)    0x0000022b4a32d980</span><br><span class="line"> 16   8               long MyClass.l                 0</span><br><span class="line"> 24   8             double MyClass.d                 0.0</span><br><span class="line"> 32   4                int MyClass.i                 0</span><br><span class="line"> 36   4              float MyClass.f                 0.0</span><br><span class="line"> 40   2              short MyClass.st                0</span><br><span class="line"> 42   2               char MyClass.c                  </span><br><span class="line"> 44   1            boolean MyClass.bool              false</span><br><span class="line"> 45   1               byte MyClass.b                 0</span><br><span class="line"> 46   2                    (alignment/padding gap)   </span><br><span class="line"> 48   4   java.lang.String MyClass.s                 null</span><br><span class="line"> 52   4              int[] MyClass.arr               null</span><br><span class="line">Instance size: 56 bytes</span><br><span class="line">Space losses: 2 bytes internal + 0 bytes external = 2 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看到，Klass Word 的大小变为了 8 个字节，但是对齐填充只浪费了 2 个字节。接下来我们直接关闭指针压缩：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   8                    (object header: class)    0x0000019166eb0b08</span><br><span class="line"> 16   8               long MyClass.l                 0</span><br><span class="line"> 24   8             double MyClass.d                 0.0</span><br><span class="line"> 32   4                int MyClass.i                 0</span><br><span class="line"> 36   4              float MyClass.f                 0.0</span><br><span class="line"> 40   2              short MyClass.st                0</span><br><span class="line"> 42   2               char MyClass.c                  </span><br><span class="line"> 44   1            boolean MyClass.bool              false</span><br><span class="line"> 45   1               byte MyClass.b                 0</span><br><span class="line"> 46   2                    (alignment/padding gap)   </span><br><span class="line"> 48   8   java.lang.String MyClass.s                 null</span><br><span class="line"> 56   8              int[] MyClass.arr               null</span><br><span class="line">Instance size: 64 bytes</span><br><span class="line">Space losses: 2 bytes internal + 0 bytes external = 2 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看到，除了 Klass Word 的大小变为了 8 个字节外，引用类型的地址大小也变为了 8 个字节。</p>
<p>我们之前提到 Array base offsets 表示的是数组的第一个元素的地址偏移量，如何理解呢？请看下面的代码，运行时启用指针压缩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(VM.current().details());</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(arr).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VM mode: 64 bits</span><br><span class="line"># Compressed references (oops): 3-bit shift</span><br><span class="line"># Compressed class pointers: 0-bit shift and 0x800000000 base</span><br><span class="line"># Object alignment: 8 bytes</span><br><span class="line">#                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl</span><br><span class="line"># Field sizes:            4,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array element sizes:    4,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array base offsets:    16,   16,   16,   16,   16,   16,   16,   16,   16</span><br><span class="line"></span><br><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4                    (object header: class)    0x0001dbc0</span><br><span class="line"> 12   4                    (array length)            2</span><br><span class="line"> 16   8   java.lang.String String;.&lt;elements&gt;        N/A</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>由于开启了指针压缩，Mark Word 占用 8 字节，Klass Word 占用 4 字节，由于是数组，还有 4 个字节用来存储数组的长度。也就是说，对于该数组而言（数组元素的内存分配是连续的），数组中的第一个元素的内存地址为：该对象的内存地址 + 16 字节。同时，该数组是一个长度为 2 的 String 数组，因此实例数据的大小为 2 个引用类型的地址值占用的大小。如果这里的数组是基本类型数组，那么实例数据的大小就是数组长度乘上基本类型的大小。接下来关闭指针压缩：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># VM mode: 64 bits</span><br><span class="line"># Compressed references (oops): disabled</span><br><span class="line"># Compressed class pointers: disabled</span><br><span class="line"># Object alignment: 8 bytes</span><br><span class="line">#                       ref, bool, byte, char, shrt,  int,  flt,  lng,  dbl</span><br><span class="line"># Field sizes:            8,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array element sizes:    8,    1,    1,    2,    2,    4,    4,    8,    8</span><br><span class="line"># Array base offsets:    24,   24,   24,   24,   24,   24,   24,   24,   24</span><br><span class="line"></span><br><span class="line">[Ljava.lang.String; object internals:</span><br><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   8                    (object header: class)    0x000001f341b64248</span><br><span class="line"> 16   4                    (array length)            2</span><br><span class="line"> 20   4                    (alignment/padding gap)   </span><br><span class="line"> 24  16   java.lang.String String;.&lt;elements&gt;        N/A</span><br><span class="line">Instance size: 40 bytes</span><br><span class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>与开启指针压缩相比，由于 Klass Word 变回了 8 个字节，所以需要对齐填充，可以看到这里对齐填充的部分紧跟在数组长度之后。</p>
<h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对齐填充不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。HotSpot 虚拟机自动内存管理系统要求对象的起始地址必须是 8 字节的整数倍，换句话说，就是对象的大小必须是 8 字节的整数倍。从上面的例子中我们也能够发现，对齐填充不光局限于对象的尾部，有时候也会在对象的字段中间插入填充间隙。</p>
<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java 程序需要通过栈上的 reference 数据来操作堆上具体的对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位和访问，所以对象访问的方式也是取决于虚拟机的实现。目前主流的访问方式有<strong>句柄</strong>和<strong>直接指针</strong>两种，HotSpot 虚拟机采用的是直接指针的方式。</p>
<p>如果使用句柄访问，那么 Java 堆中将会划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自具体的地址信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004171532/2020/04/17/4Vb.png" alt="句柄"></p>
<p>如果使用直接指针，那么 Java 堆对象的内存布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的内存地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004171532/2020/04/17/qYz.png" alt="直接指针"></p>
<p>这两种方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象非常常见）时只会改变句柄中实例数据的指针，而 reference 本身不需要修改。使用直接指针访问的最大好处就是速度块，它节省了一次指针定位的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
<h1 id="关于类型指针"><a href="#关于类型指针" class="headerlink" title="关于类型指针"></a>关于类型指针</h1><p>JDK 8 在指针压缩之外，额外增加了一个新选项叫做 UseCompressedClassPointer。这个选项打开后，就像我们上面分析的那样，类型指针会被压缩成 4 个字节。而类型指针存放的数据作为 JVM 中的元数据，在 JDK 7 及以前是存放在永久代的，但是 Hotspot 在 JDK 8 中已经没有了永久代，取而代之的是元空间（meta space）。于是之前类型指针指向的这块区域就有了一个新名字：Compressed Class Space，默认大小是 1GB，但是可以通过 <code>CompressedClassSpaceSize</code> 选项调整。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《深入理解 Java 虚拟机:JVM 高级特性与最佳实践》</p>
</blockquote>
<blockquote>
<p><a href="https://wiki.openjdk.org/display/HotSpot/CompressedOops">CompressedOops</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 性能分析之火焰图</title>
    <url>/2020/08/27/Java%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8B%E7%81%AB%E7%84%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>在程序运行期间，可能会因为某段代码大量占用 CPU 时间而拖累整个应用的执行，能够快速定位这类热点代码的性能分析工具有很多，这里介绍的火焰图比较特殊，它可以将很多性能分析工具的采样结果以一种更加直观的方式展现出来，从而快速定位热点问题。</p>
<span id="more"></span>

<p>网上很多关于火焰图的讲解最初来自于 Brendan Gregg 的博客文章：<a href="http://www.brendangregg.com/flamegraphs.html">Flame Graphs</a>，火焰图的效果大致如下图：</p>
<embed src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008271727/2020/08/27/RjK.svg" width="900" height="563.4" type="image/svg+xml" />

<p>该火焰图是一个 SVG 格式的文件，由开源工具：<a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> 生成。图中的每个色块代表的是一个线程栈帧，色块中是该栈帧加载执行的函数以及一些采样信息。Y 轴代表调用栈的深度，调用从底部开始向上进行，顶部是正在执行的函数，下面是它的父函数，调用栈越深，火焰就越高。X 轴代表抽样数，如果一个函数在 X 轴占据的宽度越大，表示它被抽取到的次数越多，也就意味着它占用的 CPU 时间越长。</p>
<blockquote>
<p>需要注意的是，图中的颜色并不重要，只用于区分不同的函数，同时 X 轴的从左到右的顺序也不重要，默认按照字典顺序排序。</p>
</blockquote>
<p>我们可以简单举个例子来理解。一般在使用性能分析工具时，我们会选取一个合适的时机启动分析采样，然后等待一段时间后停止采样。假设采样时间为 20 秒，每秒采样 100 次，那么共采样 2000 次，在这 2000 次中，共有 1800 次执行的是 main 方法，其余 200 次执行的是 run 方法，同时 main 方法又调用了很多其他方法，run 方法也是，这就形成了一个从下往上的调用链，在这些调用链中，又同时会收集到每个方法采样的次数，最终形成一张火焰图。</p>
<p>火焰图是可以互动的，点击某个色块，该色块会被放大并占据所有的宽度，这样可以方便地查看某个函数内部的调用链信息。一般观察火焰图，就是看顶层函数占用的宽度，如果有些函数占用的宽度很大，形成了“平顶”，那么就代表该函数可能存在性能问题。当然，有时候直接观察平顶并不能快速定位问题，因为很多时候顶部的函数都是一些底层的库函数，这时候就应该先观察业务代码在火焰图中的宽度，然后再往上观察顶部的库函数来缩小范围。</p>
<p>IDEA 集成了 <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> 和 Java Flight Recorder（JFR），可以通过它们来生成火焰图。由于 JFR 是商用工具，因此在启动 JVM 的时候需要添加解锁商业 feature 的参数：<code>-XX:+UnlockCommercialFeatures</code>。而 async-profiler 不能在 windows 平台使用，更多信息可以查看 IDEA 官方文档：<a href="https://www.jetbrains.com/help/idea/async-profiler.html">https://www.jetbrains.com/help/idea/async-profiler.html</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://www.brendangregg.com/blog/2014-06-12/java-flame-graphs.html">Java Flame Graphs</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 方法区</title>
    <url>/2018/04/17/Java%20%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<p>JVM 管理的内存可以总体划分为两部分：Heap Memory 和 Native Memory（也叫做 Native Heap），其中 Heap Memory 可以简单看作我们常说的堆内存（也叫 GC Heap），这部分内存直接受到 GC 的管理。Native Memory 也被称为 C-Heap，这部分内存是供 JVM 进程自身使用的。Heap Memory 的大小可以通过 JVM 参数设置，而 Native Memory 的可分配空间依赖于操作系统进程可分配内存的最大值。  </p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/gzM.png" alt="JVM 内存管理"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/VAD.png" alt="JVM 内存划分"></p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>在 Java 虚拟机规范中，Java 的运行时数据区域包括<strong>虚拟机栈、本地方法栈、程序计数器、堆和方法区</strong>，其中堆和方法区是线程共享的内存区域。方法区被用于存储已经被虚拟机加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据，同时运行时常量池也是方法区的一部分，存储类在编译器生成的各种字面量和符号引用。</p>
<p>需要说明的是，Java 方法区只是一个概念，这个概念只在 JVM 规范中定义，并没有提供具体的实现细节，因此不同的虚拟机可能就有不同的实现。比如在 HotSpot 虚拟机中，在 JDK 1.7 及以前的版本中的实现是 <a href="https://plumbr.io/outofmemoryerror/permgen-space">PermGen space（永久代）</a>，而在 JDK 1.8 的实现是 <a href="https://plumbr.io/outofmemoryerror/metaspace">Metaspace（元空间）</a>。其他的虚拟机则不存在永久代的概念。</p>
<h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>在 JDK 1.7 以前的 HotSpot，方法区的实现是永久代。因为在物理上，方法区使用的是由 JVM 开辟的堆内存，在 JVM 启动时可以通过参数 <code>-XX:MaxPermSize</code> 来设置永久代的最大可分配内存空间。永久代的垃圾收集是和老年代（old generation）捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</p>
<p>由于永久代主要存储类的相关信息，所以当动态生成类时会比较容易出现永久代内存溢出的情况。典型的就是 jsp 页面过多时容易出现永久代内存溢出。同时由于 JRockit JVM 没有永久代，Oracle 为了融合 HotSpot 和 JRockit，遂开始逐步移除永久代。</p>
<p>JDK 对于永久代的替换移除工作从 JDK 1.7 就开始了，直到 JDK 1.8 时才完全移除。在 JDK 1.7 中，存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap 了。如符号引用 <code>symbols</code> 转移到了 Native Heap，字面量 <code>interned strings</code> 转移到了 Java Heap，类的静态变量 <code>class statics</code> 转移到了 Java Heap。而到了 JDK 1.8，原本属于方法区的元数据（类数据、方法数据等）也被挪到了 Native Heap 中。至此，方法区里的数据只有 static field 还存在 GC Heap 中。</p>
<h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>元空间也是 JVM 规范中方法区的一种实现，与永久代不同的是，元空间并不在虚拟机中，使用的是本地内存，如果不显式通过虚拟机参数 <code>-XX:MaxMetaspaceSize</code> 限制元空间的大小，则它仅受本地内存大小的限制。</p>
<p><strong>元空间在 GC Heap 之外，所以在 Java 语境中它属于 Native Memory。不过元空间实际上是由一个特殊的 GC 管理的，只是跟管理 Java 对象的 GC 不再共用一个而已。</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.4">The Java® Virtual Machine Specification</a></p>
</blockquote>
<blockquote>
<p><a href="https://blogs.oracle.com/jonthecollector/presenting-the-permanent-generation">Presenting the Permanent Generation</a></p>
</blockquote>
<blockquote>
<p><a href="https://sourcevirtues.com/2013/01/14/java-heap-space-and-native-heap-problems/">Java, Integration and the virtues of source</a></p>
</blockquote>
<blockquote>
<p><a href="http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/35362838/answer/62443668">Java 内存分配的问题?</a></p>
</blockquote>
<blockquote>
<p><a href="http://ifeve.com/java-permgen-removed/">Java PermGen 去哪里了?</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的闭包</title>
    <url>/2018/04/03/Java%20%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>不怎么严谨的说，闭包定义的要点有两个：</p>
<blockquote>
<ol>
<li>一个依赖于外部环境中自由变量的函数</li>
<li>自由变量所在的外部环境必须存在</li>
</ol>
</blockquote>
<span id="more"></span>

<p><a href="http://rednaxelafx.iteye.com/blog/245022">根据 R 大的说法</a>，一个函数如果依赖于外部环境中的自由变量，必须保证函数依赖的自由变量的外部环境存在。这句话是重点，需要仔细理解。</p>
<h1 id="JavaScript-的闭包"><a href="#JavaScript-的闭包" class="headerlink" title="JavaScript 的闭包"></a>JavaScript 的闭包</h1><p>我们先看一下 JavaScript 的闭包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">inner</span> (param) &#123;</span><br><span class="line">        <span class="keyword">return</span> p + param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">outer</span>()(<span class="number">10</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>outer</code> 函数中的变量 p 就是一个自由变量，函数 <code>inner</code> 依赖于这个变量，并且在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使外部函数已经结束（return）了，因为 JavaScript 实现了引用捕获（capture-by-reference）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">start</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = start;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="title class_">Counter</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">increment</span>();</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">get</span>(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>通过上述例子也能看出，闭包一个重要的作用就是将函数的内部变量封装，外部只能使用指定的函数来操作该变量。</p>
<h1 id="Java-的闭包"><a href="#Java-的闭包" class="headerlink" title="Java 的闭包"></a>Java 的闭包</h1><p>其实在 Java 中，到处都存在闭包，只不过通常不会这么说而已。比如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">addWith</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addWith()</code> 方法依赖于外部的自由变量 x ，为了让 <code>addWith()</code> 方法正确工作，它必须依附于 <code>Foo</code> 的一个实例，不然就得不到 x 的值。严格来说，<code>addWith()</code> 方法捕获的不是自由变量 x ，而是 <code>this</code>，变量 x 是通过 <code>this</code> 访问到的。</p>
<p>如果这个外部环境是一个函数，并且内部函数可以作为返回值返回，那么外部环境函数中的局部变量就不能在调用结束时就销毁，<strong>也就是说不能在栈上分配空间（每执行一个方法都会在栈上压入一个新的栈帧，栈帧包含局部变量表，方法执行完毕后，栈帧弹出销毁，所以局部变量也就被销毁了）</strong>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里用 JavaScript 来演示</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AddWith</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，内部函数返回时，外部函数也就结束了，JavaScript 实现了引用捕获，使得内部函数在返回之后，还能够拥有外部函数环境中的自由变量而不会销毁。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>Java 的内部类也是一个闭包结构，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 的内部类包含一个指向外部类的引用，因此才能够做到访问外部环境中的变量。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>Java 的匿名内部类就比较尴尬了。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 <code>add()</code> 依赖于外部环境中的自由变量，此时外部方法 <code>getInner()</code> 构成了对匿名内部类的一个闭包。但是这里别扭的地方是，变量 x 和 y 都必须使用 <code>final</code> 修饰，不允许修改。当然，在 JDK 8 以后，这里已经可以不用 <code>final</code> 修饰了，但是变量 x 和 y 必须是 <code>effectively final</code> 的，即有效只读的，还是不允许修改，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Variable &#x27;y&#x27; is accessed from within inner class,</span></span><br><span class="line">            <span class="comment">// needs to be final or effectively final</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">()</span> &#123;</span><br><span class="line">                y = <span class="number">21</span>; <span class="comment">// 这里编译器报错了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？这是因为 Java 编译器支持了闭包，但是支持的不完整。说它支持了闭包是因为编译器在编译时偷偷的对函数做了处理，把外部环境中的局部变量 x 和 y 拷贝了一份放到了匿名内部类里，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>() &#123;</span><br><span class="line">            <span class="comment">// 编译器相当于拷贝了外部自由变量的一个副本到匿名内部类里</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">copyX</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="type">int</span> <span class="variable">copyY</span> <span class="operator">=</span> y;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 这里使用的实际上是拷贝的变量</span></span><br><span class="line">                <span class="keyword">return</span> x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 R 大的话说，就是：</p>
<blockquote>
<p>Java 编译器实现的只是 capture-by-value，并没有实现 capture-by-reference。</p>
</blockquote>
<p>从语义上看，修改 x 和 y 的值，需要反映到外部环境中的变量上，即外部环境中的变量也要变化，而实际上因为在匿名内部类中使用的其实是自由变量 x 和 y 的副本，即在匿名内部类中修改自由变量的值是无法相应的修改外部环境中自由变量的值的。所以当前的 Java 干脆设置了一个限制，就是外部环境中的变量必须使用 <code>final</code> 修饰（JDK 8 中可以不加，但是变量必须是有效只读的，还是不能修改）。</p>
<blockquote>
<p>这其实与 Java 中局部变量和实例变量的实现有关，我们知道局部变量是保存在栈上的，而实例变量是保存在堆中的，如果闭包中可以直接访问局部变量而不是局部变量的副本的话，那么很可能会出现一个分配该局部变量的线程将变量收回后，另一个使用闭包的线程又去访问该变量。</p>
</blockquote>
<h2 id="其他类似的闭包结构"><a href="#其他类似的闭包结构" class="headerlink" title="其他类似的闭包结构"></a>其他类似的闭包结构</h2><p>外部类成员方法中的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInner</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块中的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">BlockInner</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BlockInner</span> <span class="variable">blockInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockInner</span>();</span><br><span class="line">        num = blockInner.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://rednaxelafx.iteye.com/blog/245022">关于对象与闭包的关系的一个有趣小故事 </a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/27416568/answer/36565794">JVM 的规范中允许编程语言语义中创建闭包 (closure) 吗？</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/28190927/answer/39786939">为什么 Java 闭包不能通过返回值之外的方式向外传递值？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 运行时数据区域</title>
    <url>/2017/08/05/Java%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM 在执行 Java 程序时会将它所管理的内存划分为几个数据区域，《Java 虚拟机规范 (Java SE 7 版)》中规定了以下运行时的数据区域。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004162216/2020/04/16/aNB.png" alt="运行时数据区域"></p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>一块较小的内存空间，可以看作是当前线程执行字节码的行号指示器。在虚拟机的概念模型中，字节码解析器就是通过修改这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>程序计数器是线程私有的，每个线程都有一个独立的程序计数器，方便线程切换后能够恢复到当初的执行位置。</p>
<p>如果线程正在执行的是 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，则值为 <code>Undefined</code>。该区域是 Java 虚拟机规范中唯一没有规定 <code>OutOfMemoryError</code> 情况的区域。</p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame）用来存储局部变量表、操作数栈、动态链接、方法返回地址等信息。每个方法从调用到结束的过程，对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p>
<p>Java 虚拟机规范中对该区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机允许的深度，则抛出 <code>StackOverFlowError</code> 异常；如果虚拟机栈可以动态扩展而在扩展时无法申请到足够的内存，则会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧是虚拟机进行方法调用和执行的数据结构，是虚拟机栈的栈元素。栈帧中需要多大的局部变量表，多深的操作数栈在编译时就已经确定，不会受程序运行时的影响，仅仅取决于具体的虚拟机实现。</p>
<p>一个线程的方法调用链可能很长，对于执行引擎来说，在活动线程中，位于栈顶的栈帧才是有效的，称为<strong>当前栈帧（Current Stack Frame）</strong>，相关联的方法称为<strong>当前方法（Current Method）</strong>。执行引擎执行的字节码指令都只针对当前栈帧操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/WO3.png" alt="栈帧"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，存放<strong>方法参数和方法内定义的局部变量</strong>，大小在编译时就确定并存放在方法的 Code 属性的 max_locals 数据项中。</p>
<p>Java 虚拟机的数据类型有 boolean、byte、char、short、int、float、reference、returnAddress、long、double，它们与 Java 语言中的数据类型有本质区别。其中，long 和 double 需要占用 64 位，reference 类型可能是 32 位或 64 位，其余数据类型占用 32 位或小于 32 位。</p>
<p>局部变量表的基本单位是变量槽（Variable Slot），Java 虚拟机规范没有明确指定一个 Slot 占用的内存空间大小，但是一个 Slot 应该能够存放一个 32 位或小于 32 位的虚拟机数据类型。long 类型和 double 类型的数据虚拟机会通过高位对齐的方式为其分配两个连续的 Slot。因为没有明确指定，所以 Slot 可以随着处理器、OS 或虚拟机的不同而变化，如果使用 64 位虚拟机和 64 位物理内存空间，虚拟机可以通过对齐和补白的方式让 Slot 看起来仍和在 32 位虚拟机中一致。</p>
<p>虚拟机通过索引定位来使用局部变量表，从 0 开始到最大的 Slot，访问 32 位数据类型的变量，索引 n 就代表第 n 个 Slot；访问 64 位数据类型变量，会使用索引 n 和 n+1 两个连续的 Slot。</p>
<p>在执行方法时，虚拟机通过使用局部变量表来完成参数值到参数列表的传递。如果执行实例方法（非 static 的方法），局部变量表的索引 0 的 Slot 默认用于传递方法所属对象的引用，方法中可以使用  <code>this</code> 来访问这个隐含的参数，其余参数按照参数列表的顺序从索引 1 开始。当参数列表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈是一个先进后出栈，最大深度也在编译时确定并保存到方法 Code 属性的 max_stacks 数据项中，每个元素可以是任意 Java 数据类型，32 位数据占用 1 个栈容量，64 位数据占用 2 个栈容量。</p>
<p>当方法开始执行时，这个方法的操作数栈是空的，在执行过程中，各种字节码指令向操作数栈写入（入栈）和提取（出栈）数据。如算术运算、调用其他方法时的参数传递等等都是通过操作数栈来进行的。</p>
<p>在概念模型中，虚拟机栈中的两个栈帧是完全独立的，但是在大多虚拟机实现中都会做一些优化处理，让上下两个栈帧共享一部分数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/16/AWV.png" alt="共享区域"></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法栈与虚拟机栈作用相似，虚拟机栈为执行 Java 方法（也就是字节码）服务，而本地方法栈为虚拟机使用到的 <code>Native</code> 方法服务。虚拟机规范没有对本地方法栈中使用的语言、使用方式和数据结构做强制规定，具体的虚拟机可以自由实现。在 <code>HotSpot</code> 虚拟机中就直接把本地方法栈与虚拟机栈合二为一。本地方法栈也有 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，几乎所有的对象实例在这里分配内存，根据 JSR133，即 Java 内存模型与线程规范的规定，所有的<strong>类实例</strong>和<strong>数组</strong>都存储在堆中。</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.3">The Java® Virtual Machine Specification 原文</a></p>
<blockquote>
<p>The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.</p>
</blockquote>
<p>大意是所有的对象实例以及数组都要在堆上分配内存。但是随着 JIT 编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换优化技术会导致一些微妙的变化，所有对象都在堆上分配内存也不那么绝对了。</p>
<p>Java 堆是垃圾收集器管理的主要区域，堆可以处于物理上不连续的内存空间，只要逻辑上连续即可，当对象在堆中没有完成内存分配，并且堆无法再扩展时，会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区也是各个线程共享的，它被用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、方法数据、方法代码</strong>等数据，当方法区无法满足内存分配需求时，抛出 <code>OutOfMemoryError</code> 异常。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本信息、字段、方法、方法数据、构造函数、接口等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，常量池的信息会在类加载后进入方法区的运行时常量池中存放（注意区分运行时常量池与 Class 文件的常量池信息）。</p>
<p>虚拟机对于 Class 文件的每一部分的格式都有严格的规定，每一个字节用于存储哪些数据都必须符合规范才能被虚拟机装载和执行，但是对于运行时常量池，Java 虚拟机规范没有做出细节要求。</p>
<p>运行时常量池相对于 Class 文件常量池的一个重要特征就是具有动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入。这一特性利用最多的便是 <code>String</code> 类的 <code>intern()</code> 方法。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区域的一部分，也不是 Java 虚拟机规范中定义的内存区域，但是这部分内存被频繁使用，并且也可能导致 <code>OutOfMemoryError</code>。</p>
<p>在 JDK 1.4 加入的 NIO 中，引入了一种基于通道（Channel）与缓冲区的 I&#x2F;O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样就避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>本机直接内存的分配不受 Java 堆大小的限制，但是肯定还是会受到本机总内存（RAM、SWAP 区或者分页文件）大小以及处理器寻址空间的限制。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架</title>
    <url>/2017/08/21/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Map 属不属于集合？在讨论这个问题之前，要先分清什么才是集合。如果说实现了 Collection 接口的叫集合，那么显然 Map 并不属于集合；如果说集合指的是集合框架（或容器），那么 Map 也属于集合。</p>
<span id="more"></span>
<p>《Java 编程思想》的 11 章中，明确表示了集合包含 List、Set、Queue 和 Map ；《Java 核心技术 卷一》中也表示集合有两个基本的接口，Collection 和 Map。集合框架属于 Java 的基础知识，也是日常开发中常用的工具，面试也经常考察，因此作为一个 Java 程序员应该熟练掌握它。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/d2n.png" alt="collection_framework"></p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>底层维护着一个 Object 数组。使用默认的构造函数会初始化一个容量为 0 的数组，在放第一个元素时会扩容成容量为 10 的数组。可指定初始化容量。扩容时会重新开辟一个计算好容量的数组，并使用 <code>System.arraycopy()</code> 复制元素，每次扩容后容量为上次容量的 1.5 倍，容量上限为 <code>Integer.MAX_VALUE - 8</code>（2^31-1-8）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(E e);</span><br></pre></td></tr></table></figure>

<p>在容量足够时速度很快，在容量不足时，数组会扩容，因此在可以预见的元素个数超过默认的 10 个时，最好在初始化时指定一个合适的容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="type">int</span> index,E e);</span><br><span class="line">remove(<span class="type">int</span> index);</span><br><span class="line">remove(E e);</span><br></pre></td></tr></table></figure>

<p>这些方法都需要使用 <code>System.arraycopy()</code> 来移动元素，效率低，并且越是靠前的元素，需要移动的元素越多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get(<span class="type">int</span> index);</span><br><span class="line">set(<span class="type">int</span> index,E e);</span><br></pre></td></tr></table></figure>

<p>使用索引，速度快。</p>
<p><strong>总结：使用 ArrayList 最好能够指定容量，获取和修改元素较快，删除效率较低。</strong></p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>底层维护着一个类似双向链表的结构，元素类型是 LinkedList 的静态内部类 Node ，每个 Node 包含它的前一个 Node、后一个 Node 和它本身的数据。LinkedList 将它的头结点和尾节点作为成员变量，每次添加元素都会开辟一个新的 Node 节点，无容量上限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get(<span class="type">int</span> index);</span><br><span class="line">set(<span class="type">int</span> index,E e);</span><br></pre></td></tr></table></figure>

<p>查找和修改需要遍历，当要查找的索引位置超过链表大小的一半时，反向遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(E e); <span class="comment">// 向尾部插入</span></span><br><span class="line">addFirst(E e);</span><br><span class="line">addLast(E e);</span><br><span class="line">removeFirst();</span><br><span class="line">removeLast();</span><br></pre></td></tr></table></figure>

<p>在 LinkedList 中，添加方法就是向尾部添加元素。上述方法只对链表的头尾两侧操作，不需要移动指针，效率高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="type">int</span> index,E e);</span><br><span class="line">remove(E e);</span><br><span class="line">remove(<span class="type">int</span> index);</span><br></pre></td></tr></table></figure>

<p>上述方法需要遍历查找索引，之后再改变元素前后指针指向，效率相对也较高（与数组不同，不需要改变结构）。</p>
<p><strong>总结：使用 LinkedList 向前后插入元素效率高，其余需要知道索引位置的方法效率相对要低，但是不需要修改结构，是以空间换时间的思路。</strong></p>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet 的源码很少，也非常简单。它的内部维护着一个 HashMap，使用 key 存储数据，value 都是同一个 Object 对象。</p>
<h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p>LinkedHashSet 继承自 HashSet，它的源码更少，也更简单，与 HashSet 唯一区别就是它的内部使用的是 LinkedHashMap 存储数据，可以保证元素的插入顺序与遍历顺序一致。</p>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>TreeMap 内部使用的是红黑树结构，插入的数据可以按照 key 的自然顺序排序，也可以自定义比较器实现自定义排序。其增删改查的平均时间复杂度为 <code>O(logN)</code>。</p>
<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>TreeSet 内部使用的是 TreeMap，因此可以保证插入元素的唯一性，并且插入的元素会进行排序。</p>
]]></content>
      <categories>
        <category>Java 集合框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 之 bind、call 和 apply</title>
    <url>/2020/04/18/JavaScript%20%E4%B9%8B%20bind%E3%80%81call%20%E5%92%8C%20apply/</url>
    <content><![CDATA[<p>在 js 中，bind、call 和 apply 这三个方法的作用很像，但是它们还是有一些区别的。</p>
<span id="more"></span>

<p>让我们先看一段简单的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>, <span class="number">1000</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>直接调用 obj.foo 方法时，输出的结果为 2，因为此时 foo 方法是 obj 调用的，所以 this 指向的是 obj 对象；而通过定时器的方式调用，输出的结果为 1，原因是此时 this 指向的是全局环境（window）。为了让结果符合我们的预期，我们可以将 obj.foo 放在一个匿名函数中，这样 foo 方法的调用上下文就又变成了 obj。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    obj.<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>或者更直接的方式是修改方法调用的上下文，此时可以使用 bind 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">foo</span>.<span class="title function_">bind</span>(obj), <span class="number">1000</span>) <span class="comment">// 结果为 2，bind 方法将方法调用的上下文与 obj 对象绑定</span></span><br></pre></td></tr></table></figure>

<p>其实 call 和 apply 方法也有类似的作用，比如我们可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">foo</span>.<span class="title function_">call</span>(obj) <span class="comment">// 2</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">apply</span>(obj) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>但是它们有什么区别呢？首先调用 bind 方法返回的是一个函数，我们再次调用这个函数才能得到结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种调用方式都可以</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">bind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)() <span class="comment">// 3</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">bind</span>(obj)(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>而 call 与 apply 方法的区别主要在传参。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">foo</span>.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>下面我们简单实现一个相对严谨的 bind 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">oThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fToBind = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>) <span class="comment">// 调用 arguments 数组的 slice 方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// this instanceof fBound 说明返回的 fBound 被当作 new 时的构造函数调用</span></span><br><span class="line">        <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fBound ? <span class="variable language_">this</span> : oThis, </span><br><span class="line">        <span class="comment">// 获取调用 fBound 时的传参</span></span><br><span class="line">        args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 当执行 Function.prototype.bind 方法时，this 为 Function.prototype</span></span><br><span class="line">        <span class="comment">// 因此 this.prototype 即为 Function.prototype.prototype 也就是 undefined</span></span><br><span class="line">        fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使 fBound.prototype 成为 fNOP 的实例，因此返回的 fBound 如果是作为 new 的构造函数，</span></span><br><span class="line">    <span class="comment">// 那么 new 生成的新对象作为 this 传入 fBound，新对象的 __proto__ 就是 fNOP 的实例</span></span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>()</span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 之函数</title>
    <url>/2020/04/18/JavaScript%20%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在 JavaScript 中，函数是第一等公民，它的地位与其他值（数值、布尔值、字符串等）相同。同时函数也是对象，它可以保存在变量、对象和数组中，可以作为参数传递，也可以作为结果返回，同时它还可以拥有自己的方法。</p>
<span id="more"></span>

<h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p>使用 function 关键字可以声明一个函数字面量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用将匿名函数赋值给一个变量的方式声明一个函数，这时这个匿名函数又叫做函数表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h1><p>JavaScript 引擎将函数名视同变量名，所以函数的声明就会像变量声明一样被提升到整个代码的顶部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>() <span class="comment">// 这样使用并不会报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>表面上好像是在声明之前调用了函数 foo，但是实际上由于“变量提升”，函数 foo 已经被提升到了代码顶部，也就是在调用之前已经声明了。但是如果此时采用赋值语句来声明函数就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>

<p>原因是上面的代码等同于下面的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 此时 foo 还没有被赋值，所以为 undefined</span></span><br><span class="line">foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h1><p>我们可以声明一个函数，然后打印它的属性看看。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(foo)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004182309/2020/04/18/9NP.png" alt="函数 foo"></p>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>其中 arguments 并不能显式创建，它只有在函数中才可以使用（箭头函数不能使用），使用它可以接收数目不定的实参。arguments 是一个类数组，它并非数组，但是具有数组一样的访问方式，也具有数组的 length 属性。同时它还有一个 callee 属性，该属性仅在相关的函数正在执行时才可以使用，callee 属性的初始值就是正在执行的函数，这个特性使得我们可以通过它来实现匿名的函数递归。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num + <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>callee 属性的长度是正在执行的函数形参的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">length</span>) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>name 属性存放的是函数的名称，如果通过变量赋值的方式声明函数，那么 name 属性存放的就是变量的名称。具名函数的 name 属性存放的就是函数声明时指定的名称。</p>
<h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>length 属性存放的是函数在调用时预期会传入的参数个数（必须传入的参数个数）。这里预期传入的参数不包括默认值和 rest 参数（<code>...变量名</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">length</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">length</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="literal">undefined</span></span>) &#123;&#125; <span class="comment">// 有默认值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">length</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="number">1</span>, ...z</span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p>caller 代表的是调用函数的对象，即函数执行的环境。如果执行函数的是全局环境（window），则 caller 为 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">caller</span>) <span class="comment">// null</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">caller</span>) <span class="comment">// null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">caller</span> === foo) <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h2 id="prototype"><a href="#prototype" class="headerlink" title="[[prototype]]"></a>[[prototype]]</h2><p>在 JavaScript 中，每个对象都有一个 [[prototype]] 属性，在标准中，这是一个隐藏属性。[[prototype]] 也叫做隐式原型，<strong>它指向的是这个对象的原型，具体来说就是指向创建这个对象的函数的显式原型</strong>。在 ES5 之前没有标准的方法来访问这个内置属性，但是大多数浏览器都支持通过 <code>__proto__</code> 属性来访问一个对象的隐式原型，在 ES5 中才有了获取这个内置属性的方法：Object.getPrototypeOf()。一个对象的隐式原型是由构造该对象的方法决定的，目前有三种常见的构造对象的方法。</p>
<blockquote>
<p>需要注意的是，Object.prototype 比较特殊，它的隐式原型为 null。可以认为 Object 是所有对象的顶层，所有的内建对象（Array、String、Number 等）都是由 Object 创建而来。</p>
</blockquote>
<p>通过对象字面量的方式构造一个对象，它的隐式原型指向 Object.prototype。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(foo) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>通过构造函数构造出来的对象，它的隐式原型指向其构造函数的 prototype 属性指向的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>通过 Object.create 方法构造出来的对象，它的隐式原型指向调用 create 方法时指定的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;saber&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">233</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(person)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>本质上这三种构造对象的方式可以看作是一种，也就是通过构造函数的方式创建对象。对象字面量可以认为是为了方便开发人员创建对象的语法糖，本质上还是通过以下代码来创建对象的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">foo.<span class="property">name</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">foo.<span class="property">age</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>而 Object.create 方法是 ES5 才提供的方法。在 2006 年，也就是 ES5 之前，道格拉斯写了一篇题为 <a href="http://crockford.com/javascript/prototypal.html">Prototypal Inheritance In JavaScript</a> 的文章。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不用因此创建自定义类型。他给出了如下函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是分析原理的伪代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">    f.<span class="property">__proto__</span> === F.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 因为 F.prototype === o</span></span><br><span class="line">    f.<span class="property">__proto__</span> === o <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法在 ES5 之前被普遍用于实现对象的继承。</p>
<h2 id="prototype-1"><a href="#prototype-1" class="headerlink" title="prototype"></a>prototype</h2><p>prototype 也叫做显式原型，该属性指向函数的原型对象。不是所有的对象都有 prototype 属性，只有函数才有 prototype 属性。隐式原型和显式原型的关系是：对象的隐式原型指向创建这个对象的函数的显式原型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004191648/2020/04/19/Yly.png" alt="隐式原型和显式原型"></p>
<p>显式原型主要用来实现基于原型的继承和属性的共享，隐式原型则主要用来构成原型链，而原型链同样用于实现基于原型的继承，比如当我们在访问一个对象的属性时，如果在这个对象中找不到，那么就会继续沿着隐式原型继续向上查找，直到隐式原型为空为止。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是指变量存在的范围。在 ES5 中，变量只有两种作用域，一种是全局作用域，变量在“整个程序”中都存在，另一种是函数作用域，变量只在函数内部存在。对于顶层函数来说，函数外部声明的变量就是全局变量，它可以在函数内部读取。在函数内部定义的变量外部无法读取，称为局部变量。</p>
<p>与全局作用域一样，函数作用域内部也存在变量提升。使用 var 声明的变量，不管在什么位置，变量的声明都会被提升到函数体的头部。同时由于函数本身也是值，所以它也有自己的作用域，它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span></span><br><span class="line">    <span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span></span><br><span class="line"><span class="title function_">foo</span>()() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行上下文也叫调用上下文、执行栈、调用栈等。执行上下文是代码被解析和执行时所在环境的抽象。在 js 中有三种执行上下文：全局执行上下文、函数执行上下文和 eval 执行上下文。</p>
<p>全局执行上下文是代码首次执行时默认的环境，不在任何函数中的代码都会在全局执行上下文中执行。全局上下文的创建做了两件事：首先创建一个变量对象（Variable Object，VO），在浏览器中这个变量对象就是 window 对象。然后将 this 指针指向这个全局对象。每次调用函数时，js 解释器都会为该函数创建一个对应的执行上下文，这个执行上下文就是函数执行上下文。在运行 eval 函数时，函数中的文本代码也会有自己的执行上下文，这个上下文就是 eval 执行上下文。</p>
<p>当浏览器第一次加载代码时，首先会进入到一个全局执行上下文中，如果在全局代码中调用了一个函数，那么程序就会进入到这个被调用的函数中，并创建一个新的执行上下文，并将这个函数执行上下文推到执行栈的顶部。如果在当前函数中再次调用了另一个函数，那么在程序执行到此处时同样会为之创建一个新的执行上下文并再次推入执行栈顶。一旦该函数执行完毕，该函数执行上下文就会从执行栈顶部弹出，以此类推，直到程序执行再次回到全局执行上下文，继续执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inside first function&#x27;</span>)</span><br><span class="line">    <span class="title function_">second</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;again inside first function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inside second function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">first</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inside global execution context&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004201409/2020/04/20/MDE.jpg" alt="执行上下文"></p>
<p>在 js 解释器内部，每次调用执行上下文都会经过两个阶段：创建阶段和执行阶段。</p>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>创建阶段是在函数被调用，但还未执行任何代码之前。在创建阶段主要做三个工作，确定 this 的值、创建词法环境组件（Lexical Environment）和创建变量环境组件（Variable Environment）。其中词法环境和变量环境是 ES5 才有的，在 ES5 之前，创建阶段的工作是确定 this 的值、创建作用域链（Scope Chain）和创建变量对象（Variable Object）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutionContext = &#123;  </span><br><span class="line">  ThisBinding = &lt;this value&gt;,  </span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,  </span><br><span class="line">  VariableEnvironment = &#123; ... &#125;,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="确定-this-的值"><a href="#确定-this-的值" class="headerlink" title="确定 this 的值"></a>确定 this 的值</h3><p>在全局执行上下文中，this 指向全局对象，在浏览器中，这个值就是 window。而在函数执行上下文中，this 的值取决于函数的调用方式。如果它被一个对象引用调用，那么 this 的值就是该对象，否则 this 的值会被设置为全局对象或 undefined（严格模式）。这是语言设计上的一个错误，因为如果设计正确，当嵌套的函数被调用时，this 应该绑定到外部函数的 this 变量上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;the window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;the object&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">// the object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>()()) <span class="comment">// the window</span></span><br></pre></td></tr></table></figure>

<h3 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h3><p>在 <a href="http://ecma-international.org/ecma-262/6.0/">ES6 官方文档</a>中，对于词法环境是这样描述的：</p>
<blockquote>
<p>词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符与特定变量和函数的关联关系。词法环境由环境记录（environment record）和可能为空引用（null）的外部词法环境组成。</p>
</blockquote>
<p>简单来说，词法环境是一个包含标识符和变量之间映射的结构，这里的标识符指的是变量或者函数的名称，而变量是指对实际对象（包括函数对象）或原始值的引用。词法环境有两个组成部分，环境记录和对外部环境的引用。环境记录中存储变量和函数声明的实际位置，对外部环境的引用意味着它可以访问外部的词法环境（可以简单理解为作用域链）。</p>
<p>与全局执行上下文和函数执行上下文对应，词法环境也有全局词法环境和函数词法环境之分。全局词法环境中，对外部环境的引用为 null，因为它本身就是最外层的环境，除此之外它还拥有一个全局对象及其关联的属性和方法（比如 Array 方法），以及任何用户自定义的全局变量。函数词法环境中，用户在函数中定义的变量被存储在环境记录中，对外部环境的引用可能是全局环境，也可能是包含内部函数的外部函数的环境。对于函数词法环境而言，环境记录还包含了一个 arguments 对象。</p>
<p>环境记录也有两种类型，声明性环境记录和对象环境记录。其中函数词法环境中的环境记录是声明性环境记录，它存储变量、函数和参数。在全局词法环境中的环境记录是对象环境记录，它存储全局执行上下文中出现的变量和函数。词法环境在伪代码中看起来就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局环境</span><br><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">    // 全局词法环境</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        // 环境记录</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;, // 类型为对象环境记录</span><br><span class="line">            // 标识符绑定在这里 </span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt; null &gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 函数环境</span><br><span class="line">FunctionExecutionContext = &#123;</span><br><span class="line">    // 函数词法环境</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        // 环境纪录</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;, // 类型为声明性环境记录</span><br><span class="line">            // 标识符绑定在这里 </span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt; Global or outerfunction environment reference &gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h3><p>变量环境也是一个词法环境，它具有词法环境的所有属性，包括环境记录和对外部环境的引用。在 ES6 中，变量环境和词法环境的唯一区别就是：词法环境用于存储函数声明和变量（let 和 const）绑定，而变量环境仅用于存储变量（var）绑定。举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span></span><br><span class="line"><span class="keyword">var</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">e, f</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> g = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span> e * f * g</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="title function_">multiply</span>(<span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局执行上下文</span><br><span class="line">GlobalExecutionContext = &#123;</span><br><span class="line">    // this 绑定为全局对象</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;,</span><br><span class="line">    // 词法环境</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        //环境记录</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,  // 对象环境记录</span><br><span class="line">            // 标识符绑定在这里</span><br><span class="line">            // let const 创建的变量 a b</span><br><span class="line">            a: &lt; uninitialized &gt;,</span><br><span class="line">            b: &lt; uninitialized &gt;,</span><br><span class="line">            multiply: &lt; func &gt;</span><br><span class="line">        &#125;</span><br><span class="line">        // 全局环境外部环境引入为 null</span><br><span class="line">        outer: &lt;null&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 变量环境</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Object&quot;,  // 对象环境记录</span><br><span class="line">            // 标识符绑定在这里</span><br><span class="line">            // var 创建的 c</span><br><span class="line">            c: undefined,</span><br><span class="line">        &#125;</span><br><span class="line">        // 全局环境外部环境引入为 null</span><br><span class="line">        outer: &lt;null&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数执行上下文</span><br><span class="line">FunctionExecutionContext = &#123;</span><br><span class="line">    // 由于函数是默认调用 this 绑定同样是全局对象</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;,</span><br><span class="line">    // 词法环境</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,  // 声明性环境记录</span><br><span class="line">            // 标识符绑定在这里</span><br><span class="line">            // arguments 对象</span><br><span class="line">            Arguments: &#123; 0: 20, 1: 30, length: 2 &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        // 外部环境引入记录为 &lt;/Global&gt;</span><br><span class="line">        outer: &lt;GlobalEnvironment&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 变量环境</span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: &quot;Declarative&quot;,  // 声明性环境记录</span><br><span class="line">            // 标识符绑定在这里</span><br><span class="line">            // var 创建的 g</span><br><span class="line">            g: undefined</span><br><span class="line">        &#125;,</span><br><span class="line">        // 外部环境引入记录为 &lt;/Global&gt;</span><br><span class="line">        outer: &lt;GlobalEnvironment&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><p>在执行阶段，js 引擎会完成对所有变量的分配，最后执行代码。如果在声明的实际位置找不到 let 变量的值，那么会分配 undefined 值给它。</p>
<h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>变量对象和活动对象是 ES3 提出的老概念，其实变量对象和活动对象都是变量对象，在全局执行上下文中的变量对象允许直接使用，而在函数执行上下文中的变量对象是不能直接访问的，此时由激活对象（Activation Object）扮演 VO 的角色，我们可以在函数执行上下文中直接使用 AO。这似乎与全局词法记录和函数词法记录相对应。</p>
<p>使用词法环境和变量环境可以比较清楚地解释为什么 var 存在变量提升，而 let 和 const 却不会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2333</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y) <span class="comment">// ReferenceError: Cannot access &#x27;y&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">233</span></span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>我们知道，js 有两种作用域，全局作用域和函数作用域。在函数内部可以直接使用全局作用域中的变量，而在全局作用域中则不能使用函数作用域中的变量，有一个变通的方式可以将这种不可能变为可能，那就是闭包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2333</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>()())</span><br></pre></td></tr></table></figure>

<p>上面的例子中，函数 bar 就是一个闭包。由于在 js 中，只有函数内部的子函数才可以读取函数内部的变量，因此可以将 js 中的闭包理解为“定义在一个函数内部的函数”。闭包最大的特点就是它能够记住诞生的环境，比如函数 bar 记住了它诞生的环境 foo，所以可以通过 bar 得到 foo 内部的变量。</p>
<p>闭包的用途主要有两个，其中一个是用于读取函数内部的变量，这个特性可以方便我们实现封装（封装私有属性，对外提供公有方法，从而保护函数内部的属性）。另一个就是可以让一些变量始终保持在内存中，即闭包可以使得它的诞生环境一直存在，因为这个原因，滥用闭包是很危险的。</p>
<h1 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h1><p>立即执行函数（Immediately-Invoked Function Expression，IIFE）能让函数在声明完成后立即执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/34183746">js 中 <code>__proto__</code> 和 prototype 的区别和关系？</a></p>
</blockquote>
<blockquote>
<p><a href="https://wangdoc.com/javascript/types/function.html">JavaScript 教程</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/48590085">【译】理解 Javascript 执行上下文和执行栈</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 分区</title>
    <url>/2022/04/26/Kafka%20%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<p>主要讨论 Kafka 分区与生产者和消费者之间的分配关系。</p>
<span id="more"></span>

<h1 id="分区与生产者"><a href="#分区与生产者" class="headerlink" title="分区与生产者"></a>分区与生产者</h1><p>生产者在往主题发送消息时，首先需要确定这条消息最终要发送到哪个分区上，为此 Kafka 提供了多种选择分区的策略。在 Kafka 2.4 以前，默认的策略是：如果指定了分区，则消息投递到指定分区。如果未指定分区，但是指定了 key，那么通过 <code>hash(key)</code> 来计算分区。如果分区和 key 都没有指定，则轮询选择分区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ref: org/apache/kafka/clients/producer/KafkaProducer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="type">byte</span>[] serializedKey, <span class="type">byte</span>[] serializedValue, Cluster cluster)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">partition</span> <span class="operator">=</span> record.partition();</span><br><span class="line">    <span class="comment">// 如果指定了分区，则直接使用该分区；否则通过分区策略去选择</span></span><br><span class="line">    <span class="keyword">return</span> partition != <span class="literal">null</span> ?</span><br><span class="line">            partition :</span><br><span class="line">            partitioner.partition(</span><br><span class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ref: org/apache/kafka/clients/producer/internals/DefaultPartitioner.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过元数据获取 topic 下的所有分区</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPartitions</span> <span class="operator">=</span> partitions.size();</span><br><span class="line">    <span class="comment">// 如果 key 为空</span></span><br><span class="line">    <span class="keyword">if</span> (keyBytes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取主题中递增的一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextValue</span> <span class="operator">=</span> nextValue(topic);</span><br><span class="line">        <span class="comment">// 获取所有的可用分区（可用分区是指该分区存在首领副本）</span></span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将递增的值进行取模运算，即轮询算法</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">part</span> <span class="operator">=</span> Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法可以理解为在消息记录中没有指定 key 的情况下，通过生成一个数来代替 key hash</span></span><br><span class="line"><span class="comment">// 即为主题生成一个随机数，之后就在这个随机数的基础上递增</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">nextValue</span><span class="params">(String topic)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存获取主题的起始随机数</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> topicCounterMap.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == counter) &#123;</span><br><span class="line">        <span class="comment">// 创建随机数</span></span><br><span class="line">        counter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ThreadLocalRandom.current().nextInt());</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">currentCounter</span> <span class="operator">=</span> topicCounterMap.putIfAbsent(topic, counter);</span><br><span class="line">        <span class="keyword">if</span> (currentCounter != <span class="literal">null</span>) &#123;</span><br><span class="line">            counter = currentCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Kafka 2.4 中，默认的分区器中实现了粘性分区（Sticky Partition），这个就不展开了，具体可以看<a href="https://www.cnblogs.com/huxi2b/p/12540092.html">这篇译文</a>。</p>
<h1 id="分区与消费者"><a href="#分区与消费者" class="headerlink" title="分区与消费者"></a>分区与消费者</h1><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202204271740/2022/04/26/lD9.png" alt="分区与消费者" style="width: 80%" />

<p>在 Kafka 中，一个主题（topic）下可以有一个或多个分区（partition），消费者以分组的形式订阅主题，分组内可以有一个或多个消费者。同一时刻，一条消息只能被同一组内的某个消费者消费。这就意味着，在一个主题下，如果分区数大于消费者的个数，那么必定有消费者同时消费 2 个或以上的分区；如果分区数等于消费者的个数，那么正好一个消费者对应一个分区；如果分区数小于消费者的个数，那么必定有消费者处于空闲状态。</p>
<p>当消费者组成员变更时，包括成员加入或离开（比如 shutdown 或 crash），消费者组订阅的主题数变更时（主要发生在基于正则表达式订阅主题，当有新匹配的主题创建时）以及消费者组订阅的主题分区数变更时，Kafka 都将进行一次分区分配的过程，这个过程也叫做再平衡（rebalance）。再平衡过程中，如何分配分区则需要根据消费者的分区分配策略来实现，它可以通过 <code>partition.assignment.strategy</code> 属性来配置，Kafka 默认提供了三种策略：range、roundrobin 和 sticky。</p>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range 策略基于每个主题，按照序号排列可用分区，以字典顺序排列消费者，将分区数除以消费者数，得到每个消费者的分区数。如果没有平均划分，那么最初的几个消费者将有一个额外的分区。</p>
<p>假设有两个消费者 c0 和 c1，两个主题 t0 和 t1，每个主题有三个分区，即 t0p0，t0p1，t0p2，t1p0，t1p1，t1p2。那么使用 range 分配策略得到的结果就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c0 [t0p0，t0p1，t1p0，t1p1]</span><br><span class="line">c1 [t0p2，t1p2]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; <span class="title function_">assign</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span><br><span class="line"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> &#123;</span><br><span class="line">    <span class="comment">// 主题与消费者集合的映射</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; consumersPerTopic = consumersPerTopic(subscriptions);</span><br><span class="line">    <span class="comment">// key 为消费者 ID，value 为分配给该消费者的 TopicPartition</span></span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; topicEntry : consumersPerTopic.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> topicEntry.getKey();</span><br><span class="line">        List&lt;String&gt; consumersForTopic = topicEntry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该 topic 的 partition 个数</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">numPartitionsForTopic</span> <span class="operator">=</span> partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 对消费者按照字典顺序排序</span></span><br><span class="line">        Collections.sort(consumersForTopic);</span><br><span class="line">        <span class="comment">// 计算每个消费者分到的分区数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numPartitionsPerConsumer</span> <span class="operator">=</span> numPartitionsForTopic / consumersForTopic.size();</span><br><span class="line">        <span class="comment">// 取余，计算剩余分区数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">consumersWithExtraPartition</span> <span class="operator">=</span> numPartitionsForTopic % consumersForTopic.size();</span><br><span class="line"></span><br><span class="line">        List&lt;TopicPartition&gt; partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = consumersForTopic.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 剩余分区分配给前面的几个消费者</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition);</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> numPartitionsPerConsumer + (i + <span class="number">1</span> &gt; consumersWithExtraPartition ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            assignment.get(consumersForTopic.get(i)).addAll(partitions.subList(start, start + length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="round-robin"><a href="#round-robin" class="headerlink" title="round robin"></a>round robin</h2><p>轮询策略基于所有可用消费者和所有可用分区，与 range 策略最大的不同是它不再局限于某个主题。如果所有的消费者的订阅都是相同的，那么就可以均衡分配。</p>
<p>假设有两个消费者 c0 和 c1，两个主题 t0 和 t1，每个主题有三个分区，即 t0p0，t0p1，t0p2，t1p0，t1p1，t1p2。那么最终的分配结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c0 [t0p0，t0p2，t1p1]</span><br><span class="line">c1 [t0p1，t1p0，p1p2]</span><br></pre></td></tr></table></figure>

<p>事实上，同组也可以订阅不同的主题。如果组中的每个消费者订阅的主题都不相同，分配的过程仍然使用轮询的方式，若消费者没有订阅主题，那么就要跳过该实例，这有可能会导致分配不平衡。也就是说，消费者组是一个逻辑概念，同组意味着同一时刻分区只能被一个消费者实例消费，换句话说，同组意味着一个分区只能分配给组中的一个消费者。</p>
<p>假设有三个消费者 c0、c1、c2 和三个主题 t0、t1、t2，三个主题分别具有 1、2、3 个分区，因此分区为：t0p0、t1p0、t1p1、t2p0、t2p1、t2p2。如果 c0 订阅 t0，c1 订阅 t0、t1，c2 订阅 t0、t1、t2，那么最终分配的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c0 [t0p0]</span><br><span class="line">c1 [t1p0]</span><br><span class="line">c2 [t1p1，t2p0，t2p1，t2p2]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; <span class="title function_">assign</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span><br><span class="line"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> &#123;</span><br><span class="line">    <span class="comment">// subscriptions 是组成员与它订阅的主题的映射</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    CircularIterator&lt;String&gt; assigner = <span class="keyword">new</span> <span class="title class_">CircularIterator</span>&lt;&gt;(Utils.sorted(subscriptions.keySet()));</span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> partition.topic();</span><br><span class="line">        <span class="comment">// 如果该消费者没有订阅该 topic，则跳过</span></span><br><span class="line">        <span class="keyword">while</span> (!subscriptions.get(assigner.peek()).topics().contains(topic))</span><br><span class="line">            assigner.next();</span><br><span class="line">        <span class="comment">// 找到订阅该 TopicPartition 的消费者</span></span><br><span class="line">        assignment.get(assigner.next()).add(partition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;TopicPartition&gt; <span class="title function_">allPartitionsSorted</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span><br><span class="line"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> &#123;</span><br><span class="line">    SortedSet&lt;String&gt; topics = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 所有 topic 排序</span></span><br><span class="line">    <span class="keyword">for</span> (Subscription subscription : subscriptions.values())</span><br><span class="line">        topics.addAll(subscription.topics());</span><br><span class="line"></span><br><span class="line">    List&lt;TopicPartition&gt; allPartitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">numPartitionsForTopic</span> <span class="operator">=</span> partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic != <span class="literal">null</span>)</span><br><span class="line">            allPartitions.addAll(AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allPartitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>前两种分配策略，如果遇到 rebalance 的情况，分区的调整可能会比较大，而粘性分区策略则可以保证在尽量均衡的前提下减少分配结果的变动。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的原型与继承</title>
    <url>/2017/09/14/JavaScript%20%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>在 JavaScript 中，除了字符串、数字、true、false、null 和 undefined ，其他都是对象。<br>		<br>每个对象都有一个原型指针（隐式原型），指向该对象所继承的原型对象。该对象仅供 js 引擎内部使用，一般我们无法直接使用它，也最好不要使用它。但是在一些浏览器中，可以使用对象实例的 <code>__proto__</code> 属性，可以认为它就是那个原型指针。</p>
<span id="more"></span>

<p>每个函数都有一个 prototype（显式原型）属性和一个原型指针（连接到原型对象 Function.prototype）。</p>
<h1 id="函数创建过程"><a href="#函数创建过程" class="headerlink" title="函数创建过程"></a>函数创建过程</h1><p>首先写一个函数字面量：
		</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>函数 fn 除了 name 等属性外，还包含一个 prototype 属性和一个原型指针。其中 prototype 属性是一个对象，包含一个 constructor（指向函数 fn 本身）和一个指向 Object.prototype 的原型指针。函数 fn 的原型指针指向 Function.prototype。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === fn); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004172100/2020/04/17/5de.png" alt="函数的结构"></p>
<p>用更直观的图来表示就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/mK.png" alt="函数的结构_图"></p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>按照 ECMA 的定义：</p>
<blockquote>
<p><em>Constructor is a function that creates and initializes the newly created object.</em></p>
</blockquote>
<p>构造函数是一个创建并初始化一个新对象的函数。结论是：任何一个函数都可以是一个构造函数。</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>函数在创建的时候会自动添加一个 prototype 属性，这个属性就是函数的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">b</span> = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Fn</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接给函数对象添加属性</span></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property">x</span> = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给构造函数添加属性</span></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>.<span class="property">wtf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;wtf&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给函数对象的原型对象添加属性</span></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;say&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，反映在图中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/v8.png" alt="prototype_图"><br>		<br>那么原型有什么用呢？在这之前，先了解一下 new 运算符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">b</span> = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>(<span class="string">&#x27;is a&#x27;</span>, <span class="string">&#x27;is b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004172100/2020/04/17/xPb.png" alt="new 结构"></p>
<p>通过使用 new 运算符和构造函数调用，能够创建一个新对象，需要注意的是<strong>这个对象与函数对象不同，它没有 prototype 属性</strong>。那为什么不直接使用对象字面量的方式（var obj &#x3D; {}）创建对象呢？通过上图能够发现，使用对象字面量创建的对象继承自 Object.prototype，而使用 new 和构造函数调用创建的对象继承自 Fn.prototype。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">b</span> = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>(<span class="string">&#x27;is a&#x27;</span>, <span class="string">&#x27;is b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> === fn.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其实这个 new 操作，大体上可以分为三步：第一步是新建一个对象并赋值给 fn，即 <code>var fn = &#123;&#125;</code>。第二步是改变对象的原型指针，将它指向函数 Fn 的原型，即 <code>fn.[[Prototype]] = Fn.prototype</code>。第三步是调用函数 Fn，同时把 this 指向对象 fn，对对象进行初始化，即 <code>Fn.apply(fn, arguments)</code>。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>真正体现原型作用的是原型链。</p>
<p>JavaScript 中所有的对象都有一个 [[Prototype]] 属性，保存着对象所继承的原型，由 JS 编译器在对象创建时自动添加。</p>
<p>对象在查找某个属性时，会首先遍历自身的属性，如果没有则会继续查找 [[Prototype]] 所引用的对象的属性，如果没有则继续查找 [[Prototype]].[[Prototype]] ，以此类推，直到 [[Prototype]]…[[Prototype]] 为 undefined （Object 的 [[Prototype]] 就是 undefined）。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>有了原型链，就可以进行继承了。</p>
<p>首先我们写一个函数字面量，则这个函数对象的原型指向 Object.prototype ，如何让这个函数对象的原型指向另一个函数对象的原型呢？方式一就是使用 <code>__proto__</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = B.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(A.<span class="property"><span class="keyword">prototype</span></span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(A.<span class="property"><span class="keyword">prototype</span></span>) === B.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>__proto__ </code> 不是 ECMA 的标准方法，只在某些浏览器中能够使用，如何使用标准的方法呢？方式二就是使用 new 和构造函数调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> B</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(A.<span class="property"><span class="keyword">prototype</span></span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(A.<span class="property"><span class="keyword">prototype</span></span>) === B.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这里隐含着将 A.prototype.[[Prototype]] &#x3D; B.prototype。但是这样做会产生一个问题，就是 A.prototype.constructor 为 undefined。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004172100/2020/04/17/EJg.png" alt="方式二结构1"></p>
<p>此时需要再将 A.prototype.constructor 重新赋值回去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> B</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = A</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(A.<span class="property"><span class="keyword">prototype</span></span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(A.<span class="property"><span class="keyword">prototype</span></span>) === B.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004172100/2020/04/17/kNd.png" alt="方式二结构2"></p>
<h1 id="重写原型"><a href="#重写原型" class="headerlink" title="重写原型"></a>重写原型</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;saber&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">sayName</span>()) <span class="comment">// saber</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)) <span class="comment">// [&#x27;sayName&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;nekolr&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">sayAge</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">// 隐含 p1.[[Prototype]] == Person.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">sayAge</span>()) <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">sayName</span>()) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)) <span class="comment">// [&#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;sayAge&#x27;, &#x27;sayName&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>为什么是 undefined 呢？因为 p1 &#x3D; new Person() 时，执行 Person 函数，并将 this 绑定给 p1，即 Person.apply(p1, arguments)。因为 arguments 中没有值，导致 p1.name 为 undefined，所以就返回 undefined，没有再从原型链中查找。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每个对象都有一个原型指针（<code>__proto__</code>），指向该对象所继承的原型对象。每个函数都有一个原型指针（<code>__proto__</code>）和一个 prototype 属性。使用函数和 new 来创建新对象（<code>var fn = new Fn()</code>），隐含了三步操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="keyword">var</span> fn = &#123;&#125;</span><br><span class="line"><span class="comment">// step 2</span></span><br><span class="line">fn.[[<span class="title class_">Prototype</span>]] = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// step 3</span></span><br><span class="line"><span class="title class_">Fn</span>.<span class="title function_">apply</span>(fn, <span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://blog.jobbole.com/19795/">JavaScript 原型和继承</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000005824449">JavaScript 原型中的哲学思想</a>  </p>
</blockquote>
<blockquote>
<p>《JavaScript 权威指南》</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>List 删除元素</title>
    <url>/2017/08/09/List%20%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>List 如何删除指定的元素？这个问题，不管在工作中还是面试时都经常遇到，算是比较基础的问题，但是往往基础才能考察人，如果想要比较全面的回答，还是需要仔细阅读源码的。</p>
<span id="more"></span>

<p>你首先想到的可能是并发修改异常（<code>ConcurrentModificationException</code>）这个问题，但是我们先把它放在一边，先看一道普通的笔试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;g&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如上代码，请问如何删除所有值为“java”的元素？某位同学心说这还不简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;java&quot;</span>.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有毛病吗？乍一看没毛病啊，逻辑都对啊，但是！你跑一遍试试！是不是有毛病？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">java</span><br><span class="line">f</span><br><span class="line">g</span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？我们来看看 <code>remove</code> 方法的源码（JDK 8）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个很重要的方法 <code>System.arraycopy</code>，查看方法声明：</p>
<p><code>public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</code></p>
<p>很遗憾，它是一个本地方法，但是我们可以通过多种渠道了解到这是一个数组复制的方法，作用是将一个数组复制到另一个数组中。<code>src</code> 是源数组，<code>srcPos</code> 是要复制的起始位置，<code>dest</code> 是目标数组，<code>destPos</code> 是复制到目标数组的起始位置，<code>length</code> 是复制的数组长度。</p>
<p>回到源码，看看 <code>remove</code> 方法是怎么复制的：<code>System.arraycopy(elementData, index+1, elementData, index, numMoved)</code>，很容易理解吧？它将要删除的元素后面所有的元素都往前移动了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/06J.png" alt="移动图示"></p>
<p>注意，关键来了！遇到第一个值为“java”的元素时，索引为 <strong>3</strong>，此时删除索引为 <strong>3</strong> 的元素，所有的后续元素前移，以前索引为 <strong>4</strong> 的元素跑到了 <strong>3</strong> 的位置，但是当前遍历的位置就是 <strong>3</strong> ，继续执行的结果可想而知。</p>
<p>那么正确的代码该怎么写呢？你可能首先想到用迭代器。对，用迭代器迭代元素，同时用迭代器来删除元素可行。但是根据数组复制的这个原理，我们还有一种做法：<strong>倒序删除</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;java&quot;</span>.equals(list.get(i))) &#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔试题看完了，来看看并发修改异常。单线程的好处理，那多线程下的如何处理？</p>
]]></content>
      <categories>
        <category>Java 集合框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 概述</title>
    <url>/2020/06/03/MyBatis%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>好久不用 MyBatis，都快忘了怎么使用了，重新看一遍文档并简单记录下来，方便下次查阅。</p>
<span id="more"></span>

<h1 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202006032025/2020/06/03/Bxg.png" alt="工作原理图"></p>
<h1 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h1><p><code>SqlSessionFactory</code> 是创建 SqlSession 的工厂类。SqlSessionFactory 对象的实例可以通过 SqlSessionFactoryBuilder 获得，具体来说就是通过 XML 配置文件或一个预先定制的 <code>org.apache.ibatis.session.Configuration</code> 实例构建出 SqlSessionFactory 的实例。SqlSessionFactory 是线程安全的，它一旦被创建，应该在应用执行期间都存在，同时需要注意不要重复创建，建议使用单例模式。</p>
<p><code>SqlSession</code> 类似于 JDBC 中的 Connection，应用程序通过它与持久层进行交互。SqlSession 的底层封装了 JDBC 连接，可以用 SqlSession 实例来直接执行被映射的 SQL 语句。需要注意的是，SqlSession 不是线程安全的，因此每个线程都应该有它自己的 SqlSession 实例，要尽量避免 SqlSession 的实例被共享。</p>
<h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>首先读取配置文件（包括全局配置文件和映射文件），通过配置构造出 SqlSessionFactory，即会话工厂。接着通过 SqlSessionFactory 创建 SqlSession（即会话）。最后通过 SqlSession 来执行映射的 SQL 语句。SqlSession 本身是不能直接操作数据库的，它是通过底层的 Executor 执行器接口来操作数据库的。SqlSession 将要处理的 SQL 信息封装到一个底层对象 MappedStatement 中，该对象主要包括：SQL语句、输入参数映射信息、输出结果集映射信息等，然后再将封装的 MappedStatement 对象传入 Executor 中去执行相关操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(input);</span><br><span class="line">        <span class="comment">// 创建 SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 xml 映射文件中获取数据库操作语句</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;com.github.nekolr.mapper.UserMapper.selectOne&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Mapper 接口的代理对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> userMapper.selectOne(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用完关闭</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 接口的实现大致有两种，其中一种是普通的执行器，另外一种是缓存执行器（CachingExecutor）。CachingExecutor 有一个重要的属性就是 delegate，它保存的是某类普通的 Executor。在执行 update 操作时，它直接调用 delegate 的 update 方法，而在执行 query 方法时会先尝试从 cache 中取值，取不到再调用 delegate 的查询方法，并将查询结果存入 cache 中。</p>
<p>普通的 Executor 大致有三个：SimpleExecutor、ReuseExecutor 和 BatchExecutor。它们都继承自 BaseExecutor。SimpleExecutor 是一种常规执行器，每次执行都会创建一个 Statement，用完后关闭。ReuseExecutor 是可重用执行器，它会将 Statement 存入 map 中，这样就可以重用已经创建过的 Statement。BatchExecutor 是批处理执行器，doUpdate 预处理存储过程或批处理操作，doQuery 提交并执行过程。</p>
<h1 id="接口绑定"><a href="#接口绑定" class="headerlink" title="接口绑定"></a>接口绑定</h1><p>我们定义的接口需要与 SQL 语句进行绑定之后才能使用。接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上添加 @Select、@Update 等注解，注解中包含 SQL 语句来进行绑定；另外一种就是通过 XML 里面编写 SQL 来进行绑定，在这种情况下，要指定 XML 映射文件里的 namespace 必须为接口的全限定类名。</p>
<h1 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h1><p>MyBatis 的映射器大致包括 XML 映射，XML + 接口映射，注解 + 接口映射这三类。其中 XML 映射是最早提供和支持的，这种只需要定义映射的 xml 文件即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入映射文件的 namespace + 语句的 id</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;com.github.nekolr.mapper.UserMapper.selectOne&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>XML + 接口映射的方式需要在 XML 映射的基础上再添加一个接口，其中 XML 映射文件中的 namespace 应该对应接口的全限定类名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>注解 + 接口映射的方式完全抛弃了 XML，这种方式将以前需要在 XML 映射文件中定义的 SQL 语句全部转移到了接口文件中，通过注解的方式在接口方法上添加 SQL 语句，需要注意的是，使用这种方式需要修改 MyBatis 的全局配置文件，将以前的 mapper 换成包名或者接口类名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectOne</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h1><p>MyBatis 提供了三种内建的 DataSource，包括 UNPOOLED、POOLED 和 JNDI。其中 UNPOOLED 数据源没有使用连接池技术，因此每次请求都会新建和销毁连接。POOLED 就是使用了数据库连接池技术的数据源，而 JNDI 数据源是为了能在 EJB 或应用服务器这类容器中使用，容器可以集中或者在外部配置数据源，然后通过 JNDI 来引用。如果想使用第三方的数据库连接池，可以有两种实现方式。</p>
<p>其中一种是实现 <code>org.apache.ibatis.datasource.DataSourceFactory</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataSourceFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties props)</span>;</span><br><span class="line"></span><br><span class="line">  DataSource <span class="title function_">getDataSource</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方式就是继承 <code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code> 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HikariDataSourceFactory</span> <span class="keyword">extends</span> <span class="title class_">UnpooledDataSourceFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HikariDataSourceFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HikariDataSourceFactory</span><span class="params">(String driver, String url, String username, String password)</span> &#123;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        config.setDriverClassName(driver);</span><br><span class="line">        config.setJdbcUrl(url);</span><br><span class="line">        config.setUsername(username);</span><br><span class="line">        config.setPassword(password);</span><br><span class="line">        <span class="built_in">this</span>.dataSource = <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让自定义的数据源生效，还需要修改 MyBatis 的全局配置文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;com.github.nekolr.HikariDataSourceFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>MyBatis 提供了两种类型的事务管理器，包括 JDBC 和 MANAGED。其中 JDBC 事务管理器使用的是 JDBC 的提交和回滚机制，它依赖从数据源获取的连接来管理事务的作用域。MANAGED 事务管理器则几乎什么都不做，它不会提交或者回滚一个连接，而是让容器（比如 Web 容器或者 Spring 容器）来管理事务的整个生命周期。如果我们的项目中使用了 Spring 和 MyBatis，那么就不需要给 MyBatis 配置事务管理器，因为 Spring 会用自带的事务管理器来覆盖当前的配置。</p>
<h1 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h1><p>ObjectFactory 是一个接口类，它默认的实现类是 DefaultObjectFactory。在 MyBatis 中，默认的 DefaultObjectFactory 要做的就是实例化查询结果对应的目标类。MyBatis 允许注册自定义的 ObjectFactory，只需要实现 ObjectFactory 接口并修改 MyBatis 的全局配置文件即可。在大多数情况下，我们都不需要自定义对象工厂，只需要继承 DefaultObjectFactory，然后通过一定的改写来完成我们所需要的工作。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>MyBatis 的缓存分为一级缓存和二级缓存，其中一级缓存是会话级别的缓存，它的作用域是 SqlSession。在同一个会话中，查询会被缓存，但是一旦执行新增、修改和删除的操作，缓存就会被清空。</p>
<p>二级缓存是相对一级缓存而言的，二级缓存是 Mapper 级别的缓存，在同一个命名空间（namespace）下所有的操作都会影响着同一个缓存容器，即当多个 SqlSession 去执行同一个 Mapper 的操作时，它们的二级缓存是共享的。在 MyBatis 中，一级缓存默认是开启的，二级缓存默认是关闭的。</p>
<p>在一级缓存中，不同的 session 执行相同的 SQL 查询时，每次都需要查询数据库，这显然是一种浪费。另外，如果在项目中同时使用了 Spring 和 MyBatis，那么每次查询之后都要关闭 SqlSession，关闭之后数据就被清空了，所以此时一级缓存是没有意义的。这也是为什么需要二级缓存的一个原因。</p>
<p>开启二级缓存需要在 XML 映射文件中加入类似下面的配置（也可以在接口文件上使用 @CacheNamespace 注解）。其中 size 代表缓存容器可以存储的缓存对象的个数，eviction 代表使用何种算法来清除不需要的缓存，默认提供了四种缓存清除策略：LRU、FIFO、SOFT 和 WEAK，默认使用 LRU。flushInterval 代表缓存刷新的时间间隔，默认情况下不设置也就是没有刷新间隔，这样缓存仅仅会在调用相关语句时才进行刷新。readOnly 表示缓存是否会给所有的调用者返回相同的缓存实例，默认为 false。如果设置为 true，那么会直接返回缓存对象的实例，这些对象不能被修改，但是相对的，这种方式能够提供可观的性能提升。如果设置为 false，那么会返回缓存对象的拷贝，因此速度会更慢一些，但是也更安全。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了内置的缓存实现，我们还可以使用自定义的缓存实现，或者为其他第三方的缓存组件创建适配器，通过实现 <code>org.apache.ibatis.cache.Cache</code> 接口来完全覆盖缓存行为。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.github.nekolr.cache.MyCache&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么不建议使用-MyBatis-缓存"><a href="#为什么不建议使用-MyBatis-缓存" class="headerlink" title="为什么不建议使用 MyBatis 缓存"></a>为什么不建议使用 MyBatis 缓存</h2><p><strong>首先需要说一点，SQL 层面的缓存几乎没有价值，包括 MyBatis 的一级缓存和二级缓存，缓存需要基于业务来做。一个小知识点：MySQL 8.0 已经废弃了查询缓存。</strong></p>
<p>一级缓存也就是本地缓存，默认是 Session 级别的。一级缓存在大事务下可能会出现读到脏数据的情况，比如在会话 A 中先执行了查询，然后在会话 B 中执行了修改，会话 B 中的缓存被清空了，但是会话 A 的缓存还存在，此时在会话 A 中再次执行查询得到的还是旧数据，这种情况可以修改配置文件：<code>&lt;property name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot; /&gt;</code>，将一级缓存的作用范围缩小到语句级别，这样一个查询语句在执行完毕后会清除缓存。</p>
<blockquote>
<p>在 InnoDB 数据库中，如果需要确保一系列的语句操作要么全部成功，要么全部失败，可以通过显式指定 autocommit&#x3D;0 的方式开启一个事务；否则默认每条语句都会隐式开启一个事务，并在语句执行完成后自动提交。在会话 A 中先后执行的两次查询对应的是两个事务，因此第二次查询理应查询到最新的数据（两次查询不在一个事务中）。</p>
</blockquote>
<p>由于二级缓存是 namespace 级别的缓存，也就是说不同的 namespace 之间的缓存是相互隔离的。如果一个表的某些操作不在它独立的 namespace 下进行就有可能出现脏读的情况，比如在 UserMapper 中都是针对用户表的操作，但是在一个另一个 Mapper 中也有针对用户表的操作，如果在 UserMapper 中执行了新、修改或者删除操作，UserMapper 中的缓存会被清空，但是另一个 Mapper 中的缓存还有可能存在。比较容易出现脏读情况的就是多表操作，不管多表操作位于哪个 namespace 下，都会存在某个表不在该命名空间下的情况。当然这个情况可以使用 <code>cache-ref</code> 规避，使用它可以在多个命名空间中共享缓存配置和实例。</p>
<h1 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h1><p>MyBatis 允许我们在映射语句执行过程中的某一个点进行拦截调用。MyBatis 默认允许使用插件来拦截的方法调用包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</span><br><span class="line">ParameterHandler (getParameterObject, setParameters)</span><br><span class="line">ResultSetHandler (handleResultSets, handleOutputParameters)</span><br><span class="line">StatementHandler (prepare, parameterize, batch, update, query)</span><br></pre></td></tr></table></figure>

<p>如果我们想做的不仅仅是监控方法的调用，那么我们需要相当了解要重写的方法的行为，因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。这些都是更底层的类和方法，所以使用插件的时候要特别当心。使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(</span></span><br><span class="line"><span class="meta">        type = Executor.class,</span></span><br><span class="line"><span class="meta">        method = &quot;update&quot;,</span></span><br><span class="line"><span class="meta">        args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// implement pre processing if need</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnObject</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        <span class="comment">// implement post processing if need</span></span><br><span class="line">        <span class="keyword">return</span> returnObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.nekolr.plugin.ExamplePlugin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>MyBatis 的插件机制是通过 JDK 的动态代理 + 责任链设计模式实现的。</p>
</blockquote>
<h1 id="整合-Spring"><a href="#整合-Spring" class="headerlink" title="整合 Spring"></a>整合 Spring</h1><p>首先需要加入 MyBatis-Spring 模块。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。在 MyBatis-Spring 中，可以使用 SqlSessionFactoryBean 来创建 SqlSessionFactory。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">  factoryBean.setDataSource(dataSource());</span><br><span class="line">  <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以通过 MapperFactoryBean 将映射接口添加到 Spring 中，这种方式一次只能配置一个数据映射器类。也可以使用 MapperScannerConfigurer 直接扫描所有的数据映射器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.github.nekolr.mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MapperFactoryBean&lt;UserMapper&gt; <span class="title function_">userMapper</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  MapperFactoryBean&lt;UserMapper&gt; factoryBean = <span class="keyword">new</span> <span class="title class_">MapperFactoryBean</span>&lt;&gt;(UserMapper.class);</span><br><span class="line">  factoryBean.setSqlSessionFactory(sqlSessionFactory());</span><br><span class="line">  <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 扫描接口包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.github.nekolr.mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者更简单地，直接在一个 Spring 配置类上使用扫描注解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.github.nekolr.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 MyBatis-Spring 的一个重要原因是它允许 MyBatis 参与到 Spring 的事务管理中，而不是给 MyBatis 创建一个新的专用事务管理器。MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。一旦配置好 Spring 的事务管理器，我们就可以在 Spring 中按照平时的方式来使用事务，它支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://mybatis.org/mybatis-3/">MyBatis 官网</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.mybatis.org/">MyBatis Blog</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL MVCC 原理</title>
    <url>/2020/07/14/MySQL%20MVCC%20%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>对于使用 InnoDB 存储引擎的数据库表来说，它们聚集索引的行记录中都包含两个必要的隐藏列：DB_TRX_ID（trx_id）和 DB_ROLL_PTR（roll_pointer）。每次事务对某条记录进行修改时，都会把该事务的事务 ID 赋值给 trx_id 隐藏列，同时还会把该条记录的旧版本写入到 undo log 中，而这个 roll_pointer 就相当于一个指针，通过它可以找到该记录修改前的信息。</p>
<span id="more"></span>

<h1 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h1><p>每次对记录进行改动，都会写一条 undo log，同时每条 undo log 也都有一个 old_trx_id 属性和一个 old_roll_pointer 属性（INSERT 操作对应的 undo log 没有这些属性，因为该记录没有更早的版本）用于记录上一个 undo log。最终这些 undo log 就连接起来形成了一个链表，这个链表称之为版本链，版本链的头节点就是当前记录的最新值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007150025/2020/07/14/24O.png" alt="版本链"></p>
<h1 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h1><p>对于使用 READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，因此直接读取记录的最新版本即可。对于使用 SERIALIZABLE 隔离级别的事务来说，InnoDB 规定必须使用加锁的方式来访问记录。而对于使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，如果一个事务修改了记录但尚未提交，其他事务是不能读取记录的最新版本的。此时就需要判断版本链中的哪个版本是可以被当前事务访问的，为此 InnoDB 的设计人员提出了 ReadView 的概念。</p>
<table>
<thead>
<tr>
<th>ReadView 组成部分</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>在生成 ReadView 时当前系统中活跃的读写事务（区别于只读事务，默认的事务就是读写事务）的事务 ID 列表</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>在生成 ReadView 时当前系统中活跃的读写事务中最小的事务 ID，也就是 m_ids 中的最小值</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>系统应该给下一个事务分配的 ID 值</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>生成该 ReadView 的事务 ID 值</td>
</tr>
</tbody></table>
<blockquote>
<p>只有在对记录做改动（INSERT、DELETE、UPDATE）时才会为事务分配事务 ID，否则在一个只读事务中的事务 ID 默认都是 0。</p>
</blockquote>
<p>有了这个 ReadView，这样在访问某条记录时，只需要按照以下规则判断记录的某个版本是否可见：</p>
<p>(1) 被访问版本的 trx_id 与 ReadView 中的 creator_trx_id 相同，说明当前事务在访问自己修改过的记录，因此该版本可以被当前事务访问。</p>
<p>(2) 被访问版本的 trx_id 小于 ReadView 中的 min_trx_id 值，说明该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</p>
<p>(3) 被访问版本的 trx_id 在 min_trx_id 与 max_trx_id 之间，说明需要判断 trx_id 值是否在 m_ids 列表中，如果在，说明创建 ReadView 的事务还是活跃的，该版本不可以被当前事务访问；如果不在，说明创建 ReadView 时生成该版本的事务已经提交，那么该版本可以被当前事务访问。</p>
<p>(4) 被访问版本的 trx_id 大于或等于 ReadView 中的 max_trx_id 值，说明生成该版本的事务在当前事务生成 ReadView 之后才开启，所以该版本不可以被当前事务访问。</p>
<p>在 MySQL 中，READ COMMITTED 隔离级别与 REPEATABLE READ 隔离级别的一个很大的区别就是它们生成 ReadView 的时机不同。为了方便说明，这里先创建一张表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hero (</span><br><span class="line">    number <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    country <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> hero <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;刘备&#x27;</span>, <span class="string">&#x27;蜀&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h2><p><strong>在读提交隔离级别中，每次读取数据前都会生成一个 ReadView。</strong></p>
<p>假如现在系统中有两个事务 ID 分别为 100、200 的事务在运行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务 100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务 200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 更新了其他表的一些记录，这里这么做是因为只有修改操作才会生成事务 ID</span></span><br></pre></td></tr></table></figure>

<p>此时 hero 表中主键值为 1 的记录的版本链类似下面这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007150025/2020/07/14/avb.png" alt="版本链1"></p>
<p>假设此时有一个 READ COMMITTED 隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 事务 100、200 还未提交，得到的是刘备的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个查询的执行过程大概是这样：首先在执行 SELECT 语句时会生成一个 ReadView，m_ids 列表的内容就是 <code>[100, 200]</code>，min_trx_id 为 100，而 max_trx_id 为 201，creator_trx_id 则为 0。然后开始从版本链中寻找可见的记录，由于最新版本的 trx_id 为 100，处于 min_trx_id 与 max_trx_id 之间，而同时 trx_id 为 100 的事务还处于活跃状态，所以该版本不能被当前事务访问。那么此时就根据 roll_pointer 跳到下一个版本中。同样的，这个版本的 trx_id 值也是 100，因此继续到下一个版本。这个版本中的 trx_id 为 80，小于 ReadView 中的 min_trx_id，因此这个版本是符合要求的，所以返回的就是该版本的信息。</p>
<p>接下来我们把事务 100 提交，然后在事务 200 中更新一下记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务 100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务 200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 更新了其他表的一些记录，这里这么做是因为只有修改操作才会生成事务 ID</span></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;赵云&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;诸葛亮&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此时的 hero 表中，主键值为 1 的记录的版本链类似下面这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007150025/2020/07/14/pnv.png" alt="版本链2"></p>
<p>然后我们再到刚才的事务中继续查找主键值为 1 的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 事务 100、200 还未提交，得到的是刘备的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询，此时事务 100 已经提交，事务 200 还未提交，得到的是张飞的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询的执行过程大概是这样的：首先<strong>在执行查询时会再次生成一个 ReadView</strong>，m_ids 的值为 <code>[200]</code>，min_trx_id 变成了 200，而 max_trx_id 为 201，creator_trx_id 为 0。然后从版本链中查询可见的记录，最新版本记录的 trx_id 为 200，在事务活跃列表中，因此不符合规则。以此类推，只有 trx_id 为 100、name 列的内容为“张飞”的版本符合规则。</p>
<h2 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h2><p>与 READ COMMITTED 隔离级别不同，在使用 REPEATABLE READ 隔离级别的事务中，只会在第一次执行查询语句时生成一个 ReadView，之后该事务中所有的查询操作都会重复使用这个 ReadView。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于使用 READ UNCOMMITTED 隔离级别的事务来说，直接读取记录的最新版本即可。对于使用 SERIALIZABLE 隔离级别的事务来说，通过使用锁来实现事务的串行化执行。而对于使用 READ COMMITTED 隔离级别的事务来说，会在每次执行普通查询时都生成一个 ReadView，如果其他事务在它生成 ReadView 之前提交了事务，那么这些事务的修改就对它可见；否则就不可见，这样也就实现了只读取提交过的事务。而对于使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行普通查询时生成一个 ReadView，后续该事务中所有的查询都会使用之前生成的 ReadView，这样就可以避免出现不可重复读的情况。</p>
<p>其实在 InnoDB 中，读操作可以分为两种：快照读（Snapshot Read&#x2F;Consistent Read）和当前读（Current Read&#x2F;Locking Read）。快照读就是简单的 SELECT 操作，不需要加锁，读取的是当前记录的快照。而当前读则是特殊的读操作，读取的是记录的最新数据，包括隐含当前读逻辑的插入、更新和删除，以及一些手工添加锁的读，比如 <code>SELECT ... FOR UPDATE</code>、<code>SELECT ... LOCK IN SHARE MODE</code>，它们都属于当前读，需要加锁。<strong>对于快照读来说，不存在幻读的问题；而对于当前读来说，会出现幻读的问题，这个可以通过 Next-Key Locking 来解决</strong>。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 执行计划</title>
    <url>/2020/09/08/MySQL%20%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>一条查询语句在经过 MySQL 的查询优化器分析后，会生成一个所谓的执行计划，这个计划能够告诉我们接下来的查询的一些信息，比如单表采用哪种访问方法，多表连接的顺序，预估需要读取的记录数等等。</p>
<span id="more"></span>

<p>我们平常使用的查询语句，甚至是增删改的语句，都可以在前面加上 <code>EXPLAIN</code> 关键字列出该条语句的执行计划，不过一般存在性能瓶颈的都是查询语句，所以我们主要关注的也是查询语句。下面先简单说明一下 EXPLAIN 语句输出的各个列的含义。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>SELECT 标识符，每个 SELECT 关键字都对应一个唯一的 id</td>
</tr>
<tr>
<td>select_type</td>
<td>查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，不使用分区表时，默认为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>单表访问的方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用索引的字段长度</td>
</tr>
<tr>
<td>ref</td>
<td>使用索引列等值查询时，与索引列进行等值匹配的对象，可以是一个常数或者某个列</td>
</tr>
<tr>
<td>rows</td>
<td>预估需要扫描的行数，也就是结果集的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>通过条件过滤出的行数的百分比估值</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>不管我们的查询语句有多复杂，最终都会分解成一个个的单表查询，所以 EXPLAIN 输出的每条记录都对应着某个单表的访问，该条记录的 table 列就代表这张表的名称。比如一个简单的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12286</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<p>然后再看看一个连接查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested Loop)<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br></pre></td></tr></table></figure>

<h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p>一般情况下的查询只有一个 SELECT 关键字，比如普通的单表查询或者连接查询，但是有时候也会有多个 SELECT 关键字，比如包含子查询语句以及 UNION 查询等。在整个查询语句中，每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id。</p>
<p>对于连接查询来说，有一个比较重要的规则就是，在连接查询的执行计划中，每个表都会对应一条记录，它们的 id 值都相同，但是出现在前面的表是驱动表，而出现在后面的表是被驱动表。</p>
<p>对于子查询来说，一般会包含多个 SELECT 关键字，每个关键字都会对应一个唯一的 id 值，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">or</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>    <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>  <span class="operator">|</span>idx_username <span class="operator">|</span><span class="keyword">NULL</span>    <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>SUBQUERY   <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>但是有时候查询优化器可能会对涉及子查询的查询语句进行重写并转换为连接查询，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+------------+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>         <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+------------+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>        <span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>demo.user.id<span class="operator">|</span><span class="number">1</span>     <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+------------+------+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>对于 UNION 查询来说，由于还需要去重，所以执行计划可能会有点不一样，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+----------+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span>id  <span class="operator">|</span>select_type <span class="operator">|</span><span class="keyword">table</span>     <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+----------+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="keyword">PRIMARY</span>     <span class="operator">|</span>t1        <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span>   <span class="operator">|</span><span class="keyword">UNION</span>       <span class="operator">|</span>t2        <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">UNION</span> <span class="keyword">RESULT</span><span class="operator">|</span><span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span><span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>  <span class="operator">|</span><span class="keyword">NULL</span>    <span class="operator">|</span><span class="keyword">Using</span> temporary<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+----------+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br></pre></td></tr></table></figure>

<p>为了将 id 为 1 的查询和 id 为 2 的查询结果集合并起来并去重，需要创建一个临时表，也就是上面的 <code>&lt;union1,2&gt;</code>，而由于 UNION ALL 不需要去重，所以执行计划里没有 id 为 NULL 的记录。</p>
<p>总的来说，一般情况下，id 值相同时，按照从上到下的顺序执行；id 值不同时，id 值大的先执行。</p>
<h1 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h1><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单查询，不包含子查询或者 UNION 查询</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>最外层的那个查询</td>
</tr>
<tr>
<td>UNION</td>
<td>UNION 后面的查询</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>UNION 去重时使用的临时表的查询</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>不依赖外部查询的子查询</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>依赖外部查询的子查询</td>
</tr>
<tr>
<td>DERIVED</td>
<td>采用物化的方式执行包含派生表的查询</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>查询优化器选择将子查询物化后与外层查询进行连接查询时</td>
</tr>
</tbody></table>
<h2 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h2><p>查询中不包含子查询或者 UNION 查询的都算作 SIMPLE 类型的查询，当然，连接查询也是 SIMPLE 类型的，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested Loop)<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h2><p>对于包含子查询或者 UNION 查询的大查询来说，它是由几个小的查询组成的，其中最左边也就是最外层的那个小查询就是 PRIMARY 类型的。</p>
<h2 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h2><p>如果包含子查询的查询语句不能转换为对应的 semi-join 的形式，并且该子查询不依赖外部的查询，同时查询优化器决定将子查询进行物化，此时子查询的第一个 SELECT 关键字代表的那个查询就是 SUBQUERY 类型的，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">or</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>    <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>  <span class="operator">|</span>idx_username <span class="operator">|</span><span class="keyword">NULL</span>    <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>SUBQUERY   <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>由于 SUBQUERY 类型的子查询会被物化，所以它只需要执行一遍即可。</strong></p>
<h2 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h2><p>如果包含子查询的查询语句不能转换为对应的 semi-join 的形式，并且该子查询依赖于外部的查询，那么子查询的第一个 SELECT 关键字代表的那个查询就是 DEPENDENT SUBQUERY 类型的，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> t2 <span class="keyword">where</span> t1.id <span class="operator">=</span> t2.id) <span class="keyword">or</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------------+-----+----------+------+-------------+-------+-------+----------+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type       <span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>       <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------------+-----+----------+------+-------------+-------+-------+----------+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>           <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span>idx_username <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>DEPENDENT SUBQUERY<span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>demo.t1.id<span class="operator">|</span><span class="number">1</span>     <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------------+-----+----------+------+-------------+-------+-------+----------+------+--------+------------------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>与 SUBQUERY 不同，查询类型为 DEPENDENT SUBQUERY 的查询可能会执行多次。</strong></p>
<h2 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h2><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询就是 DERIVED 类型的，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> province, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> province) <span class="keyword">as</span> derived_t;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+----------+----------+-----+-------------+-----------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span>     <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+----------+----------+-----+-------------+-----------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>    <span class="operator">|</span><span class="operator">&lt;</span>derived2<span class="operator">&gt;</span><span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>  <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>DERIVED    <span class="operator">|</span><span class="keyword">user</span>      <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">909</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+----------+----------+-----+-------------+-----------+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<h2 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a>MATERIALIZED</h2><p>查询优化器在执行子查询时，如果选择将子查询物化后与外层查询进行连接查询时，该子查询就是 MATERIALIZED 类型的，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> post);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------+-----------+----------+------+-------------+-------+-------+-------------------+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type <span class="operator">|</span><span class="keyword">table</span>      <span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>                <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------+-----------+----------+------+-------------+-------+-------+-------------------+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE      <span class="operator">|</span><span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span><span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>               <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE      <span class="operator">|</span><span class="keyword">user</span>       <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span><span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span>.user_id<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>MATERIALIZED<span class="operator">|</span>post       <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>               <span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------+-----------+----------+------+-------------+-------+-------+-------------------+----+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>最后一条记录的 id 为 2，查询类型是 MATERIALIZED，说明查询优化器对它进行了物化，而前两条记录的 id 为 1，说明这两条记录对应的表进行了连接查询，<code>&lt;subquery2&gt;</code> 对应的就是物化表。</p>
<h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>对应的是单表的访问方法，除了之前讲过的那些，还有一些比较特殊的访问方法，比如 system、eq_ref、fulltext 等。</p>
<h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、Memory 等，那么该表的访问方法就是 system。</p>
<h2 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h2><p>在进行连接查询时，如果被驱动表是通过主键或者唯一二级索引等值匹配的方式进行访问的话，那么对该被驱动表的访问方法就是 eq_ref，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> t2 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+----------+------+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>       <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+----------+------+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>demo.t1.id<span class="operator">|</span><span class="number">1</span>     <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+----------+------+--------+-----+</span></span><br></pre></td></tr></table></figure>

<h1 id="possible-keys-和-key"><a href="#possible-keys-和-key" class="headerlink" title="possible_keys 和 key"></a>possible_keys 和 key</h1><p>possible_keys 表示可能会用到的索引，而 key 代表的是实际用到的索引，比如下面的查询语句可能用到的索引为 ids_code 和 idx_username，但是在计算成本之后，还是选择了 idx_username。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">and</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+---------------------+------------+-------+-----+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys        <span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+---------------------+------------+-------+-----+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_code,idx_username<span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1724</span><span class="operator">|</span><span class="number">50</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+---------------------+------------+-------+-----+----+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用 index 访问方法时，possible_keys 的值为 NULL，但是 key 是有值的。另外 possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算各个索引的查询成本时就要花费更多的时间。</p>
<h1 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h1><p>在一般情况下，key_len 代表当查询优化器决定使用某个索引时，该索引列的最大长度。对于使用固定长度类型的索引列来说，它实际占用的存储空间就是该固定值；对于变长类型的字段来说，比如 VARCHAR(100)，使用 UTF8 字符集，那么它实际占用的最大存储空间就是 100 * 3 &#x3D; 300 个字节，同时还需要 2 个字节的空间来存储变长字段的实际长度值。如果索引列可以存储 NULL 值，那么 key_len 会比不能为空时多一个字节。比如下面这个例子，code 列是 int 类型的，并且可以存储 NULL 值，所以 key_len 的大小为 5。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code  <span class="operator">=</span> <span class="number">122</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<p>当然有时候，key_len 代表的是实际用到的索引列的长度，比如在使用联合索引时，只用到一个索引列和两个索引列，key_len 的值是不一样的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东省&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----+-----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span> <span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----+-----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">95924</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----+-----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东省&#x27;</span> <span class="keyword">and</span> city <span class="operator">=</span> <span class="string">&#x27;青岛市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>        <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">606</span>    <span class="operator">|</span>const,const<span class="operator">|</span><span class="number">6000</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<h1 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h1><p>这个还是举例子比较清楚，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">and</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+---------------------+--------+-------+----+----+--------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys        <span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+---------------------+--------+-------+----+----+--------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_code,idx_username<span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">999</span> <span class="operator">|</span><span class="number">0.17</span>    <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+---------------------+--------+-------+----+----+--------+----------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，通过索引条件 code &lt; 1000，查询优化器估算出了需要扫描的行数为 999，而这 999 行中，经过条件过滤，最终只有一条结果，也就是估算出有 0.17 % 的行满足剩下的条件（<code>username = &#39;Bob&#39;</code>）。</p>
<h1 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h1><p>Extra 可以提供一些额外的信息，使我们能够更加准确地理解查询优化器到底会如何执行给定的查询语句。</p>
<ul>
<li><p>No tables used<br>查询语句没有 FROM 子句，比如 SELECT 1，或者 SELECT 1 FROM dual。</p>
</li>
<li><p>Impossible WHERE<br>查询语句的 WHERE 子句永远为 FALSE 时，比如 SELECT * FROM user WHERE 1 !&#x3D; 1。</p>
</li>
<li><p>Using index<br>当使用覆盖索引时，比如 <code>SELECT province, city, county FROM user WHERE province = &#39;上海市&#39;</code>。</p>
</li>
<li><p>Using index condition<br>在查询语句的执行过程中使用了**索引条件下推（Index Condition Pushdown）**这个特性。举个例子，比如：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">and</span> username <span class="keyword">like</span> <span class="string">&#x27;%ce&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">3516</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>username &gt; &#39;z&#39;</code> 可以通过索引列使用 range 访问方法，但是 <code>username like &#39;%ce&#39;</code> 不行，在以前的 MySQL 中，此时需要回表获取完整的用户记录，然后再检查记录是否符合条件；在 5.6 以后的版本中，此时先不急着回表，而是直接检查是否满足条件，如果没有满足就没必要回表，这样就可以省去好多回表的 I&#x2F;O 成本。</p>
<ul>
<li><p>Using where<br>当使用全表扫描的访问方法查询某个表，同时语句中有对应的 where 条件时。或者当使用索引查询，并且该查询的 where 子句中还使用了其他非索引的列作为搜索条件。</p>
</li>
<li><p>Zero limit<br>当 limit 子句的参数为 0 时，这意味着根本不打算从表中读出任何记录。</p>
</li>
<li><p>Using filesort<br>有时候排序操作无法使用索引，这时只能在内存中（记录较少时）或者磁盘中（记录较多时）进行排序，这种排序方式称为文件排序（filesort）。</p>
</li>
<li><p>Using temporary<br>在很多查询中，MySQL 可能需要借助临时表来完成一些功能，比如使用 UNION、DISTINCT 去重、使用 GROUP BY 排序等。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="keyword">DISTINCT</span> avatar <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> temporary<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> avatar, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> avatar;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> temporary; <span class="keyword">Using</span> filesort<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>由于 MySQL 默认会在 GROUP BY 子句中添加 ORDER BY 子句，所以这里的分组还出现了 Using filesort，如果我们不想进行排序，可以显式地使用 ORDER BY NULL 来指定。</p>
<h1 id="查询成本"><a href="#查询成本" class="headerlink" title="查询成本"></a>查询成本</h1><p>通过 EXPLAIN 输出的执行计划缺少了一个衡量执行计划“好坏”的重要因素，那就是<strong>成本</strong>。从 MySQL 5.6 版本开始，我们可以通过在 EXPLAIN 后面加上 FORMAT&#x3D;JSON 来得到一个 json 格式的执行计划，里面包含了查询成本。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain FORMAT<span class="operator">=</span>JSON <span class="keyword">select</span> avatar, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> avatar;</span><br><span class="line"></span><br><span class="line">&quot;&#123;</span><br><span class="line">  &quot;&quot;query_block&quot;&quot;: &#123;</span><br><span class="line">    &quot;&quot;select_id&quot;&quot;: 1,</span><br><span class="line">    &quot;&quot;cost_info&quot;&quot;: &#123;</span><br><span class="line">      &quot;&quot;query_cost&quot;&quot;: &quot;&quot;1200635.00&quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;&quot;grouping_operation&quot;&quot;: &#123;</span><br><span class="line">      &quot;&quot;using_temporary_table&quot;&quot;: true,</span><br><span class="line">      &quot;&quot;using_filesort&quot;&quot;: true,</span><br><span class="line">      &quot;&quot;cost_info&quot;&quot;: &#123;</span><br><span class="line">        &quot;&quot;sort_cost&quot;&quot;: &quot;&quot;991800.00&quot;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;&quot;table&quot;&quot;: &#123;</span><br><span class="line">        &quot;&quot;table_name&quot;&quot;: &quot;&quot;user&quot;&quot;,</span><br><span class="line">        &quot;&quot;access_type&quot;&quot;: &quot;&quot;ALL&quot;&quot;,</span><br><span class="line">        &quot;&quot;rows_examined_per_scan&quot;&quot;: 991800,</span><br><span class="line">        &quot;&quot;rows_produced_per_join&quot;&quot;: 991800,</span><br><span class="line">        &quot;&quot;filtered&quot;&quot;: &quot;&quot;100.00&quot;&quot;,</span><br><span class="line">        &quot;&quot;cost_info&quot;&quot;: &#123;</span><br><span class="line">          &quot;&quot;read_cost&quot;&quot;: &quot;&quot;10475.00&quot;&quot;,</span><br><span class="line">          &quot;&quot;eval_cost&quot;&quot;: &quot;&quot;198360.00&quot;&quot;,</span><br><span class="line">          &quot;&quot;prefix_cost&quot;&quot;: &quot;&quot;208835.00&quot;&quot;,</span><br><span class="line">          &quot;&quot;data_read_per_join&quot;&quot;: &quot;&quot;1G&quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;&quot;used_columns&quot;&quot;: [</span><br><span class="line">          &quot;&quot;id&quot;&quot;,</span><br><span class="line">          &quot;&quot;avatar&quot;&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>这里需要关注的重点就是 cost_info，其中 read_cost 包含 IO 成本以及扫描 <code>rows * (1 - filtered)</code> 条记录的 CPU 成本，而 eval_cost 是扫描 rows * filtered 条记录的成本，而 prefix_cost &#x3D; read_cost + eval_cost。data_read_per_join 表示此次查询中需要读取的数据量。如果觉得这样还是不够详细，可以直接修改 MySQL 的参数来启动查询优化器的追踪。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 的单表查询</title>
    <url>/2020/09/04/MySQL%20%E7%9A%84%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>从最简单的单表查询开始，能够更加简单直接地接触到 MySQL 中最基础的一些访问方法，结合 MySQL 的行记录、数据页以及索引结构的知识，在出现性能问题时才可以更有底气地应对。</p>
<span id="more"></span>

<p>在开始之前，首先我们创建一张表，其中 id 列创建聚簇索引，username 和 email 列创建二级索引，code 列创建唯一的二级索引，而 province、city 和 county 这三列创建一个联合索引。接着通过程序插入随机数据 100 万条。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id         <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    username   <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    code       <span class="type">int</span>          <span class="keyword">null</span>,</span><br><span class="line">    email      <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    avatar     <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    province   <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    city       <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    county     <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    key idx_username (username),</span><br><span class="line">    <span class="keyword">unique</span> key idx_code (code),</span><br><span class="line">    key idx_email (email),</span><br><span class="line">    key idx_address (province, city, county)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<h1 id="访问方法（access-method）"><a href="#访问方法（access-method）" class="headerlink" title="访问方法（access method）"></a>访问方法（access method）</h1><p>对于单表来说，MySQL 查询能够执行的方式大致有两种，一种是使用全表扫描，即扫描表的每一行记录，把符合条件的记录加入到结果集中。另一种就是使用索引查询，但是针对索引的查询也细分为很多种，比如针对主键或者唯一二级索引的等值查询，普通二级索引的等值查询，索引列的范围查询等等，这些都是 MySQL 执行查询时的访问方法。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>通过主键或者唯一二级索引进行等值查询时使用的就是 const，意为常数级别的访问方法，它的代价几乎可以忽略。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12286</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">=</span> <span class="number">12286</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<p>与主键不同的是，使用唯一二级索引作为查询条件时，如果没有覆盖索引，那么就需要回表。同时由于唯一二级索引并不限制 NULL（没有填充数据）的数量，所以在进行判空查询时无法使用 const，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+--------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+--------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">4</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+--------+-------+-----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>通过二级索引进行等值查询时使用的就是 ref，由于索引列的值相同的记录基本上是连续的，因此这种访问方式也是比较快的。但是二级索引的等值查询不是一定使用 ref 的访问方式，这取决于查询条件所匹配到的记录条数，如果匹配到的记录较少，那么回表的代价还是比较低的，此时可以使用 ref 的方式；如果匹配到的记录较多，那么 MySQL 可能会选择使用全表扫描的方式执行查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+------------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+------------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1724</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+------------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<p>对于包含多个索引列的二级索引（也叫联合索引）来说，只要符合最左匹配原则就可能采用 ref 的访问方式。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东省&#x27;</span> <span class="keyword">and</span> city <span class="operator">=</span> <span class="string">&#x27;济南市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>        <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">606</span>    <span class="operator">|</span>const,const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;济南市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">989489</span><span class="operator">|</span><span class="number">10</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<h2 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h2><p>有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列值为 NULL 的记录也找出来，此时使用的就是 ref_or_null 的访问方法，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span> <span class="keyword">or</span> username <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+-------------+------------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+-------------+------------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>ref_or_null<span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1725</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+-------------+------------+-------+-----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure>

<p>上面的查询相当于分别从索引树中找出 username is null 和 username &#x3D; ‘Bob’ 的两个连续的记录范围，然后根据记录中的主键值回表查询完整的用户记录。</p>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>如果使用索引列进行范围查询，一般会使用 range 访问方法。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">in</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">3425</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">&gt;=</span> <span class="number">122</span> <span class="keyword">and</span> code <span class="operator">&lt;=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">179</span> <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子看，范围一般有单点区间和连续区间，单点区间只要多次使用索引的等值查询即可，而连续区间则只要找到区间的起始点，之后沿着该点向后顺序查询即可，速度也是比较快的。</p>
<p>总的来说，只要索引列和常数使用比较符号（等于、不等于、大于等于等等），<code>in</code> 和 <code>not in</code>，<code>is null</code> 和 <code>is not null</code>，以及 <code>between</code> 和 <code>like</code> 连接起来就可以产生一个区间，就可以使用 range 访问方法，但是 like 比较特殊，只有符合最左前缀匹配原则时才可以。</p>
<h2 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h2><p>有些特殊的查询会在一个查询中使用到多个索引，这种查询使用的访问方法就是 index_merge，即索引合并。索引合并的算法一般有三种：Intersection、Union、Sort-Union。</p>
<h3 id="Intersection"><a href="#Intersection" class="headerlink" title="Intersection"></a>Intersection</h3><p>所谓交集合并就是将从多个索引中查询到的结果取交集，比如下面这个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span> <span class="keyword">and</span> email <span class="operator">=</span> <span class="string">&#x27;orghxctxih@cxmxz.gmz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys         <span class="operator">|</span>key                   <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span>idx_username,idx_email<span class="operator">|</span>idx_email,idx_username<span class="operator">|</span><span class="number">303</span>,<span class="number">303</span><span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">2</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">intersect</span>(idx_email,idx_username); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>整个过程就是分别将根据索引列查询得出的结果，然后根据结果中的主键值取交集，最后回表查询。这里我们可能会疑惑为什么不先拿到一个根据索引列查询的结果，然后在它的基础上进行回表查询并过滤第二个条件呢？这其实就要比较两种方式的成本。我们知道，读取二级索引是顺序 I&#x2F;O，而回表有很大可能是随机 I&#x2F;O，虽然使用交集合并的方式需要读取多个二级索引，但是多个索引合并后，交集的记录数一定要比只读取一个索引的记录数要少，需要回表的记录数也少，所以成本更低。</p>
<blockquote>
<p>一个查询使用多个索引列，有时候可能并不会像我们预料的那样使用索引合并，这取决于索引列能够匹配到的记录个数，如果记录数比较少，可能只是单纯的使用 ref 访问方式。</p>
</blockquote>
<p>一般只有在多个二级索引进行等值匹配（联合索引需要每个列都进行匹配，不能只匹配部分列）时才会使用 Intersection 索引合并，但是有些特殊的情况也可以使用，比如在主键列使用范围匹配的时候：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">12205</span> <span class="keyword">and</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+--------------------+--------------------+-------+----+----+--------+--------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys       <span class="operator">|</span>key                 <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+--------------------+--------------------+-------+----+----+--------+--------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span><span class="keyword">PRIMARY</span>,idx_username<span class="operator">|</span>idx_username,<span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">307</span>,<span class="number">4</span>  <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">852</span> <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">intersect</span>(idx_username,<span class="keyword">PRIMARY</span>); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+--------------------+--------------------+-------+----+----+--------+--------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>对于这种特殊情况，我们只要记住一点，即：<strong>二级索引的索引列相同的记录是按照主键排序的</strong>。因此使用主键进行范围查询的结果可以很容易地跟二级索引的等值查询的结果进行取交集。</p>
<h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>与 Intersection 类似的，只不过不再使用 and 取交集，而是使用 or 取并集。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span> <span class="keyword">or</span> email <span class="operator">=</span> <span class="string">&#x27;orghxctxih@cxmxz.gmz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys         <span class="operator">|</span>key                   <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span>idx_username,idx_email<span class="operator">|</span>idx_username,idx_email<span class="operator">|</span><span class="number">303</span>,<span class="number">303</span><span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">3317</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">union</span>(idx_username,idx_email); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>在拿到两个结果集之后，由于这两个结果集都是按照主键排序的，因此按照主键值进行合并也是比较容易的，只有合并后的结果集也是按照主键排序，回表时才能够降低成本。</p>
<h3 id="Sort-Union"><a href="#Sort-Union" class="headerlink" title="Sort-Union"></a>Sort-Union</h3><p>一般使用 Union 索引合并的条件太苛刻，必须保证每个二级索引都是等值匹配，比如下面这种就无法使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">in</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>) <span class="keyword">or</span> code <span class="operator">&lt;</span> <span class="number">2205</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+---------------------+---------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys        <span class="operator">|</span>key                  <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+---------------------+---------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span>idx_code,idx_username<span class="operator">|</span>idx_username,idx_code<span class="operator">|</span><span class="number">303</span>,<span class="number">5</span>  <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">5628</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> sort_union(idx_username,idx_code); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+---------------------+---------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>这是因为通过这两个索引列匹配到的结果集并不是按照主键排序的，但是我们可以将查询的结果再根据主键进行一次排序，这样就可以使用 Union 的方式进行索引合并。这种将多个根据索引列查询到的结果集进行再次排序，最后取并集的方式就是 Sort-Union。</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>当我们使用索引覆盖，但需要扫描全部的索引记录时，使用的就是 index 访问方法。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> province, city, county <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;青岛市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-----------+-------+----+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-----------+-------+----+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">909</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">989489</span><span class="operator">|</span><span class="number">10</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-----------+-------+----+------+--------+------------------------+</span></span><br></pre></td></tr></table></figure>

<p>查询的字段都是索引列，因此可以使用覆盖索引，但是由于查询条件不符合最左前缀原则，所以只能对整个索引树（联合索引树）进行扫描，不过这颗树要比聚簇索引“小”很多，所以性能要比直接遍历聚簇索引（全表扫描）要好一些。</p>
<h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>all 就是全表扫描，也就是直接遍历聚簇索引，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> avatar <span class="operator">=</span> <span class="string">&#x27;https://avatar.github.com/cjFQDo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">989489</span><span class="operator">|</span><span class="number">10</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure>

<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>很多时候查询优化器并不会按照我们预想的方式进行查询，这都是基于查询成本考量下的结果。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 的锁机制</title>
    <url>/2020/07/16/MySQL%20%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>并发事务访问相同记录的情况大致可以分为三种：读读、读写和写写。读读的情况并不会产生并发问题，真正会产生问题的是并发的读写或者写写。并发的写写可能会产生脏写和丢失更新的问题，由于这类问题比较严重，数据库会通过加锁的方式阻塞并发的修改，因此在任何隔离级别下数据库都不会出现脏写和丢失更新的情况，但是在应用层面，还是有可能出现逻辑意义上的丢失更新。</p>
<span id="more"></span>

<p>并发的读写可能会产生脏读、不可重复读以及幻读的问题。处理这类问题有两种可选的方案，一种是对写操作加锁，读操作则利用 MVCC 机制。在 READ COMMITTED 隔离级别中，一个事务中每次执行普通的 SELECT 操作都会生成一个 ReadView，这样就保证了每次的读操作都只能读到已经提交的事务的更改。而在 REPEATABLE READ 隔离级别中，一个事务中只有第一次执行普通的 SELECT 操作才会生成一个 ReadView，之后的读操作都会复用该 ReadView，因此也就避免了不可重复读和幻读的问题。</p>
<p>另一种就是对读操作和写操作都加锁，如果一些业务场景中不允许读取记录的旧版本，而是每次都需要读取记录的最新版本，那么就需要在读的时候加锁，同时写操作也需要加锁，这也就意味着读写操作也像写写操作那样排队执行。很明显，因为使用 MVCC 可以使读写操作并发执行，因此性能更好。在一般情况下，我们都采用默认的方式，也就是读操作利用 MVCC，写操作加锁。当一些业务需要的时候，再手动给读操作加锁。</p>
<h1 id="MySQL-中的数据操作"><a href="#MySQL-中的数据操作" class="headerlink" title="MySQL 中的数据操作"></a>MySQL 中的数据操作</h1><p>在 MySQL 中，读操作分为两种。一种是快照读（Snapshot Read），也叫做一致性读（Consistent Read）或者一致性无锁读。快照读通过 MySQL 的 MVCC 机制实现，不需要加锁，读取的是当前记录的快照。所有普通的 SELECT（plain SELECT）语句在读提交和可重复读隔离级别下都是快照读。</p>
<p>另一种就是锁定读（Locking Read），也叫做当前读（Current Read）。当前读可以看作是一种特殊的读操作，它读取的是最新的记录，包括隐含当前读逻辑的插入、更新和删除，以及一些手工添加锁的读都是当前读。使用 <code>SELECT ... LOCK IN SHARE MODE</code> 语句会为读取到的数据加入 S 锁，这样别的事务可以继续获取这些记录的 S 锁，但是不能获取这些记录的 X 锁。使用 <code>SELECT ... FOR UPDATE</code> 语句会为读取到的数据加入 X 锁，这样别的事务就无法再获取这些记录的 S 锁和 X 锁。</p>
<p>在 MySQL 中，写操作无非就是 DELETE、UPDATE 和 INSERT 这三种。对一条记录进行 DELETE 操作的过程实际上是先在 B+树中定位到这条记录的位置，然后获取该记录的 X 锁，最后再执行设置删除标记位的操作。因此我们可以把删除操作看作是一个获取 X 锁的锁定读。</p>
<p>对一条记录进行 UPDATE 操作时可以分为三种情况。第一种就是没有修改该记录的键值，并且更新后的列占用的存储空间没有发生变化，那么只需要在 B+树中定位该记录，然后获取该记录的 X 锁，最后完成修改操作即可。因此这个过程可以看作是一个获取 X 锁的锁定读。第二种就是没有修改该记录的键值，但是更新后至少有一个列占用的存储空间发生了变化，那么就需要在 B+树中定位该记录，然后获取该记录的 X 锁，接下来将该记录删除掉，最后再插入一条新的记录。这个定位记录的过程可以看作是一个获取 X 锁的锁定读，而接下来新插入的记录由 INSERT 操作提供的隐式锁来保护。第三种就是修改了该记录的键值，此时相当于在原记录上做了 DELETE 操作后又进行了一次 INSERT 操作。</p>
<p>对于 INSERT 操作来说，新插入一条记录的操作会通过隐式锁来保护这条插入的记录在本事务提交之前不会被其他事务访问。</p>
<h1 id="MySQL-中的锁分类"><a href="#MySQL-中的锁分类" class="headerlink" title="MySQL 中的锁分类"></a>MySQL 中的锁分类</h1><p>从锁的属性来分，锁分为两种：共享锁（S 锁）和独占锁（X 锁）。一个事务获取到了一些记录的 S 锁，其他事务还可以继续获取这些记录的 S 锁，但是不可以获取这些记录的 X 锁。而当一个事务获取到了一些记录的 X 锁，那么其他事务就不能再获取这些记录的 S 锁和 X 锁。也就是 S 锁和 X 锁互斥，同时 X 锁与 X 锁也互斥，只有 S 锁与 S 锁能够共存。</p>
<p>从锁的粒度来分，锁可以分为行锁和表锁。如果给一个表加了 S 锁，那么其他事务可以继续获取该表或者该表中某些记录的 S 锁，但是不能获取该表或者该表中某些记录的 X 锁。而如果给一个表加了 X 锁，那么其他事务既不能给该表或者该表中的某些记录加 S 锁，也不能给该表或者该表中的某些记录加 X 锁。</p>
<p>有的时候我们需要在给表上锁之前检查表中有没有行锁，此时不可能依次遍历每一条记录，因此 InnoDB 提供了一种称为意向锁的表锁。意向锁可以分为意向共享锁（Intention Shared Lock）和意向独占锁（Intention Exclusive Lock）。意向共享锁也叫 IS 锁，当事务准备给某条记录加 S 锁时，需要先给表加一个 IS 锁。而意向独占锁也叫 IX 锁，当事务准备给某条记录加 X 锁时，需要先给表加一个 IX 锁。有了这两种锁，如果我们需要给表加 S 锁，那么就需要检查该表有没有 IX 锁，如果没有则可以给表加 S 锁，否则需要等 IX 锁释放。同样，如果我们需要给表加 X 锁，需要先看该表有没有 IS 锁和 IX 锁，如果没有则可以直接给表加 X 锁，否则需要等待锁释放。</p>
<p>虽然 IS 和 IX 是表锁，但是它们仅仅是为了在给表加锁时可以快速判断表中的记录是否上锁，因此 IS 与 IX 是可以共存的。</p>
<h1 id="InnoDB-中的表锁"><a href="#InnoDB-中的表锁" class="headerlink" title="InnoDB 中的表锁"></a>InnoDB 中的表锁</h1><p>InnoDB 中的表锁除了之前所说的 S 锁和 X 锁，IS 锁和 IX 锁，还有 AUTO-INC 锁，该锁只有在某个列添加了 AUTO_INCREMENT 属性，之后插入记录时才会使用。</p>
<p>在对某个表执行增删改查操作时，InnoDB 存储引擎是不会为该表添加 S 锁或者 X 锁的。只有在一些特殊场景下才会使用，比如崩溃恢复。当然我们也可以手工获取，比如先设置 <code>autocommit=0, innodb_table_locks=1</code>，然后通过 <code>LOCK TABLES t READ</code> 和 <code>LOCK TABLES t WRITE</code> 来分别获取表 t 的 S 锁和 X 锁。另外对于一些 DDL 操作，比如 ALTER TABLE、DROP TABLE 等操作，其实是在 MySQL 的 Server 层使用了一种称为元数据锁（Metadata Locks）的东西来实现的。</p>
<h1 id="InnoDB-中的行锁"><a href="#InnoDB-中的行锁" class="headerlink" title="InnoDB 中的行锁"></a>InnoDB 中的行锁</h1><p>InnoDB 中的行锁有很多种，包括普通的记录锁（官方名称为 <code>LOCK_REC_NOT_GAP</code>）、GAP 锁（又叫间隙锁，官方名称为 <code>LOCK_GAP</code>）、Next-Key Lock（官方名称为 <code>LOCK_ORDINARY</code>）、插入意向锁（官方称为 <code>LOCK_INSERT_INTENTION</code>）。</p>
<p>接下来为了说明方便，先创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hero (</span><br><span class="line">    number <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    country <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> hero <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;l刘备&#x27;</span>, <span class="string">&#x27;蜀&#x27;</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="string">&#x27;z诸葛亮&#x27;</span>, <span class="string">&#x27;蜀&#x27;</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="string">&#x27;c曹操&#x27;</span>, <span class="string">&#x27;魏&#x27;</span>),</span><br><span class="line">    (<span class="number">15</span>, <span class="string">&#x27;x荀彧&#x27;</span>, <span class="string">&#x27;魏&#x27;</span>),</span><br><span class="line">    (<span class="number">20</span>, <span class="string">&#x27;s孙权&#x27;</span>, <span class="string">&#x27;吴&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h2><p>普通的记录锁只会锁住当前行，它有 S 锁和 X 锁之分，它们之间的关系与之前讲的一样，S 锁之间可以共存，S 锁与 X 锁之间、X 锁与 X 锁之间不能共存。在 READ COMMITTED 隔离级别下的当前读大多使用该锁，在 REPEATABLE READ 隔离级别下，唯一索引上的等值当前读也会给索引键对应的行加普通的记录锁。比如下面这个例子：</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>BEGIN;</code></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><code>SELECT * FROM hero WHERE number = 8 FOR UPDATE;</code></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td><code>BEGIN;</code></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><code>INSERT INTO hero VALUES (4, &#39;g关羽&#39;, &#39;蜀&#39;);</code></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td><code>COMMIT;</code></td>
</tr>
<tr>
<td>6</td>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
</tbody></table>
<p>由于 number 是主键，因此在会话 A 中只会给 number &#x3D; 8 的记录加 X 锁，而不是 <code>(3, 8)</code> 这个范围，这样会话 B 中的插入操作可以立即执行而不会阻塞。</p>
<p>如果加锁查询时使用的是辅助索引，那么就需要分别锁定辅助索引和聚簇索引，我们假设上面的例子中 name 是辅助索引。</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>BEGIN;</code></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><code>SELECT * FROM hero WHERE name = &#39;c曹操&#39; FOR UPDATE;</code></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td><code>BEGIN;</code></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><code>INSERT INTO hero VALUES (4, &#39;b&#39;, &#39;蜀&#39;); # 阻塞</code></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td><code>INSERT INTO hero VALUES (4, &#39;d&#39;, &#39;蜀&#39;); # 阻塞</code></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td><code>INSERT INTO hero VALUES (4, &#39;t&#39;, &#39;蜀&#39;); # 立即执行</code></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td><code>COMMIT;</code></td>
</tr>
<tr>
<td>8</td>
<td><code>COMMIT;</code></td>
<td></td>
</tr>
</tbody></table>
<p>上面的例子中，对于聚簇索引，其仅对列 number &#x3D; 8 的行加普通的记录锁；而对于辅助索引，其使用的是 Next-Key 锁，锁定的范围为 <code>(-∞, c曹操)</code>，需要注意的是，InnoDB 存储引擎还会对辅助索引的下一个键值加入 GAP Lock，即还有一个辅助索引范围为 <code>(c曹操, s孙权)</code> 的锁。</p>
<blockquote>
<p>在辅助索引中，“c曹操”的前面没有键值，因此这个间隙是从负无穷开始。后面的键值是“s孙权”，原因是在已有的数据当中，name 列按照字典顺序排序，c 字母的下一个就是 s。由于 t 字母不在这个范围内，因此可以立即执行。只有当首字母相同时，才会使用后面的数据继续排序。</p>
</blockquote>
<h2 id="GAP-Lock"><a href="#GAP-Lock" class="headerlink" title="GAP Lock"></a>GAP Lock</h2><p>我们说 MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，具体来说是通过 MVCC 机制解决了快照读时可能产生的幻读问题，通过 Next-Key Lock 解决了使用当前读时可能产生的幻读问题。</p>
<p>由于在事务在第一次执行读取操作时，那些幻影记录并不存在，因此我们无法给这些记录加上普通的记录锁，这时就可以使用 GAP 锁。如果我们给 number 为 8 的那条记录加一个 GAP 锁，那么就不允许别的事务在 number 值为 8 的记录前的<strong>间隙</strong>插入新的记录，也就是 <code>(3, 8)</code> 这个区间内是不允许立即插入新记录的。比如一个 number 为 4 记录就无法插入到该间隙中。</p>
<p>可以看到，给一条记录添加一个 GAP 锁，只是不允许其他事务在这条记录前的间隙插入新记录，那么如果向最后一条记录之后的间隙插入新记录又该怎么办呢？答案就是给表中最后一条记录，也就是 number 值为 20 的记录所在页面的 Supremum 记录加上一个 GAP 锁。由于 Supremum 记录总是比该数据页中最大的行记录还大，因此可以阻止其他事务向 <code>(20, +∞)</code> 这个区间插入新记录。</p>
<h2 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h2><p>Next-Key 锁本质上就是一个普通的记录锁与一个 GAP 锁的结合，它既能保护该条记录，又能阻止其他事务将新记录插入到当前记录前边的间隙中。因此在上面提供的数据中，可以被 Next-Key Lock 锁住的区间包括：(-∞, 1]、(1, 3]、(3, 8]、(8, 15]、(15, 20]、(20, +∞)。下面通过一个例子来说明 InnoDB 是如何使用 Next-Key 锁来避免当前读可能出现的幻读问题的：</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>BEGIN;</code></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td><code>SELECT * FROM hero WHERE number &gt; 3 FOR UPDATE;</code></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td><code>BEGIN;</code></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><code>INSERT INTO hero VALUES (4, &#39;g关羽&#39;, &#39;蜀&#39;);</code></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td><code>COMMIT;</code></td>
</tr>
<tr>
<td>6</td>
<td><code>SELECT * FORM hero WHERE number &gt; 3 FOR UPDATE;</code></td>
<td></td>
</tr>
</tbody></table>
<p>会话 A 中的查询语句，锁的范围为 <code>(3, +∞)</code>，这就意味着在会话 B 中的插入操作会被阻塞，这样就可以避免出现幻影行。</p>
<h2 id="Insert-Intention-Lock"><a href="#Insert-Intention-Lock" class="headerlink" title="Insert Intention Lock"></a>Insert Intention Lock</h2><p>一个事务在插入一条记录时需要判断插入位置是否被别的事务添加了 GAP 锁或者 Next-key 锁，如果有，那么就需要等待锁释放。该事务在等待的同时，也会生成一个锁结构，表明该事务想在某个间隙中插入新记录，但是现在处于等待状态，这个锁就是插入意向锁。插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 连接的原理</title>
    <url>/2020/09/07/MySQL%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>连接有内连接和外连接之分，而外连接又分为左外连接和右外连接，这些我们都很熟悉。提到连接就不得不提到驱动表和被驱动表的概念，因为是多表联查，肯定需要先查询一张表，然后拿着查询到的记录分别到另一张表中去匹配，这个过程中，首先查询的那张表就是驱动表，而另一张表就是被驱动表。而内连接与外连接的区别，本质就是驱动表中的记录即使在被驱动表中没有与之相匹配的记录时，我们是否仍要将其加入到最终的结果集当中。</p>
<span id="more"></span>

<p>对于左外连接来说，驱动表就是连接符号左侧的那张表，而被驱动表就是连接符号右侧的那张表，右外连接与之相反。对于内连接来说，谁是驱动表，谁是被驱动表，并不会对最终结果产生影响。在一般情况下，MySQL 会将数据量比较小的表作为驱动表，而数据量相对较大的表作为被驱动表。至于为什么会这么做，这就涉及到连接的原理了。</p>
<h1 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested-Loop Join）"></a>嵌套循环连接（Nested-Loop Join）</h1><p>对于使用连接的两张表来说，驱动表只会访问一遍，而被驱动表却要访问很多遍，具体多少遍取决于对驱动表执行单表查询后结果集的大小，之所以这么说，主要与连接的原理有关。我们以两张表 t1 和 t2 进行内连接查询为例，简单说一下连接的查询过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.f1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> t1.f2 <span class="operator">=</span> t2.m1 <span class="keyword">AND</span> t2.m2 <span class="operator">&lt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>首先需要选取一个驱动表，我们假设选择 t1 为驱动表，那么就需要使用与驱动表 t1 相关的过滤条件，选取代价最低的单表访问方法（access method）对驱动表进行单表查询，然后每查询到一条匹配的记录，就拿着它到被驱动表中去寻找相匹配的记录。需要强调的是，这种方式中的 MySQL 并不存储驱动表的查询结果，而是查到一条就操作一条。假设结果集中某条记录的 f2 &#x3D; 2，那么就相当于执行 <code>SELECT * FROM t2 WHERE t2.m1 = 2 AND t2.m2 &lt; 12</code>。整个过程如果用伪代码表示，大概类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for each row in t1 &#123;</span><br><span class="line">  for each row in t2 &#123;</span><br><span class="line">    if row match, send to client</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果有三张表进行连接的话，会将前两张表得到的结果集作为新的驱动表，第三张表作为被驱动表，重复上面的步骤，以此类推，我们可以知道 N 张表进行连接的查询过程。整个过程就像是一个嵌套的循环，这也解释了为什么驱动表只会访问一次，而被驱动表却会访问多次。这种连接执行的查询方式称为嵌套循环连接，这是一种最笨拙但也是最简单的连接查询方式。有人可能会说，被驱动表访问这么多次，会不会影响查询性能啊，与普通的单表查询相比，连接查询肯定是要更慢的，并且这在被驱动表数据量大且没有使用索引的情况下会更加严重。</p>
<p>现在回到一开始我们提出的那个问题，即为什么在进行内连接查询时，MySQL 会选择数据量相对较少的那张表作为驱动表，而选择数据量相对较大的那张表作为被驱动表。原因很简单，前面也说了，连接就是一个嵌套循环，驱动表是外循环，被驱动表是内循环。如果驱动表是那张大表，那么外循环的次数会变多，这也就导致了加载被驱动表数据页的 I&#x2F;O 次数增多；如果驱动表是小表，那么外循环的次数会变少，加载被驱动表数据页的 I&#x2F;O 次数也会减少。</p>
<p>我们假设被驱动表在数据量大的时候执行单表查询需要 3 次 I&#x2F;O，那么可能在数据量较小的时候需要 2 次 I&#x2F;O，驱动表在数据量较大时的结果集为 100 万条，数据量较小时的结果集为 2 万条，我们可以计算得出：在选择大表为驱动表，小表为被驱动表时的 I&#x2F;O 次数为 100 w * 2 &#x3D; 200 w；而选择小表为驱动表，大表为被驱动表时的 I&#x2F;O 次数为 2 w * 3 &#x3D; 6 w。</p>
<h1 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="基于块的嵌套循环连接（Block Nested-Loop Join）"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h1><p>嵌套循环的方式虽然简单，但是明显还有很大的优化空间。由于在驱动表中每查询到一条匹配的记录就要再到被驱动表中去查询，所以最终驱动表匹配的记录有多少条，就需要查询几次被驱动表，如果我们将驱动表查询到的结果先存起来，等达到一定的量之后，再一次性地到被驱动表中去查询，这样不就可以减少加载被驱动表的 I&#x2F;O 次数了吗？（将多条驱动表记录合并在一起作为条件到被驱动表中进行查询，很大概率会出现符合条件的记录在一个数据页中）这就是基于块的嵌套循环连接所采用的思想，它提供了一个称为 join buffer 的缓存，用来存储驱动表查询得到的部分记录，该缓存的大小可以通过参数 <code>join_buffer_size</code> 设置，默认大小为 256 KB。当缓存已满或者是最后一条记录的时候，才一次性地和被驱动表进行匹配，这样就可以显著减少加载被驱动表的 I&#x2F;O 次数。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos 共识算法</title>
    <url>/2020/08/13/Paxos%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>共识算法的主要目的是屏蔽掉故障节点产生的噪音，从而让系统能够正常运行下去，常用于选举和状态机复制（state machine replication）。在保证 liveness 的同时，对 agreement 条件放宽了要求，它接受不一致是常态的事实，既然无法知道某些节点是 crash 还是消息延迟，那么只关心能够正确响应的节点，只要它们能够表决过半即可。过半表决意味着虽然没有达成完全一致，但是投票结果已经被过半的节点所继承，这样任何两个 quorum 一定会存在交集（比如 A、B、C 三个节点，两个 quorum 比如 AB 和 BC 一定会有交集 B），所以它们最终一定能通过消息交互而达成一致。</p>
<span id="more"></span>

<p>Paxos 算法由 Lamport 提出，他为了描述该算法，虚拟出了一个叫做 Paxos 的希腊城邦，这个城邦按照民主投票的方式制定法令，但是没有人愿意将自己的全部时间和精力放在这上面，无论是提议者还是接收者亦或是信使，他们只会不定时地来参加提议。Paxos 算法的目的就是让他们按照少数服从多数的方式达成一致的意见。在他的论文中，Paxos 共有三种不同的变种：Basic Paxos、Multi Paxos 和 Fast Paxos。</p>
<h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul>
<li><p>Client<br>客户端，可以理解为普通民众，他们不直接参与提议，但是他们会希望通过一个对自己有利的法令。</p>
</li>
<li><p>Proposer<br>提议者，可以理解为议员，他们接收 Client 的请求，代表民众向议会中的其他议员提出提议（Proposal），并在发生冲突时起到调节的作用。</p>
</li>
<li><p>Acceptor<br>提议接收者，可以理解为议会中的其他议员，他们接收提议者提出的提议，只有接收到提议的成员达成法定人数（quorum，一般为 majority 多数派）时，提议才会形成法令。</p>
</li>
<li><p>Learner<br>同样也是提议接收者，只不过他们并不参与提议过程，有点像议会记录人员，只负责记录已经通过的法令。</p>
</li>
</ul>
<h1 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h1><p>Basic Paxos 分为两个大的阶段，同时每个大的阶段又分为两个小的阶段。</p>
<ol>
<li>Phase 1a：Prepare</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br></pre></td></tr></table></figure>
<p>proposer 向任意一个多数派 acceptor 集合发起一个编号 number 为 n 的预请求（prepare request）。</p>
<ol start="2">
<li>Phase 1b: Promise</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |  &lt;ok, null, null&gt;  |</span><br><span class="line">   |&lt;-------------------|</span><br></pre></td></tr></table></figure>
<p>如果一个 acceptor 接收到了预请求，并且预请求的编号 n 大于任何它之前已经回复过的请求（包含 prepare request 和 accept request），那么它将承诺不再接受任何编号小于 n 的提议（proposal），并回复已经接受的编号最大的提议（如果有的话）。</p>
<ol start="3">
<li>Phase 2a: Accept</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |  &lt;ok, null, null&gt;  |</span><br><span class="line">   |&lt;-------------------|</span><br><span class="line">   |                    |</span><br><span class="line">   |    accept(n, v)    |</span><br><span class="line">   |-------------------&gt;|</span><br></pre></td></tr></table></figure>
<p>如果 proposer 接收到了来自 acceptor 对它预请求的回复，那么接下来它就可以向多数派 acceptor 集合（可以不是回复预请求的那个集合）发送一个 number 为 n，value 为 v 的提议（proposal）。其中的 v 要么是 proposer 自定义的值，要么就是预请求响应中的 value 值。我们将这样的一个请求称为 accept request。</p>
<ol start="4">
<li>Phase 2b: Accepted</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |  &lt;ok, null, null&gt;  |</span><br><span class="line">   |&lt;-------------------|</span><br><span class="line">   |                    |</span><br><span class="line">   |    accept(n, v)    |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |     &lt;ok, n, v&gt;     |</span><br><span class="line">   |&lt;-------------------|</span><br></pre></td></tr></table></figure>
<p>如果 acceptor 接收到了 number 为 n 的 accept request，并且它没有对 number 大于 n 的 prepare request 进行过回复，那么就接受这个 accept request。</p>
<p>Basic Paxos 算法中还有很多细节，可能通过上述步骤并没有很好地展现出来，这里简单列举一下：</p>
<ul>
<li><p>acceptor 必须接受它收到的第一个 proposal。并且通过上述步骤可以发现，如果一个 value 为 v 的 proposal 被选中，那么所有被选中的拥有更大编号的 proposal 的 value 值也都是 v。</p>
</li>
<li><p>acceptor 本地主要存储两个值，一个是已经接受的 proposal，另一个就是回复过的 prepare request 中最大的编号。</p>
</li>
<li><p>acceptor 总是能够对 prepare request 进行回复，除非 acceptor 还没有接受一个 proposal，同时这个 prepare request 的编号小于 acceptor 已经回复过的 prepare request 中最大的编号。</p>
</li>
<li><p>与我们的常识不同，每个 proposer 并不会执着于自己的提议通过，而是会努力让一个提议尽快达成一致。</p>
</li>
<li><p>上面没有画出 learner，但是在 acceptor 接受了一个 proposal 之后，需要 acceptor 将这个 proposal 发送给所有的 learner，由 learner 来确定是否有一个 proposal 已经被多数派接受了，之后 learner 会将最终结果发送给 Client。</p>
</li>
</ul>
<h2 id="Basic-Paxos-的潜在问题"><a href="#Basic-Paxos-的潜在问题" class="headerlink" title="Basic Paxos 的潜在问题"></a>Basic Paxos 的潜在问题</h2><p>在 prepare request 阶段可能会出现活锁，即多个 proposer 不断拿着比其他人更大的 number 来发起 prepare request，导致算法一直停留在第一阶段，可以看出，这是一个关于 liveness 的问题。目前工业界的解决方案很简单，就是在发生冲突时，加入随机等待时间，在 timeout 之后再发起 prepare request。</p>
<p>Basic Paxos 还有一些其他问题，比如可能比较难以实现，同时由于需要两轮 RPC，导致效率较低。</p>
<h1 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h1><p>Basic Paxos 通过多轮的 prepare&#x2F;accept 过程来确定一个值，我们可以称这整个过程为一个 instance。而如果需要确定很多个值，那么每个值的确定都需要经过一个 instance，显然效率不是很高。而 Multi Paxos 就是通过改变 promise 的生效范围至全局的 instance，使得我们之后可以省略第一阶段的工作（即使不 prepare 就直接 accept 也是安全的，因为 accept 已经被其中某个节点 promise 过了）。</p>
<p>上面的说法有些抽象，具体来说就是：首先也是有一些 proposer，但是依靠某种机制（比如 Raft 中的随机超时时间），proposer 集合中的某一个 proposer 自发地想成为 leader，此时它需要向 acceptor 集合中发起与 Basic Paxos 类似的两轮 RPC，在形成了多数派之后，此 proposer 才会正式成为 leader。接下来就通过 leader 来发起提议，并且不需要向 acceptor 集合发起 prepare request，直接发起 accept request 即可。</p>
<p>需要注意的是，Multi Paxos 是允许并行提交的，这就意味着可以不通过 leader 发起提议，但是这种情况下效率就会降低。比如在有一个 leader 的情况下，另一个 proposer 发起提议，就会导致 leader 的 accept 不被接受，此时就退化成了 Basic Paxos。因此我们希望大部分时间只有一个节点在提交，这样才能发挥 Multi Paxos 的优化效果。那么为了避免或者说是降低这种情况的发生，就需要一些控制：如果一个节点向其他节点发送 accept request，并且最后收到了来自其他节点的 accepted 回复，那么这个节点会认为自己是 leader，它会在一段时间内，拒绝其他节点的 prepare 请求。如果一个节点收到了来自其他节点的 accept request，那么它会认为请求方是 leader，并承诺在一段时间内不会发起 prepare request。正是这种“默契”才间接地说明了 leader 的存在，所以说在 Multi Paxos 中，leader 不是靠选举产生的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/21466932">Paxos 理论介绍(2): Multi-Paxos 与 Leader</a></p>
</blockquote>
<blockquote>
<p>《Paxos Made Simple》</p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 协程</title>
    <url>/2019/02/28/Python%20%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>在学习 Python 的协程之前，先要了解 Python 的 List Comprehensions 和 Generators。  </p>
<span id="more"></span>  

<h1 id="List-Comprehensions"><a href="#List-Comprehensions" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h1><p>List Comprehensions 一般被称为列表生成式，使用它可以用来创建 list 集合。  </p>
<p>生成简单的 list，比如 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，可以使用 <code>list(range(1, 11))</code> 来实现。对于复杂的，比如 <code>[1*1, 2*2, 3*3, ..., 10*10]</code>，我们就可以通过列表生成式来生成，写成 <code>[x * x for  x in range(1, 11)]</code>。  </p>
<p>在列表生成式中还可以加入条件判断，满足条件的才会生成，比如：<code>[x * x for x in range(1, 11) if x % 2 == 0]</code> 会仅生成偶数的平方 list 集合。  </p>
<p>由于 for 循环其实可以同时使用两个甚至多个变量，比如 dict 的 items() 方法可以同时迭代 key 和 value，所以列表生成式也可以使用两个变量来生成 list，比如：<code>[k + &quot;=&quot; + v for k, v in &#123;&#39;x&#39;: &#39;X&#39;, &#39;y&#39;: &#39;Y&#39;&#125;.items()]</code>。  </p>
<h1 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h1><p>使用列表生成式可以很方便地创建一个列表，但是这个列表的容量肯定是受限的，不能无限大，并且如果只使用列表前面的一部分数据，那么分配的大部分内存空间就被浪费掉了。Python 的生成器采用了另外一种思路，即并不预先创建出所有的数据，而是只将创建元素的逻辑提前编写好，在需要使用元素时，通过该逻辑计算出元素的值。  </p>
<p>在 Python 中，创建 Generators 主要有两种方式。  </p>
<p>第一种方式很简单，将列表生成式的方括号改为圆括号即可。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表生成式</span></span><br><span class="line">l = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line"><span class="comment"># 获取生成器的下一个值</span></span><br><span class="line">n = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<p>当推算的算法比较复杂时，可以用第二种方式，也就是函数的方式去实现。  </p>
<p>比如斐波那契数列，第一个数和第二个数都是 1，除了它俩，其余任意一个数都可由前两个数相加得到。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">num</span>):</span><br><span class="line">    i, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; num:</span><br><span class="line">        <span class="built_in">print</span>(b, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这种由前面的元素推算后续元素的逻辑非常类似生成器，此时只要将函数中的打印值改为 <code>yield b</code> 即可将函数变成生成器。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">num</span>):</span><br><span class="line">    i, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; num:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(fib(<span class="number">11</span>)))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(fib(<span class="number">11</span>), types.GeneratorType))</span><br></pre></td></tr></table></figure>

<p>在函数中，代码是顺序执行的，遇到 return 语句或者执行完毕后返回；而生成器在每次调用 next() 时执行，遇到 yield 语句返回，下次执行时会从上次返回的 yield 语句处继续执行。  </p>
<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><p>协程也叫做微线程，纤程，英文名为 Coroutine，可以看做是<strong>用户态的轻量级线程。</strong>  </p>
<p>在说协程之前，我们先简单回忆一下进程和线程。进程可以简单理解为程序的启动实例，比如运行一个游戏，打开一个软件，就是开启了一个进程。而线程通常从属于进程，是程序的实际执行者。<strong>对于操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong>  </p>
<p>协程在外观上看就是一段函数，但是在执行过程中，函数内部是可以中断的，然后转而去执行别的函数（并不是函数调用），并在适当的时候再返回来接着执行。从现象上看，有点类似 CPU 的中断，比如：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printNum</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printWord</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printNum()</span><br><span class="line">printWord()</span><br></pre></td></tr></table></figure>

<p>假如上述代码通过协程去执行，那么 printNum() 在执行过程中随时可以中断去执行 printWord()，结果可能为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">3</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>这个结果看起来像是使用了多线程，然而实际上<strong>协程使用的是单个线程。</strong>  </p>
<h1 id="协程与进程和线程的区别"><a href="#协程与进程和线程的区别" class="headerlink" title="协程与进程和线程的区别"></a>协程与进程和线程的区别</h1><p>协程与进程和线程的根本区别是，进程和线程是操作系统级别的，而协程是编译器级别的。虽然进程和线程在语言层次都有体现，但本质上都是操作系统提供的 API，程序的执行依赖操作系统的调度算法，每次暂停的位置是不确定的，也就意味着重新开始的位置不可预知；而协程是编译器的魔术，通常插入相关的代码使得代码段能够实现分段式的执行，每次执行遇到 yield 返回，重新开始时会从上一次的 yield 处继续向下执行。  </p>
<h1 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h1><ul>
<li><p>不存在线程切换开销<br>因为协程是函数切换而不是线程切换，<strong>切换的位置可以由程序自身控制</strong>，因此也就没有线程切换的开销。和多线程比，线程数量越多，协程的性能优势就越明显。  </p>
</li>
<li><p>不存在线程安全问题<br>由于不是多线程，也就不需要多线程的锁机制，因为只有一个线程，也就不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
</li>
</ul>
<h1 id="协程的劣势"><a href="#协程的劣势" class="headerlink" title="协程的劣势"></a>协程的劣势</h1><ul>
<li><p>无法发挥多核性能<br>由于协程使用的是单个线程，所以它无法充分发挥 CPU 的多核性能。当然我们可以通过使用多进程 + 协程的方式来充分利用多核，我们日常编写的大部分代码都没有必要这么做，除非是在 CPU 密集型应用中。  </p>
</li>
<li><p>协程阻塞时会阻塞整个程序<br>协程在遇到阻塞操作，如 IO 操作时会阻塞掉整个程序，因此我们使用协程时一般会配合 Event Loop 进行异步操作。</p>
</li>
</ul>
<h1 id="Python-的实现"><a href="#Python-的实现" class="headerlink" title="Python 的实现"></a>Python 的实现</h1><p>在 Python 2.x 中，协程主要通过生成器配合 yield 和 send 来实现，或者使用第三方库，比如 <code>greenlet</code>，甚至是 <code>gevent</code>。  </p>
<p>在 Python 3.3 中，官方加入了 yield from 语法，在 3.4 版本中还提供了支持异步 IO 的标准库 <code>asyncio</code>，在 3.5 版本中，加入了基于 <code>asyncio</code> 的新语法 <code>async/await</code>。因此在 Python 3.x 中实现协程可以有多种组合方式，比如：  </p>
<ul>
<li>在 Python 3.4 版本中，可以通过 <code>asyncio</code> + yield from 的方式实现</li>
<li>在 Python 3.5 版本中，可以通过 <code>async/await</code> 实现</li>
<li>使用第三方库 <code>gevent</code></li>
</ul>
<p>协程在运行的过程中共有四种状态，<code>GEN_CREATE</code>（等待执行）、<code>GEN_RUNNING</code>（正在执行）、<code>GEN_SUSPENDED</code>（中断执行） 和 <code>GEN_CLOSED</code>（执行结束）。这个状态可以通过 getgeneratorstate() 方法获取，在调用生成器生成对象后，此时的协程处于 <code>GEN_CREATE</code> 状态，即等待开始的状态。接下来需要预激协程，此时可以通过 next() 或者 send(None) 预激。预激之后的协程开始执行，当运行到 yield 处会中断执行，此时的状态就是 <code>GEN_SUSPENDED</code>。  </p>
<h2 id="基于生成器实现"><a href="#基于生成器实现" class="headerlink" title="基于生成器实现"></a>基于生成器实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_coroutine</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coroutine started&#x27;</span>)</span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coroutine received: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"></span><br><span class="line">    m = simple_coroutine()</span><br><span class="line">    <span class="comment"># 获取协程的状态</span></span><br><span class="line">    <span class="built_in">print</span>(getgeneratorstate(m))</span><br><span class="line">    <span class="comment"># 使用 next 方法预激</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(m))</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    m.send(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>在使用 Generators 实现协程时，yield 通常出现在表达式的右边，比如 <code>x = yield</code>。yield 可以产出值，也可以不产出值。如果 yield 右边没有表达式，那么值为 None，比如 <code>x = yield</code> 产出的值就是 None，而 <code>x = yield b</code> 产出的值为 b 的值。同时在调用方可以通过 send() 方法发送数据给协程，发送的数据会成为 yield 表达式的值。  </p>
<h3 id="终止协程和异常处理"><a href="#终止协程和异常处理" class="headerlink" title="终止协程和异常处理"></a>终止协程和异常处理</h3><p>在 Python 2.5 之后，生成器对象添加了 throw 和 close 方法，throw 方法会让生成器在暂停的 yield 表达式处抛出指定的异常，如果生成器处理了该异常，那么代码会继续执行到下一个 yield 表达式。如果没有处理该异常，或者抛出了另一个异常，那么异常会向上传递到调用方。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_test_throw</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coroutine started&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span> b</span><br><span class="line">        <span class="keyword">except</span> TestException:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;TestException handled&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;coroutine received: &#x27;</span>, x)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;测试 throw 后代码的执行情况&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = demo_test_throw(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(m))</span><br><span class="line">    <span class="comment"># 抛出自定义异常</span></span><br><span class="line">    m.throw(TestException)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(m))</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    coroutine started</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    TestException handled</span></span><br><span class="line"><span class="string">    测试 throw 后代码的执行情况</span></span><br><span class="line"><span class="string">    coroutine received:  None</span></span><br><span class="line"><span class="string">    测试 throw 后代码的执行情况</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在生成器因为没有后续语句而退出时，如果没有 yield 值产生，则会抛出一个 <code>StopIteration</code> 异常。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_test_throw</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coroutine started&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="keyword">yield</span> b</span><br><span class="line">    <span class="keyword">except</span> TestException:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;TestException handled&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coroutine received: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = demo_test_throw(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(m))</span><br><span class="line">    <span class="comment"># 抛出自定义异常</span></span><br><span class="line">    m.throw(TestException)</span><br><span class="line">    <span class="comment"># 最终会抛出一个 StopIteration 异常</span></span><br></pre></td></tr></table></figure>

<p>close 方法会让生成器在暂停的 yield 表达式处抛出 <code>GeneratorExit</code> 异常，如果生成器没有处理这个异常，或者抛出了 <code>StopIteration</code> 异常，则调用方不会报错。如果抛出了其他异常，则会向上传递给调用方。在抛出 <code>GeneratorExit</code> 异常后，生成器一定不能产生值，否则会抛出 <code>RuntimeError</code> 异常。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_test_close</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coroutine started&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="keyword">yield</span> b</span><br><span class="line">    <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coroutine closed&#x27;</span>)</span><br><span class="line">        <span class="comment"># 这里加入 yield 表达式会抛出 RuntimeError</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coroutine received: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = demo_test_close(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(m))</span><br><span class="line">    m.close()</span><br></pre></td></tr></table></figure>

<h3 id="装饰器预激协程"><a href="#装饰器预激协程" class="headerlink" title="装饰器预激协程"></a>装饰器预激协程</h3><p>协程如果不预激则无法使用，为了简化调用过程，我们可以使用装饰器来预激协程。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coroutine</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    装饰器，预激 fn</span></span><br><span class="line"><span class="string">    :param fn:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 把装饰器生成器函数替换成这里的 primer</span></span><br><span class="line">    <span class="comment"># 函数调用 primer 函数时，返回预激后的生成器</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">fn</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">primer</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 调用被装饰的函数，获取生成器对象</span></span><br><span class="line">        generator = fn(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 预激生成器</span></span><br><span class="line">        <span class="built_in">next</span>(generator)</span><br><span class="line">        <span class="comment"># 返回生成器</span></span><br><span class="line">        <span class="keyword">return</span> generator</span><br><span class="line">    <span class="keyword">return</span> primer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_coroutine</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coroutine started&#x27;</span>)</span><br><span class="line">    x = <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coroutine received: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"></span><br><span class="line">    m = simple_coroutine()</span><br><span class="line">    <span class="comment"># 获取协程的状态</span></span><br><span class="line">    <span class="built_in">print</span>(getgeneratorstate(m))</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    m.send(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 Python 3 中，生成器可以返回值，在协程结束后（通过 return 正常返回，而不是主动停止），调用方可以通过捕获 <code>StopIteration</code> 异常来获取返回值。    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_test_return</span>():</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tmp = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += tmp</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    m = demo_test_return()</span><br><span class="line">    <span class="built_in">next</span>(m)</span><br><span class="line">    m.send(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        m.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        result = e.value</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><p>yield from 是从 Python 3.3 开始添加的语法，在其他语言中，类似的结构使用 <code>await</code> 关键字。在 yield from 的后面需要添加的是可迭代对象，它可以是普通的可迭代对象，也可以是迭代器，甚至是生成器。  </p>
<p>我们可以通过一个例子简单认识 yield 和 yield from 的区别。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_test_yield_from</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> item:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = <span class="string">&#x27;AB&#x27;</span></span><br><span class="line">    li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;saber&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">22</span>&#125;</span><br><span class="line">    g = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    generator = demo_test_yield_from(s, li, d, g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(generator))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_test_yield_from</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = <span class="string">&#x27;AB&#x27;</span></span><br><span class="line">    li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    d = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;saber&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">22</span>&#125;</span><br><span class="line">    g = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    generator = demo_test_yield_from(s, li, d, g)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(generator))</span><br></pre></td></tr></table></figure>

<p>更复杂的，我们可以在 yield from 后面加入子生成器来实现生成器的嵌套。当然使用 yield 也可以完成生成器的嵌套，但是使用 yield from 可以避免自己处理很多意料不到的异常，从而专注于业务实现。  </p>
<p>在生成器的嵌套中，有几个重要的概念。比如，委派生成器指的是包含 yield from 表达式的生成器函数，子生成器指的是 yield from 后边添加的生成器函数，而调用方指的是调用委派生成器的客户端。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_sum</span>():</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tmp = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += tmp</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proxy_generator</span>(<span class="params">results</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        results[<span class="string">&#x27;total&#x27;</span>] = <span class="keyword">yield</span> <span class="keyword">from</span> calculate_sum()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    cal_sum = proxy_generator(results)</span><br><span class="line">    <span class="comment"># 预激</span></span><br><span class="line">    <span class="built_in">next</span>(cal_sum)</span><br><span class="line">    cal_sum.send(<span class="number">10</span>)</span><br><span class="line">    cal_sum.send(<span class="number">22</span>)</span><br><span class="line">    cal_sum.send(<span class="number">14</span>)</span><br><span class="line">    cal_sum.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(results[<span class="string">&#x27;total&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>委派生成器的作用是在调用方和子生成器之间建立一个<strong>双向通道</strong>。调用方可以通过 send() 方法直接发送消息给子生成器，而子生成器产生的 yield 的值也可以直接返回给调用方。  </p>
<p>yield from 的具体语义很难理解，我们为什么还要使用它呢？比如我们需要返回值，完全可以麻烦点通过异常的方式获取。其实 yield from 在背后为我们做了很多事，具体做了什么可以参考下面官方提供的说明。比如 <code>RESULT = yield from EXPR</code> 语句，解释器在背后做了哪些工作呢？  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_i = <span class="built_in">iter</span>(EXPR)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = <span class="built_in">next</span>(_i)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.close</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()</span><br><span class="line">            <span class="keyword">raise</span> _e</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e:</span><br><span class="line">            _x = sys.exc_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.throw</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _y = _m(*_x)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    _y = <span class="built_in">next</span>(_i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                _r = _e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">RESULT = _r</span><br></pre></td></tr></table></figure>

<h2 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h2><p>使用 yield 可以实现协程，但是实现的过程不易于理解，我们可以使用第三方库 <code>greenlet</code> 来实现相同的效果。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_demo1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;inner demo 01&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        g2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_demo2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;inner demo 02&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        g1.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建协程</span></span><br><span class="line">    g1 = greenlet(test_demo1)</span><br><span class="line">    g2 = greenlet(test_demo2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 手动切换至 g1，先启动 g1</span></span><br><span class="line">    g1.switch()</span><br></pre></td></tr></table></figure>

<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>asyncio 是 Python 3.4 版本引入的标准库，它支持异步 IO 操作。asyncio 的编程模型就是一个消息循环，类似 JavaScript 中的 Event Loop，我们将需要执行的协程放入 EventLoop 中就可以实现异步操作。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World! (%s)&quot;</span> % threading.current_thread())</span><br><span class="line">    <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello Python! (%s)&quot;</span> % threading.current_thread())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 获取 EventLoop</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 执行协程</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait([hello_world(), hello_world()]))</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure>

<p>@asyncio.coroutine 把一个 generator 标记为 coroutine 类型，然后放到 EventLoop 中去执行。由于 <code>asyncio.sleep()</code> 也是一个协程，所以我们可以使用 yield from 接收，但是主线程并不会一直等待它执行完毕，而是直接中断并去执行下一个消息循环。当 <code>asyncio.sleep()</code> 返回时，主线程就可以从 yield from 处拿到返回值（此处是 None），然后继续向下执行。  </p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><p>为了更好的标识异步 IO，从 Python 3.5 开始引入了新的语法 <code>async</code> 和 <code>await</code>，使用该语法只需要将 @asyncio.coroutine 替换为 <code>async</code>，再把 yield from 替换为 await 即可。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World! (%s)&quot;</span> % threading.current_thread())</span><br><span class="line">    <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    r = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello Python! (%s)&quot;</span> % threading.current_thread())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 获取 EventLoop</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 执行协程</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait([hello_world(), hello_world()]))</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/23895384">在 Unity 中 StartCoroutine&#x2F;yield return 这个模式到底是怎么应用的？其中的原理是什么？</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">Python 教程</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0380/">PEP 380 – Syntax for Delegating to a Subgenerator</a>  </p>
</blockquote>
<blockquote>
<p>《流畅的 Python》</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 虚拟环境</title>
    <url>/2019/03/08/Python%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>在初学 Python 时，我使用的是官方推荐的 Pipenv，一开始用起来还好，但是每次创建和修改 lock 文件时都会卡住很长时间，在切换了其他镜像后问题依旧，最后忍无可忍直接放弃了 Pipenv，改用原始的 pip + virtualenv 的方式。  </p>
<span id="more"></span>

<h1 id="为什么要使用虚拟环境"><a href="#为什么要使用虚拟环境" class="headerlink" title="为什么要使用虚拟环境"></a>为什么要使用虚拟环境</h1><p>我们在使用 pip 安装第三方包时，通常都会安装到 Python 的 <code>site-packages</code> 目录中。比如我本地的是 Windows 平台，安装目录为 <code>C:\Users\nekolr\AppData\Roaming\Python\Python37\site-packages</code>。我们可以通过 <code>py -m site --user-site</code> 命令查看 pip 的安装目录，也可以通过 <code>pip list</code> 命令列出所有通过 pip 安装的包，然后再通过 <code>pip show 包名</code> 来查看每个包具体的安装路径。  </p>
<p>如果我们要同时开发多个应用，所有的应用都会使用同一个 Python 环境，那么使用 pip 命令安装的包都会在同一个目录中。这会存在两个问题：一个问题是当应用很多时该目录会膨胀到很大，不利于 IDE 进行索引；另一个问题是由于使用 pip 安装的包不会带有版本后缀，因此只会有一个版本，如果不同的应用需要使用不同版本的包，这就无法实现了。  </p>
<p>因此我们需要每个应用都能够有一套自己独立的 Python 运行环境，这也就是 virtualenv 的由来。  </p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>为了能够全局使用 python 和 pip 命令，以及后续我们安装的第三方包提供的命令，我们需要设置环境变量。  </p>
<p>设置 <code>PYTHON_HOME</code> 为 Python 的安装目录，同时在 <code>PATH</code> 中加入 <code>%PYTHON_HOME%</code> 和 <code>%PYTHON_HOME%\Scripts</code>，这样我们就可以在全局使用 python 和 pip 等命令了。接下来再添加第三方包的命令的搜索目录，为此我创建了 <code>PIPINSTALL</code> 变量，然后使用 <code>py -m site --user-site</code> 找到 pip 的第三方包安装目录，把最后的 site-packages 替换为 Scripts，这个替换后的路径作为 <code>PIPINSTALL</code> 变量的值，然后将该变量加入到 <code>PATH</code> 变量的值中。  </p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 virtualenv 比较简单，直接通过 pip 命令安装。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>

<p>pip 默认会从 <a href="https://pypi.org/simple">https://pypi.org/simple</a> 处下载第三方包，如果下载速度较慢，可以切换到其他源下载。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">pip install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"><span class="comment"># 阿里云源</span></span><br><span class="line">pip install virtualenv -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>假如我们有一个新项目需要一套独立的 Python 运行环境，我们可以通过以下步骤操作。  </p>
<p>首先，我们要创建项目，然后通过 cd 切换到项目所在目录。  </p>
<p>然后使用 <code>virtualenv --no-site-packages venv</code> 命令来创建一个独立的 Python 运行环境，这里的 venv 是我自己指定的虚拟环境的名称，<code>no-site-packages</code> 参数意为不会将 site-packages 下的包复制到新环境中，因此我们就能够得到一个干净的新环境。  </p>
<p>这个新环境默认会在当前应用的目录下创建一个与创建虚拟环境时指定的虚拟环境名称相同的目录，比如我上面创建虚拟环境时指定的名称为 venv，因此在当前应用下会出现一个新的名为 venv 的文件夹。然后我们可以通过该目录下的 Scripts 目录中的命令来进入虚拟环境。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ venv\Scripts\activate</span><br></pre></td></tr></table></figure>

<p>进入虚拟环境后，在命令提示符前面会多出一个 (venv) 前缀。在 venv 环境下，用 pip 安装的包都被安装到 venv 这个环境下，系统 Python 环境不会受到任何影响。如果想退出虚拟环境，可以使用 <code>deactivate</code> 命令。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ venv\Scripts\deactivate</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000">virtualenv</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC 概述</title>
    <url>/2019/11/13/RPC%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>RPC，也就是远程过程调用（Remote Procedure Call），通俗的解释就是通过网络来请求服务，而不需要了解底层网络技术的协议和细节。可能就是因为这个通俗的解释，造成很多人混淆了 HTTP 与 RPC。</p>
<span id="more"></span>

<p>首先需要明确的是 HTTP 与 RPC 从严格意义上讲不是并行的概念，虽然它们的最终目的都是通过网络来请求服务，但是 HTTP 只是一种工作在应用层的简单的请求-响应协议，而 RPC 更多的是一种概念、编程模式或者说是框架。维基百科上对于 RPC 的定义更为严谨，它说：RPC 是指计算机程序在运行过程中导致子进程在不同的地址空间（通常是指不同的机器）运行时，其编码方式与在本地的过程调用相同，即无论子进程（子程序）正在执行的是本地程序还是远程程序，程序的编码基本相同。比如在 Java 中，使用 Dubbo 获取远程业务类时与在本地使用该类的方式是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@com</span>.alibaba.dubbo.config.annotation.Reference</span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;orderId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">getOrder</span><span class="params">(<span class="meta">@PathVariable</span> String orderId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.getOrderById(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RPC 是进程间通信（IPC，Inter process communication）的一种形式，因为不同的进程具有不同的地址空间，与之相对的是本地过程调用（LPC，Local Procedure Call）。要实现一个 RPC 框架，首先需要解决的就是网络传输，也就是通信的问题。通信协议可以选择使用 HTTP，比如 Google 开源的 <a href="https://github.com/grpc/grpc">gRPC</a> 就是使用的 HTTP&#x2F;2 作为通信协议；也可以选择在 TCP 的基础上定制私有协议，比如 <a href="https://github.com/apache/dubbo">Dubbo</a> 使用的 Dubbo 协议就是在 TCP 协议的基础上封装了自己的报文格式。</p>
<p>当我们解决了通信问题后，就可以开始调用远程方法了，那么我们怎么知道要调用哪个方法呢？我们可以很容易的在本地调用本地的某个对象的某个方法，但是在本地调用远程的方法时就不会这么简单了，因为这两个应用，具体来说是这两个进程的地址空间完全不同。所以此时需要解决的问题是寻址问题，也就是要找到具体应该调用哪个主机的哪个端口的哪个方法。比如在 RMI 中，需要提供一个 RMI Registry 来注册服务的地址，然后通过这个地址就可以调用指定的方法。</p>
<p>假设我们已经解决了寻址问题，但是方法不可能都是空参数的方法啊，如果方法需要传参怎么办？在本地调用时，我们只需要把参数压到栈里，然后让函数到栈里读取就可以了。但是在远程调用的过程中，客户端跟服务端是不同的进程，因此参数不能直接通过内存来传递。甚至有时候我们的客户端与服务端都不是使用同一种语言来实现的。由于我们的参数需要经过网络传输，所以参数最终必须转换成二进制的数据，而参数是在内存中的，所以我们需要将内存中的参数序列化成我们需要的二进制的形式。</p>
<p>在这里需要多说一些有关序列化的内容。我们知道序列化（Serialization）是将程序中的数据结构或对象的状态信息转换为可以存储或者可以通过网络传输的形式的过程，而反序列化（Deserialization）则是序列化的反向过程。在序列化之前，对象或数据结构作为一种结构化的数据被保存在内存当中，由于我们需要将它持久化或者通过网络将它传输到其它机器，此时就需要将内存中的对象进行序列化，从而形成可以取用的格式（例如文件，或经由网络传输）。序列化后的数据格式一般需要满足数据结构化的需求，这里比较有代表性的格式就是 XML 和 JSON。</p>
<p>序列化后数据的格式（也可以称为数据交换格式）大致可以分为三类：自解析型、半解析型和无解析型。自解析型的数据包含完整的结构，包括字段的名称、类型和值，调整不同属性的顺序对序列化和反序列化没有影响，比较有代表性的有 XML、JSON、Java Serialization 以及百度的 <code>mcpack/compack</code> 等。半解析型的数据丢弃了部分信息，比如字段的名称，但引入了 index（通常是 id + type 的方式）来对应具体的属性，比较有代表性的有 Google protobuf、Apache Thrift 等。而无解析型则丢弃了很多有效信息，性能和压缩比最好，但是向后兼容需要做一定的工作，传说中百度的 <code>infpack</code> 就属于此列。</p>
<table>
<thead>
<tr>
<th>数据传输格式</th>
<th>类型</th>
<th>平台相关性</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>XML</td>
<td>文本</td>
<td>无</td>
<td>可读性高，序列化后的数据包含完整的结构，调整不同属性的顺序不影响序列化和反序列化</td>
<td>序列化后的数据量大，不支持二进制数据类型</td>
</tr>
<tr>
<td>JSON</td>
<td>文本</td>
<td>无</td>
<td>可读性高，调整不同属性的顺序不影响序列化和反序列化</td>
<td>丢弃了类型信息，比如 “price”: 10，对 price 类型的解析有二义性（是 int 还是 double），不支持二进制数据类型</td>
</tr>
<tr>
<td>Java Serialization</td>
<td>二进制</td>
<td>Java 平台</td>
<td>使用简单</td>
<td>可读性较差，序列化后的数据量较大，序列化和反序列化性能较差</td>
</tr>
<tr>
<td>Apache Thrift</td>
<td>二进制</td>
<td>无</td>
<td>序列化后的数据量较小，序列化和反序列化性能较高</td>
<td>可读性较差，向后兼容有一定的限制，采用 id 递增的方式标识并以 optional 修饰来添加</td>
</tr>
<tr>
<td>Google protobuf</td>
<td>二进制</td>
<td>无</td>
<td>序列化后的数据量较小，序列化和反序列化性能较高</td>
<td>可读性较差，向后兼容有一定的限制</td>
</tr>
</tbody></table>
<p>我们接着说，假设客户端上的应用发起了远程过程调用，方法的参数在序列化之后连同请求一起通过底层的网络协议传输到服务器，服务器在接收到请求后，需要对参数进行反序列化的操作，将参数恢复为内存中的表达方式，然后通过寻址找到对应的方法，从而进行本地调用并得到返回值。返回值同样需要经过序列化返回给客户端上的应用，客户端在接收到响应后，同样需要进行反序列化恢复为内存中的表达方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/11/15/qjz.png" alt="rpc"></p>
<p>RPC 可以粗略的划分为平台相关和平台无关两大类。平台相关的代表有 Java RMI、.NET Remoting 等。平台无关的有早期的 CORBA、XML-RPC、XML-RPC 的后继者 SOAP、Web Service、JSON-RPC 等，以及很多现代 RPC 框架比如 Google gRPC、Apache Thrift、Apache Avro、Hprose 等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">远程过程调用</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/25536695">谁能用通俗的语言解释一下什么是 RPC 框架？</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/45206710">Apache Thrift 系列详解(三) - 序列化机制</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/q/1010000003064904?_ea=298208">什么是 RESTful？到底 REST 和 SOAP、RPC 有何区别？</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/sunsky303/p/7718192.html">那些年，我们追过的 RPC</a></p>
</blockquote>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/OXIFJGSozoRWNaLhnD0wxw">咖啡馆的故事：FTP, RMI , XML-RPC, SOAP, REST 一网打尽</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ 入门</title>
    <url>/2020/02/08/RabbitMQ%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>最早在 Java 体系中使用最多的消息队列是 ActiveMQ，但是由于其社区不够活跃且历史包袱较重，目前使用者已经越来越少，此时另一个合适的选择就是 RabbitMQ。</p>
<span id="more"></span>

<h1 id="安装及准备工作"><a href="#安装及准备工作" class="headerlink" title="安装及准备工作"></a>安装及准备工作</h1><p>在 Windows 系统中可以使用 Chocolatey 安装，比较方便。在安装完成后，可以使用 <code>rabbitmqctl start_app</code> 命令启动 RabbitMQ 服务。同时可以使用 <code>rabbitmq-plugins list</code> 命令列出所有插件的启用状态。然后我们使用 <code>rabbitmq-plugins enable rabbitmq_management</code> 命令来启动 RabbitMQ 内置的 web 管理服务插件。web 管理服务默认的端口号为 15672，用户名和密码都是 guest，第一次使用时最好新建一个用户并设置管理员权限后删除 guest 用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\RabbitMQ Server\rabbitmq_server-3.8.2\sbin&gt;rabbitmq-plugins list</span><br><span class="line">Listing plugins with pattern &quot;.*&quot; ...</span><br><span class="line"> Configured: E = explicitly enabled; e = implicitly enabled</span><br><span class="line"> | Status: * = running on rabbit@nekolr</span><br><span class="line"> |/</span><br><span class="line">[  ] rabbitmq_amqp1_0                  3.8.2</span><br><span class="line">[  ] rabbitmq_auth_backend_cache       3.8.2</span><br><span class="line">[  ] rabbitmq_auth_backend_http        3.8.2</span><br><span class="line">[  ] rabbitmq_auth_backend_ldap        3.8.2</span><br><span class="line">[  ] rabbitmq_auth_backend_oauth2      3.8.2</span><br><span class="line">[  ] rabbitmq_auth_mechanism_ssl       3.8.2</span><br><span class="line">[  ] rabbitmq_consistent_hash_exchange 3.8.2</span><br><span class="line">[  ] rabbitmq_event_exchange           3.8.2</span><br><span class="line">[  ] rabbitmq_federation               3.8.2</span><br><span class="line">[  ] rabbitmq_federation_management    3.8.2</span><br><span class="line">[  ] rabbitmq_jms_topic_exchange       3.8.2</span><br><span class="line">[E*] rabbitmq_management               3.8.2</span><br><span class="line">[e*] rabbitmq_management_agent         3.8.2</span><br><span class="line">[  ] rabbitmq_mqtt                     3.8.2</span><br><span class="line">[  ] rabbitmq_peer_discovery_aws       3.8.2</span><br><span class="line">[  ] rabbitmq_peer_discovery_common    3.8.2</span><br><span class="line">[  ] rabbitmq_peer_discovery_consul    3.8.2</span><br><span class="line">[  ] rabbitmq_peer_discovery_etcd      3.8.2</span><br><span class="line">[  ] rabbitmq_peer_discovery_k8s       3.8.2</span><br><span class="line">[  ] rabbitmq_prometheus               3.8.2</span><br><span class="line">[  ] rabbitmq_random_exchange          3.8.2</span><br><span class="line">[  ] rabbitmq_recent_history_exchange  3.8.2</span><br><span class="line">[  ] rabbitmq_sharding                 3.8.2</span><br><span class="line">[  ] rabbitmq_shovel                   3.8.2</span><br><span class="line">[  ] rabbitmq_shovel_management        3.8.2</span><br><span class="line">[  ] rabbitmq_stomp                    3.8.2</span><br><span class="line">[  ] rabbitmq_top                      3.8.2</span><br><span class="line">[  ] rabbitmq_tracing                  3.8.2</span><br><span class="line">[  ] rabbitmq_trust_store              3.8.2</span><br><span class="line">[e*] rabbitmq_web_dispatch             3.8.2</span><br><span class="line">[  ] rabbitmq_web_mqtt                 3.8.2</span><br><span class="line">[  ] rabbitmq_web_mqtt_examples        3.8.2</span><br><span class="line">[  ] rabbitmq_web_stomp                3.8.2</span><br><span class="line">[  ] rabbitmq_web_stomp_examples       3.8.2</span><br></pre></td></tr></table></figure>

<h1 id="原理及重要概念"><a href="#原理及重要概念" class="headerlink" title="原理及重要概念"></a>原理及重要概念</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202002092141/2020/02/09/NQY.png" alt="原理图"></p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>在 RabbitMQ 中，消息只能存储于队列中，而在 Kafka 中消息则是存储在 topic 这一逻辑层面，Kafka 中的队列逻辑只是 topic 实际存储文件的位移标识。RabbitMQ 中的生产者将消息最终投递到队列，消费者从队列获取消息并消费。当多个消费者订阅了同一个队列，这时队列中的消息会被均摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p>
<h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>Exchange 可以叫做交换器。实际上，生产者并不是直接将消息投递到队列中，而是先经过 Exchnage，再由 Exchange 转发到队列。在 RabbitMQ 中有四种不同类型的交换器，不同类型的交换器有着不同的路由策略。</p>
<p>为什么 RabbitMQ 需要 Exchange 呢？因为 AMQP 中有一个思想就是生产者和消费者解耦。我们只需要定义好 Exchange 的路由策略，生产者不需要关心消息会发送给哪个 Queue 或被哪些消费者消费。这种模式下生产者只面向 Exchange，消费者只面向 Queue。Exchange 定义了消息路由到 Queue 的规则，将各个层面的消息传递隔离开来，每一层只需要关心面向的下一层，从而降低了整体的耦合度。</p>
<p>RabbitMQ 中常用的交换器类型有 fanout、direct、topic 和 headers 这四种，其中 fanout 类型的交换器会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中，它不处理任何路由规则，直接将消息发送给所有绑定的队列，是四种交换机中速度最快的。direct 类型的交换器则会把消息路由到 BindingKey 与 RoutingKey 完全匹配的队列中，但是有时像 direct 这种严格匹配的方式在很多时候并不能满足实际的需要，因此 topic 类型的交换器则在 direct 的基础上进行了扩展，它约定 RoutingKey 和 BindingKey 都为一个点号分隔的字符串，比如 <code>com.rabbitmq.client</code>，BindingKey 中可以存在两种特殊的字符串 <code>*</code> 和 <code>#</code>，用于模糊匹配，其中 <code>*</code> 只能匹配一个单词，而 <code>#</code> 可以匹配零个或多个单词。举个例子：比如 BindingKey 为 <code>*.rabbitmq.*</code>，那么 Routingkey 必须为类似 <code>com.rabbitmq.client</code> 这种的，一个 <code>*</code> 号就代表一个单词，如果 BindingKey 为 <code>java.#</code>，那么 RoutingKey 就必须为 java 开头的任意字符串，比如 <code>java.util.concurrent</code>。至于 headers 类型的交换器则并不依赖路由键的匹配规则来路由消息，而是根据发送消息中的 headers 属性进行匹配。在绑定队列和交换器的时候指定一组键值对，当消息到达交换器时，RabbitMQ 会将该消息的 headers 与绑定时指定的键值对进行比较，完全匹配才会路由到该队列。由于 headers 类型的交换器性能很差，一般不会使用。</p>
<h2 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h2><p>生产者将消息发送给交换器后，交换器如何知道要将消息发送到哪个队列中呢？答案就是通过绑定。绑定是指将交换器与队列进行关联，在绑定的时候一般还会指定一个绑定键（Binding Key）。生产者在将消息发送给交换器的时候，一般会指定一个 Routing Key，用于表示这个消息的路由规则。这个 Routing Key 需要与交换器类型以及绑定键配合使用。比如一个 direct 类型的交换器，那么消息会路由到 Routing Key 与 Binding Key 完全匹配的某个队列中。所以在交换器类型和绑定键固定的情况下，生产者发送消息时指定的 Routing Key 将最终决定消息的流向。</p>
<h2 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h2><p>每个 RabbitMQ 服务都可以创建多个 Virtual Host，即虚拟主机。每一个 Virtual Host 本质上都是一个独立的小型 RabbitMQ 服务，拥有自己独立的队列、交换器及绑定关系，并且拥有自己独立的权限。Virtual Host 与 RabbitMQ 服务的关系类似于虚拟机与物理主机的关系，它的存在为各个实例提供了逻辑上的隔离，既能区分 RabbitMQ 中众多的用户，又可以避免队列和交换器等的命名冲突。</p>
<h1 id="AMQP-简单介绍"><a href="#AMQP-简单介绍" class="headerlink" title="AMQP 简单介绍"></a>AMQP 简单介绍</h1><p>AMQP 协议本身包含三层。位于协议最高层的是 Module Layer，主要定义了一些供客户端调用的命令，客户端可以通过这些命令实现自己的业务逻辑。比如，客户端可以通过 Queue.Declare 命令声明一个队列。位于中间层的是 Session Layer，主要负责将客户端的命令发送给服务端，再将服务端的响应发送给客户端，为客户端与服务端之间的通信提供可靠的同步机制和错误处理。位于最底层的是 Transport Layer，主要负责传输二进制数据流，提供帧的处理、信道复用等。</p>
<p>AMQP 说到底还是一个通信协议，通信协议都会涉及到报文的交互，从 low-level 来说，AMQP 协议是应用层的协议，其填充了 TCP 协议层的数据部分。从 high-level 来说，AMQP 协议是通过协议命令进行交互的。AMQP 协议可以看作一系列结构化命令的集合，类似于 HTTP 协议中的方法（GET、POST、DELETE 等）。我们可以运行一段代码，并使用 Wireshark 分析数据包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutExchangeProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">// 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明非持久化、非自动删除的 Fanout Exchange</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello Fanout Exchange &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">// 关闭 Channel</span></span><br><span class="line">        channel.close();</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202002102344/2020/02/10/71e.png" alt="AMQP 协议封包"></p>
<h1 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h1><p>使用 RabbitMQ 的客户端发送和接收消息时，大体上都需要先通过连接工厂创建一个到 Broker 的连接，然后通过连接开启一个信道，由信道声明交换器和队列，再将交换器与队列绑定，然后就可以处理发送或者接收消息的逻辑了。</p>
<p>使用连接工厂创建连接，由连接开启信道不需要过多说明，有一点需要注意的就是通过 Connection 可以创建多个 Channel 实例，但是 Channel 实例不能在线程间共享，也就是说 Channel 实例是非线程安全的。</p>
<h2 id="交换器的声明和删除"><a href="#交换器的声明和删除" class="headerlink" title="交换器的声明和删除"></a>交换器的声明和删除</h2><p>声明交换器的 exchangeDeclare 方法有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exchange.DeclareOk <span class="title function_">exchangeDeclare</span><span class="params">(String exchange,</span></span><br><span class="line"><span class="params">                                          String type,</span></span><br><span class="line"><span class="params">                                          <span class="type">boolean</span> durable,</span></span><br><span class="line"><span class="params">                                          <span class="type">boolean</span> autoDelete,</span></span><br><span class="line"><span class="params">                                          <span class="type">boolean</span> internal,</span></span><br><span class="line"><span class="params">                                          Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>其中 exchange 是交换器的名称，type 是交换器的类型，有 fanout、direct、topic 和 headers 四种。durable 用于设置是否进行持久化，autoDelete 用于设置是否自动删除。自动删除的意思不是在所有与该交换器连接的客户端都断开后，RabbitMQ 会自动删除该交换器，自动删除的前提是至少有一个队列或交换器与该交换器绑定，之后所有与该交换器绑定的队列或交换器都与该交换器进行了解绑，只有在这个前提下自动删除才会生效。internal 用于设置交换器是否为内置的，客户端无法直接发送消息到内置交换器，只能通过交换器路由到内置交换器的方式发送消息。arguments 用于传递一些结构化的参数，比如 alternate-exchange。</p>
<p>上面声明交换器的方法是有返回值的，为 Exchange.DeclareOk，表示客户端在声明了一个交换器后，需要等待服务端的 Exchange.Declare-Ok 返回命令。同时客户端 API 也提供了不需要服务端返回值的方法 exchangeDeclareNoWait，使用该方法声明的交换器不能紧接着就使用。还有一个非常有用的方法为 exchangeDeclarePassive，可以用它来检测相应的交换器是否存在，如果存在则正常返回；如果不存在则会抛出异常，同时 Channel 也会被关闭。</p>
<p>有声明创建交换器的方法，那么当然会有删除的方法，相应的方法如下，其中 ifUnused 用来设置是否在交换器没有被使用的情况下删除，如果设置为 true 则表示只有该交换器没有被使用的情况下才会删除；否则一定会被删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exchange.DeleteOk <span class="title function_">exchangeDelete</span><span class="params">(String exchange, <span class="type">boolean</span> ifUnused)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h2 id="队列的声明和删除等"><a href="#队列的声明和删除等" class="headerlink" title="队列的声明和删除等"></a>队列的声明和删除等</h2><p>声明队列的方法主要有两个，其中一个不带任何参数，默认会创建一个由 RabbitMQ 命名的（类似 amq.gen-j6mNQFoLARlq18lj0LTjWQ 这种，它们也被称为匿名队列）、排他的、自动删除的、非持久化的队列。另一个方法带有很多参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue.DeclareOk <span class="title function_">queueDeclare</span><span class="params">(String queue, <span class="type">boolean</span> durable, <span class="type">boolean</span> exclusive, <span class="type">boolean</span> autoDelete,</span></span><br><span class="line"><span class="params">                                 Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>其中 queue 是队列的名称，durable 是设置是否持久化。exclusive 用于设置是否为排他，如果一个队列被声明为排他队列，那么它仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意的有三点：首先排他队列是基于连接可见的，即同一个连接的不同信道可以同时访问同一连接创建的排他队列；首次是指如果一个连接已经声明了一个排他队列，那么其他连接是不允许再声明一个同名的排他队列的；即使排他队列是持久化的，一旦连接关闭或者客户端退出，该队列都会自动删除。因此排他队列适用于一个客户端同时处理发送和接收消息的场景。autoDelete 是设置是否为自动删除，它的意思不是当所有连接到此队列的客户端都断开后，这个队列会自动删除。自动删除的前提是至少有一个消费者连接到这个队列，之后所有与该队列连接的消费者都断开，只有在这个前提下自动删除才会生效。因此生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除该队列。arguments 用于设置一些参数，比如 x-message-ttl、x-max-length、x-expires 等。</p>
<blockquote>
<p>生产者和消费者都可以使用 queueDeclare 来声明一个队列，但是如果消费者在一个信道上订阅了另一个队列，此后就无法在该信道上声明队列了，必须先取消订阅，将信道置为传输模式后才可以继续声明队列。</p>
</blockquote>
<p>队列删除的方法与交换器删除的方法类似，有一点不同是多了一个 ifEmpty 参数设置，为 true 时表示只有队列为空（即队列中没有任何消息堆积）时才会进行删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue.DeleteOk <span class="title function_">queueDelete</span><span class="params">(String queue, <span class="type">boolean</span> ifUnused, <span class="type">boolean</span> ifEmpty)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>还有一个比较特殊的方法，为 queuePurge，该方法用来清空队列中的内容但是不会删除队列本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue.PurgeOk <span class="title function_">queuePurge</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h2 id="队列和交换器绑定"><a href="#队列和交换器绑定" class="headerlink" title="队列和交换器绑定"></a>队列和交换器绑定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue.BindOk <span class="title function_">queueBind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>其中 queue 是要绑定的队列名称，exchange 是要绑定的交换器名称，routingKey 为绑定队列和交换器的路由键，arguments 则定义了绑定的一些参数。</p>
<h2 id="交换器和交换器绑定"><a href="#交换器和交换器绑定" class="headerlink" title="交换器和交换器绑定"></a>交换器和交换器绑定</h2><p>我们不仅可以将交换器与队列绑定，还可以将交换器与交换器绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exchange.BindOk <span class="title function_">exchangeBind</span><span class="params">(String destination, String source, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>其中 destination 可以理解为消息流向的目的交换器，source 可以理解为消息的源头交换器，这里可以举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;source&quot;</span>, <span class="string">&quot;direct&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;destination&quot;</span>, <span class="string">&quot;fanout&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">channel.exchangeBind(<span class="string">&quot;destination&quot;</span>, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;exKey&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue&quot;</span>, <span class="string">&quot;destination&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">channel.basicPublish(<span class="string">&quot;source&quot;</span>, <span class="string">&quot;exKey&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;exToExDemo&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202002141416/2020/02/14/bBg.png" alt="交换器绑定交换器"></p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>使用 Channel 类的 basicPublish 方法来发送消息，该方法也有多个重载方法，其中参数最全的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="type">boolean</span> mandatory, <span class="type">boolean</span> immediate, BasicProperties props, <span class="type">byte</span>[] body)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>其中 exchange 为交换器名称，如果设置为空字符串则消息会被转发到默认的交换器中，<strong>默认的交换器为 direct 类型，隐式地绑定到了每个队列，并且路由键等于各自绑定的队列名称。不能显式绑定到默认的交换器或与之解绑。默认交换器不能删除</strong>。routingKey 为路由键。当 mandatory 设置为 true，如果交换器出现无法根据自身的类型和路由键匹配一个队列时，那么 RabbitMQ 就会调用 Basic.Return 命令将消息返回给生产者，生产者可以通过 <code>channel.addReturnListener</code> 方法添加一个监听器来获取无法匹配的消息；当 mandatory 设置为 false 时，遇到上述情况消息则会被丢弃。当 immediate 设置为 true，如果交换器在将消息路由到队列时发现队列上不存在任何消费者，那么这条消息不会被存入队列中，当与路由键匹配的所有队列中都没有消费者时，消息会通过 Basic.Return 返回至生产者。概括来说就是，mandatory 参数告诉服务端至少要将消息路由到一个队列中，否则消息将返回给生产者。immediate 参数告诉服务端，如果消息匹配的队列上有消费者，则立刻投递，如果所有匹配的队列上都没有消费者，则立即将消息返回给生产者，而不需要将消息存储至队列。</p>
<blockquote>
<p>需要注意的是，RabbitMQ 3.0 版本开始去掉了对 immediate 参数的支持，官方解释是该参数会影响镜像队列的性能，增加代码的复杂度，建议采用 TTL（过期时间）和 DLX（死信交换器）的方法来替代。</p>
</blockquote>
<p>props 为消息的基本属性集，其中包含 14 个属性，包括 contentType、contentEncoding、headers、deliveryMode、priority、correlationld、replyTo、expiration、messageld、timestamp、type、userld、appld、clusterld。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BasicProperties</span> <span class="keyword">extends</span> <span class="title class_">com</span>.rabbitmq.client.impl.AMQBasicProperties &#123;</span><br><span class="line">    <span class="keyword">private</span> String contentType; <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">private</span> String contentEncoding; <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; headers; <span class="comment">// 消息头</span></span><br><span class="line">    <span class="keyword">private</span> Integer deliveryMode; <span class="comment">// 投递模式，1 表示不持久化，2 表示持久化</span></span><br><span class="line">    <span class="keyword">private</span> Integer priority; <span class="comment">// 优先级</span></span><br><span class="line">    <span class="keyword">private</span> String correlationId; <span class="comment">// 用于将 RPC 响应与请求相关联</span></span><br><span class="line">    <span class="keyword">private</span> String replyTo; <span class="comment">// 通常用于命名回调队列</span></span><br><span class="line">    <span class="keyword">private</span> String expiration; <span class="comment">// 消息的过期时间</span></span><br><span class="line">    <span class="keyword">private</span> String messageId;</span><br><span class="line">    <span class="keyword">private</span> Date timestamp;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="keyword">private</span> String clusterId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><p>RabbitMQ 的消费模式有两种，分别是推模式（Push）和拉模式（Pull），其中推模式使用 Basic.Consume，拉模式使用 Basic.Get。</p>
<h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><p>在推模式中，消息是由服务端主动推送给消费者的，因此消费者可以通过持续订阅（监听）的方式来获取消息，具体的操作一般是通过实现 Consumer 接口或者继承 DefaultConsumer 类的方式。在调用与 Consumer 相关的方法时，不同的订阅使用不同的消费者标签（consumerTag）来区分，在同一个 Channel 中的消费者也要通过唯一的消费者标签来区分。下面展示一段推模式监听消息的代码，除去声明部分的样板代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag,</span></span><br><span class="line"><span class="params">                               Envelope envelope,</span></span><br><span class="line"><span class="params">                               AMQP.BasicProperties properties,</span></span><br><span class="line"><span class="params">                               <span class="type">byte</span>[] body)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 此处编写处理消息的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动确认</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 指定队列的消费者，取消自动确认，改为手动确认</span></span><br><span class="line">channel.basicConsume(queueName, <span class="literal">false</span>, <span class="string">&quot;consumerTag1&quot;</span>, consumer);</span><br></pre></td></tr></table></figure>

<p>除了简单重写 handleDelivery 方法外，还可以重写更多的方法来实现更加复杂的需求，具体可以重写的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当消费者调用 Channel.basicConsume 方法时都会调用，即消费者消费之前都会调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleConsumeOk</span><span class="params">(String consumerTag)</span>;</span><br><span class="line"><span class="comment">// 使用 Channel.basicCancel 方法显式取消消费时调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleCancelOk</span><span class="params">(String consumerTag)</span>;</span><br><span class="line"><span class="comment">// 当消费者由于其他原因（比如队列被删除）而被取消时调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleCancel</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">// 当 Channel 或者 Connection 关闭时调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleShutdownSignal</span><span class="params">(String consumerTag, ShutdownSignalException sig)</span>;</span><br><span class="line"><span class="comment">// 在调用 Channel.basicRecover 方法返回 Basic.recover-ok 时调用，调用之前所有收到但尚未确认的消息将会重发。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleRecoverOk</span><span class="params">(String consumerTag)</span>;</span><br></pre></td></tr></table></figure>

<p>和生产者一样，消费者客户端同样需要考虑线程安全的问题。消费者客户端的这些重写方法都会被分配到与 Channel 不同的线程上运行，这意味着消费者客户端可以安全地调用一些阻塞方法，比如 channel.queueDeclare、channel.basicCancel 等。每个 Channel 都拥有自己独立的线程，一般最常用的做法就是一个 Channel 对应一个消费者。</p>
<h3 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h3><p>在拉模式中，消费者主动从服务端拉取消息。拉取消息对应在客户端 API 上就是 channel.basicGet 方法，使用该方法可以从服务端获取单条消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> channel.basicGet(queueName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No message retrieved</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getBody()));</span><br><span class="line">    <span class="comment">// 手动确认</span></span><br><span class="line">    channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Basic.Consume 会将信道设置为接收模式，直到取消队列的订阅为止。在接收模式期间，服务端会根据 Basic.Qos 的限制不断地给消费者推送消息。如果想从队列获取单条消息而不是持续订阅，可以使用 Basic.Get，但是切记不要将 Basic.Get 放在一个循环中来实现类似 Basic.Consume 的效果，这样做会严重影响 RabbitMQ 的性能。</p>
<h2 id="消费端的确认与拒绝"><a href="#消费端的确认与拒绝" class="headerlink" title="消费端的确认与拒绝"></a>消费端的确认与拒绝</h2><p>为了保证消息可靠地投递到消费者手中，RabbitMQ 提供了消费者确认机制，消费者在订阅队列时，可以指定 autoAck 参数。当设置 autoAck 为 true 时，RabbitMQ 会自动将发送出去的消息置为确认，然后从内存或磁盘中删除，而不管消费者是否真正消费了该条消息；当设置 autoAck 为 false 时，消费者就不必担心处理消息的过程中消费者进程挂掉后造成消息丢失，RabbitMQ 会一直等到持有消息的消费者显式调用 Basic.Ack 命令为止。</p>
<p>在消费者收到消息后，如果想拒绝当前的消息而不是确认，那么可以使用 Basic.Reject 这个命令，对应的客户端方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicReject</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>其中 deliveryTag 可以看作消息的编号，它是一个 64 位的长整型。如果 requeue 为 true，那么 RabbitMQ 会将这条消息重新存入队列，以便发给下一个消费者；如果 requeue 为 false，那么该消息就会变成死信被丢弃或者发送到死信队列。</p>
<p>Basic.Reject 命令一次只能拒绝一条消息，如果想要批量拒绝消息，可以使用 Basic.Nack 命令，对应的客户端方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">basicNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple, <span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>其中 deliveryTag 和 requeue 的含义与 basicReject 方法相同。如果 multiple 为 false，那么该方法只会拒绝编号为 deliveryTag 的这一条消息；如果 multiple 为 true，那么该方法会拒绝 deliveryTag 编号之前所有未被消费者确认的消息。</p>
<p>针对 requeue，AMQP 中还有一个 Basic.Recover 命令具备可重入队列的特征，对应的客户端方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Basic.RecoverOk <span class="title function_">basicRecover</span><span class="params">(<span class="type">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>这个方法用来请求 RabbitMQ 重新发送还未被确认的消息。如果 requeue 为 true，那么未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者；如果 requeue 为 false，那么同一条消息就会被分配给与之前相同的消费者。</p>
<h1 id="RabbitMQ-进阶"><a href="#RabbitMQ-进阶" class="headerlink" title="RabbitMQ 进阶"></a>RabbitMQ 进阶</h1><p>RabbitMQ 除了具有消息队列常用的功能外，还有很多高级特性，比如备份交换器、死信队列、延迟队列等。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>在 RabbitMQ 中，持久化包括交换器的持久化、队列的持久化以及消息的持久化。交换器的持久化可以在声明交换器时设置，如果交换器不设置持久化，那么在 RabbitMQ 服务重启后，相关交换器的元信息就会丢失。队列的持久化同样也在声明时设置，如果不设置队列持久化，那么在 RabbitMQ 服务重启后，相关队列的元信息也会丢失，同时数据（消息）也会丢失。队列的持久化只能保证队列本身的元信息不会丢失，无法保证队列内部存储的消息不会丢失。要确保消息不会丢失，需要在发送消息时将消息的投递模式，即 deliveryMode 属性设置为 2。只有同时设置了队列和消息的持久化，RabbitMQ 服务重启后消息才不会丢失。</p>
<p>我们可以将所有的消息都设置为持久化，但是这样会严重影响 RabbitMQ 的性能，如果对可靠性要求不高可以选择不持久化消息。即使交换器、队列和消息都设置了持久化，也不能保证消息百分百不丢失。消息从生产到消费经历了生产、转储和消费三个阶段，每个阶段都有可能出现消息丢失的情况。消费阶段出现消息丢失一般是因为消费者订阅队列时设置了 autoAck 为 true，如果此时消费者接收到消息还没来得及处理就宕机了，消息就会丢失，解决方法就是将 autoAck 设置为 false 并进行手工确认。在转储阶段，持久化的消息正确存入 RabbitMQ 后，还需要一段时间（很短，但不能忽视）才能存入磁盘。RabbitMQ 并不会为每条消息都进行同步存盘（调用内核的 fsync 方法），可能仅仅保存到操作系统缓存中，如果这段时间内 RabbitMQ 服务宕机，消息还没来得及落盘就会丢失。解决这种问题的方法就是使用 RabbitMQ 的镜像队列机制，虽然这样不能完全保证消息不会丢失，但是可靠性要比普通的单机模式要高。至于生产阶段，可以在生产者中引入事务机制或者使用发送方确认机制来保证消息已经正确发送并存储到 RabbitMQ 中。</p>
<h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>默认情况下，生产者发送消息是不会有任何响应信息返回的，也就是默认情况下生产者并不知道消息到底有没有正确到达服务器，如果消息在到达服务器之前就已经丢失，那么持久化操作也就无从谈起。针对这个问题，RabbitMQ 提供了两种解决方式，其一就是事务机制，其二就是发送方确认机制。</p>
<h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>RabbitMQ 客户端中与事务相关的方法有三个，channel.txSelect、channel.txCommit 和 channel.txRollback，其中 channel.txSelect 方法用于将当前信道设置为事务模式，channel.txCommit 方法用于提交事务，channel.txRollback 则用于事务回滚。当信道开启了事务模式后，我们就可以发送消息了，如果事务提交成功，则表示消息一定到达了 RabbitMQ 服务中；如果在事务提交之前由于异常崩溃或其他原因抛出异常，此时就可以将其捕获并进行事务回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送方确认"><a href="#发送方确认" class="headerlink" title="发送方确认"></a>发送方确认</h3><p>事务确实能够解决发送方和 RabbitMQ 之间消息确认的问题，但是使用事务会严重影响 RabbitMQ 的性能，因此 RabbitMQ 还提供了一种更轻量的改进方案，它就是发送方确认机制。在该机制中，生产者将信道设置为 confirm（确认）模式，一旦信道进入确认模式，所有在该信道上发布的消息都会被指派一个唯一的 ID（即 deliveryTag，从 1 开始）。在消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（Basic.Ack）给生产者，确认中包含之前指派的唯一 ID。**如果消息和队列是持久化的，那么确认会在消息写入磁盘之后发出。**此外 RabbitMQ 也可以设置 channel.basicAck 方法中的 multiple 参数，表示这个 ID 序号之前的所有消息都已经得到了处理。</p>
<p>事务机制在发送一条消息后会使发送端阻塞，以等待 RabbitMQ 的响应，之后才能继续发送下一条消息。与之相比，发送方确认机制最大的好处在于它是异步的，生产者发送消息后可以在等信道返回确认的同时继续发送下一条消息。下面使用一段代码简单介绍确认机制的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启信道的确认模式</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;publisher confirm&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 等待消息确认响应，可能是 Basic.Ack 也可能是 Basic.Nack</span></span><br><span class="line">    <span class="keyword">if</span> (!channel.waitForConfirms()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Send message failed.&quot;</span>);</span><br><span class="line">        <span class="comment">// 此处编写消息发送失败时需要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似 channel.waitForConfirms 的方法共有四种，默认的无参方法返回的条件是客户端收到了相应的回复（Basic.Ack 或 Basic.Nack）或被中断，带有参数 timeout 的方法会在超时时间结束后抛出 <code>java.util.concurrent.TimeoutException</code> 异常。剩下两个 waitForConfirmsOrDie 方法在收到 Basic.Nack 回复后会抛出 <code>java.io.IOException</code> 异常。</p>
<p>在生产者确认模式中，如果每发送一条消息后就调用 channel.waitForConfirms 方法等待服务端确认，这实际上与事务机制一样还是一种串行同步等待的方式，同时它们的存储确认原理相同，尤其对于持久化的消息来说，两者都需要等待消息落盘（调用 fsync 内核方法）后才会返回。在同步等待的方式下，消息确认机制发送一条消息需要通信交互的命令是 2 条：Basic.Publish 和 Basic.Ack；事务机制是 3 条：Basic.Publish、Tx.Commit 和 Tx.Commit-Ok（或者 Tx.Rollback 和 Tx.Rollback-Ok）。而我们知道，消息确认机制的优势在于并不一定需要同步确认，我们可以采用批量确认或者异步确认的方式。下面针对这两种改进方式分别举例。</p>
<p>在批量确认的方式中，客户端程序需要定期或者定量，亦或者两者结合发送消息后调用 channel.waitForConfirms 方法等待服务端的确认返回。相比之前的一条一确认，批量确认极大地提高了确认的效率，但是当出现返回 Basic.Nack 或者超时的情况时，客户端需要将之前批量发送的消息全部重发，这在网络情况不佳消息经常丢失时性能不升反降。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">// 等待确认的消息总数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">msgCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;batch confirm&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 将发送出去的消息存入缓存中，缓存可以是一个 ArrayList 或者 BlockingQueue 之类的</span></span><br><span class="line">        <span class="keyword">if</span> (++msgCount &gt;= BATCH COUNT) &#123;</span><br><span class="line">            msgCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待响应</span></span><br><span class="line">                <span class="keyword">if</span> (channel.waitForConfirms()) &#123;</span><br><span class="line">                    <span class="comment">// 将缓存中的消息清空</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 将缓存中的消息重新发送</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步确认的方式实现较为复杂，我们需要调用 channel.addConfirmListener 方法为消息确认添加 ConfirmListener 回调接口，该接口中有 handleAck 和 handleNack 两个方法，方法中的 deliveryTag 用来标记消息的唯一有序序号，我们需要为每个信道维护一个意为“unconfirm”的消息序号集合，每发送一条消息，集合元素加一，每当调用 ConfirmListener 接口的 handleAck 方法时，集合删掉一个（multiple 为 false）或多个（multiple 为 true）元素。该集合最好采用有序集合 SortedSet 来维护消息序号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            <span class="comment">// 如果设置的是 true，则表示这个序号之前的所有消息都得到了处理，因此删除序号之前所有的元素</span></span><br><span class="line">            unConfirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删掉对应的消息序号</span></span><br><span class="line">            unConfirmSet.remove(deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            unConfirmSet.headSet(deliveryTag - <span class="number">1</span>).clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unConfirmSet.remove(deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里需要添加处理消息重发的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一直发送消息的场景</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nextSeqNo</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line">    <span class="comment">// 将序号添加到未处理的集合中</span></span><br><span class="line">    unConfirmSet.add(nextSeqNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息分发"><a href="#消息分发" class="headerlink" title="消息分发"></a>消息分发</h2><p>当队列有多个消费者的时候，队列会将消息以轮询的方式分发，每条消息只会发送给订阅列表中的一个消费者。这种方式非常适合扩展，但是也会有它的缺陷。假如有 n 个消费者，那么 RabbitMQ 会把第 m 条消息分发给第 m % n 个消费者，RabbitMQ 不会理会消费者是否消费并已经确认了消息。如果某些消费者任务繁重，来不及处理这么多的消息，而某些消费者却由于某些原因很快就处理完了分配到的消息，这就会导致应用整体的吞吐量下降。</p>
<p>应对这种情况需要用到 <code>channel.basicQos(int prefetchCount)</code> 方法，使用该方法可以限制信道上消费者所能保持的最大未确认消息的数量。举个例子，在订阅队列之前，消费者程序调用了 <code>channel.basicQos(5)</code>，之后订阅队列进行消费。RabbitMQ 会保存一份消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了设定的上限 5，那么 RabbitMQ 就不会向这个消费者再发送任何消息，直到消费者确认了某条消息后，RabbitMQ 将对应的消费者的计数减一，之后该消费者才可以继续接收消息，直到再次达到上限。</p>
<p>basicQos 有三个重载方法，带有 prefetchCount 参数的方法设置为 0 则表示没有上限，还有带有 prefetchSize 参数的方法，该参数表示消费者所能接收未确认消息总体大小的上限，单位为 B，设置为 0 也表示没有上限。对于一个信道来说，它可以同时支持多个队列的消费，当设置了 prefetchCount 大于 0 时，这个信道需要协调各个队列以确保发送的消息都没有超过限定值，这样会使 RabbitMQ 的性能降低，尤其是这些队列分布在集群的多个 Broker 节点上时，因此 RabbitMQ 在 AMQP 0-9-1 协议之上又给 basicQos 方法重新定义了 global 这个参数。</p>
<table>
<thead>
<tr>
<th>global</th>
<th>AMQP 0-9-1</th>
<th>RabbitMQ</th>
</tr>
</thead>
<tbody><tr>
<td>false</td>
<td>信道上所有的消费者都需要遵从 prefetchCount 的限制</td>
<td>信道上新的消费者需要遵从 prefetchCount 的限制</td>
</tr>
<tr>
<td>true</td>
<td>当前 Connection 上所有的消费者都需要遵从 prefetchCount 的限制</td>
<td>信道上所有的消费者都需要遵从 prefetchCount 的限制</td>
</tr>
</tbody></table>
<p>对于同一个信道上的多个消费者而言，如果设置了 prefetchCount 的值，那么该设置会对每个消费者都生效，比如下面的例子中，每个消费者各自能接收的未确认消息的上限都是 10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="comment">// 每个消费者都会限制 10 条</span></span><br><span class="line">channel.basicQos(<span class="number">10</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="literal">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;queue2&quot;</span>, <span class="literal">false</span>, consumer2);</span><br></pre></td></tr></table></figure>

<p>如果在订阅消息之前，既设置了 global 为 true，又设置了 global 为 false，那么这两个限制都会生效，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="comment">// 每个消费者都会限制 3 条</span></span><br><span class="line">channel.basicQos(<span class="number">3</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 该信道上会限制为 5 条</span></span><br><span class="line">channel.basicQos(<span class="number">5</span>, <span class="literal">true</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="literal">false</span>, consumer1);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;queue2&quot;</span>, <span class="literal">false</span>, consumer2);</span><br></pre></td></tr></table></figure>

<p>这个例子中，每个消费者最多只能收到 3 个未确认的消息，并且两个消费者能收到的未确认消息的总和上限为 5，也就是说假如 consumer1 接收到了三条未确认的消息，那么 consumer2 至多只能接收到 2 条未确认的消息，这样设置会额外增加 RabbitMQ 的负担，因为 RabbitMQ 需要更多的资源来协调完成这种限制，因此一般使用默认的 global 设置即可。</p>
<h2 id="消息可靠传输"><a href="#消息可靠传输" class="headerlink" title="消息可靠传输"></a>消息可靠传输</h2><p>一般消息中间件的消息传输可靠性分为三级，由低到高分别为 At most once：最多一次，消息可能丢失，但绝不会重复；At least once：最少一次，消息绝不会丢失，但可能会重复；Exactly once：正好一次，消息不会丢失也不会重复。RabbitMQ 支持最多一次和最少一次，但是不支持正好一次。</p>
<p>至少一次的传输等级，需要生产者开启事务或者消息确认，使消息能够可靠地从生产者传输到 RabbitMQ 中，同时生产者还需要设置 mandatory 参数或者使用备份交换器来保证消息一定能够路由到队列中，进而保证消息不会被丢弃。然后队列和消息都需要进行持久化，消费者需要使用手动确认的方式去确认已经正确消费的消息。最多一次的传输等级是最低的等级，生产者可以随意发送，消费者也可以随意消费，不过很难保证消息不会丢失。<strong>至于正好一次的传输等级在大多数主流的消息中间件中都没有实现，原因是消息去重一般是业务客户端需要考虑的事情，也应该交由业务端实现。</strong></p>
<h2 id="备份交换器"><a href="#备份交换器" class="headerlink" title="备份交换器"></a>备份交换器</h2><p>当生产者在发送消息时设置 mandatory 为 false，那么消息会在未被路由的情况下丢失；如果设置 mandatory 参数为 true，那么还需要编写 ReturnListener 的逻辑，生产者的代码就会变得更加复杂。如果既不想丢失消息又不想使生产者的代码复杂化，那么就可以使用备份交换器（Alternate Exchange）。备份交换器可以在声明交换器的时候添加 alternate-exchange 参数来实现，也可以通过策略（Policy）来实现，两者同时使用时前者的优先级更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;alternate-exchange&quot;</span>, <span class="string">&quot;myAlternateExchange&quot;</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;normalExchange&quot;</span>, <span class="string">&quot;direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;myAlternateExchange&quot;</span>, <span class="string">&quot;fanout&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;normalQueue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;normalQueue&quot;</span>, <span class="string">&quot;normalExchange&quot;</span>, <span class="string">&quot;normalKey&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;noRouteQueue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;noRouteQueue&quot;</span>, <span class="string">&quot;myAlternateExchange&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们声明了两个交换器，两个交换器各自绑定了一个队列，同时 myAlternateExchange 交换器为 normalExchange 交换器的备份交换器。当路由键为 normalKey 时，消息能够正确路由到 normalQueue 队列中；但是当路由键不为 normalKey 时，消息因为不能路由到与 normalExchange 交换器绑定的任意队列上，此时消息就会被发送到备份交换器并最终发送到 noRouteQueue 队列中。</p>
<blockquote>
<p>需要注意的是，备份交换器与普通的交换器没有太大区别，为了方便使用，一般都会设置为 fanout 类型。如果设置为 direct 类型，那么路由键同样需要进行匹配。</p>
</blockquote>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>在 RabbitMQ 中，消息可以设置过期时间（TTL）。我们可以通过队列属性来给队列中的所有消息设置过期时间，也可以针对每条消息单独设置过期时间，两种一起使用时则以 TTL 数值较小的一方为准。一旦消息的生存时间超过设置的 TTL 值，该消息就会变成死信（Dead Message）。**一般来说，消息变成死信除了是由于消息过期以外，还可能是由于消息被拒绝（Basic.Reject 或 Basic.Nack）并设置 requeue 为 false，以及队列达到最大长度。**正常情况下消费者将无法收到变成死信的消息，但是为了避免消息变成死信后丢失，我们可以使用死信队列。</p>
<p>死信队列也可以叫做死信交换器（Dead-Letter-Exchange，DLX），当消息在一个队列中变成死信后，它能够被重新发送到另一个交换器中，这个交换器就是死信交换器，绑定死信交换器的队列就是死信队列。实际上死信交换器与普通的交换器没有区别，它能在任何队列上被指定，实际上设置死信队列就是修改某个队列的属性，在声明队列时加入 <code>x-dead-letter-exchange</code> 参数，这样普通队列就变成了死信队列，普通的交换器也就变成了死信交换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;dlx_exchange&quot;</span>, <span class="string">&quot;direct&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置参数，指定死信交换器</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>);</span><br><span class="line"><span class="comment">// 也可以给 DLX 指定路由键，如果没有特殊指定则使用原队列的路由键</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx-routing-key&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;dlx_queue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br></pre></td></tr></table></figure>

<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列中存储的是对应的延迟消息，所谓延迟消息是指当消息发送以后，并不会立刻被消费者接收，而是等待特定时间后，消费者才能拿到这个消息进行消费。RabbitMQ 本身并不直接支持延迟队列的功能，但是我们可以通过 DLX 和 TTL 模拟出延迟队列的功能，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;exchange_dlx&quot;</span>, <span class="string">&quot;direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;exchange_normal&quot;</span>, <span class="string">&quot;fanout&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);<span class="comment">// 消息过期时间，10000 毫秒</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;exchange_dlx&quot;</span>);<span class="comment">// 指定死信交换器</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;routingKey&quot;</span>);<span class="comment">// 给 DLX 指定路由键</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue_normal&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_normal&quot;</span>, <span class="string">&quot;exchange_normal&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue_dlx&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_dlx&quot;</span>, <span class="string">&quot;exchange_dlx&quot;</span>, <span class="string">&quot;routingKey&quot;</span>);</span><br><span class="line"><span class="comment">// 发送消息 dlx，路由键为 rk</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange_normal&quot;</span>, <span class="string">&quot;rk&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">&quot;dlx&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>这个例子中声明了两个交换器 exchange_normal 和 exchange_dlx，其中 exchange_dlx 是死信交换器，两个交换器各自绑定了一个队列，分别为 queue_normal 和 queue_dlx。队列 queue_normal 设置了 TTL 属性为 10 秒，当消息投递到 exchange_normal 交换器时，最终会被转发到 queue_normal 队列，10 秒后由于没有消费者消费，这条消息就会过期变成死信然后转发到死信交换器，最终投递到死信队列，此时消费者只要获取死信队列中的消息并消费就可以了。</p>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>在优先级队列中，优先级高的消息具有先被消费的特权。下面举一个例子来说明如何设置消息的优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置队列的最大优先级为 10</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue_priority&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置消息的优先级为 5</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange_priority&quot;</span>, <span class="string">&quot;rk_priority&quot;</span>, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder().priority(<span class="number">5</span>).build(), <span class="string">&quot;message&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>上面的例子中首先设置了队列的最大优先级为 10，然后又设置了一条消息的优先级为 5。默认消息的优先级最低为 0，最高为队列设置的最大优先级，优先级高的消息可以被优先消费，当然这个是有前提的：如果消费者的消费速度大于生产者的速度且 Broker 中没有消息堆积的情况下，消息设置优先级也就没有意义，因为这种情况下相当于 Broker 中至多只有一条消息，对一条消息设置优先级没有意义。</p>
<h2 id="RPC-实现"><a href="#RPC-实现" class="headerlink" title="RPC 实现"></a>RPC 实现</h2><p>在 RabbitMQ 中实现 RPC 是比较简单的，客户端发送请求消息，服务端返回响应的消息，为了接收响应的消息还需要在请求消息中指定一个回调队列，但是光有回调队列可不行，因为对于回调队列而言，在其收到一条响应的消息之后，它并不知道这条响应的消息应该和哪个请求相匹配，因此这里就需要用到 <code>correlationId</code> 属性，我们只要为每个请求设置一个唯一的 <code>correlationId</code>，在回调队列接收到响应的消息时，就可以根据这个唯一值来匹配相应的请求。下面给出 RabbitMQ 官网的一个 RPC 例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCClient</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">requestQueueName</span> <span class="operator">=</span> <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        connection = connectionFactory.newConnection();</span><br><span class="line">        channel = connection.createChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RPCClient</span> <span class="variable">fibonacciRpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RPCClient</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">i_str</span> <span class="operator">=</span> Integer.toString(i);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Requesting fib(&quot;</span> + i_str + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> fibonacciRpc.call(i_str);</span><br><span class="line">                System.out.println(<span class="string">&quot; [.] Got &#x27;&quot;</span> + response + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 关联请求的唯一值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">corrId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 声明一个匿名队列作为回调队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replyQueueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties</span><br><span class="line">                .Builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 向 rpc_queue 队列中发送消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, requestQueueName, props, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用阻塞队列存放结果</span></span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;String&gt; response = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cTag</span> <span class="operator">=</span> channel.basicConsume(replyQueueName, <span class="literal">true</span>, (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果唯一值匹配则说明是对应的响应</span></span><br><span class="line">            <span class="keyword">if</span> (delivery.getProperties().getCorrelationId().equals(corrId)) &#123;</span><br><span class="line">                <span class="comment">// 不阻塞</span></span><br><span class="line">                response.offer(<span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.take();</span><br><span class="line">        <span class="comment">// 取消该消费者，这样队列中就不存在该消费者了</span></span><br><span class="line">        channel.basicCancel(cTag);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RPC_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明 rpc_queue 队列</span></span><br><span class="line">            channel.queueDeclare(RPC_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 清空队列</span></span><br><span class="line">            channel.queuePurge(RPC_QUEUE_NAME);</span><br><span class="line">            <span class="comment">// 一次只能有一个消费者获取到消息</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Awaiting RPC requests&quot;</span>);</span><br><span class="line">            <span class="comment">// 锁</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                AMQP.<span class="type">BasicProperties</span> <span class="variable">replyProps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties</span><br><span class="line">                        .Builder()</span><br><span class="line">                        .correlationId(delivery.getProperties().getCorrelationId())</span><br><span class="line">                        .build();</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取 client 发送过来的消息</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(message);</span><br><span class="line">                    System.out.println(<span class="string">&quot; [.] fib(&quot;</span> + message + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                    response += fib(n);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; [.] &quot;</span> + e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 将计算结果发送给回调队列</span></span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, delivery.getProperties().getReplyTo(), replyProps, response.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">// RabbitMq consumer worker thread notifies the RPC server owner thread</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                        monitor.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            channel.basicConsume(RPC_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, (consumerTag -&gt; &#123; &#125;));</span><br><span class="line">            <span class="comment">// Wait and be prepared to consume the message from RPC client.</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        monitor.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《RabbitMQ 实战指南》</p>
</blockquote>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft 共识算法</title>
    <url>/2020/08/15/Raft%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Paxos 算法偏向于理论，对于如何应用到工程实践上较少提及，同时 Paxos 算法较难理解且复杂性很高，目前能够真正在生产环境中独立使用的成品很少，已知的基础库，比如 Tencent 的 <a href="https://github.com/Tencent/phxpaxos">phxpaxos</a> 早在 2016 年开源，并在很久之前就停止维护了。阿里的 X-Paxos 只有文章介绍，并不开源。</p>
<span id="more"></span>

<p>Raft 在 2013 年提出，为了更容易理解和实施，Raft 将分布式问题分解和具化，由一个强有力（比 Paxos 的 leader 更强）的 leader 统一处理变更请求，使用 term 作为逻辑时钟来保证时序，一致性具化为保证节点间的操作日志副本（log replication）一致。</p>
<h1 id="Raft-算法的目标：日志复制同步"><a href="#Raft-算法的目标：日志复制同步" class="headerlink" title="Raft 算法的目标：日志复制同步"></a>Raft 算法的目标：日志复制同步</h1><p>Raft 算法的目标是将日志完整地复制到集群所有的节点中，这些复制日志会被状态机（可以理解为一个函数）所使用，只要我们能够保证各个节点上的日志是相同的，那么各个节点上的状态机就能以相同的顺序执行相同的命令，得到一致的结果。</p>
<p>Raft 算法允许服务器崩溃，不过它更希望是 fail-stop 式的崩溃，也就是说，节点只是停止工作或者停止工作又恢复了，但是要求只要节点处于运行状态，那么它们的行为就必须是正确的，这就意味着节点不能有拜占庭式的故障。同时 Raft 算法还允许网络通信中断，消息延迟或者丢失，甚至消息无序，网络分化。</p>
<h1 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h1><p>任何时候，节点只会有以下三种状态或角色：</p>
<ul>
<li>领导者（Leader）<br>Leader 负责处理客户端的请求，同时还负责处理日志的复制同步。任何时候只会有一个 Leader。</li>
<li>跟随者（Follower）<br>绝大多数节点在大部分时间下都是 Follower 状态，同时 Follower 不会主动发起任何 RPC 调用，它们只能被动地接收请求并响应。</li>
<li>候选者（Candidate）<br>处于领导者和跟随者之间的状态，只会在选举新 Leader 的过程中临时出现。</li>
</ul>
<h1 id="领导者任期（term）"><a href="#领导者任期（term）" class="headerlink" title="领导者任期（term）"></a>领导者任期（term）</h1><p>在 Raft 中，时序被分割为领导者任期。每段领导者任期都有一个序号，这些序号随着任期数的增加会自动增长，不会重复使用。任期由选举开始（选举开始前，term 先自增），成功当选的领导者会服务至本任期结束。也有可能存在任期内没有领导者的情况，比如出现分票（Split Vote），即不存在获得大多数投票的领导者，当发生这种情况时，系统会马上进入下一个新的任期（term 增长）并尝试重新选举。在 Raft 中，所有的节点都会保持一个当前任期的值，同时该值还会被持久化到本地磁盘中，以保证节点崩溃后能够恢复。</p>
<h1 id="心跳检测及超时处理"><a href="#心跳检测及超时处理" class="headerlink" title="心跳检测及超时处理"></a>心跳检测及超时处理</h1><p>跟随者是被动的，为了让它们一直处于跟随者状态，需要集群中有一个领导者始终与它们保持通信，如果领导者没有主动发起日志复制的请求，那么领导者就必须定时向它们发送心跳检测消息，在 Raft 中，这些心跳检测消息只是一些不含有任何数据信息的 AppendEntries 远程调用。如果在一段时间内，跟随者没有收到任何的远程调用，那么它会认为集群中没有可达或者可用的领导者，因此它就会开始发起选举，看它是否有必要称为新的领导者。这段时间被称为选举超时（election timeout），通常这个时间为 100 ms 到 500 ms。</p>
<h1 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h1><p>当集群启动时，所有的节点都是跟随者，它们会等待选举超时结束后开始选举。节点在开始选举时，首先会增加当前的任期号，然后会将自己的状态转换为候选者状态，此时候选者会先给自己投票，然后再向其他所有的节点发送投票请求（Request Vote），如果该请求没有得到响应，它会持续发送重试的请求，知道获得响应为止。接下来可能会出现三种情况：</p>
<ul>
<li>第一种，就是大多数情况，获选者获得了大多数选票，然后它会将自己的状态改为领导者并持续向集群的其他节点发送心跳检测。</li>
<li>第二种，可能同时还有其他候选者在运行，或许它们有可能获得大多数选票成为领导者，此时如果候选者收到来自领导者的 RPC 调用，那么它会立刻从候选者状态转换为跟随者状态。</li>
<li>第三种，可能没有任何节点获胜，如果存在多个节点同时成为候选者，它们会导致分票，没有节点能够获得大多数投票。为了检测这种情况，随着时间的推移，如果一个候选者既没能成为领导者，也没有获得到来自领导者的请求或心跳，那么它就会假定出现了分票，此时它会简单地增加任期号，重新进行选举。</li>
</ul>
<h2 id="选举的-safety-和-liveness"><a href="#选举的-safety-和-liveness" class="headerlink" title="选举的 safety 和 liveness"></a>选举的 safety 和 liveness</h2><p>为了保证选举的 safety，每个节点只会给一个候选者投票，一旦它投出选票，那么它就会拒绝来自其他候选者的任何请求。为了实现这种机制，节点会将自己的投票信息持久化到磁盘。</p>
<p>在理论上，可能会出现反复分票的情况，多个获选者在同一任期内同时开始选举，在超时时间后，新一轮的选举再次出现分票，如此循环。为了保证选举的 liveness，每个节点会随机地计算下次超时时间间隔，这个时间间隔在 [T, 2T] 之间，其中 T 代表选举的超时时间。通过将超时时间分散，可以降低两个节点同时开始选举的几率，先开始的节点有充足的时间向其他节点发送投票请求，并在其他节点参与竞争之前就完成选举过程。</p>
<blockquote>
<p>当选举超时时间（election timeout）远大于广播投票的时间（一个节点与其他所有节点通信所需的时间）时，Raft 的这个策略就会非常有效。</p>
</blockquote>
<h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><p>日志由有序序号（log index）标记的条目组成，每个条目都包含创建时的任期号（term）和一个状态机需要执行的指令。客户端的每一个请求都包含一条被复制状态机执行的指令，领导者会将这个指令作为一条新的日志条目附加到日志中，然后并行地向其他节点发送附加日志条目（AppendEntries）的请求，当过半的节点成功复制并响应请求后，该日志条目就是<strong>已提交</strong>的，此时领导者会将该日志条目应用到状态机中，并把状态机执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，或者网络丢包，领导者会不断重复尝试发送附加日志条目的请求（尽管已经达到了多数派并将结果返回给了客户端），直到所有的跟随者都最终存储了所有的日志条目。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008241748/2020/08/21/YNE.png" alt="日志复制"></p>
<h2 id="日志的一致性检查"><a href="#日志的一致性检查" class="headerlink" title="日志的一致性检查"></a>日志的一致性检查</h2><p>Raft 的日志机制维护着以下特性：如果在不同的日志中，两个条目拥有相同的索引和任期号，那么它们存储了相同的指令，同时它们之前的所有日志条目也全部相同。</p>
<p>为了维护以上特性，领导者在一个任期内，一个索引位置只会创建一个日志条目，并且日志条目一旦创建，位置就不会改变。同时在发送附加日志请求时，领导者会把新日志条目紧挨着的前一个日志条目的索引位置和任期号也一并发送，如果跟随者在它本地的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝接受新的日志条目，这就是日志的一致性检查。</p>
<h2 id="领导者变更"><a href="#领导者变更" class="headerlink" title="领导者变更"></a>领导者变更</h2><p>在正常的操作中，领导者和跟随者的日志保持一致，所以这种一致性检查不会失败。然而，当领导者崩溃就有可能使得日志处于不一致的状态（新的领导者可能还没有完全复制所有的日志条目），并且这种不一致会在领导者和跟随者的一系列崩溃下加剧。下图展示了跟随者的日志可能和新的领导者不同的几种方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008241748/2020/08/21/MPg.png" alt="不一致"></p>
<p>当一个领导者成功当选时，跟随者可能是任何情况，比如图中的 a 到 f。图中的每个格子代表一条日志条目，其中的数字是任期号。此时新领导者的任期号是 8，跟随者可能会缺少一些条目，比如 a 和 b。也有可能会有一些未被提交的日志条目，比如 c 和 d。还有可能两种情况都存在，比如 e 和 f。在 f 中，该机器在任期号为 2 时是领导者，同时附加了一些日志条目到自己的日志中，但是在提交之前就崩溃了，然后该机器很快就重启了，并在任期号为 3 时再次当选，同时又附加了一些日志条目到自己的日志中，而在任期号为 2 和 3 的日志被提交之前，该机器又崩溃了，并在接下来的几个任期里一直处于宕机状态。</p>
<p><strong>在 Raft 算法中，领导者处理不一致是通过强制跟随者复制自己的日志来解决的，这就意味着在跟随者中的冲突日志条目会被领导者的日志覆盖</strong>。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>前面描述了 Raft 算法是如何实现选举和日志复制的，但是通过目前描述的机制是不能充分保证每一个状态机都会按照相同的顺序执行相同的指令。比如，一个跟随者可能进入了不可用状态，而此时的领导者已经提交了若干的日志条目，如果这个跟随者在之后被选举成了领导者并覆盖了这部分日志条目，就会造成不同的状态机可能会执行不同的指令序列。因此，需要我们在进行领导者选举时增加一些限制，来保证对于任意给定的任期号，被成功选举出的领导者都拥有之前任期的所有被提交的日志条目。同时增加这条限制，也使得我们在提交时的规则更加清晰。</p>
<h2 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h2><p>在选举时，候选者为了胜选必须联系集群中大部分的节点，这就意味着每一个已经提交的日志条目肯定存在于这些节点中的至少一个节点上。如果候选者的日志至少和大多数节点一样新，那么它一定持有了所有已经提交的日志条目。选举的投票请求（Request Vote）中会包含候选者最后一条日志条目的索引值和任期号，接收到该请求的投票者会比较这两个值，如果任期号不同，那么任期号大的更新；如果任期号相同，那么索引号大的日志更新。当候选者的日志没有投票者的新时，投票者会拒绝该投票请求。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Redis 设计与实现》观后总结</title>
    <url>/2018/11/06/Redis%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>《Redis 设计与实现》更多的是讲解 Redis 的底层，对于实践讲解的较少，适合想深入了解 Redis 的读者。这里总结一下要点，方便随时温习。  </p>
<span id="more"></span>  

<h1 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h1><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis 服务器的状态通过 <code>redisServer</code> 结构体来维护，其中有一个 db 数组用来维护所有的数据库，每个数据库的状态通过 <code>redisDb</code> 来维护。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数组，保存所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// 数据库的个数</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    <span class="comment">// 距离上一次执行 save 之后数据库修改的次数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    <span class="comment">// 最后一次执行 save 成功时的时间戳</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数据库切换"><a href="#数据库切换" class="headerlink" title="数据库切换"></a>数据库切换</h2><p>数据库的切换通过 <code>select</code> 命令进行。在服务器内部，客户端的状态通过 <code>client</code> 结构体来维护，db 属性是一个指向 <code>redisDb</code> 结构的指针，指向客户端当前使用的数据库。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向当前选择的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>

<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>Redis 服务器中的每个数据库都是通过 <code>redisDb</code> 结构体来维护的，其中 dict 属性保存的是数据库的所有键值对，这个字典被称为键空间。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键空间</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 过期字典</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>键空间的键都是字符串对象，值可以是字符串对象、列表对象、集合对象、哈希表对象等任意一种 Redis 对象。  </p>
<h2 id="键空间维护"><a href="#键空间维护" class="headerlink" title="键空间维护"></a>键空间维护</h2><p>在使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间进行读写，还会执行一些额外的操作。  </p>
<ul>
<li>读取键后（读和写都要先进行读），服务器会根据键是否存在来更新服务器键空间的命中（hit）和不命中（miss）次数，可以通过 <code>INFO stats</code> 命令查看。  </li>
<li>读取键后，服务器会更新键的 LRU（最后一次使用）时间，使用 <code>OBJECT IDLETIME</code> 命令查看。  </li>
<li>如果在读取键时，发现键已经过期，则会删除过期键。  </li>
<li>如果有客户端使用 <code>WATCH</code> 命令监视了某个键，那么服务器会在被监视键被修改时标记这个键为 dirty，从而让事务注意。  </li>
<li>服务器每次修改键都会对属性 dirty 增加 1，这个计数器用来触发自动执行 save 持久化。  </li>
<li>如果服务器开启了数据库通知，那么在对键进行修改后，服务器会发送相应的数据库通知。</li>
</ul>
<h2 id="过期键"><a href="#过期键" class="headerlink" title="过期键"></a>过期键</h2><p>使用 <code>EXPIRE</code>、<code>PEXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIREAT</code> 等命令可以为键设置过期时间，当过期时间到达时服务器会自动删除该键。过期时间保存在 <code>redisDb</code> 的过期字典里，这个字典中的键与键空间中的键都指向同一个键对象，值保存的是该键的过期时间（一个 long long 类型的整数，毫秒精度的 UNIX 时间戳）。  </p>
<p>使用 <code>PERSIST</code> 命令可以移除一个键的过期时间，使用 <code>TTL</code> 或 <code>PTTL</code> 命令可以返回一个键的剩余生存时间。  </p>
<h2 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h2><p>Redis 采用惰性删除和定期删除两种策略，惰性删除对 CPU 时间友好，但会浪费大量内存；定期删除需要占用大量的 CPU 时间，但能够节省内存。  </p>
<p>惰性删除由 db.c&#x2F;expireIfNeeded 函数实现，在所有的读写数据库命令执行前，都会调用该函数检查，如果键已经过期，则直接删除（根据 <code>lazyfree_lazy_expire</code> 的参数不同执行不同的删除函数，默认采用同步删除，会阻塞）。  </p>
<p>定期删除由 <code>activeExpireCycle</code> 函数实现，<strong>每当 Redis 服务器的周期性操作 <code>serverCron</code> 函数执行时，该函数就会被调用</strong>。它会在规定的时间内，分多次遍历服务器中的各个数据库，从 expires 字典中随机检查部分键的过期时间，并删除其中的过期键（默认采用同步删除，会阻塞）。该函数使用一个全局变量 <code>current_db</code> 记录每次该函数的检查进度，并在下一次调用该函数时，接着上次的进度继续进行，当所有的数据库都被检查过之后，该全局变量会重置为 0，然后继续下一轮的检查。  </p>
<h2 id="RDB、AOF-和复制对过期键的处理"><a href="#RDB、AOF-和复制对过期键的处理" class="headerlink" title="RDB、AOF 和复制对过期键的处理"></a>RDB、AOF 和复制对过期键的处理</h2><ul>
<li>在生成 RDB 文件时，已经过期的键不会被持久化。在 RDB 文件加载时，如果 Redis 服务器以<strong>主服务器模式</strong>启动，则过期键不会被载入；如果 Redis 服务器以<strong>从服务器模式</strong>启动，则所有的键都会被载入。   </li>
<li>当 Redis 服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但是还没有执行删除操作，此时 AOF 文件不会有任何变化，只有当该键执行惰性删除或者定期删除后，程序才会向 AOF 文件中追加一条 <code>DEL</code> 命令来显式的记录该键已被删除。  </li>
<li>和生成 RDB 文件类似，在执行 AOF 重写的过程中，过期键不会被保存到重写后的 AOF 文件中。  </li>
<li>当 Redis 服务器运行在复制模式下时，从服务器过期键的删除由主服务器控制。主服务器在删除一个过期键时，会向从服务器发送一个删除命令，通知从服务器删除该键。从服务器在收到主服务器删除该键的命令之前，所有对该键的读写操作都会像该键没有过期一样被执行，通过这种方式来保证主从的数据一致性。</li>
</ul>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>数据库通知功能是通过 Redis 的发布订阅功能实现的，通知具体分为键空间通知（key-space notification）和键事件通知（key-event notification），键空间通知关注的是<strong>某个键执行了什么命令</strong>，键事件通知关注的是<strong>某个命令被什么键执行了</strong>。因为通知需要耗费一定的 CPU 时间，所以默认情况下该功能是关闭的，可以通过修改配置文件或者通过 <code>CONFIG SET</code> 命令设置 <code>notify-keyspace-events</code> 选项来启用该功能，具体的设置参数可以参考 Redis 配置文件。  </p>
<p>这里举几个简单的例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: language 键是列表键，所以要加参数 l</span><br><span class="line">CONFIG SET notify-keyspace-events Kl</span><br><span class="line">:: 订阅数据库 0 上的 language 键执行的所有命令</span><br><span class="line">subscribe __keyspace@0__:language</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG SET notify-keyspace-events Elg</span><br><span class="line">:: 订阅数据库 0 上的所有执行 del 命令的所有键</span><br><span class="line">subscribe __keyevent@0__:del</span><br></pre></td></tr></table></figure>

<h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><p><strong>RDB 持久化是一种镜像全量持久化，持久化的是当前内存中所有数据的快照</strong>。  </p>
<h2 id="RDB-文件的创建与载入"><a href="#RDB-文件的创建与载入" class="headerlink" title="RDB 文件的创建与载入"></a>RDB 文件的创建与载入</h2><p>通过 <code>SAVE</code> 和 <code>BGSAVE</code> 两个命令来生成 RDB 文件，其中 <code>SAVE</code> 命令会阻塞服务器进程，<code>BGSAVE</code> 命令会 fork 出一个子进程来生成 RDB 文件，父进程继续处理客户端命令而不会阻塞。  </p>
<p>Redis 服务器会在启动时检测 RDB 文件是否存在，如果存在则会自动载入。由于 AOF 文件的更新频率一般比 RDB 文件的更新频率高，所以如果服务器开启了 AOF 持久化，服务器会优先使用 AOF 文件来还原数据库。  </p>
<h2 id="BGSAVE-命令执行时服务器的状态"><a href="#BGSAVE-命令执行时服务器的状态" class="headerlink" title="BGSAVE 命令执行时服务器的状态"></a>BGSAVE 命令执行时服务器的状态</h2><p>在 <code>BGSAVE</code> 命令执行期间，客户端的 <code>SAVE</code>、<code>BGSAVE</code> 命令会被拒绝，目的是防止同时调用 <code>rdbSave</code> 函数而产生竞态条件。虽然 <code>BGREWRITEAOF</code> 命令和 <code>BGSAVE</code> 命令没有冲突的地方，但是 Redis 不会同时执行它们，目的是防止出现多个子进程同时执行大量的磁盘写入操作。  </p>
<h2 id="自动间隔保存"><a href="#自动间隔保存" class="headerlink" title="自动间隔保存"></a>自动间隔保存</h2><p>因为 <code>BGSAVE</code> 不会阻塞主进程，所以可以通过配置，让 Redis 服务器每隔一段时间自动执行 <code>BGSAVE</code> 命令，该功能是通过 dirty 计数器和 lastsave 属性来实现的。Redis 默认的配置如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 服务器在 900 秒之内，对数据库进行了至少 1 次修改</span><br><span class="line">save 900 1</span><br><span class="line">:: 服务器在 300 秒之内，对数据库进行了至少 10 次修改</span><br><span class="line">save 300 10</span><br><span class="line">:: 服务器在 60 秒之内，对数据库进行了至少 10000 次修改</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><p>AOF 持久化是一种增量持久化，通过向文件中追加服务器所执行的写命令来记录数据库的状态。修改配置文件的 appendonly 选项为 yes 可以开启 AOF 功能。AOF 持久化的实现可以分为命令追加（append）、文件写入和文件同步（sync）三个步骤。</p>
<h2 id="AOF-持久化之命令追加"><a href="#AOF-持久化之命令追加" class="headerlink" title="AOF 持久化之命令追加"></a>AOF 持久化之命令追加</h2><p>命令追加是在服务器执行完一个写命令后，以协议方式将执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="AOF-持久化之文件写入和同步"><a href="#AOF-持久化之文件写入和同步" class="headerlink" title="AOF 持久化之文件写入和同步"></a>AOF 持久化之文件写入和同步</h2><p>**Redis 的服务器进程（主进程）就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令，以及向客户端发送回复，而时间事件负责执行像 <code>serverCron</code> 函数这样需要定时运行的函数。**Redis 在处理文件事件时可能会执行写命令，使得一些内容被追加到 aof_buf 缓冲区中，所以服务器每次结束一个事件循环之前，都会调用 <code>flushAppendOnlyFile</code> 函数来决定是否要将缓冲区中的内容写入并同步到 AOF 文件中，该函数的同步行为与服务器的配置项 <code>appendfsync</code> 的值有关。  </p>
<table>
<thead>
<tr>
<th>appendfsync</th>
<th>flushAppendOnlyFile 函数的行为</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>将 aof_buf 的所有内容写入并同步到 AOF 文件。</td>
<td>很慢，但非常安全</td>
</tr>
<tr>
<td>everysec</td>
<td>将 aof_buf 的所有内容写入到 AOF 文件，如果上次同步 AOF 的时间距离现在超过一秒，那么会再次进行同步。同步操作由一个线程专门负责。</td>
<td>每秒一次，速度足够快，但是如果发生灾难，可能会丢失一秒的数据</td>
</tr>
<tr>
<td>no</td>
<td>将 aof_buf 的所有内容写入到 AOF 文件中，至于何时进行同步由操作系统决定。</td>
<td>最快，但是不安全</td>
</tr>
</tbody></table>
<p>Redis 默认 <code>appendfsync</code> 的值为 everysec。与 AOF 不同的是，RDB 采用的是每次写入都会强制同步。</p>
<blockquote>
<p>在现代操作系统中，用户调用 write 函数将数据写入到文件时，操作系统通常会将写入的数据暂时保存在一个内存缓冲区中，等到缓冲区被填满或者超过了指定的时限时才会将缓冲区里的数据真正写入到磁盘上。这种做法虽然提高了写入的效率，但也带来了安全问题，如果计算机意外停机，那么缓冲区里的写入数据将会丢失。为此，操作系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到磁盘上。   </p>
</blockquote>
<h2 id="AOF-文件的载入"><a href="#AOF-文件的载入" class="headerlink" title="AOF 文件的载入"></a>AOF 文件的载入</h2><p>由于 AOF 文件包含重建数据库状态需要的全部写命令，因此服务器只要读取并重新执行一遍 AOF 文件中的命令即可，由于 <strong>Redis 的命令只能在客户端上下文中执行</strong>，所以 Redis 会创建一个不带网络连接的伪客户端（fake client）来执行命令。  </p>
<h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>AOF 文件会随着 Redis 运行时间的流逝而逐渐增大，为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写的功能。通过该功能，Redis 服务器可以创建一个新的 AOF 文件替换现有的 AOF 文件，新文件保存的数据库状态与现有的一致，但是不会包含冗余命令。  </p>
<p>AOF 重写功能并不会去读取现有的 AOF 文件，其核心思想是从数据库中读取键的状态，并将键的值使用一条写入命令来记录。  </p>
<blockquote>
<p>为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合等可能会有多个元素的键时，会先检查键所包含的元素数量，如果数量超过 AOF_REWRITE_ITEMS_PER_CMD 常量的值（当前版本中该值为 64），那么重写程序会使用多条命令来记录键的值。  </p>
</blockquote>
<h2 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h2><p>AOF 后台重写可以通过 <code>BGREWRITEAOF</code> 命令使用。由于 AOF 重写会进行大量的写入操作并长期阻塞主进程，所以 Redis 决定将重写程序放到子进程中执行，这样做可以达到两个目的：  </p>
<ol>
<li>子进程在 AOF 重写期间，服务器父进程仍然可以继续处理客户端命令。  </li>
<li>子进程带有父进程的数据副本，使用子进程而不是线程可以避免使用锁，保证数据安全。</li>
</ol>
<p>使用子进程需要解决一个问题，如果子进程在进行 AOF 重写期间，Redis 主进程执行的新命令对现有的数据库状态进行了修改，这会导致当前数据库的状态与重写后 AOF 文件中保存的状态不一致。为了解决这个问题，Redis 服务器又维护了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令后，它会同时将这个写命令追加到 AOF 缓冲区和 AOF 重写缓冲区。当子进程完成 AOF 重写工作后，它会向父进程发送一个信号，父进程接收到该信号后会调用一个信号处理函数，将 AOF 重写缓冲区的所有内容写入到新 AOF 文件中，然后对新的 AOF 文件改名，原子地（atomic）覆盖现有的 AOF 文件。<strong>这样在整个 AOF 重写过程中，只有信号处理函数执行时会对服务器主进程造成阻塞，把 AOF 重写对服务器性能的影响降到了最小。</strong></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 入门</title>
    <url>/2018/07/24/Redis%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Redis 是一个开源高性能的 key-value 数据库软件，主要有以下特性：</p>
<ul>
<li>可以将数据存储在内存，同时支持持久化到磁盘。  </li>
<li>支持的数据类型丰富，包括 String、List、Set、Stored Set、Hash 等。  </li>
<li>支持 master-slave 模式的数据备份和同步。  </li>
<li>所有的单个操作都是原子性的，同时多个操作也支持事务，通过 MULTI 和 EXEC 包装。</li>
</ul>
<span id="more"></span>

<p>Redis 分为服务端和客户端，一个服务端可以与多个客户端建立连接，每个客户端向服务端发送命令请求，服务端接收请求处理后返回信息给客户端。除了自带的 <code>redis-cli</code>，还可以使用其他语言提供的客户端来操作。  </p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li>获取所有配置项<br><code>CONFIG GET *</code></li>
<li>获取某个配置<br><code>CONFIG GET config_setting_name</code></li>
<li>修改配置<br><code>CONFIG SET config_setting_name new_config_value</code></li>
</ul>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>Redis 底层使用的字符串是 Sds（Simple Dynamic String，简单动态字符串），使用 Sds 主要用于实现字符串对象（StringObject），并在内部替换 char* 类型。  </p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="实现字符串对象"><a href="#实现字符串对象" class="headerlink" title="实现字符串对象"></a>实现字符串对象</h4><p>Redis 是一个 key-value 数据库，数据库的值可以是字符串，也可以是集合、列表等类型，但是数据库的键则总是字符串对象。Redis 中，一个字符串对象除了可以保存字符串值之外，还可以保存 long 类型的值。当字符串对象保存的是字符串时，它包含的才是 Sds 值；否则，它就是一个 long 类型的值。比如：  </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">:: 这里的键和值都是字符串对象，它们都包含一个 Sds 值</span><br><span class="line"><span class="built_in">SET</span> name saber</span><br><span class="line">:: 这里的键是字符串对象，包含一个 Sds 值，而值是一个集合对象</span><br><span class="line">SADD languages Java Python JavaScript Lisp</span><br></pre></td></tr></table></figure>

<h4 id="替换-char"><a href="#替换-char" class="headerlink" title="替换 char*"></a>替换 char*</h4><p>Redis 使用 Sds 替换 C 语言中的 char* 是因为在 Redis 内部，字符串的追加和长度计算很常见，甚至有专门的命令：<code>APPEND</code> 和 <code>STRLEN</code>，使用 C 语言提供的 char 类型数组并不能进行高效的长度计算和追加操作。  </p>
<p>C 语言中的字符串不会记录自己的长度，当需要获取长度的时候，需要遍历整个字符数组，直到遇到空字符为止，时间复杂度为 O(N)，而 sds 保存了自身的长度，在需要时直接获取，时间复杂度为 O(1)。  </p>
<p>C 语言中在进行字符串的扩充和收缩时，都需要重新分配内存空间。  </p>
<ul>
<li>字符串拼接会导致字符串内存空间的扩充（字符数组的扩容），如果在拼接的过程中忘记申请内存空间，就会面临内存溢出的危险。  </li>
<li>字符串切割会导致字符串内存空间的收缩（字符数组的分割），如果在字符串切割的时候没有对内存空间重新分配，那么多出来的空间就会发生内存泄露。</li>
</ul>
<p>Redis 通过内存的预分配和惰性释放来优化内存分配的问题。  </p>
<h3 id="Sds-的数据结构"><a href="#Sds-的数据结构" class="headerlink" title="Sds 的数据结构"></a>Sds 的数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sds 由两部分组成，<code>typedef char *sds</code> 表示 sds 是 char * 类型的别名，结构体 sdshdr 则包含 len、free 和 buf 三个属性。比如：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    buf = <span class="string">&quot;Hello World\0&quot;</span>; <span class="comment">// buf 的实际长度为 len + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化追加操作"><a href="#优化追加操作" class="headerlink" title="优化追加操作"></a>优化追加操作</h3><p>通过一个例子来说明追加时发生了什么。  </p>
<p>首先执行 <code>SET message Hello World</code>，<code>SET</code> 命令会创建 sdshdr，但是 free 的值为 0。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    buf = <span class="string">&quot;Hello World\0&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后执行 <code>APPEND message &quot; Avalon&quot;</code>，此时 free 变为 18。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">18</span>;</span><br><span class="line">    buf = <span class="string">&quot;Hello World Avalon\0        &quot;</span>; <span class="comment">// 空白部分为预分配的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 APPEND 命令会根据追加后内容的长度来预先分配 len 长度的空间，如果后续又使用 APPEND 命令追加内容，而内容的长度不超过 free 的大小，则不用再分配空间。  </p>
<p>sds.c&#x2F;sdsMakeRoomFor 函数描述这种内存预分配优化策略，以下为伪代码：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">sdsMakeRoomFor</span><span class="params">(sdshdr, required_len)</span> &#123;</span><br><span class="line">    # 预分配的空间足够，则直接返回</span><br><span class="line">    <span class="keyword">if</span>(sdshdr.<span class="built_in">free</span> &gt;= required_len)</span><br><span class="line">        <span class="keyword">return</span> sdshdr</span><br><span class="line">    </span><br><span class="line">    # 计算新字符串的长度</span><br><span class="line">    newLen = sdshdr.len + required_len</span><br><span class="line">    </span><br><span class="line">    # 如果新字符串的长度小于 SDS_MAX_PREALLOC，则为新字符串分配</span><br><span class="line">    # <span class="number">2</span> 倍于所需长度的空间；否则分配为所需长度加上 SDS_MAX_PREALLOC 的空间</span><br><span class="line">    <span class="keyword">if</span> newLen &lt; SDS_MAX_PREALLOC :</span><br><span class="line">        newLen *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        newLen += SDS_MAX_PREALLOC</span><br><span class="line">    </span><br><span class="line">    # 分配空间</span><br><span class="line">    newsh = zrelloc(sdshdr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr) + newLen + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    # 更新 <span class="built_in">free</span> 的值</span><br><span class="line">    newsh.<span class="built_in">free</span> = newLen - sdshdr.len</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newsh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前的 Redis 版本为 5.0 RC3，SDS_MAX_PREALLOC 的值还是 1024*1024，也就是 1MB。  </p>
<p>APPEND 的这种预先分配策略的代价就是会有额外的内存占用，这些预分配的空间只有在字符串对应的键被删除或者 Redis 实例停止时才被回收。这种以空间换时间的方式，在现在内存成本相对较低的背景下是有价值的。当然，如果 APPEND 操作过多，同时字符串的体积较大时，可能就需要调整 Redis 的配置，使它定时释放一些字符串键的预分配内存。  </p>
<h3 id="惰性释放"><a href="#惰性释放" class="headerlink" title="惰性释放"></a>惰性释放</h3><p>当字符串进行切割缩短操作时，并不立即释放空间，而是将这部分空间通过 free 标识，这样在下次使用该字符串操作时可很有可能会避免再次分配内存。同时 Redis 还提供了专门的 API 来释放这部分空余的空间。  </p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C 语言的字符串，除了末尾处，其他位置不能包含空字符，否则会被认为是字符串的结尾，从而导致读取数据时丢失后边的字符。这个限制导致了字符串不能存储图片、音视频等二进制数据。Redis 不是通过空字符来判断字符串是否结束的，它通过结构体中的 len 属性来判断，所以 Redis 可以存储文本和任意二进制数据。  </p>
<h2 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h2><p>由于 C 语言本身不支持链表类型，所以大部分的 C 语言程序都会自己实现链表结构，Redis 实现的是双端链表。Redis 的 List 使用了两种数据结构：双端链表和压缩列表。因为双端链表占用内存比压缩列表多，所以当创建新的列表键时，列表会优先考虑使用压缩列表作为底层实现，只有在有需要的时候才转换成双端链表。  </p>
<h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p>除了实现 List 外，双端链表还被很多 Redis 内部模块使用，比如：  </p>
<ul>
<li>事务模块使用双端链表依序保存输入的命令</li>
<li>服务端使用双端链表保存建立连接的多个客户端</li>
<li>订阅&#x2F;发布模块使用双端链表保存订阅的客户端</li>
<li>事件模块使用双端链表保存时间事件</li>
</ul>
<h3 id="双端链表的数据结构"><a href="#双端链表的数据结构" class="headerlink" title="双端链表的数据结构"></a>双端链表的数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/26/YQg.png" alt="双端链表"></p>
<p>源代码在 addlist.h 中。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// 复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 比对函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>根据这两个结构的定义，可以了解到双端列表的一些特性：  </p>
<ul>
<li>listNode 的 value 属性类型为 void *，也就是说双向链表对于节点保存的值的类型没有限制。  </li>
<li>由于保存了 head 和 tail 两个指针，所以对链表的头部和尾部插入元素的复杂度都为 O(1)，这也是命令 <code>LPUSH</code>、<code>RPOP</code> 和 <code>RPOPLPUSH</code> 高效的原因。  </li>
<li>双向链表保存有节点数量的 len 属性，所以计算长度的复杂度也为 O(1)，即 <code>LLEN</code> 命令的时间复杂度为 O(1)。</li>
</ul>
<p>Redis 还为双端链表实现了一个迭代器，支持从前往后和从后往前两个方向进行迭代。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="comment">// 迭代方向</span></span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典（dictionary）又名映射（map），由一个个键值对组成。它主要有两个用途：  </p>
<ul>
<li>实现数据库键空间（key space）</li>
<li>用作 Hash 类型的底层实现之一</li>
</ul>
<h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><h4 id="实现数据库键空间"><a href="#实现数据库键空间" class="headerlink" title="实现数据库键空间"></a>实现数据库键空间</h4><p>Redis 是 key-value 数据库，在 Redis 实例内部维护着一个数据库数组，每个元素都是一个数据库，在实例初始化时，默认会创建 16 个数据库，每个数据库都有一个对应的字典，这个字典就是键空间（key space）。当用户添加一个键值对到其中某个数据库时，不论键值对的值是什么类型（List、Set、String、Hash 等等），都会将该键值对添加到该数据库对应的键空间中。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 选择 0 号数据库</span><br><span class="line">SELECT 0</span><br><span class="line">:: 从列表左侧添加元素</span><br><span class="line">LPUSH languages Lisp Java Ruby Python</span><br><span class="line">:: 检查键空间中是否存在刚添加的键值对</span><br><span class="line">EXISTS languages</span><br></pre></td></tr></table></figure>
<h4 id="用作-Hash-类型的底层实现之一"><a href="#用作-Hash-类型的底层实现之一" class="headerlink" title="用作 Hash 类型的底层实现之一"></a>用作 Hash 类型的底层实现之一</h4><p>Redis 中的 Hash 类型使用字典或压缩列表来实现。因为压缩列表更节省内存，所以在创建新的 Hash 键时，默认使用压缩列表作为底层实现，只有在需要时才转换为字典。  </p>
<h3 id="字典的数据结构"><a href="#字典的数据结构" class="headerlink" title="字典的数据结构"></a>字典的数据结构</h3><p>字典的定义在 dict.h  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 特定于类型的处理函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 类型处理函数的私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表，有 2 个</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 记录 rehash 进度的标志，值为 -1 表示 rehash 未进行</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line">    <span class="comment">// 正在运行的安全迭代器数量</span></span><br><span class="line">    <span class="type">int</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>dict 使用了两个指针，分别指向两个哈希表。其中，0 号哈希表是字典主要使用的哈希表，1 号哈希表则在对 0 号哈希表进行 rehash 时才使用。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 数组的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">// 指针数组的长度掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 哈希表现有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>table 是一个数组，数组的元素是指向 dictEntry 结构的指针。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>总体结构如下图：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/02/Py6.png" alt="dict"></p>
<h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><p>dictCreate 函数创建并返回一个新的字典：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dict *d = dictCreate(&amp;hash_type, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/02/abR.png" alt="创建字典"></p>
<p>新创建的字典中，两个哈希表都没有分配任何空间，只有在以下情况才会分配：  </p>
<ul>
<li>ht[0]-&gt;table 的空间在第一次向字典中添加键值对时分配</li>
<li>ht[1]-&gt;table 的空间在 rehash 开始时分配</li>
</ul>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/02/yAL.png" alt="添加键值对"></p>
<p>其中，有三种特殊的情况需要处理：  </p>
<ul>
<li>字典没有初始化</li>
<li>添加键值对时发生哈希冲突</li>
<li>添加键值对时触发了 rehash 操作</li>
</ul>
<h3 id="初始化字典"><a href="#初始化字典" class="headerlink" title="初始化字典"></a>初始化字典</h3><p>添加键值对，结果发现字典还没有初始化，则会执行初始化操作。根据 dict.h&#x2F;DICT_HT_INITIAL_SIZE 里指定的大小为 ht[0]-&gt;table 分配空间，当前版本 5.0-rc3 中该值为 4。  </p>
<p>字典未初始化时：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/02/z99.png" alt="字典未初始化"></p>
<p>字典初始化，并添加了一个键值对后：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/02/xDJ.png" alt="字典初始化并添加了一个键值对"></p>
<h3 id="哈希冲突的解决"><a href="#哈希冲突的解决" class="headerlink" title="哈希冲突的解决"></a>哈希冲突的解决</h3><p>字典解决哈希冲突采用的方法为链地址法，即将哈希值相同的节点放在桶结构上，形成一个链表。  </p>
<p>没有哈希冲突时：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/02/rlx.png" alt="没有哈希冲突时"></p>
<p>哈希冲突时：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/02/bML.png" alt="哈希冲突时"></p>
<h3 id="触发-rehash-操作"><a href="#触发-rehash-操作" class="headerlink" title="触发 rehash 操作"></a>触发 rehash 操作</h3><p>使用链地址法处理冲突时，如果冲突比较严重，哈希表的查找性能会严重下降。最坏的情况下会退化成线性查找，即所有的节点都在一个桶结构上，时间复杂度为 O(N)。哈希表的性能可以通过哈希表的大小（数组大小，size）与节点数量（used）之间的比率来衡量。  </p>
<p>当哈希表的大小和节点的数量为 1:1 时，性能和空间利用率最好；如果哈希表中节点数量比哈希表的大小大很多时，哈希表很可能是退化成了多个链表，这时查找性能就会下降，此时就需要对哈希表进行扩容。  </p>
<p>dictAdd 函数的作用是添加新的键值对到字典中。该方法在添加键值对之前都会对哈希表 ht[0] 进行检查，判断 <code>ratio = used / size</code> 的值：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp; </span><br><span class="line">    (dict_can_resize || d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio)) &#123;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 ratio &gt;&#x3D; 1，且变量 dict_can_resize 为 true 时，执行 rehash</li>
<li>当 ratio &gt; dict_force_resize_ratio（当前版本 Redis 5.0-rc3 值为 5）时，即使 dict_can_resize 为 false（有持久化任务在进行），字典也会强制执行 rehash。</li>
</ul>
<blockquote>
<p>当 Redis 使用子进程对数据库执行后台持久化任务（比如 BGSAVE 或 BGREWRITEAOF）时，为了最大化利用系统的 copy on write 机制，程序会暂时将 dict_can_resize 设置为 false，避免执行自然 rehash，从而减少程序对内存的触碰（touch）。当持久化任务完成后，dict_can_resize 会被重新设置为 true。  </p>
</blockquote>
<h3 id="rehash-执行过程"><a href="#rehash-执行过程" class="headerlink" title="rehash 执行过程"></a>rehash 执行过程</h3><p>字典的 rehash 过程主要包括：  </p>
<ol>
<li>创建一个比 ht[0]-&gt;table 更大的 ht[1]-&gt;table</li>
<li>将 ht[0]-&gt;table 中所有的键值对迁移到 ht[1]-&gt;table</li>
<li>清空 ht[0] 的数据，用 ht[1] 替换 ht[0] 后再将 ht[1] 置为空</li>
</ol>
<h4 id="开始-rehash"><a href="#开始-rehash" class="headerlink" title="开始 rehash"></a>开始 rehash</h4><ul>
<li>在需要扩容，执行 dictExpand 方法时，rehashidx 就被设置成了 0，这标志着 rehash 的开始。</li>
<li>为 ht[1]-&gt;table 分配空间，大小至少是 ht[0]-&gt;table 的 2倍。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/04/ONr.png" alt="开始 rehash"></p>
<h4 id="rehash-进行中"><a href="#rehash-进行中" class="headerlink" title="rehash 进行中"></a>rehash 进行中</h4><p>在这个阶段，ht[0]-&gt;table 上的节点并不会一次性全部迁移，而是逐渐迁移到 ht[1]-&gt;table 上，字典的 rehashidx 会记录 rehash 进行到了 ht[0] 的哪个位置。以下是 rehashidx 值为 2 时，字典的样子：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/04/0Lk.png" alt="rehash 进行中"></p>
<h4 id="节点迁移完毕"><a href="#节点迁移完毕" class="headerlink" title="节点迁移完毕"></a>节点迁移完毕</h4><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/04/Kd6.png" alt="迁移完毕"></p>
<h4 id="rehash-完毕"><a href="#rehash-完毕" class="headerlink" title="rehash 完毕"></a>rehash 完毕</h4><p>节点迁移完毕后，还需要执行以下步骤：  </p>
<ul>
<li>释放 ht[0] 的空间</li>
<li>将 ht[0] 指向 ht[1]</li>
<li>将 ht[1] 指向一个新的空哈希表</li>
<li>将字典的 rehashidx 重新设置为 -1，表示 rehash 已经结束</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/04/2lD.png" alt="rehash 结束"></p>
<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>rehash 并不是在启动后就立马执行直到完成，而是分为多次、渐进式地完成。  </p>
<p>如果在一个有很多键值对的字典中，用户频繁添加新的键值对，可能会多次触发 rehash，如果每次都需要将全部节点迁移完毕才能继续，这对用户来说是很不友好的。并且，由于 Redis 使用的是单线程，如果必须要等待 rehash 的完成才能执行其他操作，这期间 Redis 会一直阻塞，这也是不能接受的，因此 Redis 将 rehash 的过程分散到多个步骤中进行来避免集中式的计算。  </p>
<p>渐进式 rehash 主要由 _dictRehashStep 和 dictRehashMilliseconds 两个函数来处理。  </p>
<ul>
<li>_dictRehashStep 用于对数据库键空间以及哈希键的字典进行被动 rehash。</li>
<li>dictRehashMilliseconds 则由 Redis 服务端常规任务程序执行，用于对数据库键空间进行主动 rehash。</li>
</ul>
<h4 id="dictRehashStep"><a href="#dictRehashStep" class="headerlink" title="_dictRehashStep"></a>_dictRehashStep</h4><p>每次执行 _dictRehashStep，ht[0]-&gt;table 哈希表的第一个不为空的索引上的所有节点就会全部迁移到 ht[1]-&gt;table 上。  </p>
<p>在 rehash 开始进行之后（d-&gt;rehashidx 不为 -1），每次执行一次添加、查找、删除操作，_dictRehashStep 都会被执行一次。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/04/VjG.png" alt="_dictRehashStep"></p>
<p>因为字典会让哈希表的大小和节点数量的比率维持在一个较小的范围内，所以每个索引上的节点数量不会很多，这样每次在执行添加、查找和删除操作的同时，对单个索引上的节点进行迁移就几乎不会对响应时间造成影响。  </p>
<h4 id="dictRehashMilliseconds"><a href="#dictRehashMilliseconds" class="headerlink" title="dictRehashMilliseconds"></a>dictRehashMilliseconds</h4><p>该方法可以在指定的毫秒时间内，对字典进行 rehash。当 Redis 服务端常规任务执行时会执行该方法，在规定的时间内，尽可能地对数据库中需要 rehash 的键空间进行 rehash。  </p>
<h4 id="其他措施"><a href="#其他措施" class="headerlink" title="其他措施"></a>其他措施</h4><p>在哈希表进行 rehash 时，字典还会采取一些其他措施确保 rehash 顺利进行。  </p>
<ul>
<li>因为在 rehash 时，字典会同时使用两个哈希表，所以在这期间的所有查找、删除等操作，除了在 ht[0] 上进行，还会在 ht[1] 上进行。  </li>
<li>在执行添加操作时，新的节点会被添加到 ht[1] 而不是 ht[0]，这样保证 ht[0] 的节点数量在整个 rehash 过程中只会减少不会增加。</li>
</ul>
<h3 id="字典的收缩"><a href="#字典的收缩" class="headerlink" title="字典的收缩"></a>字典的收缩</h3><p>如果哈希表的节点数量比哈希表的大小小很多的话，可以通过 rehash 对字典进行收缩。  </p>
<p>收缩与扩展执行的 rehash 操作过程一样，区别是收缩时新分配的 ht[1]-&gt;table 空间要比 ht[0]-&gt;table 小。具体的收缩规则由 server.c&#x2F;htNeedsResize 函数定义：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 检查字典的使用率是否低于系统允许的最小比率</span></span><br><span class="line"><span class="comment">* 是则返回 1，否则返回 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    <span class="comment">// 哈希表的大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    <span class="comment">// 已经存在的节点数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="comment">// DICT_HT_INITIAL_SIZE 为 4，HASHTABLE_MIN_FILL 为 10</span></span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DICT_HT_INITIAL_SIZE 的值默认为 4，HASHTABLE_MIN_FILL 的值默认是 10。也就是说，在字典的大小大于 4，并且字典的利用率小于 10% 时，就可以对字典进行收缩。  </p>
<p>字典的收缩与字典的扩展不同的是，字典的扩展是自动触发的，而字典的收缩需要由程序手动执行。  </p>
<ul>
<li>当字典用于实现哈希键时，每次从字典中删除一个键值对都会执行一次 htNeedsResize 函数来决定是否要进行 rehash 操作来收缩字典。  </li>
<li>当字典用于实现数据库键空间时，收缩的实际由 server.c&#x2F;tryResizeHashTables 函数来决定。</li>
</ul>
<h3 id="字典的迭代"><a href="#字典的迭代" class="headerlink" title="字典的迭代"></a>字典的迭代</h3><p>字典有自己的迭代器实现，在迭代时有如下几个规则：  </p>
<ul>
<li>迭代器首先迭代字典的第一个哈希表，如果 rehash 正在进行，就继续回第二个哈希表进行迭代。  </li>
<li>当迭代哈希表时，找到第一个不为空的节点，然后迭代这个索引上的所有节点。  </li>
<li>当一个索引迭代完了，会继续查找下一个不为空的节点，直到整个哈希表迭代完成。</li>
</ul>
<p>字典的迭代器主要分为安全迭代器和不安全迭代器。安全迭代器在迭代的过程中，可以对字典进行修改；不安全迭代器在迭代的过程中，不能对字典进行修改。  </p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>为了满足自身的功能需要，Redis 基于 William Pugh 论文中描述的跳跃表进行了以下修改：  </p>
<ul>
<li>允许重复的 score 值，即多个不同的节点的 score 值可以相同。  </li>
<li>进行比对操作时，不仅要检查 score 的值，还要检查数据域。当 score 值相同时，单靠 score 值无法判断一个元素的身份。  </li>
<li>每个节点都带有一个高度为 1 层的后退指针，用于从表尾向表头方向迭代。当执行 ZREVRANGE 或 ZREVRANGEBYSCORE 这类逆序处理有序集的命令时，就会用到该属性。</li>
</ul>
<h3 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h3><p>跳跃表的一个作用就是实现有序集合数据类型。  </p>
<h3 id="跳跃表的数据结构"><a href="#跳跃表的数据结构" class="headerlink" title="跳跃表的数据结构"></a>跳跃表的数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点和尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据域，之前使用的是 robj *obj，某个版本后修改为 Sds</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">// 分值，用于排序</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 这一层该节点到下一个节点跨越的节点数量</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h1 id="内存映射数据结构"><a href="#内存映射数据结构" class="headerlink" title="内存映射数据结构"></a>内存映射数据结构</h1><p>虽然 Redis 的内部数据结构很强大，但是创建一系列完整的数据结构本身也是挺耗费内存的，当一个对象包含的元素不多或元素本身的体积不大时，使用内部数据结构并不是最好的做法。为了解决这个问题，Redis 在条件允许的情况下，会使用内存映射数据结构来代替内部数据结构。内存映射数据结构是一系列经过特殊编码的字节序列，创建它们所消耗的内存通常比作用类似的内部结构要少得多，当然，创建它们所占用的 CPU 时间也会相对增多。  </p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合（intset）用于有序的、无重复的保存多个整数值，根据元素的值，自动选择该用什么长度的整数类型来保存。假如在一个 intset 中最长的元素可以用 int16_t 类型存储，那么这个 intset 的所有元素都使用 int16_t 类型存储。如果有一个新元素加入，这个元素不能用 int16_t 类型存储，那么这个 intset 就会自动升级，先将集合中现有的元素从 int16_t 转换为 int32_t，然后再将新元素加入。根据需要，intset 可以一直升级到 int64_t。  </p>
<h3 id="用途-4"><a href="#用途-4" class="headerlink" title="用途"></a>用途</h3><p>intset 是集合键的底层实现之一，如果一个集合只保存整数元素，并且元素的数量不多，则 Redis 默认会使用 intset 来保存元素。  </p>
<h3 id="整数集合的数据结构"><a href="#整数集合的数据结构" class="headerlink" title="整数集合的数据结构"></a>整数集合的数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存元素所使用的类型的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>其中，encoding 的值可以是以下三个常量之一：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 按照 posix 标准，int16_t 的大小为 1 个字节</span></span><br><span class="line"><span class="comment">* INTSET_ENC_INT16 为 1</span></span><br><span class="line"><span class="comment">* INTSET_ENC_INT32 为 2</span></span><br><span class="line"><span class="comment">* INTSET_ENC_INT64 为 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<p>contents 数组是保存元素的地方，数组中的元素有两个特点：  </p>
<ul>
<li>元素不重复  </li>
<li>元素在数组中按从小到大排序</li>
</ul>
<p>contents 数组的 int8_t 类型声明容易让人误解，其实 intset 不使用 int8_t 类型来直接保存元素，而是仅作为占位符使用，实际上 contents 数组的真正类型取决于 encoding 的值。当 encoding 的值为 INTSET_ENC_INT16 时，contents 就是一个 int16_t 类型的数组，encoding 为 INTSET_ENC_INT32时，contents 就是一个 int32_t 类型的数组。  </p>
<h3 id="创建整数集合"><a href="#创建整数集合" class="headerlink" title="创建整数集合"></a>创建整数集合</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line">intset *<span class="title function_">intsetNew</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    <span class="comment">// 指定编码</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>添加元素由 intset.c&#x2F;intsetAdd 函数完成。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line">intset *<span class="title function_">intsetAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint8_t</span> *success)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 value 值返回需要使用哪种编码方式</span></span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 需要的编码方式比现有的编码方式要大，则需要升级</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经存在该元素则不会添加，如果不存在该元素，则设置 pos 的值为</span></span><br><span class="line">        <span class="comment">// 新元素可以插入的位置</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新分配空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向后移动元素，腾出位置。内部使用 memmove</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入元素</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    <span class="comment">// 重置长度</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/06/Jly.png" alt="添加元素"></p>
<h3 id="升级操作"><a href="#升级操作" class="headerlink" title="升级操作"></a>升级操作</h3><p>添加元素时，如果发现现有的编码不能存储新元素，则通过 intsetUpgradeAndAdd 完成升级和添加元素的工作。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前编码</span></span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="comment">// 合适的编码</span></span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="comment">// 原长度</span></span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的编码</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    <span class="comment">// 重新分配空间</span></span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    <span class="comment">// 重置长度</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _intsetSet(intset *is, <span class="type">int</span> pos, <span class="type">int64_t</span> value) &#123;</span><br><span class="line">    <span class="comment">// 集合的编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="comment">// 1. 根据编码，将数组转换回正确的类型</span></span><br><span class="line">    <span class="comment">// 2. 根据索引设置值</span></span><br><span class="line">    <span class="comment">// 3. ((Enc_t*)is-&gt;contents)+pos 定位到刚设置的新值上</span></span><br><span class="line">    <span class="comment">//    然后根据需要对值进行大小端转换</span></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="type">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="type">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="type">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="type">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="type">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="type">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>升级实例：</strong>  </p>
<p>假设有一个 intset，里面有三个用 int16_t 方式保存的数值，分别是 1、2、3，结构如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">intset-&gt;encoding = INTSET_ENC_INT16;</span><br><span class="line">intset-&gt;length = <span class="number">3</span>;</span><br><span class="line">intset-&gt;contents = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>其中，intset-&gt;contents 在内存中的排列如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit     0    15    31    47</span><br><span class="line">value   |  1  |  2  |  3  |</span><br></pre></td></tr></table></figure>

<p>现在，我们将一个长度为 int32_t 的值 65535 加入到集合中，intset 需要执行以下步骤：  </p>
<p><strong>步骤一：</strong> 将 encoding 属性设置为 INTSET_ENC_INT32。<br><strong>步骤二：</strong> 根据 encoding 属性的值，对 contents 数组进行内存重分配。  </p>
<p>重分配完成之后，contents 在内存中的排列如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit     0    15    31    47     63        95       127</span><br><span class="line">value   |  1  |  2  |  3  |  ?  |    ?    |    ?    |</span><br></pre></td></tr></table></figure>

<p>contents 数组现在一共有可容纳 4 个 int32_t 值的空间。  </p>
<p><strong>步骤三：</strong> 因为原来的 3 个 int16_t 值还挤在 contents 前面的 48 个位里，所以程序需要移动它们并转换类型，让它们适应集合的新编码方式。  </p>
<ul>
<li>首先移动 3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit     0    15    31    47     63        95       127</span><br><span class="line">value   |  1  |  2  |  3  |  ?  |    3    |    ?    |</span><br><span class="line">                       |             ^</span><br><span class="line">                       |             |</span><br><span class="line">                       +-------------+</span><br><span class="line">                     int16_t -&gt; int32_t</span><br></pre></td></tr></table></figure>
<ul>
<li>然后移动 2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit     0    15    31   47     63        95       127</span><br><span class="line">value   |  1  |  2  |    2     |    3    |    ?    |</span><br><span class="line">                 |       ^</span><br><span class="line">                 |       |</span><br><span class="line">                 +-------+</span><br><span class="line">            int16_t -&gt; int32_t</span><br></pre></td></tr></table></figure>
<ul>
<li>再移动 1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit     0   15    31   47     63        95       127</span><br><span class="line">value   |    1     |    2     |    3    |    ?    |</span><br><span class="line">            | ^</span><br><span class="line">            V |</span><br><span class="line">    int16_t -&gt; int32_t</span><br></pre></td></tr></table></figure>
<ul>
<li>最后添加元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit     0   15    31   47     63        95       127</span><br><span class="line">value   |    1     |    2     |    3    |  65535  |</span><br><span class="line">                                             ^</span><br><span class="line">                                             |</span><br><span class="line">                                            add</span><br></pre></td></tr></table></figure>

<h3 id="降级操作"><a href="#降级操作" class="headerlink" title="降级操作"></a>降级操作</h3><p>intset 不支持降级操作。intset 定位为一种受限的中间表示，只能保存整数，而且元素的个数也有限制，因此没有必要进行很复杂的操作，而如果支持降级的话，代码的复杂度会增加很多。  </p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表（ziplist）是由一系列特殊编码的内存块构成的列表，一个 ziplist 可以包含多个节点（entry），每个节点可以保存一个长度受限的字符数组（不以 \0 结尾）或者整数。  </p>
<h3 id="用途-5"><a href="#用途-5" class="headerlink" title="用途"></a>用途</h3><p>为了节约内存，哈希键、列表键和有序集合键在初始化时底层使用的都是 ziplist。  </p>
<h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|</span><br><span class="line"></span><br><span class="line">  4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</span><br><span class="line">+---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">| zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |</span><br><span class="line">+---------+--------+-------+--------+--------+--------+--------+-------+</span><br><span class="line">                           ^                 ^        ^</span><br><span class="line">                           |                 |        |</span><br><span class="line">                    ZIPLIST_ENTRY_HEAD       |   ZIPLIST_ENTRY_END</span><br><span class="line">                                             |</span><br><span class="line">                                     ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>整个 ziplist 占用的内存字节数，对 ziplist 进行内存重分配，或者计算末端时使用。</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>到达 ziplist 表尾节点的偏移量。通过这个偏移量，可以在不遍历整个 ziplist 的前提下，弹出表尾节点。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>ziplist 中节点的数量。当这个值小于 UINT16_MAX（65535）时，这个值就是 ziplist 中节点的数量；当这个值等于 UINT16_MAX 时，节点的数量需要遍历整个 ziplist 才能计算得出。</td>
</tr>
<tr>
<td>entry</td>
<td>?</td>
<td>ziplist 所保存的节点，各个节点的长度根据内容而定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>255 的二进制值 1111 1111（UINT8_MAX），用于标记 ziplist 的末端。</td>
</tr>
</tbody></table>
<h3 id="节点的构成"><a href="#节点的构成" class="headerlink" title="节点的构成"></a>节点的构成</h3><p>一个 ziplist 可以包含多个节点，每个节点可以划分为以下几个部分。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;------------------- entry --------------------&gt;|</span><br><span class="line"></span><br><span class="line">+------------------+----------+--------+---------+</span><br><span class="line">| pre_entry_length | encoding | length | content |</span><br><span class="line">+------------------+----------+--------+---------+</span><br></pre></td></tr></table></figure>

<h4 id="pre-entry-length"><a href="#pre-entry-length" class="headerlink" title="pre_entry_length"></a>pre_entry_length</h4><p>pre_entry_length 记录了前一个节点的长度，通过这个值进行指针运算可以跳转到上一个节点。  </p>
<p>比如这样一个结构：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---- previous entry ---&gt;|&lt;--------------- current entry ----------------&gt;|</span><br><span class="line"></span><br><span class="line">  5 bytes                   1 byte             ?          ?        ?</span><br><span class="line">+-------------------------+-----------------------------+--------+---------+</span><br><span class="line">| ...                     | pre_entry_length | encoding | length | content |</span><br><span class="line">|                         |                  |          |        |         |</span><br><span class="line">|                         | 0000 0101        |    ?     |   ?    |    ?    |</span><br><span class="line">+-------------------------+-----------------------------+--------+---------+</span><br><span class="line">^                         ^</span><br><span class="line">|                         |</span><br><span class="line">p = e - 5                 e</span><br></pre></td></tr></table></figure>

<p>通过指向当前节点的指针 e，减去 pre_entry_length 的值（0101 是 5），得出的就是指向上一个节点的地址。  </p>
<p>根据编码方式的不同，pre_entry_length 可能占用 1 个字节或 5 个字节。  </p>
<ul>
<li>如果前一个节点的长度小于 254 字节，则使用一个字节保存它的长度。  </li>
<li>如果前一个节点的长度大于等于 254 字节，则将第一个字节的值设置为 254，然后用接下来的 4 个字节保存实际长度。</li>
</ul>
<p>示例 1，前一个节点的长度为 128 字节  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;------------------- entry --------------------&gt;|</span><br><span class="line"></span><br><span class="line">  1 byte             ?          ?        ?</span><br><span class="line">+------------------+----------+--------+---------+</span><br><span class="line">| pre_entry_length | encoding | length | content |</span><br><span class="line">|                  |          |        |         |</span><br><span class="line">| 1000 0000        |          |        |         |</span><br><span class="line">+------------------+----------+--------+---------+</span><br></pre></td></tr></table></figure>

<p>示例 2，前一个节点的长度为 10086 字节，pre_entry_length 的前一个字节用 254 填充，之后的 4 个字节被设置为 10086。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;------------------------------ entry ----------------------------------&gt;|</span><br><span class="line"></span><br><span class="line">  5 bytes                                     ?          ?        ?</span><br><span class="line">+-------------------------------------------+----------+--------+---------+</span><br><span class="line">| pre_entry_length                          | encoding | length | content |</span><br><span class="line">|                                           |          |        |         |</span><br><span class="line">| 11111110 00000000000000000010011101100110 | ?        | ?      | ?       |</span><br><span class="line">+-------------------------------------------+----------+--------+---------+</span><br><span class="line">|&lt;-------&gt;|&lt;-------------------------------&gt;|</span><br><span class="line">   1 byte       4 bytes</span><br></pre></td></tr></table></figure>

<h4 id="encoding-和-length"><a href="#encoding-和-length" class="headerlink" title="encoding 和 length"></a>encoding 和 length</h4><p>encoding 决定了 content 保存的数据的类型，length 保存着 content 的长度。  </p>
<p>其中，encoding 的长度为 2 个 bit，00、01 和 10 表示 content 保存着字符数组，11 表示 content 保存着整数。  </p>
<p>下面列出以 00、01 和 10 开头的字符数组的编码方式：  </p>
<table>
<thead>
<tr>
<th>最大编码</th>
<th>编码长度</th>
<th>content 部分保存的值</th>
</tr>
</thead>
<tbody><tr>
<td>00111111</td>
<td>1 byte</td>
<td>长度最大为 2^6 - 1 字节的字符数组</td>
</tr>
<tr>
<td>01111111 11111111</td>
<td>2 byte</td>
<td>长度最大为 2^14 - 1 字节的字符数组</td>
</tr>
<tr>
<td>10111111 11111111 11111111 11111111 11111111</td>
<td>5 byte</td>
<td>长度最大为 2^32 - 1 字节的字符数组</td>
</tr>
</tbody></table>
<p>下面列出以 11 开头的整数的编码方式：  </p>
<table>
<thead>
<tr>
<th>编码</th>
<th>类型长度</th>
<th>content 部分保存的值</th>
</tr>
</thead>
<tbody><tr>
<td>11000000</td>
<td>2 byte</td>
<td>int16_t 类型的整数</td>
</tr>
<tr>
<td>11010000</td>
<td>4 byte</td>
<td>int32_t 类型的整数</td>
</tr>
<tr>
<td>11100000</td>
<td>8 byte</td>
<td>int64_t 类型的整数</td>
</tr>
<tr>
<td>11110000</td>
<td>3 byte</td>
<td>24 bit 有符号整数</td>
</tr>
<tr>
<td>11111110</td>
<td>1 byte</td>
<td>8 bit 有符号整数</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>4 bit</td>
<td>4 bit 无符号整数，介于 0 到 12 之间（0000、1110 和 1111 已被占用，剩下 13 个值）</td>
</tr>
</tbody></table>
<h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>content 保存着节点的内容，类型和长度由 encoding 和 length 决定。  </p>
<p>例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---------------------- entry -----------------------&gt;|</span><br><span class="line"></span><br><span class="line">  ?                  2 bit      6 bit    11 byte</span><br><span class="line">+------------------+----------+--------+---------------+</span><br><span class="line">| pre_entry_length | encoding | length | content       |</span><br><span class="line">|                  |          |        |               |</span><br><span class="line">| ?                |    00    | 001011 | hello world   |</span><br><span class="line">+------------------+----------+--------+---------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---------------------- entry -----------------------&gt;|</span><br><span class="line"></span><br><span class="line">  ?                  2 bit      6 bit    2 bytes</span><br><span class="line">+------------------+----------+--------+---------------+</span><br><span class="line">| pre_entry_length | encoding | length | content       |</span><br><span class="line">|                  |          |        |               |</span><br><span class="line">| ?                |    11    | 000000 | 10086         |</span><br><span class="line">+------------------+----------+--------+---------------+</span><br></pre></td></tr></table></figure>

<h3 id="创建压缩列表"><a href="#创建压缩列表" class="headerlink" title="创建压缩列表"></a>创建压缩列表</h3><p>函数 ziplistNew 用于创建一个新的空白 ziplist，这个空白的 ziplist 可以用下图表示：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---- ziplist header ----&gt;|&lt;-- end --&gt;|</span><br><span class="line"></span><br><span class="line">  4 bytes   4 bytes 2 bytes  1 byte</span><br><span class="line">+---------+--------+-------+-----------+</span><br><span class="line">| zlbytes | zltail | zllen | zlend     |</span><br><span class="line">|         |        |       |           |</span><br><span class="line">|  1011   |  1010  |   0   | 1111 1111 |</span><br><span class="line">+---------+--------+-------+-----------+</span><br><span class="line">                           ^</span><br><span class="line">                           |</span><br><span class="line">                   ZIPLIST_ENTRY_HEAD</span><br><span class="line">                           &amp;</span><br><span class="line">                   ZIPLIST_ENTRY_TAIL</span><br><span class="line">                           &amp;</span><br><span class="line">                   ZIPLIST_ENTRY_END</span><br></pre></td></tr></table></figure>

<p>空白的 ziplist 表头、表尾和末端处于同一地址。  </p>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><h4 id="添加节点到末端"><a href="#添加节点到末端" class="headerlink" title="添加节点到末端"></a>添加节点到末端</h4><p>将新节点添加到 ziplist 的末端需要以下几步：  </p>
<ol>
<li>记录到达 ziplist 末端的偏移量。  </li>
<li>根据新节点的值计算编码这个值需要的空间大小，以及编码它的前一个节点的长度需要的空间大小，然后对 ziplist 重新分配内存。  </li>
<li>设置新节点的各个属性。  </li>
<li>更新 ziplist 的各个属性。</li>
</ol>
<p>比如有这样一个压缩列表：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---- ziplist header ----&gt;|&lt;--- entries --&gt;|&lt;-- end --&gt;|</span><br><span class="line"></span><br><span class="line">  4 bytes  4 bytes  2 bytes  5 bytes          1 bytes</span><br><span class="line">+---------+--------+-------+----------------+-----------+</span><br><span class="line">| zlbytes | zltail | zllen | entry 1        | zlend     |</span><br><span class="line">|         |        |       |                |           |</span><br><span class="line">|  10000  |  1010  |   1   | ?              | 1111 1111 |</span><br><span class="line">+---------+--------+-------+----------------+-----------+</span><br><span class="line">                           ^                ^</span><br><span class="line">                           |                |</span><br><span class="line">                    ZIPLIST_ENTRY_HEAD   ZIPLIST_ENTRY_END</span><br><span class="line">                           &amp;</span><br><span class="line">                    ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<p>假如要添加一个节点的值是一个字符数组 hello world，那么保存这个节点共需要 13 个字节的空间（1 个字节用来存 encodin 和 length，1 个字节用来存 前一个节点的长度为 5，11 个字节用来存字符数组）。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---- ziplist header ----&gt;|&lt;------------ entries ------------&gt;|&lt;-- end --&gt;|</span><br><span class="line"></span><br><span class="line">  4 bytes  4 bytes  2 bytes  5 bytes          13 bytes           1 bytes</span><br><span class="line">+---------+--------+-------+----------------+------------------+-----------+</span><br><span class="line">| zlbytes | zltail | zllen | entry 1        | entry 2          | zlend     |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|  10000  |  1010  |   1   | ?              | pre_entry_length | 1111 1111 |</span><br><span class="line">|         |        |       |                | ?                |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | encoding         |           |</span><br><span class="line">|         |        |       |                | ?                |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | length           |           |</span><br><span class="line">|         |        |       |                | ?                |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | content          |           |</span><br><span class="line">|         |        |       |                | ?                |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">+---------+--------+-------+----------------+------------------+-----------+</span><br><span class="line">                           ^                ^</span><br><span class="line">                           |                |</span><br><span class="line">                  ZIPLIST_ENTRY_HEAD   ZIPLIST_ENTRY_END</span><br><span class="line">                           &amp;</span><br><span class="line">                  ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<p>然后更新节点的属性值。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---- ziplist header ----&gt;|&lt;------------ entries ------------&gt;|&lt;-- end --&gt;|</span><br><span class="line"></span><br><span class="line">  4 bytes  4 bytes  2 bytes  5 bytes          13 bytes           1 bytes</span><br><span class="line">+---------+--------+-------+----------------+------------------+-----------+</span><br><span class="line">| zlbytes | zltail | zllen | entry 1        | entry 2          | zlend     |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|  10000  |  1010  |   1   | ?              | pre_entry_length | 1111 1111 |</span><br><span class="line">|         |        |       |                | 101              |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | encoding         |           |</span><br><span class="line">|         |        |       |                | 00               |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | length           |           |</span><br><span class="line">|         |        |       |                | 001011           |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | content          |           |</span><br><span class="line">|         |        |       |                | hello world      |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">+---------+--------+-------+----------------+------------------+-----------+</span><br><span class="line">                           ^                ^</span><br><span class="line">                           |                |</span><br><span class="line">                   ZIPLIST_ENTRY_HEAD   ZIPLIST_ENTRY_END</span><br><span class="line">                           &amp;</span><br><span class="line">                   ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure>

<p>最后更新 ziplist 的各个属性。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|&lt;---- ziplist header ----&gt;|&lt;------------ entries ------------&gt;|&lt;-- end --&gt;|</span><br><span class="line"></span><br><span class="line">  4 bytes  4 bytes  2 bytes  5 bytes          13 bytes           1 bytes</span><br><span class="line">+---------+--------+-------+----------------+------------------+-----------+</span><br><span class="line">| zlbytes | zltail | zllen | entry 1        | entry 2          | zlend     |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|  11101  |  1111  |  10   | ?              | pre_entry_length | 1111 1111 |</span><br><span class="line">|         |        |       |                | 101              |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | encoding         |           |</span><br><span class="line">|         |        |       |                | 00               |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | length           |           |</span><br><span class="line">|         |        |       |                | 001011           |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">|         |        |       |                | content          |           |</span><br><span class="line">|         |        |       |                | hello world      |           |</span><br><span class="line">|         |        |       |                |                  |           |</span><br><span class="line">+---------+--------+-------+----------------+------------------+-----------+</span><br><span class="line">                           ^                ^                  ^</span><br><span class="line">                           |                |                  |</span><br><span class="line">                           |          ZIPLIST_ENTRY_TAIL   ZIPLIST_ENTRY_END</span><br><span class="line">                           |</span><br><span class="line">                   ZIPLIST_ENTRY_HEAD</span><br></pre></td></tr></table></figure>

<h4 id="添加节点到某个节点前面"><a href="#添加节点到某个节点前面" class="headerlink" title="添加节点到某个节点前面"></a>添加节点到某个节点前面</h4><p>比起将新节点添加到 ziplist 的末端，将一个新节点添加到某个节点的前面要复杂的多，因为这种操作除了将新节点添加到 ziplist 以外，还可能引起后续一系列的变更。  </p>
<p>比如，假设我们要将一个新节点 new 添加到节点 prev 和 next 之间。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   add new entry here</span><br><span class="line">           |</span><br><span class="line">           V</span><br><span class="line">+----------+----------+----------+----------+----------+</span><br><span class="line">|          |          |          |          |          |</span><br><span class="line">|   prev   |   next   | next + 1 | next + 2 |   ...    |</span><br><span class="line">|          |          |          |          |          |</span><br><span class="line">+----------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>首先为新节点扩大 ziplist 的空间。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------+----------+----------+----------+----------+----------+</span><br><span class="line">|          |          |          |          |          |          |</span><br><span class="line">|   prev   |   ???    |   next   | next + 1 | next + 2 |   ...    |</span><br><span class="line">|          |          |          |          |          |          |</span><br><span class="line">+----------+----------+----------+----------+----------+----------+</span><br><span class="line"></span><br><span class="line">           |&lt;--------&gt;|</span><br><span class="line">              expand</span><br><span class="line">              space</span><br></pre></td></tr></table></figure>

<p>然后设置 new 的各个属性值。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             set value,</span><br><span class="line">             property,</span><br><span class="line">             length,</span><br><span class="line">             etc.</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">+----------+----------+----------+----------+----------+----------+</span><br><span class="line">|          |          |          |          |          |          |</span><br><span class="line">|   prev   |   new    |   next   | next + 1 | next + 2 |   ...    |</span><br><span class="line">|          |          |          |          |          |          |</span><br><span class="line">+----------+----------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>设置完之后，需要再重新设置 next 的 pre_entry_length 的值，而这个值需要根据 new 节点重新计算，可能会有三种情况：  </p>
<ol>
<li>next 的 pre_entry_length 的长度刚好能够存储 new 节点的长度（都是 1 字节或都是 5 字节）。  </li>
<li>next 的 pre_entry_length 只有 1 个字节，而 new 的长度需要 5 个字节。  </li>
<li>next 的 pre_entry_length 有 5 个字节，而 new 的长度只需要 1 个字节。</li>
</ol>
<p>第一和第三种情况直接更新 next 的 pre_entry_length 值就可以了，而第二种情况则需要为 ziplist 重新分配内存，扩展 next 的空间，这时还需要向后检查 next + 1 的 pre_entry_length 是否能够存储新的 next 的长度，就这样一直向后检查，直到有一个节点的 pre_entry_length 能够存储前一个节点的长度或者到达 ziplist 的末端 zlend 为止，这就是前面提到的连锁反应。  </p>
<p>不过这种连锁更新的情况一般发生在新添加的节点后面有连续多个长度接近 254 （254 是 1 个字节和 5 个字节的分界线）的节点，这种概率是很小的，所以一般可以将添加操作的时间复杂度看作 O(N)。  </p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>定位节点，并计算节点的空间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   target start here</span><br><span class="line">           |</span><br><span class="line">           V</span><br><span class="line">+----------+----------+----------+----------+----------+----------+</span><br><span class="line">|          |          |          |          |          |          |</span><br><span class="line">|   prev   |  target  |   next   | next + 1 | next + 2 |   ...    |</span><br><span class="line">|          |          |          |          |          |          |</span><br><span class="line">+----------+----------+----------+----------+----------+----------+</span><br><span class="line"></span><br><span class="line">           |&lt;--------&gt;|</span><br><span class="line">            target-size</span><br></pre></td></tr></table></figure>

<ul>
<li>进行内存移位，覆盖 target 的原数据，然后进行内存重分配。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   target start here</span><br><span class="line">           |</span><br><span class="line">           V</span><br><span class="line">+----------+----------+----------+----------+----------+</span><br><span class="line">|          |          |          |          |          |</span><br><span class="line">|   prev   |   next   | next + 1 | next + 2 |   ...    |</span><br><span class="line">|          |          |          |          |          |</span><br><span class="line">+----------+----------+----------+----------+----------+</span><br><span class="line"></span><br><span class="line">           | &lt;------------------------------------------ memmove</span><br></pre></td></tr></table></figure>

<ul>
<li>检查 next 的后续每个节点的 pre_entry_length 能否满足前一个节点的长度，并根据情况决定是否重分配内存。</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>可以对 ziplist 从前往后遍历，也可以从后往前遍历。  </p>
<p>当从前向后的遍历时，从指向节点 e1 的指针 p 开始，计算节点 e1 的长度（e1-size），然后将 p 加上 e1-size ，就将指针后移到了下一个节点 e2，如此反覆，直到 p 遇到 ZIPLIST_ENTRY_END 为止，这样整个 ziplist 就遍历完了。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                               p + e1-size + e2-size</span><br><span class="line">                 p + e1-size     |</span><br><span class="line">           p          |          |</span><br><span class="line">           |          |          |</span><br><span class="line">           V          V          V</span><br><span class="line">+----------+----------+----------+----------+----------+----------+----------+</span><br><span class="line">| ZIPLIST  |          |          |          |          |          | ZIPLIST  |</span><br><span class="line">| ENTRY    |    e1    |    e2    |    e3    |    e4    |   ...    | ENTRY    |</span><br><span class="line">| HEAD     |          |          |          |          |          | END      |</span><br><span class="line">+----------+----------+----------+----------+----------+----------+----------+</span><br><span class="line"></span><br><span class="line">           |&lt;--------&gt;|&lt;--------&gt;|</span><br><span class="line">             e1-size    e2-size</span><br></pre></td></tr></table></figure>

<p>当从后往前遍历的时候，从指向节点 eN 的指针 p 出发，取出 eN 的 pre_entry_length 值，然后用 p 减去 pre_entry_length ，这样就将指针移动到了前一个节点 eN-1，如此反覆，直到 p 遇到 ZIPLIST_ENTRY_HEAD 为止，这样整个 ziplist 就遍历完了。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                         p - eN.pre_entry_length</span><br><span class="line">                                            |</span><br><span class="line">                                            |          p</span><br><span class="line">                                            |          |</span><br><span class="line">                                            V          V</span><br><span class="line">+----------+----------+----------+----------+----------+----------+----------+</span><br><span class="line">| ZIPLIST  |          |          |          |          |          | ZIPLIST  |</span><br><span class="line">| ENTRY    |    e1    |    e2    |   ...    |   eN-1   |    eN    | ENTRY    |</span><br><span class="line">| HEAD     |          |          |          |          |          | END      |</span><br><span class="line">+----------+----------+----------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="对象处理机制"><a href="#对象处理机制" class="headerlink" title="对象处理机制"></a>对象处理机制</h2><p>Redis 的命令中，对键进行处理的命令占了很大一部分，而不同的命令又需要使用不同的处理方式，为了能够识别这些命令，Redis 构建了自己的类型系统，这个系统的主要功能包括对基于 redisObject 对象的类型检查、显式多态函数以及对 redisObject 进行分配、共享和销毁。  </p>
<h3 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h3><p>Redis 数据库中每个键、值，以及 Redis 本身处理的参数都表示为 redisObject。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 值的类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU 时间</span></span><br><span class="line">    <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">    * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">    * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向对象的值</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>下图展示了 redisObject、type 和 encoding 的关系。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/12/Bny.png" alt="三者之间的关系"></p>
<h3 id="命令的类型检查和多态"><a href="#命令的类型检查和多态" class="headerlink" title="命令的类型检查和多态"></a>命令的类型检查和多态</h3><p>有了 redisObject 的存在，Redis 在执行命令时进行类型检查和对编码进行多态操作就简单多了。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/12/ePx.png" alt="命令检查和多态处理"></p>
<h3 id="对象共享（已废弃）"><a href="#对象共享（已废弃）" class="headerlink" title="对象共享（已废弃）"></a>对象共享（已废弃）</h3><p>Redis 中有很多对象是很常见的，比如命令的返回值 OK、ERROR 等字符，还有一些小范围的整数等，为了利用这些经常出现的对象，Redis 使用了 Flyweight 模式，通过预分配一些常见的值对象，并在多个数据结构之间共享这些对象来避免重复分配，节约部分 CPU 时间和内存。  </p>
<p>Redis 预分配的值对象有：  </p>
<ul>
<li>各种命令的返回值，比如执行成功时返回的 OK，执行错误时返回的 ERROR，类型错误时返回的 WRONGTYPE，命令入队事务时返回的 QUEUED 等等。  </li>
<li>包括 0 在内，小于 server.h&#x2F;REDIS_SHARED_INTEGERS 的所有整数（REDIS_SHARED_INTEGERS 的值为 1000）</li>
</ul>
<p>如果某个命令的输入值是一个小于 REDIS_SHARED_INTEGERS 的整数对象，那么当这个对象要被保存进数据库时，Redis 就会释放原来的值，并将值的指针指向共享对象。  </p>
<p>共享对象只能被字典和双端链表这类带有指针的数据结构使用，像整数集合和压缩列表这些只能保存字符串、整数等字面值的内存数据结构，就不能使用共享对象。  </p>
<p>需要说明的是，Redis 的作者 antirez 为了实现异步懒惰删除，已经将对象共享机制彻底抛弃了。  </p>
<h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p>当 redisObject 用作数据库的键或者值，而不是用作存储参数时，对象的声明周期是很长的，因为 C 语言没有自动释放内存的机制，如果靠开发人员的记忆对对象进行追踪和销毁是不太可能的。为了解决这个问题，Redis 使用了引用计数来负责维持和销毁对象。每个 redisObject 都有一个 refcount 属性用来记录引用次数，当这个属性的值为 0 时，这个 redisObject 对象以及它所引用的数据结构的内存都会被释放。  </p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 类型是二进制安全的，即可以包含任何数据，如序列化的对象、图片、视频，一个键最大可以存储 512 MB 大小的数据。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/12/w2g.png" alt="字符串编码"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash 是一个键值对集合，键和值都是 String 类型的，该数据类型适合存储对象。每个 Hash 可以存储 2^32 - 1 个键值对。  </p>
<p>Hash 根据编码的不同，有压缩列表和字典两种实现。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/12/mba.png" alt="哈希表编码"></p>
<p>在创建空白的哈希表时，默认使用压缩列表数据结构，当满足以下任意一个条件时，结构切换成字典。  </p>
<ul>
<li>哈希表中某个键或某个值的长度大于 server.hash_max_ziplist_value（默认值为 64）。  </li>
<li>压缩列表中的节点数量大于 server.hash_max_ziplist_entries（默认值为 512）。</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 是简单的字符串列表，按照插入顺序排列，同时还可以将一个元素添加到 List 的头部（左边）或者尾部（右边）。每个 List 可以存储 2^32 - 1 个元素。  </p>
<p>List 根据编码的不同，有压缩列表和双端列表两种实现。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/19/nWJ.png" alt="列表编码"></p>
<p>创建新列表时默认使用 REDIS_ENCODING_ZIPLIST 编码，当满足以下任意一个条件时，列表会被转换成 REDIS_ENCODING_LINKEDLIST 编码。  </p>
<ul>
<li>试图往列表新添加一个字符串值，且这个字符串的长度超过 server.list_max_ziplist_value（默认值为 64）。  </li>
<li>ziplist 包含的节点超过 server.list_max_ziplist_entries（默认值为 512）。</li>
</ul>
<h3 id="阻塞命令"><a href="#阻塞命令" class="headerlink" title="阻塞命令"></a>阻塞命令</h3><p>在列表为空时执行 BLPOP、BRPOP 和 BRPOPLPUSH 这三个命令会阻塞。Redis 会将该客户端的状态设置为“正在阻塞”，并记录阻塞这个客户端的各个键，以及阻塞的超时时间。Redis 将客户端的这些信息记录到 server.db[i] -&gt; blocking_keys 字典中，字典的键就是造成客户端阻塞的键，值是一个链表，保存了因为这个键被阻塞的客户端。这个链表形成了一个 FIFO 队列，当满足取消阻塞条件时，先被阻塞客户端的先取消阻塞状态。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/19/6WM.png" alt="阻塞客户端"></p>
<p>当出现以下情况之一时，客户端会从阻塞状态脱离：  </p>
<ul>
<li>其他客户端在造成阻塞的键上推入了新元素。  </li>
<li>到达超时时间。  </li>
<li>客户端强制与服务端终止连接，或者服务端实例终止。</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是 String 类型的无序集合，集合的成员是唯一的，不能重复。Redis 中的集合是通过哈希实现的，所以添加、删除和查找的时间复杂度都是 O(1)，最大成员数为 2^32 - 1。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/19/3do.png" alt="集合的编码"></p>
<p>Set 根据编码的不同，有整数集合和字典两种实现。第一个添加到集合的元素，决定了创建集合时所使用的编码：  </p>
<ul>
<li>如果第一个元素可以表示为 long long 类型值（即它是一个整数），那么集合的初始编码为 REDIS_ENCODING_INTSET。  </li>
<li>否则，集合的初始编码为 REDIS_ENCODING_HT。</li>
</ul>
<p>如果一个集合使用 REDIS_ENCODING_INTSET 编码，当满足以下任意一个条件时，这个集合会被转换成 REDIS_ENCODING_HT 编码：  </p>
<ul>
<li>intset 保存的整数值个数超过 server.set_max_intset_entries（默认值为 512）。  </li>
<li>试图往集合里添加一个新元素，并且这个元素不能被表示为 long long 类型（即它不是一个整数）。</li>
</ul>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>与 Set 一样也是 String 类型的集合，且不允许重复。不同的是每个元素都会关联一个 double 类型的分数，集合中的元素通过该分数从大到小排序。其中，分数可以重复。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/19/oYv.png" alt="有序集合的编码"></p>
<p>Sorted Set 根据编码的不同，有压缩列表和跳跃表两种实现。如果第一个元素符合以下条件的话，就创建一个 REDIS_ENCODING_ZIPLIST 编码的有序集：  </p>
<ul>
<li>server.zset_max_ziplist_entries 的值大于 0（默认为 128）。  </li>
<li>元素的 member 长度小于 server.zset_max_ziplist_value 的值（默认为 64）。</li>
</ul>
<p>对于一个 REDIS_ENCODING_ZIPLIST 编码的有序集，只要满足以下任一条件，就将它转换为 REDIS_ENCODING_SKIPLIST 编码：  </p>
<ul>
<li>ziplist 所保存的元素数量超过 server.zset_max_ziplist_entries 的值（默认值为 128）。  </li>
<li>新添加元素的 member 的长度大于 server.zset_max_ziplist_value 的值（默认值为 64）。</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 通过 MULTI、DISCARD、EXEC 和 WATCH 四个命令实现事务的功能。  </p>
<p>Redis 的事务是将一系列命令打包，然后一次性的按顺序执行，事务在执行期间不会主动中断，只有服务端在执行完事务中所有的命令后，才会继续处理其他客户端的命令。客户端使用 MULTI 命令开启事务，在事务状态下，除了那四个事务命令外，其他的命令都不会立即执行，而是会被放入一个 FIFO 事务队列中，当使用 EXEC 命令时，服务端顺序执行事务队列中的命令，并将每个命令的执行结果顺序放入一个 FIFO 的回复队列中，在全部命令执行完毕后返回。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET book-name <span class="string">&quot;Effective Java&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; SADD tag <span class="string">&quot;Java&quot;</span> <span class="string">&quot;Programming&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Effective Java&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line">4) 1) <span class="string">&quot;Java&quot;</span></span><br><span class="line">   2) <span class="string">&quot;Programming&quot;</span></span><br></pre></td></tr></table></figure>

<p>Redis 的事务不可嵌套，即如果客户端已经处于事务状态，如果客户端再发送 MULTI 命令，服务端也只是简单返回一个错误，然后继续等待其他命令进入事务队列。  </p>
<h2 id="事务状态和非事务状态下执行命令"><a href="#事务状态和非事务状态下执行命令" class="headerlink" title="事务状态和非事务状态下执行命令"></a>事务状态和非事务状态下执行命令</h2><p>无论在事务状态还是在非事务状态下，Redis 命令都由同一个函数执行，所以它们共享很多服务器的一般设置，比如 AOF 的配置、RDB 的配置，以及内存限制等等。不过这两个状态下执行命令还是有区别的：  </p>
<ul>
<li><p>在非事务状态下的命令都是单条执行，前一个命令和后一个命令可能来自不同的客户端。而在事务状态下，命令是作为一个事务来执行的，除非事务执行完毕，否则服务端不会主动中断，也不会执行其他客户端的命令。  </p>
</li>
<li><p>在非事务状态下执行命令结果会立即返回，而事务状态下则需要将所有的命令结果放入回复队列中，再作为 EXEC 命令的结果返回。</p>
</li>
</ul>
<h2 id="DISCARD-命令"><a href="#DISCARD-命令" class="headerlink" title="DISCARD 命令"></a>DISCARD 命令</h2><p>DISCARD 命令用于取消一个事务，它清空客户端的整个事务队列，将客户端从事务状态转换为非事务状态，最后返回 OK 作为结果，说明事务已经取消。  </p>
<h2 id="WATCH-命令"><a href="#WATCH-命令" class="headerlink" title="WATCH 命令"></a>WATCH 命令</h2><p>WATCH 命令用于在事务开始之前监视任意数量的键，当调用 EXEC 执行事务时，如果任意一个被监视的键被其他客户端修改了，那么整个事务不再执行，直接返回失败。  </p>
<p>WATCH 命令只能在客户端进入事务状态之前执行，在事务状态下发送也只会返回一个错误，不会造成整个事务的失败，也不会修改事务队列中已有的数据。  </p>
<h3 id="WATCH-的实现"><a href="#WATCH-的实现" class="headerlink" title="WATCH 的实现"></a>WATCH 的实现</h3><p>在每个代表数据库的 server.h&#x2F;redisDb 结构中，都保存了一个 watched_keys 字典，字典的键是这个数据库中被监视的键，字典的值是一个链表，保存了所有监视这个键的客户端。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/23/WKk.png" alt="watched_keys"></p>
<h3 id="WATCH-的触发"><a href="#WATCH-的触发" class="headerlink" title="WATCH 的触发"></a>WATCH 的触发</h3><p>在对任意的数据库键空间进行修改的命令（如 FLUSHDB、SET、DEL、LPUSH、SADD、ZREM 等）执行成功后，multi.c&#x2F;touchWatchedKey 函数都会被调用，它检查数据库的 watched_keys 字典，查看是否有客户端在监视已经修改的键，如果有的话，将所有监视这个已经被修改的键的客户端的 REDIS_DIRTY_CAS 选项打开。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/23/Yng.png" alt="WATCH 触发状态变化"></p>
<p>当客户端发送 EXEC 命令时，服务端会对客户端的状态进行检查：  </p>
<ul>
<li>如果客户端的 REDIS_DIRTY_CAS 选项已经被打开，说明客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务端会放弃执行这个事务，并返回一个空的回复表示事务执行失败。  </li>
<li>如果 REDIS_DIRTY_CAS 没有打开，则说明所有被监视的键都安全，服务端正式执行事务。</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h2><ul>
<li>完全基于内存，绝大部分操作都是纯粹的内存操作。  </li>
<li>数据结构简单，同时对数据的操作也简单。  </li>
<li>采用单线程，避免了不必要的上下文切换，也不会因为多线程下为了线程安全而加锁导致性能损耗。  </li>
<li>使用 I&#x2F;O 多路复用，可以让单个线程能够更高效的处理更多的连接请求，相对来说减少了网络 IO 的时间消耗，同时这也是 Redis 能够承受很大的客户端并发量的原因。</li>
</ul>
<h2 id="为什么-Redis-是单线程的？"><a href="#为什么-Redis-是单线程的？" class="headerlink" title="为什么 Redis 是单线程的？"></a>为什么 Redis 是单线程的？</h2><p>首先需要强调的是，我们一直提到的 Redis 是单线程的是指 Redis 在处理我们的网络请求时只使用一个线程来处理（I&#x2F;O 多路复用），同时大部分的内存操作也是单线程的，实际上一个 Redis 实例在运行时肯定使用了不止一个线程。这里引用官网的一段解释：</p>
<blockquote>
<p>Redis is single threaded. How can I exploit multiple CPU &#x2F; cores?</p>
</blockquote>
<blockquote>
<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.<br>However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier.<br>You can find more information about using multiple Redis instances in the Partitioning page.<br>However with Redis 4.0 we started to make Redis more threaded. For now this is limited to deleting objects in the background, and to blocking commands implemented via Redis modules. For the next releases, the plan is to make Redis more and more threaded.</p>
</blockquote>
<p>摘取其中的重点就是，限制 Redis 使用的瓶颈通常并不是 CPU，而是内存和网络，Redis 在 4.0 版本以后使用了多线程在后台删除对象，其他大部分操作还是只使用了一个线程。</p>
<p>这里给出了一个不使用多线程的原因，就是当前的瓶颈并不在于 CPU 而在于内存和网络，那么如果使用多个线程去操作内存数据又会带来哪些问题呢？</p>
<p>我们知道多线程执行任务有个致命的问题就是线程切换，线程在获得 CPU 执行权执行一段时间后，可能其他线程获得了执行权，此时该线程需要释放执行权，而任务很可能还没有执行完，因此需要保存线程执行的上下文，以便后续该线程的恢复。这个操作需要消耗大量的 CPU 执行时间，事实上，这也是操作系统中消耗最大的操作。另外，如果线程切换是跨核上下文切换，则会引起缓存丢失，结果就需要访问本地内存，这个代价是更高的。</p>
<p>Redis 采用单个线程绑定一块内存，针对这部分内存数据的读写都是在一个 CPU 上完成的，不存在上下文切换的开销，在只有内存读写时效率最高。并且需要知道的是，Redis 的性能瓶颈不是 CPU，而是内存大小和网络带宽，既然 CPU 不会成为瓶颈，而使用多线程又会增加复杂度，因此使用单线程也就顺理成章了。</p>
<p>总结：Redis 目前使用单线程和 I&#x2F;O 多路复用处理客户端的连接，使用单线程处理内存操作，只有后台删除使用了多线程，原因是当前的瓶颈并不在于 CPU 而在于内存和网络，如果使用多线程去处理内存操作，不光增加了复杂度，也会因为线程的上下文切换增加 CPU 的开销。</p>
<h2 id="Redis-与-I-O-多路复用"><a href="#Redis-与-I-O-多路复用" class="headerlink" title="Redis 与 I&#x2F;O 多路复用"></a>Redis 与 I&#x2F;O 多路复用</h2><p>Redis 没有使用 Libevent 而是选择实现了自己的 Event Library，因为 Libevent 为了通用性编写了过多的代码，并且牺牲了在特定平台的许多特性。  </p>
<h2 id="如何利用多核优势"><a href="#如何利用多核优势" class="headerlink" title="如何利用多核优势"></a>如何利用多核优势</h2><p>可以在多核机器上启动多个 Redis 实例组成主从或者集群，然后通过内核绑定程序（比如 taskset、numactl）将实例与内核进行绑定，即一个内核绑定一个实例，这样可以避免内核分配不均，从而避免线程争用和跨核上下文切换。</p>
<h2 id="未来为什么要引入多线程"><a href="#未来为什么要引入多线程" class="headerlink" title="未来为什么要引入多线程"></a>未来为什么要引入多线程</h2><p>在 2019 年的 2 月份，Redis 的作者 antirez 在他的博客上发表了一篇题为：An update about Redis developments in 2019 的文章，其中提到了 Redis 在将来可能使用多线程的几种方式。</p>
<p>对于目前单线程的 Redis 来说，性能瓶颈主要在于网络 I&#x2F;O 的消耗，读写网络数据的 read&#x2F;write 系统调用在 Redis 执行期间占用了大量的 CPU 时间，如果把网络读写改为多线程的方式可以充分利用多核优势，提高网络 I&#x2F;O 性能。</p>
<p>在即将到来的 Redis 6.0 中，Redis 将会引入多线程支持。与 Memcached 这种从网络 I&#x2F;O 处理到数据访问的多线程实现模式不同，Redis 的多线程部分只用于处理网络数据的读写和协议的解析，真正执行命令的仍然是单线程，这样可以避免很多并发问题。其中，主线程负责接收建立连接的请求，在读事件到来时放到全局等待读队列中，在主线程处理完读事件之后，会将这些读请求分配给 I&#x2F;O 线程，然后主线程忙等，当所有的 I&#x2F;O 线程将请求数据读取并解析完成后，主线程负责执行所有的命令并清空队列。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf">Skip Lists: A Probabilistic Alternative to Balanced Trees</a></p>
</blockquote>
<blockquote>
<p>《Redis 设计与实现》</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的 Vue.js</title>
    <url>/2017/08/15/Re%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%20Vue.js/</url>
    <content><![CDATA[<p>之前有大概的学习过 Vue.js，昨天想使用 Vue.js 结合服务端做一个 TodoMVC，但是发现好多东西都忘记了，准备重新学习并记录一下。</p>
<span id="more"></span>

<h1 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>每个 Vue.js 应用都从创建一个 Vue 实例启动的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/QnV.png" alt="vue_first"></p>
<p>Vue.js 实例可以看做是一个 ViewModel，因此很多人在创建实例时将它命名为 vm。</p>
<p>实例化时，需要传入一个 options 对象，对象包含挂载元素、数据、模板、方法、生命周期钩子等。</p>
<p>详细的 options 属性戳这里：<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">API</a></p>
<h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><p>每个 Vue 实例都会代理其 data 对象里的所有属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/qx0.png" alt="proxy_data"><br>		<br>只有被代理的属性是响应的，在 Vue 实例创建后添加的新属性不具有响应特性。</p>
<p>除了 data 属性，Vue 实例还暴露了一些实例属性和方法（带有 $ 前缀标识）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/vp8.png" alt="vue_$"></p>
<p><strong>不要在实例属性或者回调函数中（如 vm.$watch(‘a’, newVal &#x3D;&gt; this.myMethod())）使用箭头函数。因为箭头函数绑定父级上下文，所以 this 不会像预想的一样是 Vue 实例，而且 this.myMethod 是未被定义的。</strong></p>
<p>详细的实例属性和实例方法戳这里：<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">API</a></p>
<h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><img alt="life_cycle" src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004261232/2020/04/26/vmj.png" style="height:65%;width:65%;" />

<p>Vue 实例在被创建之前要执行一系列的初始化过程，在这个过程中也可以调用一些生命周期钩子，这使得我们可以执行一些自定义的逻辑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/jzP.png" alt="life_cycle_hook"></p>
<p>详细的生命周期钩子戳这里：<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">API</a></p>
<h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>Vue.js 使用基于 HTML 的模板语法，允许声明式的将 DOM 与 Vue 实例的数据绑定。Vue.js 也支持使用渲染函数（render）来代替模板。</p>
<h2 id="插入值"><a href="#插入值" class="headerlink" title="插入值"></a>插入值</h2><h3 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h3><p>使用“Mustache”语法的双大括号包裹 Vue 实例的数据，页面渲染时会被解析成纯文本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/BxO.png" alt="mustache_txt"></p>
<p>也可以使用指令 <code>v-text</code> 绑定元素，这样在数据更新时会更新整个元素的 <code>textContent</code>，如果只想更新部分 <code>textContent</code>，使用双大括号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/e0L.png" alt="v-text">
		</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>使用指令<code>v-html</code>能够将数据解释成 HTML，但是这可能会被 XSS 攻击利用，因此只对可信数据使用 HTML 插入值，避免对用户输入的内容使用 HTML 插入值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/J2j.png" alt="v-html"></p>
<h3 id="JS-表达式"><a href="#JS-表达式" class="headerlink" title="JS 表达式"></a>JS 表达式</h3><p>在模板中，我们可以使用简单的 JavaScript 表达式（单行表达式和三元表达式）。在模板中不应该试图访问用户定义的全局变量，而只能访问几个内建的全局变量：<code>Date</code> 和 <code>Math</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/nKM.png" alt="js_expression"></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有“v-”前缀的特殊属性，属性值预期是单行 JavaScript 表达式（除了 <code>v-for</code> 指令外）。<strong>指令的作用是当表达式的值改变时响应式的作用于绑定的 DOM 元素。</strong></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>指令可以使用“:”接收参数。如 <code>v-bind</code> 就可以接收参数（一般是属性），表示数据与 DOM 元素的属性绑定；<code>v-on</code> 也可以接收参数作为事件绑定到 DOM 元素上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/VO9.png" alt="cmline_param1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/gam.png" alt="cmline_param2"></p>
<h3 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h3><p>指令可以使用“.”指定一个特殊的后缀，表示这个指令以特殊的方式绑定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/7dl.png" alt="cmline_teshu"></p>
<p>更多指令戳这里：<a href="https://cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4">API</a></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Vue.js 允许自定义过滤器用在<strong>双大括号</strong>和 <strong><code>v-bind</code></strong> 中来格式化数据。过滤器要放在 JavaScript 表达式尾部，并用管道符号“|”标识。过滤器函数接收表达式的值作为第一个参数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/6pL.png" alt="filter"></p>
<h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><p>过滤器可以串联。表达式的值作为参数传给第一个过滤器函数，计算后再将结果作为参数传给第二个过滤器函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/2nw.png" alt="chuanlian"></p>
<h3 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h3><p>过滤器可以接收参数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/m6K.png" alt="filter_param"></p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><p>有更简洁的使用 <code>v-bind</code> 和 <code>v-on</code> 语法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/D4w.png" alt="v-bind_sweet"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/MBp.png" alt="v-on_sweet"></p>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>模板内使用表达式很便利，但是对于复杂的逻辑最好是放在计算属性中。计算属性可能看起来和使用 <code>methods</code> 属性一样，但是区别是，使用 <code>computed</code>，在它依赖的数据没有发生改变时直接返回计算结果而不用重新计算，只有依赖的数据改变时才重新计算；使用 <code>methods</code> 每次都会调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/wNX.png" alt="computed"></p>
<h2 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h2><p>计算属性设置的方法，默认就是一个 get 方法，我们还可以添加 set 方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/3gn.png" alt="setter"></p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>Vue.js 提供了一个更为通用的观察 Vue 实例数据发生变化的属性 <code>watch</code>。当你希望数据变化时执行异步操作或者大量计算时很有用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/oo8.png" alt="watch"></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 的复制、哨兵和集群</title>
    <url>/2019/09/21/Redis%20%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%81%E5%93%A8%E5%85%B5%E5%92%8C%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>在 Redis 中，复制功能的主要作用是实现读写分离和数据备份，哨兵的作用是实现故障切换（failover），集群的主要作用是实现数据分片（sharding），解决单机的资源和性能瓶颈问题。</p>
<span id="more"></span>

<h1 id="Redis-复制"><a href="#Redis-复制" class="headerlink" title="Redis 复制"></a>Redis 复制</h1><p>Redis 基础的复制功能允许一个 Redis 服务去复制另一个 Redis 服务，被复制的服务称为主服务（master），对主服务进行复制的称为从服务（slave）。从服务作为主服务的精确备份，即使因为网络问题等原因导致主从连接断开，从服务也会不断尝试重连，并在重新建立连接后继续进行复制操作。</p>
<p>假设现在有两个 Redis 服务，分别为 <code>127.0.0.1:6379</code> 和 <code>127.0.0.1:12345</code>，如果向服务 <code>127.0.0.1:12345</code> 发送以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>那么服务 <code>127.0.0.1:12345</code> 将成为 <code>127.0.0.1:6379</code> 的从服务，而 <code>127.0.0.1:6379</code> 将成为 <code>127.0.0.1:12345</code> 的主服务。</p>
<blockquote>
<p>需要注意的是这种方式设置的主从是临时的，重启服务后失效。在配置文件中设置才会永久生效。</p>
</blockquote>
<h2 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h2><p>**Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作。**同步操作用于将从服务的状态更新至主服务当前的状态。命令传播操作则用于当主服务状态被修改后，主从服务出现状态不一致时，让从服务重新回到一致的状态。</p>
<p>当客户端向从服务发送 SLAVEOF 命令，要求从服务复制主服务时，从服务首先要做的就是将客户端给定的主服务的 IP 地址和端口号保存。SLAVEOF 命令是一个异步命令，在完成保存后从服务会向客户端返回 OK，表示复制命令已被接收，而实际的复制工作将在返回 OK 后才真正开始执行。</p>
<p>接着从服务将根据设置的主服务的 IP 地址和端口号，创建一个连向主服务的套接字连接。如果连接成功，那么从服务将会为这个套接字关联一个专门用于处理复制工作的文件事件处理器，比如接收 RDB 文件以及主服务传播过来的写命令等。而主服务将会为该套接字创建相应的客户端状态，将从服务看作是一个连接主服务的客户端，这时从服务将同时具有服务端（server）和客户端（client）两个身份：从服务可以向主服务发送命令请求，而主服务可以向从服务返回命令回复。</p>
<p>从服务成为主服务的客户端之后会向主服务发送一个 PING 命令，一个目的是检查套接字的读写状态是否正常，另一个目的是检查主服务能否正常处理命令请求。如果网络不佳或者主服务返回错误，则从服务会断开并重新创建连向主服务的套接字；如果从服务收到 PONG 回复，则表示主服务当前可以正常处理从服务的命令请求。</p>
<p>接下来就是身份验证阶段，如果主服务设置了 requirepass 选项，那么从服务必须设置 masterauth 选项（也就是密码），没有提供密码或者密码错误都会返回错误；如果主服务没有设置 requirepass 选项，从服务设置 masterauth 同样会返回错误。所有的错误都会使从服务终止当前的复制工作，直到身份验证通过。</p>
<p>身份验证通过后，从服务将执行 <code>REPLCONF listening-port &lt;port-number&gt;</code> 命令，向主服务发送从服务的监听端口号，主服务会将该端口号记录在从服务所对应的客户端状态的 slave_listening_port 属性中。</p>
<p>接下来就是真正进行同步的阶段，从服务会向主服务发送 PSYNC 命令进行同步，如果是初次同步，则使用完整重同步模式进行复制。值得一提的是，在同步操作执行之前，只有从服务是主服务的客户端，但是在执行同步操作之后，主服务也会成为从服务的客户端。正是因为这样，主服务才可以发送写命令来改变从服务的状态，这也是主服务对从服务进行命令传播的基础。</p>
<blockquote>
<p><strong>PSYNC 命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式。<strong>完整重同步用于处理初次复制的情况，收到该命令的主服务会执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令，当主服务的 BGSAVE 命令执行完毕后，主服务会将生成的 RDB 文件发送给从服务，从服务接收并载入这个 RDB 文件，从而将数据库的状态更新至主服务执行 BGSAVE 命令时的状态。接着主服务会将记录在缓冲区的所有写命令发送给从服务，从服务执行这些写命令，将数据库更新至主服务当前的状态。部分重同步则用于处理在</strong>命令传播阶段</strong>，主从发生断连后重复制的情况，当从服务在断线后重新连接主服务时，如果条件允许，主服务可以将断开期间执行的写命令发送给从服务，而不必重新进行完整重同步。</p>
</blockquote>
<p>当完成了同步之后，主从服务就进入了命令传播阶段，此时主服务只要一直将自己执行的写命令发送给从服务，而从服务只要一直接收并执行主服务发来的写命令，这样主从就可以一直保持一致了。</p>
<h2 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h2><p>部分重同步的重点包括复制偏移量（replication offset）、复制积压缓冲区（replication backlog）和运行 ID（run ID）。</p>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在命令传播阶段，心跳检测用于检测主从之间的网络连接状态、辅助实现 min-slaves 选项以及检测命令丢失。</p>
<h2 id="关于复制的几个重要事实"><a href="#关于复制的几个重要事实" class="headerlink" title="关于复制的几个重要事实"></a>关于复制的几个重要事实</h2><ul>
<li>从服务能够接受其他从服务的连接。除了可以将多个从服务连接到主服务外，还可以将从服务连接到其他从服务，所有的从服务都将从主服务接收完全相同的复制流。</li>
<li>复制在主服务中没有阻塞。当一个或多个从服务与主服务进行初次同步或部分重同步时，主服务可以继续处理其他请求。</li>
<li>复制在从服务中基本也没有阻塞。在开始执行初始同步时，从服务可以继续提供旧版本的数据。在接收到主服务发送的 RDB 文件之后，从服务必须删除旧的数据集，加载新的数据集，此时从服务会被阻塞。从 Redis 4.0 开始，可以配置使旧数据集的删除发生在其他线程，但是新数据集的加载仍然要在主线程中进行，此时从服务还是会阻塞。</li>
<li>默认情况下，从服务是以只读模式启动的，该模式可以通过 slave-read-only 选项控制。只读模式下从服务只能接收读命令，所有的写命令都会返回错误。</li>
<li>可以使用无盘复制（生成的 RDB 文件不存盘直接发送给从节点）来降低主服务的磁盘开销，这适用于主服务所在的机器磁盘性能较差但网络良好的场景。</li>
</ul>
<h1 id="哨兵（Sentinel）"><a href="#哨兵（Sentinel）" class="headerlink" title="哨兵（Sentinel）"></a>哨兵（Sentinel）</h1><p>哨兵是 Redis 高可用的解决方案，该方案是由一个或多个 Sentinel 实例组成 Sentinel 系统，这个系统可以监视多个主服务以及这些主服务下的所有从服务，在被监视的主服务进入下线状态时，自动将下线主服务下属的某个从服务提升为新的主服务，然后由新的主服务继续处理命令请求。</p>
<h2 id="哨兵的运行过程"><a href="#哨兵的运行过程" class="headerlink" title="哨兵的运行过程"></a>哨兵的运行过程</h2><p>使用 <code>redis-sentinel /path/sentinel.conf</code> 可以启动一个 Sentinel，由于 Sentinel 本质上就是一个运行在特殊模式下的 Redis 服务，所以也可以使用 <code>redis-server /path/sentinel.conf --sentinel</code> 命令来启动。</p>
<h3 id="初始化服务"><a href="#初始化服务" class="headerlink" title="初始化服务"></a>初始化服务</h3><p>启动 Sentinel 的第一步就是初始化一个普通的 Redis 服务，但是该服务不会载入 RDB 或 AOF 文件。</p>
<h3 id="使用专用代码"><a href="#使用专用代码" class="headerlink" title="使用专用代码"></a>使用专用代码</h3><p>接下来第二步就是将普通 Redis 服务使用的代码替换成 Sentinel 专用的代码。比如说，普通 Redis 服务使用 <code>server.c/redisCommandTable</code> 作为服务的命令表，而 Sentinel 则使用 <code>sentinel.c/sentinelcmds</code> 作为服务的命令表，从该命令表可以看出 Sentinel 只能使用 PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE 和 PUNSUBSCRIBE 这些命令。</p>
<h3 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h3><p>接着就是初始化 Sentinel 的状态，即通过读取配置文件来初始化 <code>sentinel.c/sentinelState</code> 结构，其中 masters 字典属性记录了所有被 Sentinel 监视的主服务信息。这里有一个配置文件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#####################</span><br><span class="line"># master1 configure #</span><br><span class="line">#####################</span><br><span class="line">sentinel monitor master1 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds master1 30000</span><br><span class="line">sentinel parallel-syncs master1 1</span><br><span class="line">sentinel failover-timeout master1 900000</span><br><span class="line">#####################</span><br><span class="line"># master2 configure #</span><br><span class="line">#####################</span><br><span class="line">sentinel monitor master2 127.0.0.1 12345 5</span><br><span class="line">sentinel down-after-milliseconds master2 50000</span><br><span class="line">sentinel parallel-syncs master2 5</span><br><span class="line">sentinel failover-timeout master2 450000</span><br></pre></td></tr></table></figure>

<h3 id="创建连向主服务的连接"><a href="#创建连向主服务的连接" class="headerlink" title="创建连向主服务的连接"></a>创建连向主服务的连接</h3><p>初始化 Sentinel 的最后一步就是创建连向监视主服务的网络连接，Sentinel 将成为主服务的客户端，它可以向主服务发送命令，并从命令回复中获取相关的信息。对于每个被 Sentinel 监视的主服务来说，Sentinel 会创建两个连向主服务的异步网络连接，一个是命令连接，用于发送命令和接收回复；另一个是订阅连接，专门用于订阅主服务的 <code>__sentinel__:hello</code> 频道。</p>
<blockquote>
<p>在 Redis 目前的发布和订阅功能中，被发送的信息都不会保存在 Redis 服务中，所以如果在信息发送时，接收的客户端不在线或者断线，则信息就会丢失。因此为了不丢失 <code>__sentinel__:hello</code> 频道的任何信息，Sentinel 必须专门用一个订阅连接来接收该频道的信息。</p>
</blockquote>
<h3 id="获取主从服务的信息"><a href="#获取主从服务的信息" class="headerlink" title="获取主从服务的信息"></a>获取主从服务的信息</h3><p>Sentinel 默认会以每 10 秒一次的频率通过命令连接向被监视的主服务发送 INFO 命令来获取主服务的当前信息，INFO 命令的回复类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Server</span><br><span class="line">...</span><br><span class="line">run_id:7611c59dc3a29aa6fa0609f841bb6a1019008a9c</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">...</span><br><span class="line">slave0:ip=127.0.0.1,port=11111,state=online,offset=43,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=22222,state=online,offset=43,lag=0</span><br><span class="line">slave2:ip=127.0.0.1,port=33333,state=online,offset=43,lag=0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Other sections</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据 INFO 命令返回的信息，Sentinel 将对主服务的实例结构 <code>sentinelRedisInstance</code> 进行更新，比如主服务重启后，它的运行 ID 就会和之前保存的不同，Sentinel 会检测到该情况并进行更新。同时主服务返回的从服务信息将会被保存到主服务实例结构中的 slaves 字典属性里，从服务的实例结构同样使用 <code>sentinelRedisInstance</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/22/ymR.png" alt="主从服务信息的存储结构"></p>
<p>Sentinel 在分析 INFO 命令返回的从服务信息时，会检查对应的从服务实例结构是否已经存在，如果存在就进行更新；如果不存在，就会在 slaves 字典中创建一个新的实例结构，同时会创建连接到从服务的命令连接和订阅连接，并同样会以每 10 秒一次的频率通过命令连接向从服务发送 INFO 命令，并根据返回信息更新从服务实例的结构。</p>
<h3 id="向所有服务发送信息"><a href="#向所有服务发送信息" class="headerlink" title="向所有服务发送信息"></a>向所有服务发送信息</h3><p>默认情况下，Sentinel 会以每 2 秒一次的频率，通过命令连接向所有被监视的主服务和从服务发送以下格式的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令向所有服务的 <code>__sentinel__:hello</code> 频道发送了一条信息，其中 s_ 开头的是 Sentinel 本身的信息，而 m_ 开头的信息，如果 Sentinel 正在监视的是主服务，则这些就是主服务的信息；如果 Sentinel 正在监视的是从服务，则这些就是从服务正在复制的主服务的信息。</p>
<h3 id="订阅所有服务的信息"><a href="#订阅所有服务的信息" class="headerlink" title="订阅所有服务的信息"></a>订阅所有服务的信息</h3><p>当 Sentinel 与一个主服务或者从服务建立了订阅连接后，Sentinel 就会通过订阅连接向服务发送以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE __sentinel__:hello</span><br></pre></td></tr></table></figure>

<p>该订阅会一直维持到 Sentinel 与服务的连接断开为止。这也就是说，对于每个与 Sentinel 连接的服务，Sentinel 既会通过命令连接向服务的 <code>__sentinel__:hello</code> 频道发送命令信息，又通过订阅连接从服务的 <code>__sentinel__:hello</code> 频道接收消息。对于监视同一个服务的多个 Sentinel 来说，一个 Sentinel 发送的信息会被其他 Sentinel 接收到（因为其他 Sentinel 也订阅了该服务的该频道）。</p>
<h3 id="更新-sentinels-字典并创建命令连接"><a href="#更新-sentinels-字典并创建命令连接" class="headerlink" title="更新 sentinels 字典并创建命令连接"></a>更新 sentinels 字典并创建命令连接</h3><p>Sentinel 为主服务创建的实例结构中的 sentinels 字典保存了所有监视该服务的 Sentinel 的信息，Sentinel 的实例结构同样使用 <code>sentinelRedisInstance</code>。当一个 Sentinel 接收到其他 Sentinel 发来的信息时，会从信息中分析并提取源 Sentinel 的信息，然后检查自己的 sentinels 字典，如果已经存在该 Sentinel 实例，则进行更新；否则会在 sentinels 字典中创建一个新的 Sentinel 实例结构，同时还会创建一个连向新 Sentinel 的命令连接，而新 Sentinel 同样也会创建连向这个 Sentinel 的命令连接，最终监视同一主服务的多个 Sentinel 将会形成互相连接的网络。</p>
<h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>默认情况下，Sentinel 会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务、从服务和其他 Sentinel）发送 PING 命令，如果一个实例在 down-after-milliseconds 毫秒内都向 Sentinel 返回无效回复，那么 Sentinel 会修改这个实例对应的实例结构，在 flags 属性中打开 SRI_S_DOWN 标识，表示该实例已经进入主观下线状态。</p>
<blockquote>
<p>用户设置的 down-after-milliseconds 不仅用来判断主服务的主观下线状态，还被用于判断主服务下属的所有从服务，以及所有同样监听该主服务的其他 Sentinel 的主观下线状态。不同的 Sentinel 设置的主观下线时长可能不同，当一个 Sentinel 将主服务判断为主观下线时，其他 Sentinel 可能仍然认为主服务处于在线状态，只有当主服务的断线时长超过其他 Sentinel 设置的时长后，所有的 Sentinel 才会认为该主服务处于主观下线状态。</p>
</blockquote>
<h3 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h3><p>当 Sentinel 将一个主服务判断为主观下线之后，为了确认这个主服务是否真的下线，它会向同样监视该主服务的其他 Sentinel 进行询问，看它们是否也认为该主服务处于下线状态。当它收集到足够数量（Sentinel 配置中设置的 quorum 参数的值）的下线判断后，就会将主服务判定为客观下线，并对主服务执行故障转移操作。</p>
<blockquote>
<p>命令 <code>sentinel monitor master 127.0.0.1 6379 2</code> 中最后的那个值就是 quorum 参数的值，每个 Sentinel 配置的 quorum 参数的值可能不同，因此判断客观下线的条件也就不同。</p>
</blockquote>
<h3 id="选举领头-Sentinel"><a href="#选举领头-Sentinel" class="headerlink" title="选举领头 Sentinel"></a>选举领头 Sentinel</h3><p>当一个主服务被判断为客观下线时，监视这个下线主服务的各个 Sentinel 会进行协商，选举出一个领头的 Sentinel，由领头的 Sentinel 对下线的主服务执行故障转移操作。</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>故障转移包含三个步骤，首先会在已经下线的主服务下属的所有从服务中挑选一个从服务，向它发送 <code>SLAVEOF no one</code> 命令，将其转换为主服务。接着会向已经下线的主服务下属的所有从服务发送 SLAVEOF 命令，让它们去复制新的主服务。最后要将已经下线的主服务设置为新的主服务的从服务，并在该从服务恢复上线后，向它发送 SLAVEOF 命令，让它真正成为新的主服务的从服务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Sentinel 只是一个运行在特殊模式下的 Redis 服务，它使用了和普通模式不同的命令表，因此能够使用的命令也和普通 Redis 服务不同。</li>
<li>Sentinel 会读取用户指定的配置文件，为每个要被监视的主服务创建相应的实例结构，同时创建连向主服务的命令连接和订阅连接。</li>
<li>Sentinel 通过向主服务发送 INFO 命令来获取主服务和主服务下属的所有从服务的信息，并为这些从服务创建相应的实例结构，以及连向这些从服务的命令连接和订阅连接。</li>
<li>Sentinel 默认会以每十秒一次的频率向被监视的主服务和从服务发送 INFO 命令，当主服务处于下线状态或者 Sentinel 正在对主服务进行故障转移时，Sentinel 向从服务发送 INFO 命令的频率会改为每秒一次。</li>
<li>对于监视同一主服务和从服务的多个 Sentinel 来说，它们会以每两秒一次的频率，通过向被监视服务的 <code>__sentinel__:hello</code> 频道发送消息来向其他 Sentinel 宣告自己的存在。</li>
<li>每个 Sentienl 也会从 <code>__sentinel__:hello</code> 频道中接收其他 Sentinel 发来的消息，并根据这些信息为其他 Sentinel 创建相应的实例结构，以及命令连接。</li>
<li>Sentinel 以每秒一次的频率向实例（包括主服务、从服务和其他 Sentinel）发送 PING 命令，并根据回复来判断实例是否在线。当一个实例在指定的时长中连续向 Sentinel 发送无效回复时，Sentinel 会将这个实例判断为主观下线。</li>
<li>当 Sentinel 将一个主服务判断为主观下线时，它会向其他同样监视该主服务的 Sentinel 询问，看它们是否同意该主服务已经主观下线，当收集到足够数量的主观下线投票后，它会认为该主服务处于客观下线状态，会发起一次针对主服务的故障转移操作。</li>
<li>故障转移操作之前需要所有监视下线主服务的 Sentinel 发起 Leader 选举，并由 Leader 对下线主服务执行故障转移操作。该选举方法是对 Raft 算法的实现。</li>
</ul>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>集群是 Redis 提供的分布式数据库方案，集群通过分片来进行数据共享，同时提供复制和故障转移的功能。集群的重要概念包括节点、槽指派、命令执行、重新分片、转向、故障转移和消息等。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>节点就是运行在集群模式下的 Redis 服务，集群模式需要在配置文件中指定，对应 cluster-enabled 选项。在节点运行时，除了会继续使用所有在单机模式下的服务组件，使用 redisServer 和 redisClient 结构保存服务端和客户端的状态外，还会使用新的结构来保存在集群模式下需要用到的数据。其中，使用 clusterNode 结构保存节点状态，使用 clusterLink 结构保存连接节点所需的信息，使用 clusterState 保存当前节点视角下的集群状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/23/27R.png" alt="集群节点结构"></p>
<p>一个 Redis 集群通常由多个节点组成，在刚开始时，每个节点都是互相独立的，只有将它们连接起来才能构成一个包含多个节点的集群。连接节点需要使用 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令，该命令可以让该节点与指定节点进行握手（handshake），握手成功的两个节点会将彼此添加到 clusterState.nodes 字典中，同时该节点会将指定节点的信息通过 Gossip 协议传播给集群中的其他节点，让其他节点也与指定节点进行握手。</p>
<h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p>Redis 集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都通过 <code>CRC16(key) &amp; 16383</code> 的方式计算它所在的哈希槽。集群的每个节点可以处理 0 个或最多 16384 个槽，当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果有任何一个槽没有得到处理，集群则处于下线状态（fail）。</p>
<p>通过向节点发送 <code>CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</code> 命令，可以将一个或多个槽指派给该节点。比如，使用以下命令可以将槽 0 到槽 5000 指派给 <code>127.0.0.1:6379</code> 节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000</span><br></pre></td></tr></table></figure>

<p>Redis 集群使用 clusterNode 结构中的 slots 属性记录节点负责处理哪些槽，使用 numslots 属性记录节点处理槽的数量。其中 slots 属性是一个二进制位数组（bit array），数组的长度为 16384&#x2F;8 &#x3D; 2048 个字节，共包含 16384 个二进制位。Redis 以 0 为起始索引，为这 16384 个二进制位进行编号，并根据索引 i 对应的二进制位的值来判断节点是否负责处理槽 i。比如下图中，该节点就负责处理 0 到 7 号这 8 个槽。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/23/aPB.png" alt="slots属性"></p>
<p>节点除了会记录自己负责处理的槽，还会通过消息发送给集群中的其他节点，当其他节点通过消息接收到该节点发送的 slots 数组时，其他节点会在自己的 clusterState.nodes 字典中查找该节点对应的 clusterNode 结构，并对结构中的 slots 属性进行保存或者更新。</p>
<p>每个节点的 clusterState 结构中都有一个 slots 数组，记录了集群中所有 16384 个槽的指派信息，每个元素都是一个指向 clusterNode 结构的指针。所以说，clusterState.slots 数组记录了集群中所有槽的指派信息，而 clusterNode.slots 数组则只记录了该节点被指派的槽信息。</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>集群上线后，客户端就可以向集群中的节点发送命令请求了。当客户端发送的命令与数据库键有关时，接收命令的节点会计算出该键属于哪个槽，并检查这个槽是否指派给了自己。如果是，则节点直接执行该命令；如果不是，则节点会向客户端返回一个 MOVED 错误，指引客户端转向（redirect）至正确的节点，并再次发送之前的命令。</p>
<h2 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h2><p>集群节点保存键值对、以及对键的过期时间的处理方式与单机 Redis 服务完全相同，唯一的区别就是，节点只能使用 0 号数据库，而单机服务则没有这种限制。另外，除了将键值对保存到数据库中，节点还会使用 clusterState 结构中的 slots_to_keys 跳跃表来保存槽与键之间的关系。通过在 slots_to_keys 跳跃表中记录各个键所属的槽，节点可以很方便地对属于某个或某些槽的所有数据库键进行批量操作。例如 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令可以返回最多 count 个属于 slot 槽的数据键，而这个命令就是通过遍历 slots_to_keys 跳跃表来实现的。</p>
<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键值对也会进行移动。重新分片操作可以在线进行，这个过程中集群不需要下线，并且这两个节点都可以继续处理命令请求。</p>
<p>Redis 集群的重新分片操作由集群管理软件 redis-trib 负责执行，在重新分片完成后，新的指派会通过消息发送至整个集群。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求。</p>
<p>向一个节点发送 <code>CLUSTER REPLICATE &lt;node_id&gt;</code> 命令可以使该节点成为指定节点的从节点，并开始对主节点进行复制。接收到该命令的节点首先会在自己的 clusterState.nodes 字典中找到 node_id 对应的 clusterNode 结构，并将自己的 clusterState.myself.slaveof 指针指向这个结构，用来记录它所复制的主节点。然后节点会修改自己的 clusterState.myself.flags 属性，关闭 REDIS_NODE_MASTER 标识，打开 REDIS_NODE_SLAVE 标识。最后会向从节点发送 <code>SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</code> 命令进行复制操作。</p>
<p>这个过程会通过消息发送给集群的其他节点，最终集群中的所有节点都会知道该从节点正在复制某个主节点，集群中的所有节点都会在代表该主节点的 clusterNode 结构的 slaves 属性和 numslaves 属性中记录正在复制这个主节点的从节点信息。</p>
<h2 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h2><p>集群中的每个节点都会以每秒一次的频率向其他节点发送 PING 消息，如果接收 PING 消息的节点没有在规定时间内发送 PONG 消息回复，则发送 PING 消息的节点就会将接收 PING 消息的节点标记为疑似下线（probable fail，PFAIL）。如果在一个集群中，半数以上的主节点都将某个主节点报告为疑似下线，那么这个主节点将被标记为已下线（FAIL），将该主节点标记为已下线的节点会向集群广播一条信息，所有收到该信息的节点都会立即将该主节点标记为已下线。</p>
<h2 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h2><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，会对下线节点进行故障转移操作，具体来说就是：首先会从复制下线主节点的从节点中选举一个从节点执行 <code>SLAVEOF no one</code>，使其成为新的主节点。然后新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。接着新的主节点会向集群广播一条 PONG 消息，告知集群中的其他节点自己已经由从节点变成了主节点，并已经接管了原本已下线主节点负责的槽。最后新的主节点开始接收和处理自己负责的命令请求，故障转移完成。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《Redis 设计与实现》</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 中 in 与 exists</title>
    <url>/2018/07/28/SQL%20%E4%B8%AD%20in%20%E4%B8%8E%20exists/</url>
    <content><![CDATA[<p>数据库使用的是 MySQL，版本为 5.7.20。有两张基础表 user 和 list，表结构如下：  </p>
<span id="more"></span>		

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">  id        <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">  head      <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">null</span>,</span><br><span class="line">  user_name <span class="type">char</span>(<span class="number">50</span>)     <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  password  <span class="type">char</span>(<span class="number">128</span>)    <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> list</span><br><span class="line">(</span><br><span class="line">  id          <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">  user_id     <span class="type">int</span>                          <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  content     <span class="type">char</span>(<span class="number">255</span>)                    <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  create_time <span class="type">char</span>(<span class="number">19</span>)                     <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  finish_time <span class="type">char</span>(<span class="number">19</span>)                     <span class="keyword">null</span>,</span><br><span class="line">  status      tinyint(<span class="number">1</span>) unsigned zerofill <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/28/l9v.png" alt="user"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/28/8yV.png" alt="list"></p>
<p>其中，list 表中的 user_id 对应 user 表中的 id。user 表共有 100 万条数据，list 表只有 4 条数据。  </p>
<h1 id="in"><a href="#in" class="headerlink" title="in"></a>in</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> list);</span><br></pre></td></tr></table></figure>

<p>在查询时，首先执行子查询中的 FROM list 进行全表扫描并物化，然后使用物化后的表与 user 表进行连接查询。整个过程耗时为 62 ms（execution：31 ms，fetching：31 ms）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/28/pLz.png" alt="in 结果集"></p>
<p>可以通过执行计划查看执行的过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  id</span><br><span class="line">  <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> list);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/28/Nxp.png" alt="in_explain_rows"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/28/RxO.png" alt="in_explain_mysql_workbench"></p>
<h1 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">EXISTS</span>(</span><br><span class="line">      <span class="keyword">SELECT</span> </span><br><span class="line">           list.id</span><br><span class="line">         <span class="keyword">FROM</span> </span><br><span class="line">           list</span><br><span class="line">         <span class="keyword">WHERE</span> </span><br><span class="line">           user.id <span class="operator">=</span> list.user_id</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>以上 SQL 的执行结果和使用 in 时一致。但是两者的执行过程完全不一样，可以先查看执行计划来分析这个过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/28/94K.png" alt="exists_explain_rows"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/07/28/XX7.png" alt="exists_explain_mysql_workbench"></p>
<p>执行计划中指出以上查询需要执行两个过程，首先执行 id 为 2 的过程，根据 type 为 ALL 判断括号中的子查询需要进行全表扫描，接下来要执行子查询的 WHERE 条件，但是根据 select_type 的值为 DEPENDENT SUBQUERY 判断括号中的子查询需要依赖外表的查询结果，所以接下来就执行 id 为 1 的过程，对 user 表进行全表扫描，接下来对外表的查询结果进行逐条 loop，每次 loop 执行子查询的 WHERE 条件，满足条件有结果返回则为 true，最终外表的 SELECT * 将满足条件的结果返回。整个过程耗时为 2 s 579 ms（execution：2 s 564 ms，fetching：15 ms）。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上实例可以看出，并不能一味的使用 exists 替换 in。在外表数据量较大，而内表数据量较小，同时外表使用的查询条件为索引时，使用 in 的效率很高。在外表数据量较小，而内表数据量较大时可以使用 exists 来替换。当两张表的数据量相当时，使用 in 和 exists 的差别并不大。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet 3.1 规范学习</title>
    <url>/2018/04/27/Servlet%203.1%20%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>此次学习 Servlet 3.1 规范的目的是整理学习规范中新的特性（一些特性在 3.0 已经出现），不会涵盖规范的全部内容，仅为个别重点。  </p>
<span id="more"></span>

<h1 id="编程注册组件"><a href="#编程注册组件" class="headerlink" title="编程注册组件"></a>编程注册组件</h1><p>除了使用 web.xml 以及注解来配置组件外，新的规范还支持以编程的方式动态注册组件（Servlet、Listener 以及 Filter），具体来说是在 Web 容器启动时动态注册。我们可以使用 Servlet API 提供的 addServlet()、addFilter() 以及 addListener() 等方法来动态注册这些组件。注册的切入点有两种选择，其中一种是实现 <code>javax.servlet.ServletContextListener</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextListener</span> <span class="keyword">implements</span> <span class="title class_">javax</span>.servlet.ServletContextListener &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;---------------------ServletContextInitialized---------------------&quot;</span>);</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> servletContextEvent.getServletContext();</span><br><span class="line">        <span class="type">ServletRegistration</span> <span class="variable">servletRegistration</span> <span class="operator">=</span> servletContext.</span><br><span class="line">                addServlet(IndexServlet.class.getSimpleName(), IndexServlet.class);</span><br><span class="line">        servletRegistration.addMapping(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;---------------------ServletContextDestroyed---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种是实现 <code>javax.servlet.ServletContainerInitializer</code> 接口，采用这种方法能够在容器运行时通过可插拔的方式来注册组件。</p>
<h1 id="Web-模块部署描述符片段"><a href="#Web-模块部署描述符片段" class="headerlink" title="Web 模块部署描述符片段"></a>Web 模块部署描述符片段</h1><p>从 Servlet 3.0 规范就开始提供一些注解来简化 web.xml 的配置，如：<code>@WebServlet</code>、<code>@WebListener</code>、<code>@WebFilter</code> 等等，这些注解的使用暂且不提。Servlet 3.0 新增可插拔性来增加 Servlet 配置的灵活性，引入了名为“Web 模块部署描述符片段”的 web-fragment.xml 部署文件。该文件必须放在 jar 文件的 META-INF 目录下，该部署描述符文件可以包含一切可以在 web.xml 文件中定义的内容。通过这种方式，能够将某些 Servlet 组件打包成 jar 文件，在需要时引入，不需要时卸载。</p>
<p>在新的规范下，我们为 Web 应用增加一个 Servlet（或 Filter、Listener 同理）也就有三种方式：</p>
<ul>
<li>继承 <code>javax.servlet.http.HttpServlet</code>，修改 web.xml 文件，增加一个 Servlet 配置项。  </li>
<li>继承 <code>javax.servlet.http.HttpServlet</code>，并为该类加上 <code>@WebServlet</code> 注解。  </li>
<li>继承 <code>javax.servlet.http.HttpServlet</code>，将该类打成 jar 包，并在 jar 包的 META-INF 目录下添加 web-fragment.xml 文件来配置相应的 Servlet。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-fragment</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://xmlns.jcp.org/xml/ns/javaee/web-fragment_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>index<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.nekolr.servlet.IndexServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>index<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>web-app</code> 元素中包含一个新的 <code>metadata-complete</code> 属性，该属性用于描述当前 web 描述符是否完整，即当前配置是否完全，默认情况下该属性值为 false。当该属性值为 true 时，表示当前配置完全，Web 容器只会应用该配置，忽略其他类文件的注解（如 @WebServlet）以及 web-fragement.xml 的配置；当该属性值为 false 时，容器会扫描其他类文件的注解以及 web-fragement.xml 的配置。</p>
<p>由于规范允许应用配置多个文件（一个 web.xml 以及多个 web-fragement.xml），从应用中的多个不同的位置发现和加载配置，因此加载的顺序必须处理。具体细节参考规范中的说明。  </p>
<h1 id="运行时可插拔性"><a href="#运行时可插拔性" class="headerlink" title="运行时可插拔性"></a>运行时可插拔性</h1><p>为了实现运行时可插拔，需要实现 <code>javax.servlet.ServletContainerInitializer</code> 接口。同时，我们的实现必须在 jar 包的 META-INF&#x2F;services 目录中一个名为 <code>javax.servlet.ServletContainerInitializer</code> 的文件中指定。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/27/O7n.png" alt="javax.servlet.ServletContainerInitializer"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="type">ServletRegistration</span> <span class="variable">servletRegistration</span> <span class="operator">=</span> servletContext.</span><br><span class="line">                addServlet(IndexServlet.class.getSimpleName(), IndexServlet.class);</span><br><span class="line">        servletRegistration.addMapping(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型的例子是 Spring，查看 spring-web 的 META-INF&#x2F;services，果然有名为 javax.servlet.ServletContainerInitializer 的文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/27/a9N.png" alt="spring-web"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.web.SpringServletContainerInitializer</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes(&#123;WebApplicationInitializer.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;WebApplicationInitializer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (webAppInitializerClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">        <span class="comment">// Be defensive: Some servlet containers provide us with invalid classes,</span></span><br><span class="line">        <span class="comment">// no matter what @HandlesTypes says...</span></span><br><span class="line">        <span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">            WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            initializers.add((WebApplicationInitializer) waiClass.newInstance());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Failed to instantiate WebApplicationInitializer class&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">      servletContext.log(<span class="string">&quot;No Spring WebApplicationInitializer types detected on classpath&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    servletContext.log(initializers.size() + <span class="string">&quot; Spring WebApplicationInitializers detected on classpath&quot;</span>);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">    <span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">      initializer.onStartup(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 SpringServletContainerInitializer 类上有一个 @HandlesTypes 注解，按照规范中的意思，这个注解可以用在一些 javax.servlet.ServletContainerInitializer 的实现类上，@HandlesTypes 注解的 value 值是一个 Class 类型的数组，通过 onStartup() 方法中的 webAppInitializerClasses 参数，我们可以获取这些类型。比如在 Spring 的实现中，SpringServletContainerInitializer 作为实现类，使用 @HandlesTypes 注解的 value 值为 WebApplicationInitializer 接口，并且通过它的 onStartup() 方法也能够发现，实际调用的是 WebApplicationInitializer 的 onStartup() 方法。我们可以模仿 Spring 的这种实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes(value = AppInitializer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        List&lt;AppInitializer&gt; initializers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (set != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; clazz : set) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!clazz.isInterface() &amp;&amp; !Modifier.isAbstract(clazz.getModifiers()) &amp;&amp;</span><br><span class="line">                        AppInitializer.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        initializers.add((AppInitializer) clazz.newInstance());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">                servletContext.log(<span class="string">&quot;No AppInitializer types detected on classpath&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            servletContext.log(initializers.size() + <span class="string">&quot; AppInitializer detected on classpath&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (AppInitializer appInitializer : initializers) &#123;</span><br><span class="line">                appInitializer.onStart(servletContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际是使用的 <code>AppInitializer</code> 接口的 <code>onStartup()</code> 方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AppInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAppInitializer</span> <span class="keyword">implements</span> <span class="title class_">AppInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="type">ServletRegistration</span> <span class="variable">servletRegistration</span> <span class="operator">=</span> servletContext.</span><br><span class="line">                addServlet(IndexServlet.class.getSimpleName(), IndexServlet.class);</span><br><span class="line">        servletRegistration.addMapping(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Session-与-Cookie"><a href="#Session-与-Cookie" class="headerlink" title="Session 与 Cookie"></a>Session 与 Cookie</h1><p>我们知道 HTTP 协议是无状态的，即没有记忆和存储的能力，这意味着当处理过一次的业务，再次请求时需要重传，这会导致每次传输的数据量很大，尤其是在客户端与服务器进行交互的 Web 应用程序出现后，这种特性严重阻碍了这些程序的实现，因为交互是需要承前启后的。为了解决这个问题，Session 和 Cookie 诞生了。</p>
<p>与 Cookie 相关的标准有四个，最早的是 Netscape 标准，这也是最原始的 Cookie 规范，同时也是 <a href="https://tools.ietf.org/html/rfc2109">RFC 2109</a> 规范的基础。1997 年 2 月份，Network Working Group 推出了第一份官方的 Cookie 标准，理论上，所有使用 Cookie 的客户端与服务端都应该实现该标准，但是由于那时的浏览器市场还是 Netscape 的天下，导致很多服务端仍然在使用 Netscape 标准。为了解决这个问题，2000 年 Network Working Group 又推出了 <a href="https://tools.ietf.org/html/rfc2965">RFC 2965</a> 规范，该规范中增加了两个新的 Header：Cookie2 和 Set-Cookie2，其他部分与 RFC 2109 相差不多。2011 年，时隔 11 年，新的 Cookie 标准：<a href="https://tools.ietf.org/html/rfc6265">RFC 6265</a> 规范发布。新规范可以说是把 Cookie 规则整个翻新了一遍，修改幅度很大，值得一提的是，新规范中增加了 HttpOnly 属性，指定 HttpOnly 的 Cookie 不能被客户端读写，仅供 HTTP 传输使用，或者只有服务端可以读写，客户端需要确保其不能读写。</p>
<p>Cookie 由服务器端生成（客户端也可以自己创建），发送给 User-Agent（一般是浏览器），浏览器会将 Cookie 的 key&#x2F;value 值保存到某个目录下的文本文件中，在下次请求同一个域时会在请求头中加上该 Cookie（前提是浏览器没有禁用 Cookie）。</p>
<blockquote>
<p>Cookie 可以设置 domain 属性，该属性可以控制能够访问该 Cookie 的域名。比如设置为 <code>.google.com</code>，那么所有以 <code>google.com</code> 结尾的域名都可以访问该 Cookie，也就意味着该 Cookie 会被发送给所有以 <code>google.com</code> 结尾的子域名。</p>
</blockquote>
<p>Session 由服务器端程序生成，在生成 Session 时会生成一个唯一的 Session Id，一般的 Web 应用会将 Session 存储到服务器内存当中，同时这个 Session Id 会以 Cookie 的形式发送给浏览器，浏览器会将它保存到本地磁盘当中，在下次请求同一个域时一并提交。</p>
<h2 id="Java-中的-Session-操作"><a href="#Java-中的-Session-操作" class="headerlink" title="Java 中的 Session 操作"></a>Java 中的 Session 操作</h2><ul>
<li>创建</li>
</ul>
<p>需要注意的是，有很多人误认为在一开始访问 Web 容器时就创建 Session，之所以这么认为大概是觉得一次访问就是一次会话，就会创建 Session。其实创建 Session 需要程序使用 <code>HttpServletRequest.getSession(true)</code> 方法。当传入 true 值时，会先获取 Session 对象，如果不存在则新建；当传入 false 值时，只获取 Session 对象，如果不存在则返回 null。容器创建 Session 时会生成一个唯一的 Session Id（Tomcat 服务器生成 Session Id 的方式是随机数+时间+jvmid），并将该 Id 发送给客户端。  </p>
<ul>
<li>删除</li>
</ul>
<p>Session 的删除有两种方式，一种是 Session 超时，由容器自行删除；一种是手动调用 <code>HttpSession</code> 对象的 <code>invalidate()</code> 方法。<strong>需要注意的是，Session 不会因为浏览器的关闭而删除，删除只能通过上述的两种方式</strong>。  </p>
<p>下面使用代码例子来证实。先写一个监听器监听 Session 的变化。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionListener</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;创建了 Session：&quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;删除了 Session：&quot;</span> + se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是两个 Servlet，一个是登录 Servlet，一个是主页 Servlet。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;---------------------doGet---------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span> &amp;&amp; password != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession(<span class="literal">true</span>);</span><br><span class="line">            session.setMaxInactiveInterval(<span class="number">10</span>); <span class="comment">// 10s 过期</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/index.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;---------------------doPost---------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;---------------------LoginServletInitialized---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value = &quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;---------------------doGet---------------------&quot;</span>);</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/index.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        LogUtil.log(<span class="string">&quot;---------------------doPost---------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个页面，一个是登录页面，一个是主页。需要注意的是，这个例子是为了观察 Session 的处理是不是我们预期的方式，而 jsp 在编译后会自动加上创建 Session 的代码，一种方式是在 <code>&lt;%@ page session=&quot;false&quot;%&gt;</code> 中显式表明不使用 Session，另一种方式就是直接使用 html。  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>login<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span> 登录 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%=<span class="string">&quot;欢迎你，&quot;</span> + session.getAttribute(<span class="string">&quot;user&quot;</span>)%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p><a href="https://jcp.org/aboutJava/communityprocess/final/jsr340/index.html">JSR 340 Java Servlet 3.1</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/">Servlet 3.0 新特性详解 </a></p>
</blockquote>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Session 共享</title>
    <url>/2020/06/19/Session%20%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<p>我们知道，Session 是由服务端生成的，在生成 Session 的同时还会生成一个唯一的 Session Id。一般的 Web 应用会在服务器内存当中开辟一部分内存用来存储 Session，同时这个 Session Id 会以 Cookie 的形式发送给浏览器，浏览器会将它保存到本地磁盘当中，在下次请求同一个域时会一并提交。然而当系统架构升级为分布式架构或者微服务架构时，作为流量入口的网关会通过负载均衡策略将用户的请求转发到不同的 Web 容器当中，这就可能会出现用户登录系统后，再次发送请求则被告知没有登录的情况。此时就需要某种机制来确保所有的 Web 容器能够共享用户的 Session 信息。</p>
<span id="more"></span>

<h1 id="不使用-Session"><a href="#不使用-Session" class="headerlink" title="不使用 Session"></a>不使用 Session</h1><p>这不是随便说说，在某些场景下确实可以不使用 Session。现在的很多接口类系统中都提倡“无状态服务”，也就是说每一次的接口访问都不依赖于前一次的接口访问，这样服务端就可以很容易地进行水平扩展，也就不存在 Session 共享的问题了。比较典型的方案就是 JWT（JSON Web Tokens）。</p>
<p><strong>在传统的 Session-Cookie 机制中，状态是由服务端负责维护的；而在 JWT 中，状态是由客户端负责维护的</strong>。JWT 的原理是，服务端在认证完成后，会将用户信息与一些 JWT 的配置信息相结合，最终通过某种算法生成一个很长的字符串。这个字符串由三部分组成，中间用 <code>.</code> 进行分隔，分别为头部（Header）、负载（Payload）和签名（Signature）。其中 Header 是一个 JSON 对象，存储的是签名使用的算法和最终生成的令牌的类型。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>Payload 部分也是一个 JSON 对象，它用来存储实际需要传递的数据，JWT 规定了 7 个官方字段供我们选用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure>

<p>Signature 部分是对前两部分的签名，这样可以有效防止数据被篡改。在生成签名时，需要指定一个密钥（secret），这个密钥需要在服务端进行保存，不能泄露给其他人。然后使用 Header 中指定的签名算法，按照下面的公式生成签名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</span><br></pre></td></tr></table></figure>

<p>JWT 方案最大的问题就是无法在使用过程中将某个已经签发的令牌作废，或者更改令牌的权限。也就是说，一旦 JWT 签发了一个令牌，那么在到期之前，该令牌会始终有效。因此如果令牌发生泄漏我们也无法处理，只能等待令牌到期失效。造成这个问题的根本原因是我们将状态维护的工作交给了客户端，服务端已经无法对状态进行控制。网上有很多人为了解决这个问题，选择了引入类似 Redis 这种的存储系统来负责维护签发过的令牌，我不能说这种做法有多不好，毕竟这也能实现需求，但是这种做法明显已经偏离了 JWT 的初衷（stateless 无状态），还不如直接使用更加成熟的 Session-Cookie 机制。总的来说，JWT 应该被用在 Token 有效时间短，或者一次性使用的场景中。设置较短的有效时间可以降低 Token 泄露时的危险程度。</p>
<p>Cookie 的特性决定了它只能在浏览器中使用，现在的很多系统服务的设备类型多种多样，如果在移动设备上采用原生的方式开发 App（Native App），那么开发人员就需要自己手动模拟浏览器来维护 Cookie（手动解析 <code>Set-Cookie</code> Header 等），因此在一些系统中开发人员可能更倾向于使用 Token + Redis 的方案。用户登录后，服务端通过某种方式生成一个唯一的 Token 返回给客户端，客户端在接下来的每次请求的 Header 中都携带该 Token。而服务端则会将 Token 与用户信息以键值对的形式存储在 Redis 中，并设置过期时间。这种方案本质上还是实现了类似 Session-Cookie 的机制，它还是有状态的，只不过状态的维护由之前的 Web 容器转移到了集中式的内存服务（Redis）中。同时我们很容易地就能想到，这种将状态的维护转移并集中管理的做法同样可以应用到 Session-Cookie 机制当中。</p>
<h1 id="Session-同步"><a href="#Session-同步" class="headerlink" title="Session 同步"></a>Session 同步</h1><p>所谓 Session 同步就是通过网络将 Web 容器的 Session 复制到其他 Web 容器上，最终实现所有的 Web 容器都保存相同的 Session。这种方案的优点就是不需要修改代码，但是缺点也很多：首先需要 Web 容器支持 Session 同步，一旦容器不支持那就无法使用了。Tomcat 有一个开源的 Session 同步组件 <a href="https://github.com/jcoleman/tomcat-redis-session-manager">tomcat-redis-session-manager</a>，但是它不支持 Tomcat 8 及以上的版本。同时如果数据量较大时同步还有可能会出现延迟，因此这个方案一般都不会考虑。</p>
<h1 id="IP-绑定"><a href="#IP-绑定" class="headerlink" title="IP 绑定"></a>IP 绑定</h1><p>使用 Nginx（或其他负载均衡软硬件）中的 IP 绑定策略（<code>ip_hash</code> 策略），将同一个用户（相同 IP 地址）的请求都转发到固定的一个 Web 容器中，这么做同样可以避免修改代码，但是也失去了负载均衡的意义，当一台服务器宕机的时候，会影响一批用户的使用。</p>
<h1 id="集中式存储"><a href="#集中式存储" class="headerlink" title="集中式存储"></a>集中式存储</h1><p>将 Session 交给一个集中式的存储系统负责维护，所有的 Web 容器都通过这个存储系统实现 Session 的存取。这种方案的优点就是可靠性较高，同时水平扩展方便，缺点是系统整体的复杂度提升，同时引入新的组件也就意味着可能会产生很多新的问题。这种方案是目前比较常用的方案，典型的开源实现就是 Spring Session。当然也可以选择自己实现，其核心思想就是重写 HttpServletRequestWrapper 中的 getSession 方法。</p>
<p>Spring Session 提供了多种存储方案的实现，比如 Redis、JDBC（关系型数据库）、MongoDB 等，我们这里使用 Spring Session Data Redis 模块来举一个例子。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 Spring Boot 可以减少很多手工配置的工作，接下来只需要使用 <code>@EnableRedisHttpSession</code> 注解就可以将 Session 的集中存储管理交给 Redis。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSessionDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringSessionDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>@EnableRedisHttpSession</code> 注解中，使用 <code>@Import</code> 注解引入了 RedisHttpSessionConfiguration 配置类，该配置类的主要目的是在容器中注册一个 SessionRepositoryFilter 过滤器，这个过滤器会拦截所有的请求，并将 HttpServletRequest 和 HttpServletResponse 包装成 SessionRepositoryRequestWrapper 和 SessionRepositoryResponseWrapper，在 Wrapper 类中重写了 getSession 等方法。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell Script 学习</title>
    <url>/2019/01/23/Shell%20Script%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>简单学习过 Shell 后，接下来继续学习 Shell 脚本。  </p>
<span id="more"></span>  
<h1 id="良好风格"><a href="#良好风格" class="headerlink" title="良好风格"></a>良好风格</h1><ul>
<li>在脚本的第一行，要宣告该脚本使用的 shell 名称，比如 <code>#!/bin/bash</code>。</li>
<li>说明部分，要说明脚本的功能、版本、作者、联系方式、版权声明等。</li>
<li>脚本运行时需要用到的环境变量要预先定义和配置。</li>
<li>脚本正文中，比较特殊的命令使用绝对路径的方式下达。</li>
<li>定义回传值，比如成功为 0，失败为非零整数。</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>单行注释很简单，使用 <code>#</code> 开头就代表本行注释。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我是注释</span></span><br></pre></td></tr></table></figure>

<h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>使用 <code>:&lt;&lt;</code> 开头，后边可以跟其他的字符，最后再以对应的字符结尾。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">我是多行注释</span></span><br><span class="line"><span class="string">I am multi-line comment</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">我是多行注释</span><br><span class="line">I am multi-line comment</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>一般在编程语言中，我们通常都能够使用 if else 语句进行条件判断，bash 也不例外。但是除了条件判断语句，bash 还有一些条件判断的命令。  </p>
<h2 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h2><p>test 命令可以检测系统中的文件以及相关的属性。常用的参数如下：  </p>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>判断是否存在且为文件</td>
</tr>
<tr>
<td>-d</td>
<td>判断是否存在且为目录</td>
</tr>
<tr>
<td>-L</td>
<td>判断文件是否存在且是链接文件（软链接或硬链接）</td>
</tr>
<tr>
<td>-r</td>
<td>判断文件是否存在且有读的权限</td>
</tr>
<tr>
<td>-w</td>
<td>判断文件是否存在且有写的权限</td>
</tr>
<tr>
<td>-x</td>
<td>判断文件是否存在且有执行的权限</td>
</tr>
<tr>
<td>-nt</td>
<td><code>test file1 -nt file2</code>，判断 file1 是否比 file2 新（newer than）</td>
</tr>
<tr>
<td>-ot</td>
<td>判断 file1 是否比 file2 旧（older than）</td>
</tr>
<tr>
<td>-ef</td>
<td>判断两个文件是否为同一个文件，主要用于判断硬链接。</td>
</tr>
<tr>
<td>-eq</td>
<td>判断两个整数是否相等（equals）</td>
</tr>
<tr>
<td>-ne</td>
<td>判断两个整数是否不相等（not equals）</td>
</tr>
<tr>
<td>-gt</td>
<td><code>test num1 -gt num2</code>，判断 num1 是否大于 num2（greater than）</td>
</tr>
<tr>
<td>-lt</td>
<td>判断 num1 是否小于 num2（less than）</td>
</tr>
<tr>
<td>-ge</td>
<td>判断 num1 是否大于等于 num2（greater than or equals）</td>
</tr>
<tr>
<td>-le</td>
<td>判断 num1 是否小于等于 num2（less than or equals）</td>
</tr>
<tr>
<td>-z</td>
<td>判断字符串是否为空</td>
</tr>
<tr>
<td>-n</td>
<td>判断字符串是否不为空</td>
</tr>
<tr>
<td>&#x3D;</td>
<td><code>test str1 = str2</code>，判断 str1 是否等于 str2</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td><code>test str1 != str2</code>，判断 str1 是否不等于 str2</td>
</tr>
<tr>
<td>-a</td>
<td>相当于 and，只有都成立时才会返回 true，比如 <code>test -r file1 -a -x file2</code></td>
</tr>
<tr>
<td>-o</td>
<td>相当于 or，任何一个成立时就会返回 true</td>
</tr>
<tr>
<td>!</td>
<td>取反，比如 <code>test ! -x file1</code>，当 file1 不具有执行的权限时返回 true</td>
</tr>
</tbody></table>
<p>需要注意的是，test 命令返回的值并不会直接输出到屏幕，因此需要自己控制输出，比如：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">test</span> -r file1 &amp;&amp; <span class="built_in">echo</span> <span class="literal">true</span> || <span class="built_in">echo</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号"></a>判断符号</h2><p>除了 test 命令，我们还可以使用判断符号 <code>[]</code>，也就是中括号来进行数据的判断。需要注意的是，因为中括号用在很多地方，所以在 bash 中使用中括号作为判断符号时，<strong>中括号的两端需要有空白字节来分隔，并且在中括号中的变量一定要用双引号包含，同时常量也要使用单引号或者是双引号包含</strong>。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ [ -z <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span> ]; <span class="built_in">echo</span> $?</span><br><span class="line">$ <span class="built_in">read</span> -p <span class="string">&quot;Please input (Y/N)&quot;</span> yn</span><br><span class="line">$ [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> -o <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;OK, continue.&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 bash 中使用一个等号与两个等号的意义相同，不过在程序中一般写法是，一个等号代表赋值，两个等号则代表条件判断。建议在条件判断时，使用双等号。  </p>
</blockquote>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input (Y/N): &quot;</span> yn</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;OK, continue.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;N&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;n&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Oh, interrupt!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know what your choice is&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;open&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;This switch is open&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;close&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;This switch is close&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;You must input parameters&quot;</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">printit</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Your choice is <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;one&quot;</span>)</span><br><span class="line">        <span class="comment"># 其中 1 是调用函数时传入的参数</span></span><br><span class="line">        printit 1</span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;two&quot;</span>)</span><br><span class="line">        printit 2</span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;three&quot;</span>)</span><br><span class="line">        printit 3</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> != <span class="string">&quot;Y&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> != <span class="string">&quot;y&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">read</span> -p <span class="string">&quot;Please input Y/y to stop this program: &quot;</span> yn</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;OK! you input the correct answer.&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">until</span> [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;Y&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$yn</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">read</span> -p <span class="string">&quot;Please input Y/y to stop this program: &quot;</span> yn</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;OK! you input the correct answer.&quot;</span></span><br></pre></td></tr></table></figure>

<p>while 循环与 until 循环的区别是，while 循环在条件满足时才会执行循环体；而 until 循环是在条件不满足时才会执行循环体。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog <span class="built_in">cat</span> mouse rabbit</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;There are <span class="variable">$&#123;animal&#125;</span>s.... &quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input a number, I will count for 1+2+...+your_input: &quot;</span> num</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>=0</span><br><span class="line"><span class="keyword">for</span> (( i=<span class="number">1</span>; i&lt;=<span class="variable">$num</span>; i=i+<span class="number">1</span> ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">sum</span>=$((<span class="variable">$sum</span>+<span class="variable">$i</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result of &#x27;1+2+3+...+<span class="variable">$num</span>&#x27; is ==&gt; <span class="variable">$sum</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h1><p>使用 <code>sh -n xxx.sh</code> 来检查脚本是否存在语法错误，如果没有则不会显示任何信息。同时，可以使用 <code>sh -x xxx.sh</code> 将脚本的执行过程全部列出，这样能够方便发现和调试错误。  </p>
<h1 id="运行-Shell-脚本"><a href="#运行-Shell-脚本" class="headerlink" title="运行 Shell 脚本"></a>运行 Shell 脚本</h1><p>在运行脚本之前，需要先确认脚本是否具有执行的权限。如果没有，则需要赋予执行的权限。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 以下命令需要 cd 到脚本所在目录执行</span><br><span class="line"></span><br><span class="line"># 赋予执行的权限</span><br><span class="line">chmod +x ./xxx.sh</span><br><span class="line"></span><br><span class="line"># 执行脚本</span><br><span class="line">./xxx.sh</span><br></pre></td></tr></table></figure>

<p>一定要写成 <code>./xxx.sh</code>，运行其它二进制的程序也一样。如果直接写 <code>xxx.sh</code>，系统会去 PATH 里寻找，而一般 PATH 里只有 <code>/bin</code>，<code>/sbin</code>，<code>/usr/bin</code>，<code>/usr/sbin</code> 等，当前目录通常不在 PATH 里，所以写成 <code>xxx.sh</code> 是找不到命令的，要用 <code>./xxx.sh</code> 告诉系统就在当前目录找。  </p>
<p>还有一种运行脚本的方法是直接运行解释器，传入需要运行的脚本文件名：<code>/bin/sh xxx.sh</code>。以及使用 source 命令运行脚本，比如 <code>source ./xxx.sh</code>，这种方式与前两种的区别是，使用该命令，脚本会在父程序中执行；而前两种会在子程序中运行。这也是为什么使用 source 可以使配置立即生效的原因。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《鸟哥的Linux私房菜》</p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 学习</title>
    <url>/2019/01/16/Shell%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>在计算机科学中，Shell 俗称壳程序，用来区别于操作系统内核程序。Shell 首先是 UNIX&#x2F;Linux 下的脚本编程语言，它是解释执行的，无需提前编译。同时它也是一个程序，为使用者（用户或其他应用程序）提供与内核交互的操作界面，它接收用户命令，然后通过命令解析调用相应的应用程序。  </p>
<span id="more"></span>  

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/01/16/Q4w.png" alt="Linux 下的 Shell">  </p>
<h1 id="广义上的-Shell"><a href="#广义上的-Shell" class="headerlink" title="广义上的 Shell"></a>广义上的 Shell</h1><p>广义上讲，只要能够为使用者提供与内核交互的都可以认为是 Shell，因此 Shell 可以分为两大类：图形界面 Shell（GUI Shell）与命令行 Shell（CLI Shell）。  </p>
<p>图形界面 Shell 应用最广泛的要属 Windows 系列操作系统了，还有 Linux 的 X window manager，以及功能更加强大的 CDE、GNOME、KDE 等。</p>
<p>命令行 Shell 主要包括 MS-DOS 系统下的命令行，Windows NT 下的 cmd.exe，支持 .NET Framework 的 Windows NT 系统下的 Windows PowerShell 以及 UNIX&#x2F;Linux 系统下的 sh&#x2F;bash&#x2F;csh 等。  </p>
<blockquote>
<p>我们习惯性地把微软旗下所有的操作系统都叫做 Windows，但其实它们是有很大区别的。最初的 Windows 只是一个运行在 MS-DOS 下的图形界面，从 Windows 1.x&#x2F;2.x&#x2F;3.x 一直发展到 Windows 9x&#x2F;ME，期间从 Windows 95 开始，微软划时代地推出了混合的 16 位 &#x2F; 32 位操作系统，这个时候的 Windows 虽然图形界面是 32 位的，但是操作系统还是 DOS，仍然能够运行 16 位的 DOS 程序。后来微软放弃了 MS-DOS，推出了另一条产品线 Windows NT。早期的 Windows NT 是一种纯 32 位操作系统，这个时候的操作系统除了在加电启动时是运行在 16 位模式（实模式），其他时候都是运行在 32 位模式（保护模式）。虽然 Windows NT 已经告别了 DOS，但还是可以通过模拟来运行 DOS 程序，比如在 Windows 8 中运行 DOS 程序会提示安装 NTVDM 来模拟 DOS 程序运行时的环境。但是由于 64 位的 Windows 不支持 NTVDM，所以也就没有办法运行 DOS 程序了。  </p>
</blockquote>
<blockquote>
<p>那么我们平常口中说的在 Windows NT 中运行 DOS 命令又是什么意思呢？因为在 MS-DOS 中是通过一系列的命令与内核交互，早期和中期的 Windows 都可以执行这些命令，到了 Windows NT，这些命令的使用方式并没有发生变化，于是就沿用了执行 DOS 命令这一说法了，而实际上此时在执行这些命令时使用的只是 Windows NT 提供的一个叫 cmd.exe 的命令行辅助工具，跟 DOS 已经没有关系了。  </p>
</blockquote>
<h1 id="Linux-下的-Shell"><a href="#Linux-下的-Shell" class="headerlink" title="Linux 下的 Shell"></a>Linux 下的 Shell</h1><p>在 Linux 下有很多不同的 Shell，常见的有 sh、bash、csh、tcsh、ash 等，sh 已经被 bash 代替，<code>/bin/sh</code> 往往是指向 <code>/bin/bash</code> 的符号链接。我们可以通过 <code>cat /etc/shells</code> 命令来查看当前系统下可以使用的 Shell 有哪些。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /etc/shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure>

<h1 id="进入-Shell"><a href="#进入-Shell" class="headerlink" title="进入 Shell"></a>进入 Shell</h1><p>一种进入 Shell 的方法是退出图形界面模式，进入控制台模式。现代的 Linux 操作系统在启动时会自动创建几个虚拟控制台（Virtual Console，在 Linux 系统内存中运行的虚拟终端），其中一个供图形桌面程序使用，其他的保留原生控制台的样子。例如：CentOS 在启动时会创建 6 个虚拟控制台，分别对应快捷键 <code>Ctrl + Alt + Fn(n=1,2,3,4,5,6)</code>，其中图形界面模式对应 <code>Ctrl + Alt + F1</code>。  </p>
<p>另一种方式就是使用 Linux 桌面环境提供的终端模拟包（Terminal emulation package），也就是我们常说的终端（Terminal），这样就可以在图形桌面中使用 Shell。  </p>
<h1 id="Bash-Shell-的操作环境"><a href="#Bash-Shell-的操作环境" class="headerlink" title="Bash Shell 的操作环境"></a>Bash Shell 的操作环境</h1><p>在登录主机时，屏幕会显示一些说明文字，比如告知我们 Linux 的版本等信息。我们习惯的环境变量、命令别名等在登录后也会被自动配置出来。这些都是 bash 在启动时通过读取环境配置文件来初始化的。  </p>
<h2 id="命令搜寻顺序"><a href="#命令搜寻顺序" class="headerlink" title="命令搜寻顺序"></a>命令搜寻顺序</h2><p>一个命令下达，它的搜寻顺序如下：  </p>
<ol>
<li>以相对或者绝对路径执行命令，比如 <code>/bin/ls</code> 或者 <code>./ls</code>。</li>
<li>以 alias 找到该命令执行。</li>
<li>由 bash 内建的命令来执行。</li>
<li>通过 <code>$PATH</code> 这个变量值的顺序找到第一个命令来执行。</li>
</ol>
<h2 id="bash-的环境配置文件"><a href="#bash-的环境配置文件" class="headerlink" title="bash 的环境配置文件"></a>bash 的环境配置文件</h2><p>在系统中有一些环境配置文件，在 bash 启动时会去读取这些文件来初始化 bash 的操作环境。而 shell 又有 login shell 和 non-login shell，不同的 shell 读取的配置也是有区别的。  </p>
<h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>login shell 指的是在获取 bash 时进行了完整的登录流程。比如，由 tty1 ~ tty6 登录，通过输入用户名和密码成功进入 bash。  </p>
<p>一般来说，login shell 只会读取两个文件，一个是 <code>/etc/profile</code>，它是系统整体的配置文件；另一个是用户的配置文件。  </p>
<p>在 <code>/etc/profile</code> 文件中，它会根据用户的 UID 去配置 PATH、MAIL、USER、HISTSIZE 等变量的值，然后设置用户的 umask 的值，最后读取 <code>/etc/profile.d/*.sh</code> 中的一系列文件。  </p>
<p>在读取完系统配置文件后，接下来就会去读取用户的配置文件。用户的配置文件按照读取的顺序分别为：<code>~/.bash_profile</code>、<code>~/.bash_login</code> 和 <code>~/.profile</code>，login shell 只会读取其中的某一个。如果在用户目录下存在 <code>.bashrc</code> 文件，则会读取该文件。  </p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>由于配置文件的内容是在取得 login shell 的时候才会读取，因此如果后续修改配置文件，就需要注销后重新登录才能生效。如果不想重新登录，可以使用 <code>source</code> 命令重新读取配置文件。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新读取配置文件</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="non-login-shell"><a href="#non-login-shell" class="headerlink" title="non-login shell"></a>non-login shell</h3><p>non-login shell 是指在获取 bash 时没有进行登录流程。比如在图形桌面中使用 <code>Ctrl + Alt + T</code> 启动的 shell 就是 non-login shell，在使用 <code>su</code> 命令切换用户时，不加 <code>--login</code> 参数（使用 <code>su - 用户名</code> 或者 <code>su --login 用户名</code> 的方式获取到的是 login shell）获取到的也是 non-login shell。  </p>
<p>一般来说，non-login shell 只会读取 <code>~/.bashrc</code>，在该文件中除了会应用使用者的个人配置外，还会呼叫外部配置文件 <code>/etc/bashrc</code>（Red Hat 系统特有的），然后根据用户的 UID 设置 umask 和 PS1 的值，同时还会读取 <code>/etc/profile.d/*.sh</code> 中的一系列文件。  </p>
<h3 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h3><p>还有一些配置文件也会影响 bash 环境，比如 <code>~/.bash_logout</code> 就记录了当注销 bash 后系统将会执行的动作，默认情况下只是清除屏幕信息，当然我们可以自定义其他的动作。  </p>
<h1 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h1><p>bash 有很多的内建命令，这些命令可以在 bash 中直接使用。通常来说，内建命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘 I&#x2F;O，还需要 fork 出一个单独的进程来执行，执行完成后再退出。而执行内建命令相当于调用当前 Shell 进程的一个函数。要判断一个命令是不是内建命令，一种方式是通过 Linux 的联机帮助文件查看，比如使用 <code>man cd</code> 查看 <code>cd</code> 这个命令的说明文档。还有一种方式是通过 <code>type</code> 这个内建命令查询。比如 <code>ls</code> 命令，则可以使用 <code>type ls</code> 来查看该命令是否是内建命令。  </p>
<h1 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h1><p>命令替换是指将命令的输出结果作为值赋给某个变量，在写法上有两种方式，一种是使用反引号，一种是使用 <code>$()</code>。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DATE_1=`<span class="built_in">date</span>`</span><br><span class="line">DATE_2=$(<span class="built_in">date</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DATE_1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DATE_2</span></span><br></pre></td></tr></table></figure>

<p>如果被替换的命令的输出内容包括多行（即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个，比如：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行 ls -l</span></span><br><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 28</span><br><span class="line">drwxr-xr-x  3 root root  20480 Jan 21 09:25 bin</span><br><span class="line">drwxr-xr-x  2 root root   4096 Oct 17 10:14 include</span><br><span class="line"><span class="comment"># 设置变量 LSL</span></span><br><span class="line">$ LSL=`<span class="built_in">ls</span> -l`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$LSL</span></span><br><span class="line">total 28 drwxr-xr-x 3 root root 20480 Jan 21 09:25 bin drwxr-xr-x 2 root root 4096 Oct 17 10:14 include</span><br><span class="line"><span class="comment"># 使用双引号包裹</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$LSL</span>&quot;</span></span><br><span class="line">total 28</span><br><span class="line">drwxr-xr-x  3 root root  20480 Jan 21 09:25 bin</span><br><span class="line">drwxr-xr-x  2 root root   4096 Oct 17 10:14 include</span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用 <code>$()</code> 相对清晰，且支持嵌套，但是 <code>$()</code> 仅在 bash 环境下有效。而反引号由于看起来与单引号类似，可能会对使用者造成困扰，但是反引号可以在多种 shell 环境中使用。  </p>
<h1 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h1><p><code>alias</code> 命令用来给命令创建别名，如果直接下达该命令不带任何参数，则会列出 shell 环境中使用的所有别名。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置别名</span></span><br><span class="line">$ <span class="built_in">alias</span> avalon=<span class="string">&quot;netstat -tunlp&quot;</span></span><br><span class="line"><span class="comment"># 删除别名</span></span><br><span class="line">$ <span class="built_in">unalias</span> avalon</span><br></pre></td></tr></table></figure>

<p>如果想要别名永久生效，需要把别名写入到用户目录下的 <code>.bashrc</code> 文件中。  </p>
<h1 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h1><p>历史命令记录的笔数与环境变量 <code>HISTFILESIZE</code> 的配置有关。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前内存中的所有 history 记录</span></span><br><span class="line">$ <span class="built_in">history</span></span><br><span class="line"><span class="comment"># 列出最近的 5 笔命令</span></span><br><span class="line">$ <span class="built_in">history</span> 5</span><br><span class="line"><span class="comment"># 立即将当前内存中 history 记录写入 ~/.bash_history 文件中</span></span><br><span class="line">$ <span class="built_in">history</span> -w</span><br><span class="line"><span class="comment"># 写入到指定的文件中</span></span><br><span class="line">$ <span class="built_in">history</span> -w ~/history_file</span><br><span class="line"><span class="comment"># 将当前内存中的 history 记录全部删除</span></span><br><span class="line">$ <span class="built_in">history</span> -c</span><br><span class="line"><span class="comment"># 从文件中读取记录到当前环境中</span></span><br><span class="line">$ <span class="built_in">history</span> -r ~/history_file</span><br><span class="line"><span class="comment"># 运行第 5 条命令</span></span><br><span class="line">$ !5</span><br><span class="line"><span class="comment"># 由最近的命令向前搜索，寻找符合的字串并运行</span></span><br><span class="line">$ !netstat</span><br><span class="line"><span class="comment"># 运行上一条命令，等同于按 ↑ 键后再回车</span></span><br><span class="line">$ !!</span><br></pre></td></tr></table></figure>

<h1 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h1><p>系统的可用资源是有限的，如果不限制用户和进程对系统资源的使用，则很容易造成资源耗尽。使用 <code>ulimit</code> 命令可以控制进程对可用资源的访问。  </p>
<p>默认情况下 Linux 系统的各个资源都做了软硬限制，其中硬限制的作用是控制软限制（即软限制不能高于硬限制）。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的软限制</span></span><br><span class="line">$ <span class="built_in">ulimit</span> -a</span><br><span class="line"><span class="comment"># 查看当前系统的硬限制</span></span><br><span class="line">$ <span class="built_in">ulimit</span> -a -H</span><br><span class="line"><span class="comment"># core 文件大小，单位是 block，默认为 0，表示没限制</span></span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line"><span class="comment"># 数据段大小，单位是 Kbyte，默认不做限制</span></span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line"><span class="comment"># 调度优先级，默认为 0，表示没限制</span></span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line"><span class="comment"># 创建文件的大小，单位是 block，默认不做限制</span></span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line"><span class="comment"># 挂起的信号数量，默认是 8192</span></span><br><span class="line">pending signals                 (-i) 8192</span><br><span class="line"><span class="comment"># 最大锁定内存的值，单位是 Kbyte，默认是 32</span></span><br><span class="line">max locked memory       (kbytes, -l) 32</span><br><span class="line"><span class="comment"># 最大可用的常驻内存值，单位是 Kbyte，默认不做限制</span></span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line"><span class="comment"># 最大打开的文件数，默认是 1024</span></span><br><span class="line">open files                      (-n) 1024</span><br><span class="line"><span class="comment"># 管道最大缓冲区的值</span></span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line"><span class="comment"># 消息队列的最大值，单位是 byte</span></span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line"><span class="comment"># 程序的实时性优先级，默认为 0</span></span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line"><span class="comment"># 栈大小，单位是 Kbyte</span></span><br><span class="line">stack size              (kbytes, -s) 10240</span><br><span class="line"><span class="comment"># 最大 cpu 占用时间，默认不做限制</span></span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line"><span class="comment"># 用户最大进程数，默认是 8192</span></span><br><span class="line">max user processes              (-u) 8192</span><br><span class="line"><span class="comment"># 最大虚拟内存，单位是 Kbyte，默认不做限制</span></span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line"><span class="comment"># 文件锁，默认不做限制</span></span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置最大可以打开的文件数</span></span><br><span class="line"><span class="comment"># 该命令会同时设置软、硬限制</span></span><br><span class="line">$ <span class="built_in">ulimit</span> -n 4096</span><br><span class="line"><span class="comment"># 单独设置软限制</span></span><br><span class="line">$ <span class="built_in">ulimit</span> -S -n 4096</span><br><span class="line"><span class="comment"># 单独设置硬限制</span></span><br><span class="line">$ <span class="built_in">ulimit</span> -H -n 4096</span><br></pre></td></tr></table></figure>

<p>使用 <code>ulimit</code> 命令可以修改资源的限制，但是当用户注销后会失效。如果想永久生效，则需要修改 <code>/etc/security/limits.conf</code> 文件。  </p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在 bash 中定义变量不需要指明变量的类型，每个变量的值都是字符串，即使在赋值时没有使用引号，它们也会被视为字符串。当然，在实际解释执行的过程中，如果需要进行算术运算，则会自动将值转化为整数（bash 不支持浮点类型的运算，除非借助于第三方工具）。</p>
<h2 id="变量声明及赋值"><a href="#变量声明及赋值" class="headerlink" title="变量声明及赋值"></a>变量声明及赋值</h2><p>变量命名时只能使用字母、数字和下划线，首字符不能以数字开头，同时不能使用 bash 里的关键字，比如：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义变量 your_name</span></span><br><span class="line">your_name=<span class="string">&quot;Alice&quot;</span></span><br><span class="line">your_name=Alice</span><br><span class="line">your_name=<span class="string">&#x27;Alice&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="变量的测试与替换"><a href="#变量的测试与替换" class="headerlink" title="变量的测试与替换"></a>变量的测试与替换</h2><p>有时候我们需要判断某个变量是否存在，并根据判断的结果进行选择性地赋值。  </p>
<table>
<thead>
<tr>
<th>参数设置表达式</th>
<th>str 没有设置</th>
<th>str 为空字符串</th>
<th>str 为非空字符串</th>
</tr>
</thead>
<tbody><tr>
<td>var&#x3D;${str-expr}</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:-expr}</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str+expr}</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;${str:+expr}</td>
<td>var&#x3D;</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;${str&#x3D;expr}</td>
<td>str&#x3D;expr, var&#x3D;expr</td>
<td>str 不变, var&#x3D;</td>
<td>str 不变, var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:&#x3D;expr}</td>
<td>str&#x3D;expr, var&#x3D;expr</td>
<td>str&#x3D;expr, var&#x3D;expr</td>
<td>str 不变, var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str?expr}</td>
<td>expr 输出至 stderr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:?expr}</td>
<td>expr 输出至 stderr</td>
<td>expr 输出至 stderr</td>
<td>var&#x3D;$str</td>
</tr>
</tbody></table>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加上 <code>$</code> 符号即可。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&quot;Saber&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure>

<p>变量名外可以不使用花括号，加上花括号是为了帮助解释器识别变量的边界，比如：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Java;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$&#123;skill&#125;</span>Script&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 <code>readonly</code> 命令可以将变量定义为只读的，只读变量的值不能被修改。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myUrl=<span class="string">&quot;https://nekolr.com&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line"><span class="comment"># 或者直接定义</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl=<span class="string">&quot;https://nekolr.com&quot;</span></span><br><span class="line"><span class="comment"># 或者使用 declare 命令来声明变量</span></span><br><span class="line"><span class="built_in">declare</span> -r myUrl=<span class="string">&quot;https://nekolr.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用 <code>unset</code> 命令可以删除变量，已经删除的变量无法再次使用，该命令无法删除只读变量。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myUrl=<span class="string">&quot;https://nekolr.com&quot;</span></span><br><span class="line"><span class="built_in">unset</span> myUrl</span><br><span class="line"><span class="comment"># 不会有任何输出</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$myUrl</span></span><br></pre></td></tr></table></figure>

<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>bash 中的变量根据作用范围划分共有三种，包括局部变量、全局变量和环境变量。  </p>
<ul>
<li>局部变量，只能在函数内部有效。使用 <code>local</code> 命令定义局部变量，该命令只能在函数中使用。如果在函数中没有使用该命令定义变量，那么变量会如同在 JavaScript 里没有使用 <code>var</code> 定义变量一样是全局变量。</li>
<li>全局变量，在当前 shell 进程中都可以使用，一般在 shell 中定义的变量，默认都是全局变量。</li>
<li>环境变量，可以在当前进程或者子进程中使用。</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>全局变量只能在当前 shell 进程中使用，如果使用 <code>export</code> 命令将它导出，那么它就可以在所有的子进程中使用了，这时它也就变成了环境变量。  </p>
<p>当登录 Linux 并取得一个 bash 之后，该 bash 就作为一个独立的进程存在。接下来在这个 bash 底下所下达的任何命令都会执行成为这个 bash 的子程序。<strong>子程序会继承父程序的环境变量，但是不会继承父程序的自定义变量。</strong>  </p>
<blockquote>
<p>需要注意的是，在父 shell 中创建的环境变量可以在所有的子程序中使用，但是如果使用终端创建一个新的 shell，那么它就不是当前 shell 的子进程，当前 shell 的环境变量对它也就无效了。  </p>
</blockquote>
<p>我们可以使用 <code>env</code> 命令查看当前 shell 环境下的所有环境变量，比如以下就是常见的环境变量。  </p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>HOME</td>
<td>表示用户的根目录。当我们使用 <code>cd</code> 或者 <code>cd ~</code> 命令时，取用的就是这个变量。</td>
</tr>
<tr>
<td>SHELL</td>
<td>表示当前 shell 环境使用的是什么 shell 程序，比如 Linux 默认使用的是 <code>/bin/bash</code>。</td>
</tr>
<tr>
<td>MAIL</td>
<td>当我们使用 mail 这个命令收信时，系统会去读取的邮件信箱文件。</td>
</tr>
<tr>
<td>PATH</td>
<td>运行文件时搜寻的路径，目录与目录中间以冒号分隔。</td>
</tr>
<tr>
<td>LANG</td>
<td>表示系统使用的语言。一般默认是 <code>en_US.UTF-8</code></td>
</tr>
</tbody></table>
<p>通过 <code>export 变量名</code> 的形式导出的是临时环境变量，当 shell 会话注销后会失效。如果想永久生效，一种是对当前用户永久生效，这种需要在当前的用户目录下的 <code>.bash_profile</code> 文件中新增变量并导出。另一种是对所有用户永久生效，这种则需要在 <code>/etc/profile</code> 文件中新增变量并导出。最后再使用 <code>source 文件名</code> 的方式通知当前 shell 读取并执行修改后的文件，使配置立即生效。  </p>
<h2 id="bash-操作接口有关的变量"><a href="#bash-操作接口有关的变量" class="headerlink" title="bash 操作接口有关的变量"></a>bash 操作接口有关的变量</h2><p>bash 中不光有环境变量，还有一些与 bash 操作接口有关的变量，以及用户自定义的变量，这些变量可以使用 <code>set</code> 命令查看，其中有几个比较重要的变量。  </p>
<p><strong><code>PS1</code></strong>，当我们每次按下 [Enter] 按键去运行某个命令后，最后要再次出现提示字符时，就会主动去读取这个变量值。每个 distributions 的 bash 默认的 PS1 变量内容可能有些许的差异。举例来说，CentOS 下 PS1 的值为：<code>&#39;[\u@\h \W]\$ &#39;</code>，对应的命令提示符可能为：<code>[root@VM_59_13_centos ~]</code>，具体可以通过 <code>man bash</code> 命令查找这些符号的说明。  </p>
<p><strong><code>$</code></strong> 代表的是当前这个 shell 的进程号，亦即是所谓的 PID (Process ID)。使用 <code>echo $$</code> 命令可以查看当前 shell 的 PID。  </p>
<p><strong><code>?</code></strong> 代表的是上一个运行的命令所回传的值。当我们运行某些命令时，这些命令都会回传一个运行后的代码。一般来说，如果成功的运行该命令，则会回传一个 0 值；如果运行过程发生错误，就会回传错误代码，一般以非为 0 的数值表示，比如：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ehco <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>当前脚本的文件名。</td>
</tr>
<tr>
<td><code>$n</code> (n≥1)</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>传递给脚本或函数的所有参数。当变量被双引号包含时，$@ 与 $* 稍有不同。比如传递了 3 个参数，那么对于 <code>&quot;$*&quot;</code> 来说，这 3 个参数会合并到一起形成一份数据，它们之间是无法分割的；而对于 <code>&quot;$@&quot;</code> 来说，这 3 个参数是相互独立的，它们是 3 份数据。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>上个命令的退出状态，或函数的返回值。0 表示没有错误，其他任何值表示有错误。</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前 Shell 进程 ID。对于 Shell 脚本来说就是这些脚本所在的进程 ID。</td>
</tr>
</tbody></table>
<p>使用一个例子说明这些参数。编写脚本，并保存为 <code>test.sh</code>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Process ID: $$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;File Name: <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;First Parameter: <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Second Parameter: <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 1: <span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 2: $*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total: <span class="variable">$#</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来运行该脚本。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x ./test.sh</span><br><span class="line">$ ./test.sh Java Python</span><br><span class="line">Process ID: 18235</span><br><span class="line">File Name: ./test.sh</span><br><span class="line">First Parameter: Java</span><br><span class="line">Second Parameter: Python</span><br><span class="line">All parameters 1: Java Python</span><br><span class="line">All parameters 2: Java Python</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Shell 中的字符串可以用单引号或者是双引号表示，但是这两种方式是有区别的。  </p>
<p>使用单引号字符串，字符串里的内容都会原样输出，在里面使用变量是无效的；而使用双引号，则可以在里面使用变量，同时也支持转义。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="comment"># 会原样输出</span></span><br><span class="line">str=<span class="string">&#x27;$&#123;str&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 能够使用变量，并且支持转义</span></span><br><span class="line">str2=<span class="string">&quot;Hello, I kown your name is <span class="variable">$&#123;your_name&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># Hello, I kown your name is &quot;Alice&quot;</span></span><br><span class="line">str3=<span class="string">&quot;Hello, I kown your name is \&quot;<span class="variable">$&#123;your_name&#125;</span>\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">str=<span class="string">&quot;Hello, &quot;</span><span class="variable">$&#123;your_name&#125;</span><span class="string">&quot;!&quot;</span></span><br><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">str2=<span class="string">&#x27;Hello, &#x27;</span><span class="variable">$&#123;your_name&#125;</span><span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&quot;Alice&quot;</span></span><br><span class="line"><span class="comment"># 长度为 5</span></span><br><span class="line"><span class="variable">$&#123;#your_name&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><p>具体的格式为：<code>$&#123;string: start: length&#125;</code>。这里需要注意的是，有从左或者从右两种计数方式，如果从左计数，则从 0 开始；如果从右开始计数，则从 1 开始。不管从左还是从右计数，截取始终是从左向右。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&quot;Alice&quot;</span></span><br><span class="line"><span class="comment"># 截取的子串为 lice</span></span><br><span class="line"><span class="variable">$&#123;your_name: 1: 4&#125;</span></span><br><span class="line"><span class="comment"># 从右向左计数，取倒数第二个字符一直截取到末尾</span></span><br><span class="line"><span class="variable">$&#123;your_name: -2&#125;</span></span><br><span class="line"><span class="comment"># 等同于 $&#123;your_name: -2&#125;</span></span><br><span class="line"><span class="variable">$&#123;your_name: -2: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>复杂的，还可以根据指定的子串进行截取。  </p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>${变量#关键词}</td>
<td>若变量内容从头开始的数据符合关键词，则将符合的最短数据删除</td>
</tr>
<tr>
<td>${变量##关键词}</td>
<td>若变量内容从头开始的数据符合关键词，则将符合的最长数据删除</td>
</tr>
<tr>
<td>${变量%关键词}</td>
<td>若变量内容从尾向前的数据符合关键词，则将符合的最短数据删除</td>
</tr>
<tr>
<td>${变量%%关键词}</td>
<td>若变量内容从尾向前的数据符合关键词，则将符合的最长数据删除</td>
</tr>
<tr>
<td>${变量&#x2F;旧字符串&#x2F;新字符串}</td>
<td>若变量内容中包含旧字符串，则变量中第一个旧字符串会被新字符串取代</td>
</tr>
<tr>
<td>${变量&#x2F;&#x2F;旧字符串&#x2F;新字符串}</td>
<td>若变量内容中包含旧字符串，则变量中全部的旧字符串会被新字符串取代</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">url=<span class="string">&quot;https://nekolr.com&quot;</span></span><br><span class="line"><span class="comment"># 截取的字符串为 //nekolr.com</span></span><br><span class="line"><span class="variable">$&#123;url#*:&#125;</span></span><br><span class="line"><span class="comment"># 截取的字符串为 /nekolr.com</span></span><br><span class="line"><span class="variable">$&#123;url#https:/&#125;</span></span><br><span class="line"><span class="comment"># 因为没有从第一个字符开始匹配，所以截取的字符串为 https://nekolr.com</span></span><br><span class="line"><span class="variable">$&#123;url#/&#125;</span></span><br><span class="line"><span class="comment"># 如果希望直到最后一个指定的子串再匹配结束，那么可以使用 `##`。  </span></span><br><span class="line">str=<span class="string">&quot;aBa@@--&quot;</span></span><br><span class="line"><span class="comment"># 截取的字符串为 @@--</span></span><br><span class="line"><span class="variable">$&#123;str##*a&#125;</span></span><br><span class="line"><span class="comment"># 截取的字符串为 https://nekolr.</span></span><br><span class="line"><span class="variable">$&#123;url%com*&#125;</span></span><br><span class="line"><span class="comment"># 将 path 变量内容的 sbin 取代成大写</span></span><br><span class="line"><span class="comment"># /usr/local/SBIN:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br><span class="line"><span class="variable">$&#123;path/sbin/SBIN&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"><span class="comment"># 小写转大写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name^^&#125;</span></span><br><span class="line"><span class="comment"># 大写转小写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name,,&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>bash 支持一维数组，但不支持多维数组，数组的大小没有限制。  </p>
<h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr=(<span class="string">&quot;Java&quot;</span> <span class="string">&quot;Python&quot;</span> <span class="string">&quot;Ruby&quot;</span> <span class="string">&quot;Go&quot;</span>)</span><br><span class="line"><span class="comment"># shell 是弱类型的，不要求元素类型必须都相同</span></span><br><span class="line">arr=(12 <span class="string">&quot;Java&quot;</span> <span class="string">&quot;Go&quot;</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">arr[0]=<span class="string">&quot;Java&quot;</span></span><br><span class="line">arr[1]=<span class="string">&quot;Python&quot;</span></span><br><span class="line">arr[2]=<span class="string">&quot;Ruby&quot;</span></span><br><span class="line">arr[3]=<span class="string">&quot;Go&quot;</span></span><br></pre></td></tr></table></figure>

<p>定义数组无需给每个元素赋值，可以只给特定位置的元素赋值。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组的长度为 3</span></span><br><span class="line">arr=([3]=24 [5]=19 [11]=33)</span><br></pre></td></tr></table></figure>

<h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr=(<span class="string">&quot;Java&quot;</span> <span class="string">&quot;Python&quot;</span> <span class="string">&quot;Ruby&quot;</span> <span class="string">&quot;Go&quot;</span>)</span><br><span class="line"><span class="comment"># 获取第一个元素</span></span><br><span class="line"><span class="variable">$&#123;arr[0]&#125;</span></span><br><span class="line"><span class="comment"># 获取所有的元素</span></span><br><span class="line"><span class="variable">$&#123;arr[@]&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>获取数组长度的方法与获取字符串长度的方法一样。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr=([3]=<span class="string">&quot;Java&quot;</span> [5]=19 [11]=33)</span><br><span class="line"><span class="comment"># 获取数组元素的个数</span></span><br><span class="line">len=<span class="variable">$&#123;#arr[@]&#125;</span></span><br><span class="line"><span class="comment"># 获取数组元素的个数</span></span><br><span class="line">len=<span class="variable">$&#123;#arr[*]&#125;</span></span><br><span class="line"><span class="comment"># 获取某个元素的长度</span></span><br><span class="line">length=<span class="variable">$&#123;#arr[3]&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h2><p>在 shell 中使用 <code>unset</code> 删除数组元素。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr=([3]=<span class="string">&quot;Java&quot;</span> [5]=19 [11]=33)</span><br><span class="line"><span class="comment"># 删除下标为 3 的元素</span></span><br><span class="line"><span class="built_in">unset</span> arr[3]</span><br><span class="line"><span class="comment"># 删除整个数组</span></span><br><span class="line"><span class="built_in">unset</span> arr</span><br></pre></td></tr></table></figure>
<h2 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr1=(23 55)</span><br><span class="line">arr2=(99 <span class="string">&quot;Java&quot;</span> <span class="string">&quot;Python&quot;</span>)</span><br><span class="line">arr_new=(<span class="variable">$&#123;arr1[@]&#125;</span> <span class="variable">$&#123;arr2[*]&#125;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="变量宣告"><a href="#变量宣告" class="headerlink" title="变量宣告"></a>变量宣告</h1><p>bash 中的变量默认都是字符串类型，如果需要非字符串类型的变量，就需要通过 <code>declare</code> 或 <code>typeset</code> 命令进行变量宣告，即声明变量的类型。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义数组</span></span><br><span class="line">$ <span class="built_in">declare</span> -a arr=(1 2 3)</span><br><span class="line"><span class="comment"># 定义整数类型</span></span><br><span class="line">$ <span class="built_in">declare</span> -i <span class="built_in">sum</span>=100+200+300</span><br><span class="line"><span class="comment"># 定义为只读类型</span></span><br><span class="line">$ <span class="built_in">declare</span> -r url=<span class="string">&quot;https://nekolr.com&quot;</span></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line">$ <span class="built_in">declare</span> -x <span class="built_in">sum</span></span><br><span class="line"><span class="comment"># 单独列出变量的类型</span></span><br><span class="line">$ <span class="built_in">declare</span> -p <span class="built_in">sum</span></span><br><span class="line"><span class="comment"># 使用 + 号可以进行取消动作，这里取消作为环境变量</span></span><br><span class="line">$ <span class="built_in">declare</span> +x <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<h1 id="键盘读取"><a href="#键盘读取" class="headerlink" title="键盘读取"></a>键盘读取</h1><p>使用 <code>read</code> 命令能够读取键盘输入的内容。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数 p 后面跟着提示信息</span></span><br><span class="line">$ <span class="built_in">read</span> -p <span class="string">&quot;请输入用户名：&quot;</span></span><br><span class="line"><span class="comment"># 读取输入的字符，并将值赋给 v1 变量</span></span><br><span class="line">$ <span class="built_in">read</span> v1</span><br><span class="line"><span class="comment"># 读取指定个数的字符，字符数目足够后自动返回并赋值</span></span><br><span class="line">$ <span class="built_in">read</span> -n 1 v1</span><br><span class="line"><span class="comment"># 关闭回显，可以用在输入密码时</span></span><br><span class="line">$ <span class="built_in">read</span> -s -p <span class="string">&quot;Enter your password:&quot;</span> pass</span><br><span class="line"><span class="comment"># 等待 5 秒后退出</span></span><br><span class="line">$ <span class="built_in">read</span> -t 5 -p <span class="string">&quot;Please enter your name:&quot;</span> name</span><br></pre></td></tr></table></figure>

<h1 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h1><p>数据流重导向就是将某个命令执行后要出现在屏幕上的数据（standard output 和 standard error output）传输到其他地方，例如：文件、打印机等。  </p>
<h2 id="标准输入和输出"><a href="#标准输入和输出" class="headerlink" title="标准输入和输出"></a>标准输入和输出</h2><table>
<thead>
<tr>
<th>名称</th>
<th>代码</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入（stdin）</td>
<td>0</td>
<td>使用 <code>&lt;</code> 或 <code>0&lt;</code> 覆盖，<code>&lt;&lt;</code> 或 <code>0&lt;&lt;</code> 追加。</td>
</tr>
<tr>
<td>标准输出（stdout）</td>
<td>1</td>
<td>使用 <code>&gt;</code> 或 <code>1&gt;</code> 覆盖，<code>&gt;&gt;</code> 或 <code>1&gt;&gt;</code> 追加。</td>
</tr>
<tr>
<td>标准错误输出（stderr）</td>
<td>2</td>
<td>使用 <code>2&gt;</code> 覆盖，<code>2&gt;&gt;</code> 追加。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用一般用户账号搜寻 /home 底下是否有 .bashrc 文件</span></span><br><span class="line"><span class="comment"># 如果没有权限会有错误输出，将 stdout 和 stderr 分开存放到不同的文件</span></span><br><span class="line">$ find /home -name .bashrc &gt; list_right 2&gt; list_error</span><br><span class="line"><span class="comment"># 将数据全部写入同一个文件</span></span><br><span class="line">$ find /home -name .bashrc &gt; list 2&gt;&amp;1</span><br><span class="line">$ find /home -name .bashrc &amp;&gt; list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先演示如何使用 cat 创建文件</span></span><br><span class="line"><span class="comment"># 使用该命令后，通过键盘输入内容，按 ctrl + d 结束</span></span><br><span class="line">$ <span class="built_in">cat</span> &gt; catfile</span><br><span class="line"><span class="comment"># 使用该命令后，通过键盘输入内容，当键盘输入 eof 后会自动结束</span></span><br><span class="line">$ <span class="built_in">cat</span> &gt; catfile &lt;&lt; <span class="string">&quot;eof&quot;</span></span><br><span class="line"><span class="comment"># 使用文件内容取代键盘输入</span></span><br><span class="line">$ <span class="built_in">cat</span> &gt; catfile &lt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，<code>cmd &gt; file 2&gt;&amp;1</code> 中的 <code>&amp;</code> 表示重定向的目标不是某个文件，而是一个<strong>文件描述符</strong>，换句话说就是 <code>2&gt;&amp;1</code> 表示将 stderr 重定向到文件描述符为 1 的文件（即 &#x2F;dev&#x2F;stdout，这个文件就是 stdout 在文件系统中的映射）中，而 <code>&amp;&gt; file</code> 是另一种写法。  </p>
<h2 id="垃圾桶"><a href="#垃圾桶" class="headerlink" title="垃圾桶"></a>垃圾桶</h2><p>如果提前知道有错误信息会输出，想要将错误信息忽略掉或者不存储时，可以使用 <code>/dev/null</code> 文件。该文件是一个特殊的文件，写入到它的内容都会被丢弃，如果尝试读取它的内容，那么什么也读不到。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将错误的数据丢弃，屏幕只会显示正确的信息</span></span><br><span class="line">$ find /home -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure>

<h1 id="命令运行的判断依据"><a href="#命令运行的判断依据" class="headerlink" title="命令运行的判断依据"></a>命令运行的判断依据</h1><p>很多时候我们想要一次运行很多条命令，除了使用 shell 脚本，另一种方式就是使用多重命令。  </p>
<p>在不用考虑命令的相关性时，连续下达命令。使用 <code>cmd;cmd</code> 的形式，比如：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在关机前执行两次同步写入磁盘</span></span><br><span class="line">$ <span class="built_in">sync</span> ; <span class="built_in">sync</span> ; shutdown -h now</span><br></pre></td></tr></table></figure>

<p>如果一个命令的运行需要另一个命令先执行，则可以使用 <code>cmd &amp;&amp; cmd</code> 或者 <code>cmd || cmd</code> 的形式下达命令。  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>cmd1 &amp;&amp; cmd2</td>
<td>如果 cmd1 运行完毕且正确执行（命令回传 <code>$?</code> 的值为 0），则执行 cmd2；否则不执行 cmd2</td>
</tr>
<tr>
<td>cmd1 &#124;&#124; cmd2</td>
<td>如果 cmd1 运行完毕且正确执行，则 cmd2 不执行；否则执行 cmd2</td>
</tr>
</tbody></table>
<h1 id="管线命令"><a href="#管线命令" class="headerlink" title="管线命令"></a>管线命令</h1><p>如果命令输出的内容必须经过处理才能得到我们想要的格式，那么此时就需要用到管线命令（pipe）。需要注意的是，管线命令与连续下达命令是不一样的。  </p>
<p>管线命令使用的是 <code>|</code> 这个界定符号，它只能处理前面的命令传递过来的 stdout。每个管线后面的第一个数据必定是命令，而且这个命令必须能够接受 stdin 的数据。比如：<code>less</code>、<code>more</code>、<code>head</code>、<code>tail</code> 等命令可以接受 stdin 的数据，而 <code>ls</code>、<code>cp</code>、<code>mv</code> 等就不是管线命令了。  </p>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p><code>cut</code> 命令主要用来切割文件内容。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数 d 代表的是分隔符，参数 f 代表的当使用分隔符切割后的第几段</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 3,4</span><br><span class="line">/usr/local/bin:/usr/sbin</span><br><span class="line"><span class="comment"># 取出第 10 个字符以后所有的字符串</span></span><br><span class="line">$ <span class="built_in">export</span> | <span class="built_in">cut</span> -c 10-</span><br></pre></td></tr></table></figure>

<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><code>grep</code> 命令主要用来筛选匹配的数据。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据关键字筛选</span></span><br><span class="line">$ netstat -tunlp | grep java</span><br><span class="line"><span class="comment"># 反向选择，选出不包含关键字的内容</span></span><br><span class="line">$ netstat -tunlp | grep -v java</span><br><span class="line"><span class="comment"># 取出 /etc/man.config 文件内容中包含 MANPATH 的那几行</span></span><br><span class="line">$ grep --color=auto MANPATH /etc/man.config</span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><code>sort</code> 命令主要用来对数据进行排序。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按字典顺序排序</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span></span><br><span class="line"><span class="comment"># /etc/passwd 的内容都是以 : 分隔的，如何以第三栏排序</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t <span class="string">&quot;:&quot;</span> -k 3</span><br></pre></td></tr></table></figure>

<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p><code>uniq</code> 命令主要用来去重。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排序完成后，将重复的数据仅显示一份</span></span><br><span class="line">$ last | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"><span class="comment"># 在上面的基础上计数</span></span><br><span class="line">$ last | <span class="built_in">cut</span> -d <span class="string">&quot;&quot;</span> -f 1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>

<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p><code>wc</code> 命令主要用来统计文件的行数、字符数等信息。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出文件中有多少行、多少字（英文单字）、多少字符</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/man.config | <span class="built_in">wc</span></span><br><span class="line"><span class="comment"># 仅列出行</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/man.config | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment"># 仅列出单字</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/man.config | <span class="built_in">wc</span> -w</span><br><span class="line"><span class="comment"># 仅列出字符</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/man.config | <span class="built_in">wc</span> -m</span><br></pre></td></tr></table></figure>

<h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><p><code>tee</code> 命令会同时将数据流发送到文件和屏幕，而输出到屏幕的，其实就是 stdout，因此后面可以继续使用管线命令。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 last 命令的输出保存一份到文件中</span></span><br><span class="line">$ last | <span class="built_in">tee</span> last.list | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 1</span><br><span class="line"><span class="comment"># 以累加的方式输出</span></span><br><span class="line">$ last | <span class="built_in">tee</span> -a last.list | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 1</span><br></pre></td></tr></table></figure>

<h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p><code>tr</code> 命令可以用来删除或替换一段数据中的某些内容。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将所有内容小写转大写</span></span><br><span class="line">$ last | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br><span class="line"><span class="comment"># 删除所有的冒号</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/passwd | <span class="built_in">tr</span> -d <span class="string">&quot;:&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="col"><a href="#col" class="headerlink" title="col"></a>col</h2><p><code>col</code> 命令可以用来将内容中的 Tab 转换为对等的空格。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件中的 Tab 转换为空格</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/man.config | col -x | <span class="built_in">cat</span> -A | more</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/24744565">DOS 系统和 Windows 系统有什么关系？</a>  </p>
</blockquote>
<blockquote>
<p>《鸟哥的Linux私房菜》</p>
</blockquote>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro RESTful 化改造</title>
    <url>/2019/01/29/Shiro%20RESTful%20%E5%8C%96%E6%94%B9%E9%80%A0/</url>
    <content><![CDATA[<p>实际上 Shiro 是支持 RESTful 风格的权限校验的，默认提供的 <code>HttpMethodPermissionFilter</code> 过滤器可以将 HTTP 请求的方法转化为相应的动词，并使用该动词构造对应的权限。  </p>
<span id="more"></span>  

<p>在使用该过滤器时，默认情况下一个 <code>/api/user/123</code> 的 GET 请求将被映射为 <code>user:read</code> 权限，然后通过 <code>Subject.isPermitted(&quot;user:read&quot;)</code> 来校验用户是否具有该权限。而一个 <code>/api/user</code> 的 POST 请求将被映射为 <code>user:create</code> 权限来进行校验。  </p>
<p>这里有一个 ini 配置文件，在 urls 中配置使用了 RESTful 风格的过滤器。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line"></span><br><span class="line">[users]</span><br><span class="line"># 用户名 = 密码, 角色1, 角色2,...</span><br><span class="line">saber = saber, employee</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line"># 角色 = 权限1, 权限2,...</span><br><span class="line">admin = *</span><br><span class="line">employee = user:read:*</span><br><span class="line"></span><br><span class="line">[urls]</span><br><span class="line"># 所有的 /user/** 请求都经过 RESTful 风格的过滤器，映射成对应的权限后校验</span><br><span class="line">/user/** = rest[user]</span><br></pre></td></tr></table></figure>

<p>使用上述配置，在 saber 用户登录后，通过 GET 方法访问 <code>/user/123</code> 是可以通过的；而使用其他方法访问 <code>/user</code> 则会返回错误码 401。  </p>
<p>其实总的来看，Shiro 默认的过滤器已经能够满足基本的需求了，但是缺点是不够灵活，所以对其进行改造。在改造之前，先简单研究一下 Shiro 的设计。  </p>
<h1 id="Shiro-架构"><a href="#Shiro-架构" class="headerlink" title="Shiro 架构"></a>Shiro 架构</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/rzG.png" alt="Shiro 架构">  </p>
<ul>
<li><strong>Subject</strong><br>主体，代表当前用户。这个主体不一定是一个人，和当前应用交互的都是主体。在使用 Shiro 的过程中更多的是与 Subject 交互，所有的 Subject 都绑定到 Security Manager 中，与 Subject 的交互最终都会由 Security Manager 来执行。  </li>
<li><strong>SecurityManager</strong><br>安全管理器，是 Shiro 架构的核心，协调绑定在其上的所有的 Subject 和其它组件的工作。有点类似 Spring MVC 的 DispatcherServlet 前端控制器。  </li>
<li><strong>Authenticator</strong><br>身份认证器，负责用户登录的一个组件。当用户尝试登录时，Authenticator 知道如何协调一个或多个存储用户相关信息的 Realm（域），从这些 Realms 获取数据来验证用户身份。如果默认的 Authenticator 不能满足需求则可以自定义实现。如果配置了多个 Realm，则需要设置<strong>认证策略（Authentication Strategy）</strong>，即何种情况算作认证通过，如：必须所有的域都成功，只有一个成功等等。  </li>
<li><strong>Authorizer</strong><br>授权器，负责用户权限控制的一个组件。和 Authenticator 一样，Authorizer 知道如何协调一个或多个后端数据源来访问角色和权限信息，Authorizer 根据这些信息来确定用户是否具有该权限。  </li>
<li><strong>SessionManager</strong><br>会话管理器，负责创建和管理用户会话的生命周期。默认情况下，Shiro 将使用现有的会话机制，比如 Servlet 容器默认的会话机制，如果没有提供 Web&#x2F;Servlet 或 EJB 容器，Shiro 也可以使用其内置的会话管理。  </li>
<li><strong>SessionDAO</strong><br>Session 持久化，使用它可以进行 Session 的 CRUD，可以将 Session 持久化到关系型或非关系型数据库中，我们只要实现对应的 SessionDAO 即可，同时还可以使用缓存来提高效率。  </li>
<li><strong>Realm</strong><br>域，允许有一个或多个域。可以把它看做是连接 Shiro 与安全数据（用户、角色、权限等）之间的“桥”或“连接器”，它封装了连接数据源的细节，Shiro 通过它们来获取安全数据，这些安全数据源可以是关系型数据库（JDBC）、LDAP、文本配置（INI 或属性文件等）等。<strong>Shiro 不会去维护用户角色、权限，需要我们提供实现后通过相应的接口注入给 Shiro</strong>。  </li>
<li><strong>CacheManager</strong><br>缓存管理，由于 Shiro 抽象了 Realm 这个概念，类似数据源，因此可以通过缓存这些域来提高效率，几乎所有的现代开源或企业级缓存产品都能够使用到 Shiro 中来。  </li>
<li><strong>Cryptography</strong><br>密码模块，提供了简单易用的加密和解密组件。</li>
</ul>
<h1 id="入口分析"><a href="#入口分析" class="headerlink" title="入口分析"></a>入口分析</h1><p>常见的使用 Shiro 的应用有三种。第一种就是普通的应用程序，不使用 Web 容器。第二种就是使用 Web 容器提供服务的应用，通过 Shiro 的过滤器实现用户的身份认证、权限校验等。最后一种就是在第二种的基础上集成了 Spring 容器。  </p>
<p>首先观察第一种应用使用 Shiro 的例子。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(App.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 SecurityManager 工厂类，加载 ini 配置文件</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> <span class="title class_">IniSecurityManagerFactory</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 SecurityManager 实例</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> factory.getInstance();</span><br><span class="line">        <span class="comment">// 设置一次即可</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 获取 Subject</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 创建 Token</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;saber&quot;</span>, <span class="string">&quot;saber&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!subject.isAuthenticated()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行登录</span></span><br><span class="line">                subject.login(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">                <span class="comment">// 账号不存在，给用户返回一个提示</span></span><br><span class="line">                log.info(<span class="string">&quot;账号：&quot;</span> + token.getPrincipal() + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">                <span class="comment">// 错误的密码，给用户返回一个提示</span></span><br><span class="line">                log.info(<span class="string">&quot;账号：&quot;</span> + token.getPrincipal() + <span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">                <span class="comment">// 账号被锁定，给用户返回一个提示</span></span><br><span class="line">                log.info(<span class="string">&quot;账号：&quot;</span> + token.getPrincipal() + <span class="string">&quot;被锁定&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;其他错误&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;账号：&quot;</span> + subject.getPrincipal() + <span class="string">&quot; 登录成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Session 测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> subject.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;someKey&quot;</span>, <span class="string">&quot;aValue&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;someKey&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">&quot;aValue&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Session 值正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 角色测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (subject.hasRole(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;具有 admin 角色&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;不具有 admin 角色&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 权限测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (subject.isPermitted(<span class="string">&quot;user:read&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;具有查看的权限&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;不具有查看的权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要使用 Web 容器的应用中，一般会在 <code>web.xml</code> 中配置监听器和过滤器。我们知道，在 Servlet 容器启动的过程中，会先调用 Listener 的初始化方法，然后调用 Filter 的初始化方法。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.apache.shiro.web.env.EnvironmentLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroEnvironmentClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.apache.shiro.web.env.IniWebEnvironment<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>shiroConfigLocations<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:shiro-web.ini<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.shiro.web.servlet.ShiroFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>INCLUDE<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，在调用监听器的初始化方法时会创建一个 <code>WebEnvironment</code> 放入 <code>ServletContext</code> 的全局属性中，它封装了 Shiro 运行时所需要的所有对象，比如 <code>SecurityManager</code>、<code>FilterChainResolver</code> 等。在 Web 容器启动时，<code>ShiroFilter</code> 的初始化方法中会从 Web 容器上下文的全局属性中获取 <code>WebEnvironment</code>，并将 <code>SecurityManager</code> 等值注入到过滤器中备用。  </p>
<p>在集成了 Spring 之后，就需要将 Shiro 纳入容器管理。Spring 提供了 <code>DelegatingFilterProxy</code> 类，它的作用就是代理 Filter。简单来说，它就是一个过滤器，因为它实现了 Filter 接口。在 web.xml 中配置它之后，就可以在 Web 容器启动时执行它的初始化方法，在初始化方法中会从 Spring 容器中寻找它代理的过滤器，然后注入到 <code>delegate</code> 属性中。同时它实现了 <code>DisposableBean</code> 接口，因此在需要销毁时，会调用 destroy 方法完成销毁。这样 Spring 就可以通过它间接管理过滤器的生命周期。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 applicationContext.xml 中配置的 shiroFilter 是 <code>ShiroFilterFactoryBean</code>。我们知道，FactoryBean 是一种特殊的 bean，通过 getBean 方法从容器中获取实例时，其实获取到的是该实例的 getObject 方法返回的对象。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;shiroFilter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;realm&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myRealm&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifecycleBeanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在查看了 <code>ShiroFilterFactoryBean</code> 后会发现，它的 getObject 方法里会创建 <code>PathMatchingFilterChainResolver</code>，而它并不能满足我们的需求，因此都需要重写。首先重写 <code>PathMatchingFilterChainResolver</code> 的 getChain 方法，我们约定配置的过滤链的 path 应包含请求路径和请求方法，格式为 <code>uri==httpMethod</code>，比如 <code>/user/nekolr==GET</code>。只有请求路径和请求方法同时匹配，才会认为真正匹配，并将请求交由过滤器处理。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestPathMatchingFilterChainResolver</span> <span class="keyword">extends</span> <span class="title class_">PathMatchingFilterChainResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FilterChain <span class="title function_">getChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain originalChain)</span> &#123;</span><br><span class="line">        <span class="type">FilterChainManager</span> <span class="variable">filterChainManager</span> <span class="operator">=</span> getFilterChainManager();</span><br><span class="line">        <span class="keyword">if</span> (!filterChainManager.hasChains()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> getPathWithinApplication(request);</span><br><span class="line">        <span class="type">boolean</span> isMatch;</span><br><span class="line">        Iterator&lt;String&gt; iterator = filterChainManager.getChainNames().iterator();</span><br><span class="line">        String pathPattern;</span><br><span class="line">        String[] strings;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pathPattern = iterator.next();</span><br><span class="line">            strings = pathPattern.split(<span class="string">&quot;==&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (strings.length == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 比较 HTTP METHOD 是否一致，不一致就不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (WebUtils.toHttp(request).getMethod().toUpperCase().equals(strings[<span class="number">1</span>].toUpperCase())) &#123;</span><br><span class="line">                    isMatch = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    isMatch = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isMatch = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新赋值</span></span><br><span class="line">            pathPattern = strings[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">while</span> (!<span class="built_in">this</span>.pathMatches(pathPattern, requestURI) || !isMatch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Matched path pattern [&quot;</span> + pathPattern + <span class="string">&quot;] for requestURI [&quot;</span> + requestURI + <span class="string">&quot;].  &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Utilizing corresponding filter chain...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (strings.length == <span class="number">2</span>) &#123;</span><br><span class="line">            pathPattern = pathPattern.concat(<span class="string">&quot;==&quot;</span>).concat(WebUtils.toHttp(request).getMethod().toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filterChainManager.proxy(originalChain, pathPattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestShiroFilterFactoryBean</span> <span class="keyword">extends</span> <span class="title class_">ShiroFilterFactoryBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractShiroFilter <span class="title function_">createInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Creating Shiro Filter instance.&quot;</span>);</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="built_in">this</span>.getSecurityManager();</span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">if</span> (securityManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            msg = <span class="string">&quot;SecurityManager property must be set.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(securityManager <span class="keyword">instanceof</span> WebSecurityManager)) &#123;</span><br><span class="line">            msg = <span class="string">&quot;The security manager does not implement the WebSecurityManager interface.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">FilterChainManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="built_in">this</span>.createFilterChainManager();</span><br><span class="line">            <span class="comment">// RestPathMatchingFilterChainResolver</span></span><br><span class="line">            <span class="type">RestPathMatchingFilterChainResolver</span> <span class="variable">chainResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestPathMatchingFilterChainResolver</span>();</span><br><span class="line">            chainResolver.setFilterChainManager(manager);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestShiroFilterFactoryBean</span>.SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SpringShiroFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractShiroFilter</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">SpringShiroFilter</span><span class="params">(WebSecurityManager webSecurityManager, FilterChainResolver resolver)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (webSecurityManager == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;WebSecurityManager property cannot be null.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setSecurityManager(webSecurityManager);</span><br><span class="line">                <span class="keyword">if</span> (resolver != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.setFilterChainResolver(resolver);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 启动及自动配置</title>
    <url>/2017/07/22/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E5%8F%8A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>本文分析使用的 Spring Boot 版本为 Spring Boot 2.1.18.RELEASE</p>
</blockquote>
<p>一个简单的 Spring Boot 启动类：  </p>
<span id="more"></span>  

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@SpringBootApplication</code> 主要包含 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 三个注解，能够实现自动配置的是 <code>@EnableAutoConfiguration</code> 注解。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">  Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">  String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 框架提供了许多以 @Enable 开头的注解，比如 <code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableMBeanExport</code> 等，<code>@EnableAutoConfiguration</code> 的理念和做事方式其实一脉相承，简单概括一下就是，借助 <code>@Import</code> 的支持，收集和注册特定场景相关的 bean。<code>@EnableAutoConfiguration</code> 就是通过 <code>@Import</code> 的帮助，将所有符合自动配置条件的 bean 加载到 IoC 容器中的。</p>
<p>Spring 对于 <code>@Import</code> 注解的处理是在 ConfigurationClassPostProcessor 类的 postProcessBeanFactory 方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">factoryId</span> <span class="operator">=</span> System.identityHashCode(beanFactory);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">        <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">    <span class="comment">// 处理所有的配置类 BeanDefinition</span></span><br><span class="line">    processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  enhanceConfigurationClasses(beanFactory);</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ImportAwareBeanPostProcessor</span>(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 BeanDefinition 在容器初始化阶段就注册了，但是有些 BeanDefinition 可能是配置类，因此需要解析这些配置类（配置类可能包含其他的 BeanDefinition）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">  List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 从 registry 获取所有的 BeanDefinition</span></span><br><span class="line">  String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">  <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// 检查是否是配置类</span></span><br><span class="line">    <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">        ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是一个配置类，并为 BeanDefinition 设置属性为 lite 或者 full，方便后续的使用</span></span><br><span class="line">    <span class="comment">// 如果使用了 @Configuration 注解则设置属性为 full</span></span><br><span class="line">    <span class="comment">// 如果使用了 @Bean、@Component、@ComponentScan、@Import、@ImportResource 注解，则设置属性为 lite</span></span><br><span class="line">    <span class="comment">// 如果使用了 @Order 注解，则为 BeanDefinition 设置 order 属性值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">      <span class="comment">// 将该配置类 Holder 添加到 configCandidates</span></span><br><span class="line">      configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有发现任何配置类，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据 order 排序</span></span><br><span class="line">  configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">  <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">    sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">      <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">      <span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">        <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析每个配置类</span></span><br><span class="line">  <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">      <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">      <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line">  <span class="comment">// 将所有的配置类放入候选集合中</span></span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">  <span class="comment">// 已经解析过的配置类</span></span><br><span class="line">  Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 解析配置类</span></span><br><span class="line">    parser.parse(candidates);</span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    parser.validate();</span><br><span class="line">    <span class="comment">// 获取所有解析过的配置类</span></span><br><span class="line">    Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">    configClasses.removeAll(alreadyParsed);</span><br><span class="line">    <span class="comment">// 创建 BeanDefinitionReader</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">          registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">          <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将完全填充好的 ConfigurationClass 实例转化成 BeanDefinition 注册到容器</span></span><br><span class="line">    <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">    alreadyParsed.addAll(configClasses);</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line">  <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">  <span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">    sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">    ((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会筛选出容器中所有的配置类 BeanDefinition，然后解析它们。最终所有的 BeanDefinition 都能被注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.context.annotation.ConfigurationClassParser</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">        parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(<span class="meta">@Nullable</span> String className, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  Assert.notNull(className, <span class="string">&quot;No bean class name for configuration class bean definition&quot;</span>);</span><br><span class="line">  <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="built_in">this</span>.metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">  processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(reader, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Class&lt;?&gt; clazz, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(clazz, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是根据不同类型的 BeanDefinition 使用不同的解析方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 根据条件注解判断是否跳过解析过程</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">  <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">        existingClass.mergeImportedBy(configClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 删除旧的，在下面替换成新的</span></span><br><span class="line">      <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">      <span class="built_in">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归处理配置类及其超类</span></span><br><span class="line">  <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 将处理后的配置类放入</span></span><br><span class="line">  <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Process any @Import annotations</span></span><br><span class="line">  processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">    Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ImportSelector</span></span><br><span class="line">        <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">          Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">          <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">          ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">              selector, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">          <span class="comment">// 如果是 DeferredImportSelector</span></span><br><span class="line">          <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">            <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 不是的话就调用 selectImports 方法</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">            Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">            processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，如果导入的是一个 ImportSelector，那么会调用它的 selectImports 方法获取更多需要导入到容器的类。由于 AutoConfigurationImportSelector 是一个 DeferredImportSelector，这里会执行 handle 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.context.annotation.ConfigurationClassParser$DeferredImportSelectorHandler</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DeferredImportSelectorHandler</span> &#123;</span><br><span class="line">  <span class="comment">// deferredImportSelectors 在类创建时就会初始化</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;DeferredImportSelectorHolder&gt; deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(ConfigurationClass configClass, DeferredImportSelector importSelector)</span> &#123;</span><br><span class="line">    <span class="type">DeferredImportSelectorHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorHolder</span>(configClass, importSelector);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.deferredImportSelectors == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">DeferredImportSelectorGroupingHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorGroupingHandler</span>();</span><br><span class="line">      handler.register(holder);</span><br><span class="line">      handler.processGroupImports();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次调用时会走这里</span></span><br><span class="line">      <span class="built_in">this</span>.deferredImportSelectors.add(holder);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一次调用该方法时，deferredImportSelectors 已经初始化，因此只将 DeferredImportSelectorHolder 放入其中。在回到 parse 方法时，则会调用 deferredImportSelectorHandler 的 process 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.context.annotation.ConfigurationClassParser$DeferredImportSelectorHandler</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="built_in">this</span>.deferredImportSelectors;</span><br><span class="line">  <span class="comment">// 置为 null</span></span><br><span class="line">  <span class="built_in">this</span>.deferredImportSelectors = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (deferredImports != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 DeferredImportSelectorGroupingHandler</span></span><br><span class="line">      <span class="type">DeferredImportSelectorGroupingHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorGroupingHandler</span>();</span><br><span class="line">      deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);</span><br><span class="line">      <span class="comment">// 对每个 DeferredImportSelectorHolder 执行 register 方法，将它们添加到对应的分组中</span></span><br><span class="line">      deferredImports.forEach(handler::register);</span><br><span class="line">      <span class="comment">// 处理每个分组</span></span><br><span class="line">      handler.processGroupImports();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(DeferredImportSelectorHolder deferredImport)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取 deferredImport 对应的分组</span></span><br><span class="line">  <span class="comment">// 目前只会返回 AutoConfigurationImportSelector$AutoConfigurationGroup.class</span></span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">Group</span>&gt; group = deferredImport.getImportSelector().getImportGroup();</span><br><span class="line">  <span class="comment">// 创建 DeferredImportSelectorGrouping，createGroup 方法将实例化这个 Group 类型</span></span><br><span class="line">  <span class="type">DeferredImportSelectorGrouping</span> <span class="variable">grouping</span> <span class="operator">=</span> <span class="built_in">this</span>.groupings.computeIfAbsent(</span><br><span class="line">      (group != <span class="literal">null</span> ? group : deferredImport),</span><br><span class="line">      key -&gt; <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorGrouping</span>(createGroup(group)));</span><br><span class="line">  <span class="comment">// 将 deferredImport 也放入其中</span></span><br><span class="line">  grouping.add(deferredImport);</span><br><span class="line">  <span class="built_in">this</span>.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">      deferredImport.getConfigurationClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeferredImportSelectorGrouping 的结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DeferredImportSelectorGrouping</span> &#123;</span><br><span class="line">  <span class="comment">// 分组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DeferredImportSelector.Group group;</span><br><span class="line">  <span class="comment">// 分组下的 DeferredImportSelector 集合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  DeferredImportSelectorGrouping(Group group) &#123;</span><br><span class="line">    <span class="built_in">this</span>.group = group;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(DeferredImportSelectorHolder deferredImport)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deferredImports.add(deferredImport);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="built_in">this</span>.deferredImports) &#123;</span><br><span class="line">      <span class="comment">// 先调用 Group 的 process 方法</span></span><br><span class="line">      <span class="built_in">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">          deferredImport.getImportSelector());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再调用 Group 的 selectImports 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.group.selectImports();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 5 中，DeferredImportSelector 接口新增了一个内部接口 Group，这个接口的作用是对 ImportSelector 进行分组。register 方法的作用是将每个 DeferredImportSelector 存放到它对应的分组之中。在该方法中，首先调用 getImportGroup 拿到 Group 类型的类，然后通过 createGroup 方法实例化这个类，最后通过这个 Group 实例构建一个 DeferredImportSelectorGrouping 并放入 <code>this.groupings</code> 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processGroupImports</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (DeferredImportSelectorGrouping grouping : <span class="built_in">this</span>.groupings.values()) &#123;</span><br><span class="line">    grouping.getImports().forEach(entry -&gt; &#123;</span><br><span class="line">      <span class="type">ConfigurationClass</span> <span class="variable">configurationClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(entry.getMetadata());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        processImports(configurationClass, asSourceClass(configurationClass),</span><br><span class="line">            asSourceClasses(entry.getImportClassName()), <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">                configurationClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来调用 processGroupImports 方法。在该方法中会遍历所有的分组，每个分组分别执行对应的 process 方法和 selectImports 方法。selectImports 方法能够获取到所有经过处理的自动配置类集合，最后遍历这个集合并通过一开始我们就提到过的 processImports 方法逐个解析配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationGroup</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>.Group, BeanClassLoaderAware, BeanFactoryAware, ResourceLoaderAware &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> &#123;</span><br><span class="line">    <span class="comment">// 确定是 AutoConfigurationImportSelector 类型</span></span><br><span class="line">    Assert.state(deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">        () -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">            AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">            deferredImportSelector.getClass().getName()));</span><br><span class="line">    <span class="comment">// 调用 getAutoConfigurationEntry 方法获取要引入的配置实体（包含所有处理过的自动配置类）</span></span><br><span class="line">    <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">        .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);</span><br><span class="line">    <span class="comment">// 放入自动配置实体集合中</span></span><br><span class="line">    <span class="built_in">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">    <span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Entry&gt; <span class="title function_">selectImports</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.autoConfigurationEntries.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要排除的配置</span></span><br><span class="line">    Set&lt;String&gt; allExclusions = <span class="built_in">this</span>.autoConfigurationEntries.stream()</span><br><span class="line">        .map(AutoConfigurationEntry::getExclusions).flatMap(Collection::stream).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">// 处理过的自动配置类</span></span><br><span class="line">    Set&lt;String&gt; processedConfigurations = <span class="built_in">this</span>.autoConfigurationEntries.stream()</span><br><span class="line">        .map(AutoConfigurationEntry::getConfigurations).flatMap(Collection::stream)</span><br><span class="line">        .collect(Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">// 排除</span></span><br><span class="line">    processedConfigurations.removeAll(allExclusions);</span><br><span class="line">    <span class="comment">// 返回排序过的配置</span></span><br><span class="line">    <span class="keyword">return</span> sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream()</span><br><span class="line">        .map((importClassName) -&gt; <span class="keyword">new</span> <span class="title class_">Entry</span>(<span class="built_in">this</span>.entries.get(importClassName), importClassName))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 process 方法中会调用 getAutoConfigurationEntry 方法获取要引入的配置实体（包含所有处理过的自动配置类）。getAutoConfigurationMetadata 方法的作用是从 <code>META-INF\spring-autoconfigure-metadata.properties</code> 文件中获取自动配置的元数据。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只列出了部分内容</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration.ConditionalOnClass</span>=<span class="string">com.google.gson.Gson</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration.AutoConfigureOrder</span>=<span class="string">-2147483638</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.freemarker.FreeMarkerServletWebConfiguration.ConditionalOnClass</span>=<span class="string">javax.servlet.Servlet,org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration.ConditionalOnClass</span>=<span class="string">javax.servlet.Servlet,org.springframework.web.servlet.config.annotation.WebMvcConfigurer,org.springframework.web.servlet.DispatcherServlet</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">        AutoConfigurationMetadata autoConfigurationMetadata,</span></span><br><span class="line"><span class="params">        AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 EnableAutoConfiguration 注解的属性（exclude、excludeName）</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取所有自动配置类的全限定名集合</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">            attributes);</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 应用 exclusion 属性排除</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// 根据自动配置元数据来过滤</span></span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// 现在已经找到所有需要被应用的候选配置类，广播事件 AutoConfigurationImportEvent</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 构建 AutoConfigurationEntry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法总的来说是对所有已知的自动配置类进行处理和筛选。</p>
<p>getCandidateConfigurations 方法使用了内部工具类 SpringFactoriesLoader 查找 classpath 下所有 jar 包中的 <code>META-INF\spring.factories</code> 文件，读取文件中 key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 的所有配置类的全限定名，保存到集合中。下面是 spring-boot-autoconfigure.jar 包中 <code>spring.factories</code> 文件的内容。   </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="attr">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Auto Configuration Import Listeners</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.AutoConfigurationImportListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Auto Configuration Import Filters</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string"># 以下内容过长，省略之</span></span><br></pre></td></tr></table></figure>

<h1 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h1><p>要启动 Spring Boot，一个常见的方式就是在 main 方法中调用 SpringApplication 的 run 方法，其中 primarySource 参数可以理解为带有 BeanDefinition 信息的类。一般我们会将带有 <code>@SpringBootApplication</code> 注解的类作为 primarySource，同时为了方便，也直接在该类中创建 main 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.boot.SpringApplication</span></span><br><span class="line"><span class="comment">*   <span class="doctag">@param</span> primarySource the primary bean source</span></span><br><span class="line"><span class="comment">*   <span class="doctag">@param</span> args the application arguments（通常是 main 方法的参数）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">  <span class="comment">// 通过尝试加载不同 Web application 的代表性类来确认当前的 Web 环境，比如 Servlet、Reactive</span></span><br><span class="line">  <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">  <span class="comment">// 从 META-INF/spring.factories 中获取所有的 ApplicationContextInitializer 并进行实例化，保存到 initializers 属性中</span></span><br><span class="line">  setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">  <span class="comment">// 从 META-INF/spring.factories 中获取所有的 ApplicationListener 并进行实例化，保存到 listeners 属性中</span></span><br><span class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  <span class="comment">// 根据方法调用的堆栈找到调用 main 方法的类</span></span><br><span class="line">  <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个名为 run 的类方法实际上创建了一个 SpringApplication 实例，然后再调用该实例的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.boot.SpringApplication</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">  <span class="comment">// 主要用来计算启动用时</span></span><br><span class="line">  <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="comment">// 容器上下文</span></span><br><span class="line">  <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 错误汇报机制</span></span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 设置 Headless 模式</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  <span class="comment">// 从 META-INF/spring.factories 中获取所有的 SpringApplicationRunListener 并传入 args 进行实例化</span></span><br><span class="line">  <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">  <span class="comment">// 执行所有 SpringApplicationRunListener 的 starting 方法</span></span><br><span class="line">  listeners.starting();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">    <span class="comment">// 准备 Environment</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">    <span class="comment">// 跳过对自定义 BeanInfo 的搜索</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line">    <span class="comment">// Banner 的处理</span></span><br><span class="line">    <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">    <span class="comment">// 创建容器上下文，在 Servlet 环境下创建的是 AnnotationConfigServletWebServerApplicationContext</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    <span class="comment">// 从 META-INF/spring.factories 中获取所有的 SpringBootExceptionReporter 并传入 context 进行实例化</span></span><br><span class="line">    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">    <span class="comment">// 容器上下文的准备工作</span></span><br><span class="line">    prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">    <span class="comment">// 刷新容器，最终执行的是 AbstractApplicationContext 的 refresh 方法，同时还会注册 shutdownHook</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line">    <span class="comment">// 空方法，可以由子类实现</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    <span class="comment">// 启动结束，计算用时</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="comment">// 日志处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行所有 SpringApplicationRunListener 的 started 方法</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line">    <span class="comment">// 执行所有 ApplicationRunner 和 CommandLineRunner 的 run 方法</span></span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行所有 SpringApplicationRunListener 的 running 方法</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中的逻辑比较清晰，但是有些逻辑并不是我们要重点关注的，这里只捡着重点的说。在容器上下文创建之前，Spring Boot 会通过 SpringFactoriesLoader 从 <code>META-INF/spring.factories</code> 中加载所有的 SpringApplicationRunListener，目前该接口只有一种官方实现：EventPublishingRunListener，它的作用是在容器启动的各个阶段调用对应的方法来广播对应的容器事件。</p>
<p>Spring Boot 在创建容器上下文时，会根据当前的环境（比如 Servlet、Reactive）来创建对应的容器上下文，在 Servlet 环境下创建的容器上下文为：<code>AnnotationConfigServletWebServerApplicationContext</code>。接着需要调用 prepareContext 方法来执行上下文的一些准备工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.boot.SpringApplication</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="line"><span class="params">    SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;</span><br><span class="line">  <span class="comment">// 设置 Environment</span></span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  <span class="comment">// 后置处理，注册 beanNameGenerator，设置 resourceLoader 等</span></span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  <span class="comment">// 执行所有 initializer 的 initialize 方法</span></span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  <span class="comment">// 执行所有 listener 的 contextPrepared 方法</span></span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  <span class="comment">// 启动日志的处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">    logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加几个单例 bean</span></span><br><span class="line">  <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">  <span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) &#123;</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">        .setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 加载 sources（primarySources 和 sources）</span></span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">  load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">  <span class="comment">// 执行所有 listener 的 contextLoaded 方法</span></span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.boot.SpringApplication</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建 BeanDefinitionLoader</span></span><br><span class="line">  <span class="type">BeanDefinitionLoader</span> <span class="variable">loader</span> <span class="operator">=</span> createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.beanNameGenerator != <span class="literal">null</span>) &#123;</span><br><span class="line">    loader.setBeanNameGenerator(<span class="built_in">this</span>.beanNameGenerator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">    loader.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;</span><br><span class="line">    loader.setEnvironment(<span class="built_in">this</span>.environment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行 load 方法</span></span><br><span class="line">  loader.load();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) &#123;</span><br><span class="line">  Assert.notNull(registry, <span class="string">&quot;Registry must not be null&quot;</span>);</span><br><span class="line">  Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.sources = sources;</span><br><span class="line">  <span class="comment">// 初始化了一个 AnnotatedBeanDefinitionReader</span></span><br><span class="line">  <span class="built_in">this</span>.annotatedReader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(registry);</span><br><span class="line">  <span class="comment">// 初始化了一个 XmlBeanDefinitionReader</span></span><br><span class="line">  <span class="built_in">this</span>.xmlReader = <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(registry);</span><br><span class="line">  <span class="keyword">if</span> (isGroovyPresent()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.groovyReader = <span class="keyword">new</span> <span class="title class_">GroovyBeanDefinitionReader</span>(registry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化了一个 ClassPathBeanDefinitionScanner</span></span><br><span class="line">  <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(registry);</span><br><span class="line">  <span class="built_in">this</span>.scanner.addExcludeFilter(<span class="keyword">new</span> <span class="title class_">ClassExcludeFilter</span>(sources));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.boot.BeanDefinitionLoader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Object source : <span class="built_in">this</span>.sources) &#123;</span><br><span class="line">    count += load(source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">load</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">  Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">  <span class="comment">// source 是 Class，使用 AnnotatedBeanDefinitionReader 加载 BeanDefinition</span></span><br><span class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> load((Class&lt;?&gt;) source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// source 是 Resource，使用 XmlBeanDefinitionReader 加载 BeanDefinition</span></span><br><span class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource) &#123;</span><br><span class="line">    <span class="keyword">return</span> load((Resource) source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// source 是 Package，使用 ClassPathBeanDefinitionScanner 扫描</span></span><br><span class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package) &#123;</span><br><span class="line">    <span class="keyword">return</span> load((Package) source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// source 是字符串，解析字符串，然后尝试使用多种方式来处理</span></span><br><span class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">    <span class="keyword">return</span> load((CharSequence) source);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid source type &quot;</span> + source.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">load</span><span class="params">(Class&lt;?&gt; source)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123;</span><br><span class="line">    <span class="comment">// Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here</span></span><br><span class="line">    <span class="type">GroovyBeanDefinitionSource</span> <span class="variable">loader</span> <span class="operator">=</span> BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">    load(loader);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注解中是否包含 Component 注解（Configuration 注解也算）</span></span><br><span class="line">  <span class="keyword">if</span> (isComponent(source)) &#123;</span><br><span class="line">    <span class="comment">// 将 source 作为 BeanDefinition 注册到容器中</span></span><br><span class="line">    <span class="built_in">this</span>.annotatedReader.register(source);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备工作结束以后，需要执行 refreshContext 方法。在该方法中，实际执行的是 AbstractApplicationContext 的 refresh 方法，与此同时还会注册 shutdownHook。其余的工作由于不是重点，这里不再详细说明。</p>
<h1 id="main-方法不退出的秘密"><a href="#main-方法不退出的秘密" class="headerlink" title="main 方法不退出的秘密"></a>main 方法不退出的秘密</h1><p>也许你会好奇，在 main 方法执行完毕之后，Spring Boot 为什么没有退出呢？我们知道，使用 <code>System.exit()</code> 或 <code>Runtime.exit()</code> 可以使当前 JVM 进程退出。而另一个会导致 JVM 进程退出的原因是所有的非 daemon 线程完全终止，如果根据这个条件反推的话，只要保证 Spring Boot 进程中包含至少一个非 daemon 线程一直运行，就可以保证程序不会退出。</p>
<p>通过跟踪代码可以发现，在调用 refresh 方法时，会调用一个叫做 onRefresh 的方法，该方法是一个空方法，由子类实现。由于在 Servlet 环境下创建的容器上下文是：<code>AnnotationConfigServletWebServerApplicationContext</code>，实际实现 onRefresh 方法的是它的父类：<code>ServletWebServerApplicationContext</code>。在该类中，onRefresh 方法会创建一个 WebServer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onRefresh();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    createWebServer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这个 WebServer 也就是 Tomcat，这里最终会调用 TomcatWebServer 的 initialize 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class="literal">false</span>));</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.monitor) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addInstanceIdToEngineName();</span><br><span class="line">      <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> findContext();</span><br><span class="line">      context.addLifecycleListener((event) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">          <span class="comment">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class="line">          <span class="comment">// happen when the service is started.</span></span><br><span class="line">          removeServiceConnectors();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// Start the server to trigger initialization listeners</span></span><br><span class="line">      <span class="built_in">this</span>.tomcat.start();</span><br><span class="line">      <span class="comment">// We can re-throw failure exception directly in the main thread</span></span><br><span class="line">      rethrowDeferredStartupExceptions();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line">        <span class="comment">// Naming is not enabled. Continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class="line">      <span class="comment">// blocking non-daemon to stop immediate shutdown</span></span><br><span class="line">      startDaemonAwaitThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      stopSilently();</span><br><span class="line">      destroySilently();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WebServerException</span>(<span class="string">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startDaemonAwaitThread</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">awaitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;container-&quot;</span> + (containerCounter.get())) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      TomcatWebServer.<span class="built_in">this</span>.tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  awaitThread.setContextClassLoader(getClass().getClassLoader());</span><br><span class="line">  awaitThread.setDaemon(<span class="literal">false</span>);</span><br><span class="line">  awaitThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 initialize 方法中，调用了一个名为 <code>startDaemonAwaitThread</code> 的方法，从方法的注释可以看出：与 Jetty 这些容器不同，Tomcat 的所有线程都是守护线程。所以该方法创建了一个非 daemon 的线程，这个线程会一直检测 stopAwait 变量，在这个变量值为 false 时会直接休眠（调用 <code>Thread.sleep(10000)</code> 方法）。只有在 Tomcat 收到终止运行的信号时，该变量的值才会改变，在该线程从休眠中苏醒时会检测变量并结束运行。由于 JVM 进程中所有的非 daemon 线程都结束了运行，此时 JVM 进程也会退出。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 概述</title>
    <url>/2020/03/10/Spring%20Cloud%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>Spring Cloud 其实就是一个全家桶，建立在 Spring Boot 之上，是微服务系统架构的一站式解决方案，覆盖了微服务的各个核心组件，其中很多组件都是 Netflix 家的。Spring Cloud 的版本号是以英国伦敦地铁站的名字命名的，同时按照字典顺序对应版本的时间顺序，最早的 Release 版本为 Angel，最新的 Release 版本为 Hoxton。</p>
<span id="more"></span>

<h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><p><a href="https://github.com/Netflix/eureka">Eureka</a> 是 Netflix 开发的服务注册与发现组件，它是一个基于 REST 的服务，主要用于运行在 AWS 中以云定位为目的中间层服务器的负载均衡和故障转移。Spring Cloud 将它集成到了 Spring Cloud Netflix 项目中，用于 Spring Cloud 服务注册与发现功能的其中一种解决方案（还可以使用 Consul、Etcd、Zookeeper 等作为服务注册中心）。</p>
<blockquote>
<p>由于 Eureka 2.x 孵化失败，因此官方不再对 Eureka 开发新的功能，项目转为维护状态。</p>
</blockquote>
<p>Eureka 主要包含两大组件：Eureka Server 和 Eureka Client。其中 Eureka Server 主要提供服务注册与发现的功能，Eureka Server 之间通过复制的方式完成服务注册表的同步，形成 Eureka 的高可用。Eureka Client 是客户端程序，主要用于简化与 Eureka Server 的交互，同时它还内置了一个使用轮询算法的负载均衡器。在使用了 Eureka Client 的应用启动后，它会周期性地（默认为 30 秒）向 Eureka Server 发送心跳请求以完成续约（Renew），而 Eureka Server 则会定期（默认为 60 秒）执行一次失效服务检测，检查超过一定时间（默认为 90 秒）没有续约的服务并将该服务从服务注册列表中剔除。与此同时，Eureka Client 还会缓存 Eureka Server 中的信息，即使所有的 Eureka Server 节点都宕机，服务消费者仍可以使用缓存找到服务提供者。</p>
<p>Eureka Client 可以分为两种角色，分别是 Application Service（即服务提供者）和 Application Client（即服务消费者）。Application Service 作为服务的提供者，会将自身提供的服务注册到 Eureka Server 中，而 Application Client 作为服务的消费者，会通过 Eureka Server 发现服务并进行消费。需要注意的是，服务提供者和服务消费者并不是绝对的，因为服务提供者在提供服务的同时也可以作为服务消费者进行消费，同理服务消费者也可以对外提供服务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003102049/2020/03/10/Jrn.png" alt="Eureka 架构"></p>
<h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><p>在 Spring Cloud 中，服务都是以 HTTP 接口的形式暴露的，因此在调用远程服务的时侯就必须使用 HTTP 客户端。常用的 HTTP 客户端除了 JDK 原生提供的 URLConnection，还有一些第三方的库，比如 Apache HttpClient、OkHttp、RestTemplate 等等。我们接下来要说的就是这个 RestTemplate，它是 Spring 提供的用于进行 HTTP 请求的模板类，在 Spring 框架下位于 spring-web 模块中，在 Spring Boot 框架下则位于 spring-boot-starter-web 模块中。下面列举一个使用 RestTemplate 的小例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="comment">// 如果使用了 Eureka，此处就应该是服务提供者的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">PROVIDER_URL</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> PROVIDER_URL + <span class="string">&quot;/order&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, Order.class, order).getStatus() == OrderStatus.COMPLETE.getCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在使用了 RestTemplate 之后，调用 HTTP 服务就变得更加简单优雅了，但是我们还不能满足，原因是每次调用远程服务的时候，我们都需要提供服务名称和发起请求等这样的样板代码，这未免也太过繁琐了，我们能不能像在单个进程内调用服务那样直接调用呢？答案是可以的，这就引出了 <a href="https://github.com/OpenFeign/feign">Feign</a> 这个框架。Feign 是一个轻量级的 Java HTTP 请求调用的框架，它可以以声明式（接口注解）的方式调用 HTTP 请求，通过处理注解将请求模板化，当实际调用时传入参数，进而转化成真正的请求。Feign 有自己的声明式规范，同时也支持 JAX-RS 1&#x2F;2 规范，而 Spring 官方为了使其适配 Spring 自己的注解规范，也就是 Spring Web MVC 的注解规范，又开发了 <a href="https://github.com/spring-cloud/spring-cloud-openfeign">spring-cloud-openfeign</a>。下面列举一个使用 Feign 的小例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;eureka-client-order-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/order&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    Order <span class="title function_">getOrder</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> orderService.getOrder(order).getStatus() == OrderStatus.COMPLETE.getCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h1><p>说起负载均衡，不得不说一下集中式的（服务端）负载均衡和进程内的（客户端）负载均衡，这两种都是业界主流的负载均衡方案，区别在于：集中式的负载均衡是在服务消费者和服务提供者之间的独立的负载均衡设备，它可以是硬件（比如 F5），也可以是软件（比如 Nginx），它负责将消费者的请求通过某种负载均衡策略转发给服务提供者；而进程内的负载均衡是将负载均衡集成到了服务消费者中，消费者从注册中心获取到所有可用的服务地址，然后经过某种负载均衡算法选出一个合适的服务地址发起请求。客户端的负载均衡更适合在微服务中进行远程服务调用时作为本地的负载均衡使用，而像 Nginx 这种集中式的负载均衡设备则更适合服务端实现负载均衡，比如一个 Tomcat 集群，使用 Nginx 作为前端的负载均衡和流量入口。</p>
<p><a href="https://github.com/Netflix/ribbon">Ribbon</a> 就是一个由 Netflix 开发的客户端负载均衡组件，它会优先选择在同一个 Zone 并且负载较少的 Eureka Server，然后从该注册中心获取服务注册列表并缓存到本地，待客户端进行 HTTP 请求调用时，默认使用轮询的算法从服务注册列表中选取一个服务地址进行请求。如果单独使用 Ribbon 进行服务调用，则需要使用 HTTP 客户端（比如 RestTemplate）来构建请求，比较繁琐，而 Feign 其实内置了 Ribbon，所以一般我们会直接使用 Feign。</p>
<h1 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h1><p>实际上，微服务之间的调用不可能都是简单的一对一调用，更多时候是复杂的一对多，甚至层层调用，形成一条复杂的调用链，这种情况下如果某个服务出现问题，很容易就会造成整个应用出现问题，这也就是我们常说的<strong>服务雪崩</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003111808/2020/03/11/WvW.png" alt="服务雪崩"></p>
<p>如上图所示，Service A 在某一时刻突然面临大量的请求调用，即便此时服务 A 扛住了请求，但是也不能保证 Service B 和 Service C 都能抗住。假设服务 C 扛不住挂掉了，那么服务 B 的请求就会阻塞，很快服务 B 的资源就会被耗尽，最终服务 B 也会变成不可用，同理，最终服务 A 也会变成不可用。在这个过程中，由于某个服务不可用而最终导致了整条链路上的服务都不可用，这就是服务雪崩。为了应对这个问题，就出现了服务熔断、服务降级、服务隔离（舱壁隔离 Bulkhead Isolation）等技术。</p>
<h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>服务熔断具体来说就是当下游的服务因为某些原因突然变得不可用或者响应缓慢时，上游服务为了保证自身以及整体服务的可用性，不再继续调用目标服务，而是直接返回，从而能够快速释放资源。如果目标服务情况好转，则会恢复调用。业内常用的熔断机制就是断路器模式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003111808/2020/03/11/LDR.png" alt="断路器模式"></p>
<p>上图是 Martin Fowler 提出的断路器状态转换图，在最开始时断路器处于 closed 状态，当错误达到一定的阈值后，便转换为 open 状态，这时会有一个重置的超时时间，一旦到了这个时间，断路器就会变成半开状态并尝试放行一部分的请求，一旦请求成功，断路器就会变成一开始的关闭状态。</p>
<p>目前比较常见的熔断器有：大名鼎鼎的 Netflix 家的 <a href="https://github.com/Netflix/Hystrix">Hystrix</a>，只不过与 Eureka 一样，项目处于维护阶段。还有阿里开源的 <a href="https://github.com/alibaba/Sentinel">Sentinel</a> 和 Hystrix 官方推荐的 <a href="https://github.com/resilience4j/resilience4j">Resilience4J</a>。</p>
<p>在使用 Hystrix 时，可以通过 <code>@HystrixCommand</code> 注解来标注某个方法，这样该方法就会被 Hystrix 以 AOP 的方式包裹起来，每当该方法的调用时间超过指定的时间时，断路器就会中断该方法的调用。但是中断调用就会返回错误，一种更好的使用方式就是提供一个后备方法，在断路器起作用后转而去调用后备方法，从而为用户提供更加友好的响应信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getOrder&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;getOrderFallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8000/order&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, Order.class, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderFallback</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>需要注意的是，服务熔断和服务降级是两个不同的概念。有一种说法是，服务熔断是服务降级的其中一种方式，还有很多其他的服务降级方式，比如开关降级（又称为埋点）、限流降级等。当然这种说法也是合理的，但是我们可以更深入地探讨服务熔断与服务降级之间的异同。前几天，也就是 9 号那天，美股三大股指开盘大跌触发了熔断机制，上一次触发熔断还是在 1997 年。在股市中，当股指波动幅度达到某个点后，就会触发熔断，此时交易所为了控制风险就会暂停股市交易。与之类似的，软件系统中的熔断也是在某些服务出现问题时，为了避免整个系统故障而采取的一种保护措施。而服务降级有一个比较形象的生活小例子，就是出远门行李箱的例子。平常去不是很远的地方，可能一个小行李箱就足够了，但是如果出一趟远门，可能带的东西就比较多了，如果一股脑的把所有的东西都拿出来放在行李箱中，放不下，这个时候可能就需要把东西分分类，然后比来比去，最后忍痛将一些非必需品舍弃掉。服务降级就是这么一回事，在整个应用资源紧缺的时候，将一些不是特别重要的服务先关掉，待困难过去后再重新开启。</p>
<p>可以看到，其实服务熔断和服务降级的目的是一致的，都是从可用性的角度出发，为了防止整个系统出现问题而采取的一些措施，它们作用的粒度一般都是服务级别（也有更细粒度的，比如做到数据持久层，允许查询但不允许增删改等），最终都会造成用户体验上的一些缺失。当然它们还是有区别的，一般熔断是一个框架级的处理，即每个微服务都需要具有熔断机制，同时熔断一般都是基于策略自动触发的；而降级一般需要根据具体业务进行分析划分，降级一般先从最外围的服务开始，并且降级很多时候需要人工进行干预，当然完全靠人工是不可能的，服务开关、配置中心等都是必要的。</p>
<h2 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h2><p>服务隔离的思想来源于造船业中舱壁隔离的设计，将船体的内部空间划分为若干个舱室，舱室与舱室之间严密分开，这样即使出现意外导致船舱破损进水也不会影响整个船只的安全。</p>
<p>Hystrix 就是使用舱壁模式来实现的服务隔离，通过舱壁模式来隔离各个依赖服务之间的调用，同时限制对各个依赖服务的并发访问，从而使得各个依赖服务之间互不影响。Hystrix 具体提供了两种隔离方式，一种是线程池，另一种就是信号量，这两种也是目前比较主流的服务隔离的实现方式。</p>
<p>线程池的实现方式是将对各个依赖服务的调用交由独立的线程池来处理，Hystrix 会为每个依赖服务创建一个线程池，当某个服务出现问题时，该服务对应的线程池就会被迅速占满，服务调用方也就不会再去调用该服务了。线程池的实现方式虽然可以起到很好的隔离作用，但是也因此增加了计算开销，每个命令的执行都会涉及到排队（queueing）、调度（scheduling）和上下文切换（context switching）。而信号量的实现方式是为各个依赖服务设置信号量（或计数器）来限制并发调用，相当于对各个依赖服务做限流，信号量实现下的任务由当前的用户请求线程直接处理，不涉及线程的上下文切换，也没有了超时控制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003122221/2020/03/12/KPD.png" alt="线程池的实现方式"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003122221/2020/03/12/rpj.png" alt="线程池与信号量"></p>
<p>还有一种服务隔离的实现方式，这种实现方式是从用户的角度进行服务的隔离，这就是我们常说的<strong>多租户设计架构</strong>。一个用户我们可以理解为一个系统的使用者，而租户则是将所有的用户按照某种粒度划分到若干个组内，每个组就是该系统的一个租户（tenant）。组的划分粒度需要根据具体的业务场景来分析，比如根据用户是否付费的特征将用户划分为会员和非会员，那么就会产生会员组和非会员组。用户划分完毕后再进行服务隔离就非常简单了，此时的服务隔离也可以理解为用户隔离，划分后的组与组之间形成不同的服务实例，这样即使某个服务挂掉了，也只会影响该分组的用户，而不是所有的用户。</p>
<h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><p>假如我们开发了一个电商网站，这个网站涉及到了很多个微服务，比如商品服务、订单服务、支付服务等等，此时我们就会面临一个问题，即用户如何去访问这些微服务呢？举个例子，比如说用户在手机上看中了一款商品并进行了下单操作，此时我们的 APP 可能需要调用订单服务、会员服务、库存服务等等。如果我们的业务比较简单，完全可以直接调用各个服务的 API，但是这就会有一个问题，即服务的鉴权、限流、日志监控等等这些逻辑应该怎么做？我们总不能为每个服务都集成一遍这些逻辑吧？因此最理想的做法就是将这些公共的业务抽取出来，放到一个统一的地方去处理。抛开这些不谈，就说如果到了后期，我们的业务越来越复杂，需要的微服务也越来越多，可能我们使用客户端（浏览器或者移动应用）打开一个页面就涉及到上百个微服务的协同工作，如果这个时候还是使用客户端直接调用各个服务 API 的方式，一方面我们的客户端代码会变得很难维护，毕竟这可能会涉及到上百个服务的域名和地址，另一个方面也会造成客户端 HTTP 请求的连接数膨胀增多。除此之外，还有一个问题就是现在很多时候由于各方面的因素，我们的微服务可能是由不同的编程语言编写的，也有可能采用了不同的通信协议，比如 HTTP、Dubbo、Thrift 等，这个时候我们不可能要求客户端去适配这么多的协议，这会导致客户端变得更加复杂。</p>
<p>说了这么多，其实就是想说明为了解决以上种种问题，我们非常需要在客户端与微服务之间引入一个中间服务，这个服务就是我们常说的服务网关（API Gateway）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003132235/2020/03/13/gda.png" alt="服务网关"></p>
<p>目前常见的服务网关除了 Netflix 开发的 <a href="https://github.com/Netflix/zuul">Zuul</a>，还有 Spring Cloud 官方提供的 <a href="https://github.com/spring-cloud/spring-cloud-gateway">Spring Cloud Gateway</a>，以及一些基于 Nginx + Lua 二次开发的比如 <a href="https://github.com/openresty/openresty">OpenResty</a>、<a href="https://github.com/Kong/kong">Kong</a> 等。Zuul 的内部原理可以简单看作是很多不同功能的 filter 的集合。Zuul 1.x 中使用的是基于 Servlet 的同步 IO，2.x 的版本中引入了 Netty 来实现异步 IO，因此可以实现更高的性能。Spring Cloud Gateway 基于 Spring 5、Spring Boot 2.0 和 Project Reactor，发展的比 Zuul 2.x 要早，比 Zuul 2.x 更早地使用 Netty 实现了异步 IO，可以看作是 Zuul 1.x 的升级替代品。而像 OpenResty、Kong 这样的服务网关则既可以拥有 Nginx 处理 HTTP 的高性能，同时又通过 Lua 这种脚本语言获得了强大的动态扩展和处理能力，但是相对的可维护性较差，将来可能需要维护大量的 Lua 脚本。</p>
<blockquote>
<p>在很多时候，微服务项目中并不会选择使用 nginx 作为服务网关，因为微服务框架一般都是配套的，这样集成起来就比较容易。使用 Nginx + Lua 的方式虽然性能高、扩展性强，但是需要开发人员了解和维护 Lua 脚本，与直接使用 Spring Cloud 全家桶来说无疑成本更高。</p>
</blockquote>
<h1 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h1><p>当我们的微服务逐渐增多，那么多的 Consumer、Provider、Eureka Server、Zuul 等等都有自己的配置，如果这时我们想修改某些服务的配置，我们总不能挨个到这些服务下寻找配置并在修改完成后再重启服务吧？所以此时我们需要一种既能对所有服务的配置文件进行统一管理，又能在服务运行时动态修改服务配置的方法，这种方法就是使用配置中心。目前常见的配置中心有 Spring Cloud Config、Zookeeper、Consul、携程的 Apollo 以及阿里的 Nacos。</p>
<p>Spring Cloud Config 通过 Git 来管理各个服务的配置文件，这样就可以直接利用 Git 来实现配置的权限控制、版本控制和回滚等操作，但是由于 Git 客户端的限制，导致它在读写时性能较差。Spring Cloud Config 总体上可以分为两部分：Config Server 和 Config Client。其中 Config Server 作为配置中心的服务端，负责在客户端请求时从 Git 仓库拉取最新的配置，同时配合 Eureka 和 Spring Cloud Bus 实现服务发现和配置的推送更新。Config Client 则负责在服务需要配置时向服务端发起请求来获取配置，使用 Config Client 的服务几乎不需要修改任何代码，只要求加入一个启动配置文件指明使用 Config Server 上的哪个配置文件即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003141603/2020/03/14/Qrv.png" alt="Spring Cloud Config"></p>
<p>在进行了统一的配置管理之后，我们还需要考虑一个问题，那就是如何进行配置的更新。我们知道，服务中的配置一般会在服务启动时进行加载，如果我们在服务启动之后修改了 Git 仓库中某些服务的配置文件，我们该如何提醒这些服务配置发生了变动呢？不幸的是 Spring Cloud Config 原生不支持配置的实时推送，但是我们可以很容易地想到利用 Git 的 Webhooks 来实现当配置变动时触发相应的刷新操作。此时 Config Client 需要提供一个获取配置变更通知的接口，这样当 Git 仓库中的配置文件发生改变时，就会调用 Webhook 中配置的该接口，Config Client 在接收到该接口请求时就可以主动向 Config Server 请求获取新的配置了。</p>
<p>但是此时又出现了一个新的问题，即如果我们有多个微服务（也就是有多个 Config Client），那么每个服务都需要提供一个通知刷新配置的接口，这样 Webhooks 就会随着服务的增多而越来越难以维护。此时引入消息中间件就成了一个比较合适的选择，因为消息中间件可以将消息路由到一个或多个目的地。Spring Cloud Bus 就是这样的一个组件。</p>
<p>在下图中，我们有一个 Config Server 和微服务 Service A 的三个实例，这三个实例我们都引入了 Spring Cloud Bus，这样它们就都连接到了消息总线上。由于使用 Spring Cloud Bus 的服务都会对外提供一个 URI 为 <code>/bus/refresh</code> 的接口用于触发配置变更的通知。因此我们只需要在 Webhooks 中配置一个接口地址即可，这样当我们修改了配置文件之后就会调用该接口触发通知，然后这个消息事件就会被微服务中的其他两个实例从总线中获取到，然后它们就会主动从 Config Server 中获取最新的配置信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003141756/2020/03/14/OyQ.png" alt="某个服务承担配置刷新的职责"></p>
<p>上面的例子中，我们是通过向某个服务实例请求 <code>/bus/refresh</code> 接口的方式来触发总线上其他服务实例的配置刷新，但是在某些特殊场景下（比如灰度发布），我们希望只刷新微服务中的某个实例。此时我们只需要在 <code>/bus/refresh</code> 中添加 <code>destination</code> 参数即可指定具体的服务实例。也许你觉得到这里就大功告成了，但是其实这里还有优化的空间。与配置中心相比，服务实例产生变动的可能性相对较大。如果我们需要对服务实例进行迁移，那么我们可能不得不去修改 Webhooks 中的配置，因此我们要尽可能地让服务集群中各个节点是对等的，此时我们可以在 Config Server 中也引入 Spring Cloud Bus，然后在 Webhooks 中配置 Config Server 的刷新地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202003141756/2020/03/14/yPR.png" alt="配置中心的 Server 端承担配置刷新的职责"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.cnblogs.com/rjzheng/p/10340176.html">谈谈服务雪崩、降级与熔断</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/rjzheng/p/10360454.html">谈谈怎么做服务隔离</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务</title>
    <url>/2019/10/15/Spring%20%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>传统上，Java 开发人员使用事务有两种选择：本地事务和全局事务，这两种选择都有很大的局限性。</p>
<span id="more"></span>

<p>在全局事务中我们可以使用多个事务资源，比如数据库和消息队列。Web 服务器通过 JTA 管理全局事务，但是 JTA 的 API 异常繁琐，且它的 UserTransaction 需要通过 JNDI 产生，这意味着我们需要使用 JNDI 才能使用 JTA。在以前，使用全局事务的首选方法是 EJB CMT（容器管理的事务），CMT 使用声明式的事务管理，尽管使用 EJB 本身需要使用 JNDI，但是 EJB CMT 消除了与事务相关的 JNDI 的查找，并且消除了大多数需要手工编写来控制事务的代码。遗憾的是，CMT 与 JTA 和 Web 容器的环境捆绑在了一起，使用 CMT 就必须使用 JTA 和指定的容器环境。</p>
<p>而本地事务是特定于资源的，比如与 JDBC 连接绑定的事务。本地事务可能更易于使用，但是缺点也很明显：不能跨多个事务资源工作，比如使用 JDBC 连接管理事务的代码不能在全局 JTA 事务中运行；另一个缺点就是侵入了代码模型。</p>
<p>Spring 解决了全局事务和本地事务的弊端，它可以在不同的环境中使用一致的编程模型，只需要编写一次代码，就可以在不同的环境中使用不同的事务管理策略。</p>
<h1 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/10/15/pla.png" alt="核心接口"></p>
<h2 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h2><p>Spring 并不直接管理事务，而是提供了多种事务管理器，事务管理器将事务委托给具体的持久化相关平台框架（比如 Hibernate、JTA、JDBC 等）来完成。事务管理器的核心接口为 <code>PlatformTransactionManager</code>，所有的事务管理器都需要实现该接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过 TransactionDefinition 得到 TransactionStatus</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span><br><span class="line">			<span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事务提交</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事务回滚</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们直接使用 JDBC 来进行持久化，那么需要使用 <code>DataSourceTransactionManager</code> 来处理事务，可能的配置为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同理，如果使用 Hibernate，则需要使用 <code>HibernateTransactionManager</code> 来处理事务；如果使用 Java 持久化标准，也就是 JPA 的话，那么需要使用 <code>JpaTransactionManager</code> 来处理事务等等。</p>
<h1 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h1><p>TransactionDefinition 定义了一些事务的基本属性，具体来说包括：事务的传播行为、事务的隔离级别、事务的超时时间以及事务是否只读等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回事务的传播行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回事务的隔离级别</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回事务的超时时间，事务必须在超时时间内完成</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回事务是否只读</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2><p>当一个事务方法被另一个事务方法调用时，必须指定事务应该如何传播。比如：可能会在现有的事务中运行，也有可能重新开启一个新的事务。Spring 定义了七种事务的传播行为：</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>当前方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRED_NEW</td>
<td>当前方法必须运行在它自己的事务中，即总是会开启一个新的事务。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用 JTATransactionManager 的话，需要访问TransactionManager</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>当前方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用 JTATransactionManager 的话，则需要访问 TransactionManager</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>当前方法不应该运行在事务中。如果当前有一个事务在运行，则会抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与 PROPAGATION_REQUIRED 一样。<strong>各厂商对这种传播行为的支持是有所差异的。</strong></td>
</tr>
</tbody></table>
<p>下面针对各个传播行为进行具体分析。</p>
<h3 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a>PROPAGATION_REQUIRED</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">methodA() &#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">methodB() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Spring 的声明式事务注解，Spring 会通过 AOP 的方式使用获取连接、连接提交和连接回滚的操作包裹具体的业务逻辑。当调用 methodA 时，会创建一个事务，遇到 methodB 的调用时，因为已经存在一个事务上下文，所以就将 methodB 加入到当前事务中。</p>
<h3 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a>PROPAGATION_SUPPORTS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">methodA() &#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line">methodB() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独调用 methodB 时，methodB 是在非事务环境下执行的。当调用 methodA 时，methodB 则加入到 methodA 的事务当中。</p>
<h3 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a>PROPAGATION_MANDATORY</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">methodA() &#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line">methodB() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独调用 methodB 会抛出一个异常。当调用 methodA 时，methodB 会加入到 methodA 的事务当中执行。</p>
<h3 id="PROPAGATION-REQUIRED-NEW"><a href="#PROPAGATION-REQUIRED-NEW" class="headerlink" title="PROPAGATION_REQUIRED_NEW"></a>PROPAGATION_REQUIRED_NEW</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">methodA() &#123;</span><br><span class="line">    doSomethingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomethingB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">methodB() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法 methodA 时，相当于调用以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获得一个 JTA 事务管理器</span></span><br><span class="line">    transactionManager = getTransactionManager();</span><br><span class="line">    <span class="comment">// 开启一个新的事务</span></span><br><span class="line">    transactionManager.begin();</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">ts1</span> <span class="operator">=</span> transactionManager.getTransaction();</span><br><span class="line">    doSomethingA();</span><br><span class="line">    <span class="comment">// 挂起当前事务</span></span><br><span class="line">    transactionManager.suspend();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开启第二个事务</span></span><br><span class="line">        transactionManager.begin();</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">ts2</span> <span class="operator">=</span> transactionManager.getTransaction();</span><br><span class="line">        methodB();</span><br><span class="line">        <span class="comment">// 提交第二个事务</span></span><br><span class="line">        ts2.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RunTimeException ex) &#123;</span><br><span class="line">        ts2.rollback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// methodB 执行完后，恢复第一个事务</span></span><br><span class="line">    transactionManager.resume(ts1);</span><br><span class="line">    doSomethingB();</span><br><span class="line">    <span class="comment">// 提交第一个事务</span></span><br><span class="line">    ts1.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (RunTimeException ex) &#123;</span><br><span class="line">    ts1.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ts2 是否成功并不依赖于 ts1。如果 methodA 方法在调用 methodB 方法后的 doSomethingB 方法失败了，methodB 方法所做的结果依然被提交，除了 methodB 之外的其它代码导致的结果会被回滚。PROPAGATION_REQUIRES_NEW 这一传播等级尤其适用于 JtaTransactionManager 事务管理器。</p>
<h3 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a>PROPAGATION_NOT_SUPPORTED</h3><p>总是非事务地执行，并挂起任何存在的事务。PROPAGATION_NOT_SUPPORTED 这一传播等级尤其适用于 JtaTransactionManager 事务管理器。</p>
<h3 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a>PROPAGATION_NEVER</h3><p>总是非事务地执行，如果存在一个活动的事务，则抛出异常。</p>
<h3 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h3><p>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务, 则按 PROPAGATION_REQUIRED 属性执行。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
<th>可以避免的情况</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>使用数据库默认的隔离级别</td>
<td>视数据库的隔离级别而定</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>最低的隔离级别，允许读取尚未提交的数据变更</td>
<td></td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>允许读取并发事务已经提交的数据</td>
<td>脏读</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>对同一份数据多次读取结果都是一致的，除非数据是被本身事务自己所修改</td>
<td>脏读、不可重复读</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>最高的隔离级别，所有的事务串行化执行，通常是通过完全锁定事务相关的数据库表来实现</td>
<td>脏读、不可重复读、幻读</td>
</tr>
</tbody></table>
<h2 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h2><p>只读事务并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库服务，这个事务并不包含更改数据的操作，那么 JDBC 驱动和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力。如果非要在只读事务里面修改数据，也并非不可以，只不过对于数据一致性的保护不像读写事务那样保险而已。 </p>
<h2 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h2><p>一个事务不能运行太长的时间，因为事务可能会对数据库进行加锁操作，所以长时间的事务会占用数据库资源。给事务设置超时时间，如果事务在超时时间内没有执行完毕，就会自动回滚，而不是一直等待事务结束。</p>
<h1 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h1><p>TransactionStatus 接口中提供了一些控制事务执行以及查看事务状态的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span> <span class="keyword">extends</span> <span class="title class_">SavepointManager</span>, Flushable &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否是新的事务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否有恢复点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置为只回滚</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否为只回滚</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否已经完成</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isCompleted</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.open-open.com/lib/view/open1350865116821.html">Spring 事务机制详解</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/trigl/article/details/50968079">Spring 事务管理（详解和实例）</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/u010963948/article/details/82761383">Spring 事务详细解释，满满的都是干货！</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC 容器剖析</title>
    <url>/2018/05/27/Spring%20IoC%20%E5%AE%B9%E5%99%A8%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>使用 spring 5.1.19.RELEASE 分析</p>
</blockquote>
<p>整个 IoC 容器都是围绕着 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 来设计的。<code>BeanFactory</code> 提供了容器的基本功能。<code>ApplicationContext</code> 继承自 <code>BeanFactory</code>，不光实现了容器的基本功能，还实现了一些更高级的容器特性。  </p>
<span id="more"></span>		

<h1 id="BeanFactory-容器设计"><a href="#BeanFactory-容器设计" class="headerlink" title="BeanFactory 容器设计"></a>BeanFactory 容器设计</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/3q7.png" alt="ConfigurableBeanFactory"></p>
<p>这是一条主要的 <code>BeanFactory</code> 设计路线。</p>
<ul>
<li><code>BeanFactory</code> 提供了如 <code>getBean</code> 这样的基本方法用来获取容器中的 bean。</li>
<li><code>HierarchicalBeanFactory</code> 提供了 <code>getParentBeanFactory</code> 方法，使得容器获得了父子容器管理的功能。</li>
<li><code>SingletonBeanRegistry</code> 提供了管理单例 bean 的功能。</li>
<li><code>ConfigurableBeanFactory</code> 提供了一些容器的配置功能，比如设置容器的父容器的 <code>setParentBeanFactory</code> 方法。</li>
</ul>
<p>在这条路线上，有一个实现了基本容器功能的类 <code>DefaultListableBeanFactory</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/o6x.png" alt="DefaultListableBeanFactory"></p>
<p><code>DefaultListableBeanFactory</code> 已经实现了容器的基本功能，也就是说我们可以直接使用它了。该类还有一个子类 <code>XmlBeanFactory</code>，不过已经不推荐使用了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;serial&quot;, &quot;all&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultListableBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">this</span>(resource, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">      <span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看 <code>XmlBeanFactory</code> 的代码，我们可以模仿它来使用 <code>DefaultListableBeanFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义资源文件</span></span><br><span class="line">    <span class="type">ClassPathResource</span> <span class="variable">classPathResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建 DefaultListableBeanFactory 实例</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">defaultListableBeanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 创建 XmlBeanDefinitionReader</span></span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(defaultListableBeanFactory);</span><br><span class="line">    <span class="comment">// 使用 XmlBeanDefinitionReader 来解析资源文件中的 bean 定义</span></span><br><span class="line">    reader.loadBeanDefinitions(classPathResource);</span><br><span class="line">    <span class="comment">// 获取容器中的 bean</span></span><br><span class="line">    <span class="type">ElectricCar</span> <span class="variable">electricCar</span> <span class="operator">=</span> (ElectricCar) defaultListableBeanFactory.getBean(<span class="string">&quot;electricCar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ApplicationContext-容器设计"><a href="#ApplicationContext-容器设计" class="headerlink" title="ApplicationContext 容器设计"></a>ApplicationContext 容器设计</h1><p>IoC 容器的第二条设计路线以 <code>ApplicationContext</code> 接口为主，在继承了 <code>BeanFactory</code> 的同时，还继承了 <code>MessageSource</code>、<code>ApplicationEventPublisher</code>、<code>ResourceLoader</code> 等接口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/WnD.png" alt="ApplicationContext"></p>
<p> <code>ApplicationContext</code> 作为 <code>BeanFactory</code> 的实现，和 <code>XmlBeanFactory</code> 一样，也是在 <code>DefaultListableBeanFactory</code> 这个基本的容器实现上做扩展（一般是通过持有一个 <code>DefaultListableBeanFactory</code> 对象来实现）。我们常用的应用上下文基本上都是 <code>ConfigurableApplicationContext</code> 或者 <code>WebApplicationContext</code> 的实现。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/YAN.png" alt="ConfigurableWebApplicationContext"></p>
<table>
<thead>
<tr>
<th>实现了 ConfigurableApplicationContext 接口的类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统加载 xml 配置文件来初始化容器</td>
</tr>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过 classpath 加载 xml 配置文件来初始化容器</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>通过加载纯注解的配置类来初始化容器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>实现了 WebApplicationContext 接口的类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AnnotationConfigWebApplicationContext</td>
<td>通过加载纯注解的配置类来初始化具有 Web 功能的容器</td>
</tr>
<tr>
<td>XmlWebApplicationContext</td>
<td>在 Web 应用中，我们一般会在 web.xml 中设置一个监听器：ContextLoaderListener，默认情况下，它会在 Servlet 容器启动时创建并初始化一个 XmlWebApplicationContext</td>
</tr>
</tbody></table>
<h1 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h1><p>IoC 容器的初始化是通过 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法来完成的，这个过程主要包括 BeanDefinition 的 Resource 定位、载入和注册三个基本操作，Spring 将这三个过程分开，使用了不同的模块来完成（比如使用 ResourceLoader、BeanDefinitionReader 等）。通过这种方式，可以让用户根据需要更加灵活地对这三个过程进行修改或者扩展。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/28/LXL.png" alt="AbstractApplicationContext"></p>
<h2 id="包含-BeanDefinition-的资源定位"><a href="#包含-BeanDefinition-的资源定位" class="headerlink" title="包含 BeanDefinition 的资源定位"></a>包含 BeanDefinition 的资源定位</h2><p>我们知道，BeanDefinition 接口是 Bean 定义的抽象，用来描述 Bean 的一些信息，比如是单例 Bean 还是原型 Bean，对应的类的全限定名称，是否需要延迟初始化，依赖关系等等。Bean 定义的存在形式有很多种，常见的可能会在文件系统中或者在类路径中，因此，Spring 抽象出了 Resource 接口，在文件系统中的 Bean 定义资源就可以通过 FileSystemResource 来抽象，而在类路径的 Bean 定义资源则可以通过 ClassPathResource 来抽象，然后它们都可以通过对应的 ResourceLoader 来获取。</p>
<p>在以编程的方式使用 DefaultListableBeanFactory 时，我们需要定义一个 Resource 来定位容器所使用的 Bean 定义资源，这里的 Resource 并不能直接交给 DefaultListableBeanFactory 使用，因为 DefaultListableBeanFactory 只是一个单纯的 IoC 容器，我们需要为它配置一个特定的 BeanDefinitionReader，用来读取 Bean 定义资源，并将 Bean 定义转换成容器能够处理的形式。而我们使用的很多 ApplicationContext 实现中已经提供了一系列能够加载不同 Resource 的读取器实现，我们以 FileSystemXmlApplicationContext 为例，从头到尾梳理一下容器的初始化过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/12/5NM.png" alt="FileSystemXmlApplicationContext"></p>
<p>通过上图可以看出，FileSystemXmlApplicationContext 通过继承 AbstractApplicationContext，具备了 ResourceLoader 读取 Resource 的能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个构造函数可以传入父容器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个构造函数可以传入 BeanDefinition 所在的文件路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;configLocation&#125;, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">        String[] configLocations, <span class="type">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">super</span>(parent);</span><br><span class="line">      <span class="comment">// 设置 BeanDefinition 所在文件路径</span></span><br><span class="line">      setConfigLocations(configLocations);</span><br><span class="line">      <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">// 这个 refresh 启动了容器的初始化过程，当然也包括 BeanDefinition 的载入过程</span></span><br><span class="line">        refresh();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Resource <span class="title function_">getResourceByPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        path = path.substring(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最后这个构造器中调用了父类的构造器，我们沿着类图一直向上，能够追溯到 AbstractApplicationContext 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">DefaultResourceLoader</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">ConfigurableApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>();</span><br><span class="line">      setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> ResourcePatternResolver <span class="title function_">getResourcePatternResolver</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 AbstractApplicationContext 中初始化了一个 PathMatchingResourcePatternResolver 类，它实现了 ResourcePatternResolver 接口。我们知道，Resource 是资源的抽象，通过它可以访问各种包含 Bean 定义的资源，但是该接口有一个问题：它不支持以通配符的方式读取资源。如果我们要访问同一个路径下所有符合条件的资源，只能将读取的资源路径全部写出来才可以，ResourcePatternResolver 的出现就是为了解决这个问题的，它能够按照相应的模式匹配策略将资源路径转换成对应的资源，默认情况下使用的 PathMatchingResourcePatternResolver 是按照 Ant 风格的匹配策略来处理资源路径的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigLocations</span><span class="params">(<span class="meta">@Nullable</span> String... locations)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (locations != <span class="literal">null</span>) &#123;</span><br><span class="line">    Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.configLocations = <span class="keyword">new</span> <span class="title class_">String</span>[locations.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">      <span class="comment">// resolvePath 方法主要用来处理资源路径中的占位符</span></span><br><span class="line">      <span class="built_in">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.configLocations = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">resolvePath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理路径中的占位符</span></span><br><span class="line">    <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着回到 setConfigLocations 方法。在该方法中，resolvePath 方法能够将资源路径字符串中的占位符转换成对应的值。比如资源路径为：<code>classpath:applicationContext-$&#123;profile&#125;.xml</code>，那么该方法会从环境变量（包括系统变量、用户自定义的变量等）中寻找对应的值进行替换。</p>
<p>对于容器的启动来说，refresh 方法是一个很重要的方法，它详细地描述了整个 ApplicationContext 的初始化过程，比如 BeanFactory 的刷新，MessageSource 和 PostProcessor 的注册等等，这个执行过程为 Bean 的生命周期管理创造了条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">        *   准备要刷新的上下文。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">        *   告诉子类刷新内部的 BeanFactory。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">        *   对 BeanFactory 做相关配置，如设置 BeanPostProcessor、BeanClassLoader 等。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">            *   允许在上下文子类中对 BeanFactory 进行后处理。</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;&#125;</span></span><br><span class="line"><span class="comment">            *   该方法是一个空方法，由 AbstractApplicationContext 的子类去实现。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">            *   执行在上下文注册为 bean 的 BeanFactoryPostProcessor。</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   Spring 提供的扩展点，我们可以实现 BeanFactoryPostProcessor 接口，并注册为 Spring 的 bean。</span></span><br><span class="line"><span class="comment">            *   在本方法中表现为通过将读取到的 beanDefinitionNames 逐个解析，判断是否为 BeanFactoryPostProcessor </span></span><br><span class="line"><span class="comment">            *   的实现类来确定执行哪些 BeanFactoryPostProcessor。</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   这样我们就可以在 bean 实例化之前，读取 BeanFactory 中的 bean 配置，并根据需要进行修改，</span></span><br><span class="line"><span class="comment">            *   比如修改 bean 的 scope 等等，甚至可以预先将 bean 初始化（不推荐）。</span></span><br><span class="line"><span class="comment">            */</span>  </span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">/** </span></span><br><span class="line"><span class="comment">            *   Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">            *   注册拦截 bean 创建的处理器</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   Spring 提供的扩展点，我们可以实现 BeanPostProcessor 接口，并注册为 Spring 的 bean。</span></span><br><span class="line"><span class="comment">            *   Spring 发现这些实现类的方式和发现 BeanFactoryPostProcessor 的方式一致。</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *   实现 BeanPostProcessor 接口需要重写 postProcessBeforeInitialization() 和 </span></span><br><span class="line"><span class="comment">            *   postProcessAfterInitialization() 方法，这两个方法会在每个非手工注册的 bean 初始化之前和初始化之后执行。</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Initialize message source for this context.</span></span><br><span class="line"><span class="comment">            *   初始化消息国际化。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">            *   初始化事件广播。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">            *   这是一个模版方法，允许子类在进行 bean 初始化之前进行一些定制操作。默认空实现。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">            *   注册事件监听者（实现了 ApplicationListener 接口）。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">            *   完成 BeanFactory 的最终配置，并实例化所有剩下的非懒加载的单例 bean。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">            *   完成刷新，调用 LifecycleProcessor 的 onRefresh() 方法，发布 ContextRefreshedEvent 事件</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line"><span class="comment">            *   销毁已经创建的单例 bean</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们需要重点关注 obtainFreshBeanFactory 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 刷新 BeanFactory</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 获取 BeanFactory</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.context.support.AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        <span class="comment">// 销毁已经实例化的 Bean</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">        <span class="comment">// 关闭 BeanFactory</span></span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 默认创建一个 DefaultListableBeanFactory，如果有父容器会作为参数传入</span></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 此处加载 bean 定义信息</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 在刷新 BeanFactory 时，会检测 BeanFactory 是否已经创建，已经创建会执行销毁方法，然后重新创建。在 BeanFactory 创建完成后，会开始加载并解析 bean 的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.context.support.AbstractXmlApplicationContext</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">    <span class="comment">// 创建 XmlBeanDefinitionReader 来读取和解析 BeanDefinition</span></span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    <span class="comment">// 配置读取器的上下文环境</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">// 允许子类自定义读取器的初始化方法</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 真正的加载 BeanDefinition</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">    <span class="comment">// 使用 ClassPathXmlApplicationContext 容器时会调用此处</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 FileSystemXmlApplicationContext 容器时调用此处</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着追溯 loadBeanDefinitions 方法，会发现由 AbstractBeanDefinitionReader 调用了该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.springframework.beans.factory.support.AbstractBeanDefinitionReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="comment">// 获取 ResourceLoader</span></span><br><span class="line">    <span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个 ResourceLoader 同样实现了 ResourcePatternResolver</span></span><br><span class="line">    <span class="comment">// 很多容器都实现了该接口，方便通过模式匹配加载多个资源</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取匹配到的资源</span></span><br><span class="line">        Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> loadBeanDefinitions(resources);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="literal">null</span>) &#123;</span><br><span class="line">          Collections.addAll(actualResources, resources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 只能通过访问绝对路径的方式加载单个资源</span></span><br><span class="line">      <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">      <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(location);</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> loadBeanDefinitions(resource);</span><br><span class="line">      <span class="keyword">if</span> (actualResources != <span class="literal">null</span>) &#123;</span><br><span class="line">        actualResources.add(resource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      count += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，如果 ResourceLoader 同样实现了 ResourcePatternResolver 接口，那么就通过模式匹配的方式加载资源；否则就单纯的使用绝对路径来加载单个资源。至此，所有的资源都已经完成了定位，接下来开始调用 loadBeanDefinitions 方法进行 BeanDefinition 的载入和解析。</p>
<h2 id="BeanDefinition-的载入和解析"><a href="#BeanDefinition-的载入和解析" class="headerlink" title="BeanDefinition 的载入和解析"></a>BeanDefinition 的载入和解析</h2><p>在这一过程中，首先需要读取所有定位好的资源，接着要按照一定的规则将读取到的内容转换成 IoC 容器内部的数据结构，这个数据结构对应的就是 BeanDefinition 接口。</p>
<p>我们接着分析上面的代码，在 loadBeanDefinitions 方法中，循环调用了一个同名的 loadBeanDefinitions 方法，该方法只有一个 Resource 参数，由 AbstractBeanDefinitionReader 的子类来实现，在我们的这个例子当中，显然这里调用的是 XmlBeanDefinitionReader 的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里拿到资源对应的流，封装成 InputSource</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">          inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正的加载流程</span></span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取文档的内容</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 注册 Bean 定义</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正执行载入 Bean 定义的是 doLoadBeanDefinitions 方法。在该方法中，doLoadDocument 方法只负责读取 xml 文档内容，生成一个 Document 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Document <span class="title function_">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="built_in">this</span>.errorHandler,</span><br><span class="line">        getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getValidationModeForResource</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 XML 文档的校验方式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">validationModeToUse</span> <span class="operator">=</span> getValidationMode();</span><br><span class="line">    <span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">      <span class="keyword">return</span> validationModeToUse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 试图查找 XML 文档的校验方式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">detectedMode</span> <span class="operator">=</span> detectValidationMode(resource);</span><br><span class="line">    <span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">      <span class="keyword">return</span> detectedMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Hmm, we didn&#x27;t get a clear indication... Let&#x27;s assume XSD,</span></span><br><span class="line">    <span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line">    <span class="comment">// detection stopped (before finding the document&#x27;s root tag).</span></span><br><span class="line">    <span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">detectValidationMode</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resource.isOpen()) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStream inputStream;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream = resource.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据文件头部是否包含 DOCTYPE 等关键字来判断采用哪种校验方式</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;Unable to determine validation mode for [&quot;</span> +</span><br><span class="line">          resource + <span class="string">&quot;]: an error occurred whilst reading from the InputStream.&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doLoadDocument 方法中，我们可以关注一下 getValidationModeForResource 这个方法，该方法主要用来获取应该采用何种方式校验 XML 文件。如果 XML 文件头部包含 <code>DOCTYPE</code> 等关键字，那么会通过 DTD 约束来校验文件；否则会通过 XSD 约束来校验文件。使用了 DTD 约束的 XML 配置文件类似下面这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">beans</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//SPRING//DTD BEAN 2.0//EN&quot;</span> <span class="string">&quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与此同时，还有一个方法值得关注，那就是 getEntityResolver，该方法用来获取 EntityResolver。我们知道，配置文件在头部会定义约束文件，而约束文件一般都带有 URL 地址，这意味着我们需要网络来获取约束文件，但现实环境往往比较复杂，项目有时会面临离线的状态。为了解决这个问题，约束文件一般会跟随框架一起打包，那么这些约束文件被放在哪里了呢？在 Spring 中，它们的位置被记录在了 <code>META-INF/spring.schemas</code> 文件中。比如我们打开 spring-beans.jar 下的该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.0.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-3.0.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line"># 以下省略</span><br></pre></td></tr></table></figure>

<p>可以看到，各个版本以及没有版本号的约束文件，都指向了同一路径下的一个约束文件。在 EntityResolver 接口中，只有一个 resolveEntity 方法，这个方法的作用就是根据提供的约束文件 URL，寻找对应的离线约束文件。</p>
<p>我们接着回到 doLoadBeanDefinitions 方法。此时我们已经将所有的配置转换成了一个 <code>org.w3c.dom.Document</code> 结构，接下来只需要将它转换成对应的 BeanDefinitions 就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="comment">// 创建 BeanDefinitionDocumentReader</span></span><br><span class="line">    <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 将解析文档的工作委派给它</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XmlReaderContext <span class="title function_">createReaderContext</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlReaderContext</span>(resource, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.eventListener,</span><br><span class="line">        <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 registerBeanDefinitions 方法中，又创建了一个 BeanDefinitionDocumentReader，然后将文档解析的工作委派给了它，同时还给它额外传入了一个 ReaderContext 参数，这个参数我们可以理解为一个文档读取的上下文环境。在这个上下文环境当中，有一个重要的属性：NamespaceHandlerResolver，乍一看这个名字起的有点奇怪，Handler 后面为什么还加了个 Resolver？我们带着这个问题，查看 getNamespaceHandlerResolver 方法，发现在这里最终是创建了一个默认的实现：DefaultNamespaceHandlerResolver，它的作用是从 <code>META-INF/spring.handlers</code> 文件中加载不同命名空间所对应的 NamespaceHandler。比如 spring-context.jar 下该文件的内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure>

<p>在这里我们随便打开一个 NamespaceHandler，比如 ContextNamespaceHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;property-placeholder&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertyPlaceholderBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;property-override&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertyOverrideBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;annotation-config&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationConfigBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;component-scan&quot;</span>, <span class="keyword">new</span> <span class="title class_">ComponentScanBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;load-time-weaver&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoadTimeWeaverBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;mbean-export&quot;</span>, <span class="keyword">new</span> <span class="title class_">MBeanExportBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;mbean-server&quot;</span>, <span class="keyword">new</span> <span class="title class_">MBeanServerBeanDefinitionParser</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里初始化的是 context 命名空间中所有可用的元素（标签）和它们对应的解析器，这个解析器被 Spring 抽象为 BeanDefinitionParser 接口。我们常见的一些命名空间配置，比如 <code>&lt;context:component-scan base-package=&quot;xxx&quot; /&gt;</code> 等，就由这些解析器来处理。</p>
<p>我们回到之前的代码。由于文档解析的工作交给了 BeanDefinitionDocumentReader，同时在这里使用的是它的一个默认实现：DefaultBeanDefinitionDocumentReader，因此我们继续深入到它的方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">    <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">// 判断是否是默认的命名空间：http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">// 获取 beans 的 profile 属性</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">        String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">            profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">        <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">        <span class="comment">// 从 ReadContext 的环境变量中获取当前被激活的 profile</span></span><br><span class="line">        <span class="comment">// 如果当前正在解析的配置文件不是被激活的 profile，那么直接跳过文档解析的过程</span></span><br><span class="line">        <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置处理，默认是一个空实现，可以由子类来重写</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析 BeanDefinitions</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 后置处理，默认是一个空实现，可以由子类来重写</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，首先执行了一些前置工作，比如检查默认激活的 profile 与当前解析的文档是否一致，如果不一致则直接跳过解析过程。然后还有两个可以由子类扩展的前置和后置处理的方法，以及真正执行解析工作的 parseBeanDefinitions 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否是默认的命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">          <span class="comment">// 如果是默认的命名空间，则使用默认的元素处理方法</span></span><br><span class="line">          <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">            parseDefaultElement(ele, delegate);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            delegate.parseCustomElement(ele);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是默认的命名空间则执行自定义元素处理方法</span></span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是 import 标签，则执行 import 的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 alias 标签，则处理 alias 的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 bean 标签，则执行解析 BeanDefinition 的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 beans 标签，则通过递归的方式回到上面的方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parseCustomElement(ele, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取命名空间约束文件 URI</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取对应的命名空间处理器</span></span><br><span class="line">    <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将解析的工作交给命名空间处理器</span></span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parseBeanDefinitions 方法的逻辑很清晰：根据不同的命名空间，调用不同的处理逻辑。在默认命名空间中有四类标签：<code>import</code>、<code>alias</code>、<code>bean</code> 和 <code>beans</code>，其中 <code>bean</code> 标签对应的处理逻辑能够将 bean 定义转换成 BeanDefinition。对于其他命名空间的标签，我们在前面提到过，使用 NamespaceHandlerResolver 可以获取对应的命名空间处理器，然后将解析工作交给对应的 NamespaceHandler 来处理。这里我们只重点关注 <code>bean</code> 标签的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 解析标签，并将转换后的 BeanDefinition 放入 BeanDefinitionHolder 中</span></span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">            bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，parseBeanDefinitionElement 方法将解析 <code>bean</code> 标签并生成对应的 BeanDefinition（创建的是一个 GenericBeanDefinition），最后将它放入一个 BeanDefinitionHolder 中。接下来的需要做的就是将 BeanDefinition 注册到容器中。</p>
<h2 id="BeanDefinition-的注册"><a href="#BeanDefinition-的注册" class="headerlink" title="BeanDefinition 的注册"></a>BeanDefinition 的注册</h2><p>向 IoC 容器注册 BeanDefinition 是通过调用 BeanDefinitionRegistry 接口的实现来完成的。简单来说就是在 IoC 容器内部有一个名为 beanDefinitionMap 的 ConcurrentHashMap，注册的过程就是将 BeanDefinition 放入这个 Map 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.BeanDefinitionReaderUtils</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">// 注册别名</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">        registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环依赖的问题"><a href="#循环依赖的问题" class="headerlink" title="循环依赖的问题"></a>循环依赖的问题</h1><p>这部分内容之所以放在容器的依赖注入之前，是因为将这类问题单独拎出来，再结合 Spring 对于循环依赖问题的处理完整分析一遍，对于接下来解析 Spring 依赖注入部分的代码很有帮助。</p>
<p>所谓循环依赖，说白了就是一个或多个对象实例之间存在直接或者间接的依赖关系，这个依赖关系最终形成了一个环形的结构。一般循环依赖可以简化为三种情况，即自己依赖自己，两两之间的直接依赖和多个对象之间的间接依赖。前两种情况的直接循环依赖比较好识别，第三种间接循环依赖的情况有时候因为业务代码调用层级很深，不容易识别出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/16/kbQ.png" alt="循环依赖"></p>
<p>在 Spring 中，出现循环依赖的场景主要有以下几种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/16/Evd.png" alt="Spring 中循环依赖的主要场景"></p>
<p>在这些可能出现循环依赖的场景中，有些 Spring 是能够处理的，有些则不能。Spring 跟我们一样，我们在平常编码时无法解决的循环依赖问题，它同样也无法解决，比如多例的 setter 注入和构造器注入。我们举个例子，用大白话来分析一下。假设有两个类 A 和 B，它们之间互相依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="comment">// 省略构造器和 setter 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> A a;</span><br><span class="line">  <span class="comment">// 省略构造器和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要实现多例，也就是每次都要创建一个新的对象。在使用 setter 方法注入时，我们首先需要实例化 A，由于 A 依赖于 B，所以我们又实例化了一个 B，然后使用 setter 方法将 B 的实例注入到 A 的实例中。接着我们又发现 B 依赖于 A，同时由于我们要实现多例，那么此时还需要再重新实例化一个 A，然后将这个 A 的新实例通过 setter 注入给 B 的实例。这还没完，A 的新实例也需要注入呀，因此我们又实例化了一个 B 的新实例，如此往复。这显然是没有尽头的，也是无法处理的。</p>
<p>而在构造器注入的场景下，无法解决循环依赖的问题是因为创建对象需要调用构造器，而构造器需要传入依赖的对象，由于此时被依赖的对象还没有创建，因此同样使用构造器创建，不过该构造器也需要传入依赖的对象，这就陷入了死胡同。</p>
<p>DependsOn 循环依赖则比较特殊，它是 Spring 框架特有的。对于一个 Bean，Spring 大体上向用户提供了两种方式来配置它的依赖。一种是使用 <code>depends-on</code> 属性或者 <code>@DependsOn</code> 注解，另一种是使用 <code>ref</code> 属性等类似的方式。其中，通过 <code>ref</code> 属性来配置依赖的对象中需要持有被依赖的对象，而 DependsOn 则不需要。所以我们可以理解为这种依赖只是一种初始化顺序上的依赖，那么因此我们就很容易理解：具有初始化顺序依赖的两个对象之间不应该存在逻辑上（初始化上）的依赖。</p>
<p>到了单例环境中，循环依赖的问题其实是很容易处理的，利用我们经常使用的 setter 方法执行注入即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">a.setB(b);</span><br><span class="line">b.setA(a);</span><br></pre></td></tr></table></figure>

<p>如果让我们按照这个思路，实现一个简易的，能够处理循环依赖的 IoC 容器，我们应该怎么做呢？回看上面的代码，你会发现其实这是一种延迟初始化的思想。也就说，我们在初始化 Bean 的时候，首先通过无参构造创建了一个“空”对象，接着我们要将这个对象的引用存储起来，方便我们后续还能找到这个未初始化完成的对象，执行 setter 注入。这里有一个很重要的信息，那就是存储对象的引用，因此我们需要一个缓存容器。到了这里，我们离 Spring 的实现又近了一步。没错，Spring 的设计思路跟我们一样，不过不同的是，它一次性使用了三个这样的缓存容器，也就是我们俗称的三级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   单例对象的缓存容器，对应的结构是：bean 名称 -&gt; bean 实例，这个 bean 是完全初始化的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   早期暴露出来的单例对象的缓存容器，对应的结构是：bean 名称 -&gt; bean 实例，这个 bean 是不完全初始化的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   单例工厂的缓存容器，对应的结构是：bean 名称 -&gt; ObjectFactory 实例，它是可以生成 Bean 的工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>一级缓存为 singletonObjects，存储的是已经完全初始化的 bean 实例。二级缓存为 earlySingletonObjects，存储的是已经实例化，但是还没有初始化的 bean 实例。三级缓存为 singletonFactories，存储的是能够生成 bean 实例的工厂对象。Spring 为什么要使用三级缓存来处理循环依赖的问题呢？换句话说，只使用一级缓存，或者只使用二级缓存可以吗？答案是不行。</p>
<p>我们先看只使用一级缓存为什么不行。同样还是拿着 A 和 B 这两个类来举例。用户获取 A 的实例，此时缓存容器中没有，因此 A 要先实例化，实例化之后放入缓存容器中，接着我们需要填充 A 的属性，也就是 B 的实例。此时我们需要先从缓存容器中尝试获取 B 的实例，如果没有我们需要先实例化 B。等等！我们先别急着向下分析，在 A 实例化并放入缓存容器之后，如果此时有个用户尝试获取 A 的实例怎么办？或者尝试获取 B 的实例，同样经过了上述步骤，在填充属性时，从缓存容器中拿到了 A 的实例。在这些场景中，A 的实例都没有完全初始化，但是用户已经获取到并开始准备使用它了。这显然是有问题的，而产生问题的关键是我们无法得知某一时刻缓存容器中的实例是否完全初始化了。比较简单直接的解决方法就是使用两个缓存容器，一个存放实例化但没初始化的 bean，另一个存放实例化并且完全初始化的 bean，各司其职。那为什么我们在一开始又说：在 Spring 中，只使用二级缓存是不行的呢？</p>
<p>我们不要忘了，Spring Framework 作为一个成熟的商业产品，IoC 只是它的一个基本功能。除了 IoC，它还有一个很重要也是很基础的功能：AOP。如果一个 bean 经过了 AOP 的织入（Weaving），那么我们拿到的这个 bean 实际上是一个代理 bean。在我们像上面那样去使用二级缓存时，二级缓存中存放只是原始的 bean 实例，这样其他依赖该 bean 的实例在填充属性时获取到的也只是原始的 bean 实例，并不是我们真正想要获取的代理 bean 实例。那么你可能又会问了，如果我们不像上面那样将实例化后的 bean 对象放入二级缓存，而是将代理对象（代理对象包裹着未初始化的原始实例）放入二级缓存中不就行了吗。理论上来说，这是完全没有问题的，那么 Spring 又为什么非要使用三级缓存呢？<strong>其实，Spring 的根本目的是为了保证在没有循环依赖的情况下，在引入了 AOP 之后，Bean 的生命周期设计不会得到破坏，即代理对象应该在 bean 初始化完成之后才生成，而不应该在 bean 实例化之后就生成。</strong></p>
<p>我们还是用上面存在循环依赖的 A 和 B 来举例，我们假设只使用二级缓存，并且二级缓存存放的是代理对象，那么整个流程大概就像下图这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/21/P3q.png" alt="使用二级缓存时的流程"></p>
<p>显然不管有没有循环依赖，在使用二级缓存时，代理对象总是在 bean 完全初始化之前生成。为了解决这个问题，Spring 又设计了一个 ObjectFactory 接口，这个接口是一个函数式接口，只有一个 getObject 方法用来获取实例对象。接下来我们只要在 bean 实例化之后，将它传入一个 ObjectFactory 的实现中，在这个实现中完成 AOP 的织入，最后将这个 ObjectFactory 放入缓存中即可。这样只有在其他依赖此 bean 的实例执行属性填充时，才会从三级缓存中拿到对应的 ObjectFactory，然后通过 getObject 方法创建对应的代理对象。但是，如果每个依赖此 bean 的实例都需要通过 getObject 方法来持有一个代理对象，那么显然它们持有的并不是同一个代理对象。因此我们需要再添加一个缓存容器，然后将 ObjectFactory 存放在三级缓存中，在其他实例获取三级缓存时，将直接调用获取到的 ObjectFactory 的 getObject 方法，并将结果存入二级缓存，同时删除对应的三级缓存，这样下次就可以直接从二级缓存获取代理对象了。</p>
<p>这就是 Spring 三级缓存的由来。在使用了三级缓存之后，如果不存在循环依赖，那么代理对象的创建会在 bean 完全初始化之后才会进行；如果存在循环依赖，整个流程大概就变成下图这样了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/21/9vo.png" alt="使用三级缓存时的流程"></p>
<blockquote>
<p>在 Spring 中，AOP 的功能通过 Bean 后置处理器来完成的，更确切的说，是由 <code>@EnableAspectJAutoProxy</code> 注解导入的 <code>AnnotationAwareAspectJAutoProxyCreator</code> 来完成的。在它的 postProcessAfterInitialization 方法中，同样实现了根据已有 bean 实例创建代理对象的逻辑，这也是为什么说如果不存在循环依赖，那么代理对象的创建会在 bean 完全初始化之后才会进行的原因。</p>
</blockquote>
<h1 id="IoC-容器的依赖注入"><a href="#IoC-容器的依赖注入" class="headerlink" title="IoC 容器的依赖注入"></a>IoC 容器的依赖注入</h1><p>IoC 容器的依赖注入过程是在用户第一次向容器索要 Bean 时触发的，当然也有例外，那些设置 Bean 的 lazy-init 属性为 false（默认就是 false）的 BeanDefinition 会在容器初始化时就完成预实例化。这个预实例化实际上也是一个完成依赖注入的过程，只不过它是在容器初始化的过程中完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.context.support.AbstractApplicationContext</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">    String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">    <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 转换 bean 的名称</span></span><br><span class="line">    <span class="comment">// 如果是别名，转换成标准名。如果首字符是 &amp;，则会去掉所有的 &amp;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">    <span class="comment">// 尝试从缓存中获取单例 bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 判断当前实例是否正在创建中</span></span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">          <span class="comment">// 省略此处代码。这里会输出 trace 级别的日志信息，主要提醒用户该实例还没有完全初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是 FactoryBean，则会根据用户传入的 name 来决定是返回 FactoryBean 实例</span></span><br><span class="line">      <span class="comment">// 还是通过 FactoryBean 的 getObject 方法返回实例。如果不是 FactoryBean 则会原样返回</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果该原型实例正在创建中，则直接抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取父容器</span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="comment">// 如果有父容器，并且当前容器中也没有 BeanDefinition，那么就去父容器查找</span></span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">              nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个标记的作用是控制是否刷新 mergedBeanDefinitions 缓存</span></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">        <span class="comment">// 标记当前 bean 为正在创建的过程中，同时清空 mergedBeanDefinitions 缓存，以防 BeanDefinition 的</span></span><br><span class="line">        <span class="comment">// 元数据发生变化后还读到旧的缓存数据</span></span><br><span class="line">        markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 合并 BeanDefinition</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">        <span class="comment">// 确保依赖的 bean 被初始化</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">            <span class="comment">// 根据暂存的依赖关系检测是否存在循环依赖</span></span><br><span class="line">            <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将依赖关系暂存</span></span><br><span class="line">            registerDependentBean(dep, beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取依赖 bean</span></span><br><span class="line">              getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建单例 bean</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">              <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">              <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建原型 bean</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">          <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在创建之前先做个标记，表示该 bean 正在创建中</span></span><br><span class="line">            <span class="comment">// 标记存储在一个名为 prototypesCurrentlyInCreation 的 ThreadLocal 中</span></span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="comment">// 创建 bean</span></span><br><span class="line">            prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除标记</span></span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">          bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 此处省略其他 scope 的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查类型，如果类型不一致会尝试进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">              ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 Bean 的方法最终调用的是 doGetBean 方法。在该方法中，首先尝试从三个级别的缓存中获取单例 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 先尝试从一级缓存获取</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="comment">// 再尝试从二级缓存获取</span></span><br><span class="line">      singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="comment">// 如果允许提前暴露单例 bean</span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">          <span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">          singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 尝试从三级缓存中获取</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">              ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">              <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                <span class="comment">// 获取到之后放入二级缓存同时删除三级缓存</span></span><br><span class="line">                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果缓存为空，那么会有三种可能：实例在父容器中，从未创建和初始化过该 bean，这是一个原型 bean。所以接下来会在父容器存在，并且当前容器中没有对应的 BeanDefinition 时，尝试从父容器获取 bean 的实例。如果父容器不存在，或者当前容器中存在对应的 BeanDefinition 时，继续向下执行获取 bean 的过程。</p>
<p>在这个过程中，如果 BeanDefinition 存在继承关系，那么还需要使用 getMergedLocalBeanDefinition 方法合并它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> <span class="built_in">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> mbd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">return</span> getMergedBeanDefinition(beanName, bd, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 先尝试从缓存中获取</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd == <span class="literal">null</span>) &#123;</span><br><span class="line">        mbd = <span class="built_in">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的 BeanDefinition 没有父级的 BeanDefinition</span></span><br><span class="line">        <span class="keyword">if</span> (bd.getParentName() == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果它是 RootBeanDefinition 类型的，则再克隆一个出来</span></span><br><span class="line">          <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">            mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果它不是 RootBeanDefinition 类型的，那么就使用 BeanDefinition 构造一个</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            mbd = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(bd);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 能走到这里代表当前 BeanDefinition 是一个 Child，因此需要合并父 BeanDefinition</span></span><br><span class="line">          BeanDefinition pbd;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前 bean 名称与父 bean 名称不同</span></span><br><span class="line">            <span class="comment">// 那么使用父 bean 的名称递归调用 getMergedBeanDefinition 方法</span></span><br><span class="line">            <span class="comment">// 这样可以确保具有继承关系的 BeanDefinition 都被合并</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">parentBeanName</span> <span class="operator">=</span> transformedBeanName(bd.getParentName());</span><br><span class="line">            <span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">              pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果名称相同，则直接通过父容器调用 getMergedBeanDefinition 方法</span></span><br><span class="line">              <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">              <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">                pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(parentBeanName,</span><br><span class="line">                    <span class="string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(bd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 先使用父级 BeanDefinition 构建一个 RootBeanDefinition</span></span><br><span class="line">          mbd = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(pbd);</span><br><span class="line">          <span class="comment">// 然后将父子 BeanDefinition 合并</span></span><br><span class="line">          mbd.overrideFrom(bd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">          mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (containingBd != <span class="literal">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">          mbd.setScope(containingBd.getScope());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (containingBd == <span class="literal">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">          <span class="built_in">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mbd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着还要处理 BeanDefinition 的 dependsOn 属性，这个依赖可以理解为只有 dependsOn 属性中指定的 bean 先完成初始化之后，该 bean 才能进行初始化。这就意味着，该 bean 并不需要持有依赖对象，如果持有的话直接使用 ref 即可。在这些前期工作完成以后，接下来会通过 <code>getSingleton(beanName, singletonFactory)</code> 方法来获取 bean 的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 先尝试从一级缓存获取</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在销毁该容器的单例 bean 时，不允许创建单例 Bean</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">              <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">              <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在创建单例 bean 之前做一些检查和标记，比如设置 singletonsCurrentlyInCreation</span></span><br><span class="line">        beforeSingletonCreation(beanName);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">          <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 通过 ObjectFactory 获取单例 bean，注意这个 bean 是一个完成初始化（依赖注入）的 bean</span></span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          newSingleton = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">          <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">          <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">          singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">          <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">              ex.addRelatedCause(suppressedException);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">            <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 在创建单例 bean 之后做一些检查和标记</span></span><br><span class="line">          afterSingletonCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是新建的 bean，将它放入一级缓存，同时删除对应的二级和三级缓存</span></span><br><span class="line">        <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">          addSingleton(beanName, singletonObject);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，我们可以看到主要的一行代码就是调用 ObjectFactory 的 getObject 方法，这个方法实际上调用的是 createBean 方法来创建并初始化一个 bean 的实例。由于这个实例是一个完成依赖注入之后的实例，因此最后还会将它放入一级缓存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line">    <span class="comment">// 确保需要创建 bean 实例的类可以被实例化</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">          beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 在 bean 实例化之前完成一些用户自定义的操作</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">          <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建 bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createBean 方法中，首先会检查需要创建 bean 实例的类是否可以被实例化。如果容器配置了 BeanPostProcessor，那么在实例化 bean 之前还会调用 Bean 后置处理器的 postProcessBeforeInstantiation 方法完成一些用户自定义的操作。该方法返回的 bean 对象可以是代替目标 bean 的代理对象，这样目标 bean 就不会执行默认的实例化操作，唯一会执行的进一步处理就是调用 Bean 后置处理器的 postProcessAfterInitialization 方法来完成 bean 的初始化操作，然后直接返回初始化完成的 bean。在方法的最后，doCreateBean 才是真正创建并初始化 bean 实例的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// 这个 BeanWrapper 用来包装实例化的 bean</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 bean 实例</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处将允许 MergedBeanDefinitionPostProcessor 对 BeanDefinition 进行处理</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">              <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果容器允许单例 bean 出现循环依赖，同时此单例 bean 还在创建中，那么提早将这个单例 bean 放入缓存（三级缓存）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">        isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">            <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将单例 bean 放入三级缓存 singletonFactories 中</span></span><br><span class="line">      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// bean 的依赖注入</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="comment">// 执行一些初始化操作</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">// 尝试从一级缓存和二级缓存中获取实例</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">          exposedObject = earlySingletonReference;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">          String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">          Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">          <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">              actualDependentBeans.add(dependentBean);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doCreateBean 方法中，通过 createBeanInstance 方法来创建 bean 的实例。如果 Spring 容器允许单例 bean 出现循环依赖，那么这个未初始化的 bean 实例会被放入三级缓存中。接下来通过 populateBean 方法对 bean 实例执行属性值的依赖注入，然后使用 initializeBean 方法执行一些初始化的操作。最后通过 registerDisposableBeanIfNecessary 方法注册一些销毁 bean 的回调方法，比如一些 DestructionAwareBeanPostProcessor 接口，DisposableBean 接口，以及自定义的 <code>destroy-method</code> 方法。将未初始化的 bean 实例放入三级缓存这部分代码最简单，我们先来看它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 一级缓存中没有</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 放入三级缓存</span></span><br><span class="line">        <span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">        <span class="comment">// 删除二级缓存中对应的数据</span></span><br><span class="line">        <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          <span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="comment">// 调用 getEarlyBeanReference 方法</span></span><br><span class="line">          exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我想说的是 getEarlyBeanReference 方法，这个方法在容器没有配置 BeanPostProcessor 时只会返回之前未完成初始化的 bean 实例，而如果容器设置了这类 Bean 后置处理器，这里就会调用它们的 getEarlyBeanReference 方法来获得用户特殊处理过的 bean 实例。这个扩展点很多时候是被用来返回经过 AOP 处理的代理 bean 对象。</p>
<p>我们回到刚才的 doCreateBean 方法，继续查看 createBeanInstance 部分的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point. </span></span><br><span class="line">    <span class="comment">// 确保需要创建 bean 实例的类可以被实例化</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">          <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在 Supplier 回调，则使用给定的回调方法进行实例化</span></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里使用 FactoryBean 的工厂方法对 bean 进行实例化，需要注意的是该工厂方法可以是一个静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 Spring 需要根据参数确认到底使用哪个构造函数，该过程比较耗时，所以采用了缓存机制</span></span><br><span class="line">    <span class="comment">// 将解析过的数据放在 BeanDefinition 中，下次创建相同 bean 时能够提高效率</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">        <span class="comment">// resolvedConstructorOrFactoryMethod 用于缓存已解析的构造函数或工厂方法</span></span><br><span class="line">        <span class="comment">// 如果它不为空，说明缓存中已经有解析好的构造函数或工厂方法</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">          resolved = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// constructorArgumentsResolved 用于标记构造函数的参数是否已经解析完毕</span></span><br><span class="line">          autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数或工厂方法已经解析过（知道该用哪个）</span></span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="comment">// 如果参数也已经解析过了，那么可以直接使用构造函数进行实例化</span></span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用默认的无参构造函数进行实例化</span></span><br><span class="line">        <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里尝试从 SmartInstantiationAwareBeanPostProcessor 中获取候选构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用首选构造函数进行实例化。比如 Kotlin 中的主要构造器（Primary Constructor）</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无需特殊的处理，直接使用默认的无参构造函数进行实例化</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createBeanInstance 方法中，大体上有四种实例化 bean 的方式。obtainFromSupplier 方法会从 BeanDefinition 中获取一个名为 instanceSupplier 的 Supplier，然后通过这个 Supplier 获取 bean 的实例。instantiateUsingFactoryMethod 使用 FactoryBean 的工厂方法来创建 bean 的实例，需要注意的是该工厂方法可以是一个静态方法。autowireConstructor 方法则是通过构造方法完成 bean 的实例化，不过由于构造函数和构造参数的不确定性，这个方法在没有提供候选的构造函数时需要花大量的精力来确定构造函数和构造参数（可以通过 BeanPostProcessor 提供候选构造器）。最后的 instantiateBean 方法则是使用默认构造函数进行实例化。</p>
<p>我们回到上面的 doCreateBean 方法，继续查看 populateBean 部分的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">    <span class="comment">// 空对象无法注入</span></span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里会调用 InstantiationAwareBeanPostProcessor 的 postProcessAfterInstantiation 方法</span></span><br><span class="line">    <span class="comment">// 执行 bean 实例化后的操作</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 BeanDefinition 获取 property 值</span></span><br><span class="line">    <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 这里是对 autowire 的处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// 根据名称执行自动注入</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">        autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据类型执行自动注入</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">        pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里会调用 InstantiationAwareBeanPostProcessor 的 postProcessProperties 方法</span></span><br><span class="line">      <span class="comment">// 在 bean 注入属性值之前，对属性值进行处理</span></span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">          <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">              filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">            &#125;</span><br><span class="line">            pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          pvs = pvsToUse;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对属性执行注入</span></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，如果容器配置了 Bean 后置处理器，那么就会执行它们的 postProcessAfterInstantiation 方法来完成用户自定义的一些 bean 实例化后的操作。如果 BeanDefinition 配置了自动注入的模式，那么还会选择对应的模式对该 bean 的属性值执行注入。接下来还会执行 Bean 后置处理器的 postProcessProperties 方法，在 bean 注入属性值之前，对属性值进行一些自定义的处理。最终会调用 applyPropertyValues 方法，对 bean 的属性值执行注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">      ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">      mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">      <span class="comment">// 已经过转换，则直接设置属性值</span></span><br><span class="line">      <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">        <span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          bw.setPropertyValues(mpvs);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">              mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">      converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BeanDefinitionValueResolver</span> <span class="variable">valueResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValueResolver</span>(<span class="built_in">this</span>, beanName, mbd, converter);</span><br><span class="line">    <span class="comment">// 创建一个属性值的深拷贝列表，最终会使用该列表对 bean 执行属性值注入</span></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(original.size());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">resolveNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">      <span class="comment">// 属性值已经过转换，则直接添加到列表中</span></span><br><span class="line">      <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">        deepCopy.add(pv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行转换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> pv.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> pv.getValue();</span><br><span class="line">        <span class="comment">// 如果有必要，使用 BeanDefinitionValueResolver 转换属性值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resolvedValue</span> <span class="operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> resolvedValue;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">convertible</span> <span class="operator">=</span> bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">            !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">        <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">          convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将转换后的值放入 PropertyValue 进行缓存</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">          <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">            <span class="comment">// 将转换后的属性值缓存起来</span></span><br><span class="line">            pv.setConvertedValue(convertedValue);</span><br><span class="line">          &#125;</span><br><span class="line">          deepCopy.add(pv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">            !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">            !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">          pv.setConvertedValue(convertedValue);</span><br><span class="line">          deepCopy.add(pv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">          deepCopy.add(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(pv, convertedValue));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="literal">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">      mpvs.setConverted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置处理后的属性值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      bw.setPropertyValues(<span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(deepCopy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，主要工作是对属性值进行处理，这项工作由 BeanDefinitionValueResolver 的 resolveValueIfNecessary 方法完成。为此还创建了一个属性值的深拷贝列表，所有已经处理过的属性值都会被放入该列表中。当所有的属性值都处理完毕之后，使用 BeanWrapper 的 setPropertyValues 方法，将这个深拷贝列表传入，执行属性值注入的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.BeanDefinitionValueResolver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveValueIfNecessary</span><span class="params">(Object argName, <span class="meta">@Nullable</span> Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 属性值可以能是另一个 bean 的引用</span></span><br><span class="line">    <span class="comment">// 这个 RuntimeBeanReference 是在载入 BeanDefinition 时根据配置生成的</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">      <span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> (RuntimeBeanReference) value;</span><br><span class="line">      <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> evaluate(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object bean;</span><br><span class="line">      <span class="type">String</span> <span class="variable">refName</span> <span class="operator">=</span> ref.getBeanName();</span><br><span class="line">      refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">      <span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.getParentBeanFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">              <span class="built_in">this</span>.beanDefinition.getResourceDescription(), <span class="built_in">this</span>.beanName,</span><br><span class="line">              <span class="string">&quot;Can&#x27;t resolve reference to bean &#x27;&quot;</span> + refName +</span><br><span class="line">                  <span class="string">&quot;&#x27; in parent factory: no parent factory available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从父容器获取 bean</span></span><br><span class="line">        bean = <span class="built_in">this</span>.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从当前容器获取 bean</span></span><br><span class="line">        bean = <span class="built_in">this</span>.beanFactory.getBean(refName);</span><br><span class="line">        <span class="built_in">this</span>.beanFactory.registerDependentBean(refName, <span class="built_in">this</span>.beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">        bean = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到上面的 doCreateBean 方法，继续查看 initializeBean 部分的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">          beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，invokeAwareMethods 方法用来向 Aware 类型的接口注入它们需要的参数，比如 beanName、beanFactory 等。如果容器配置了 Bean 后置处理器，那么还会调用它们的 postProcessBeforeInitialization 方法，在 bean 完全初始化之前执行一些用户自定义的操作。如果当前 bean 是一个 <code>InitializingBean</code>，那么还会调用它的 afterPropertiesSet 方法完成一些自定义的配置验证和最终初始化工作。接下来会调用 bean 的 <code>init-method</code> 方法。当然，最终还会调用 Bean 后置处理器的 postProcessAfterInitialization 方法来，在 bean 完全初始化之后完成一些用户自定义的操作。</p>
<p>经过上面的分析，我们已经了解了 doCreateBean 方法的细节，接下来我们回到 doGetBean 方法，来看看 Spring 是如何处理最终返回给用户的 bean 实例的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查用户传入的 name 值，如果首字符是 &amp;，而从容器中获取到的却不是 FactoryBean，则直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果用户想要获取 FactoryBean 本身，或者从容器获取到的不是 FactoryBean，直接返回该 bean</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 能走到这里说明用户想要获取的不是 FactoryBean，而是通过 FactoryBean 得到的 bean 实例</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 先尝试从缓存中获取</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">      object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">      FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">      <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">      <span class="comment">// 通过 FactoryBean 获取 bean 实例</span></span><br><span class="line">      object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">        <span class="comment">// 先尝试从缓存获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 调用 FactoryBean 的 getObject 方法获取 bean 实例</span></span><br><span class="line">          object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">          <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">          <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">            object = alreadyThere;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">              &#125;</span><br><span class="line">              beforeSingletonCreation(beanName);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 后置处理</span></span><br><span class="line">                object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                    <span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">              <span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">      <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说来，如果用户想要获取的 bean 是一个 FactoryBean，那么根据用户传入的 bean 名称（首字符是否为 <code>&amp;</code>），选择返回 FactoryBean 对象还是返回通过调用它的 getObject 方法返回的对象。而如果用户想要获取的 bean 就是一个普通的 bean，那么直接返回。</p>
<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><p>在 Spring Bean 的生命周期中，框架为我们提供了一系列扩展方法方便我们调用，可以将这些方法大体分为：bean 级别和容器级别。</p>
<p>bean 级别的方法包括 bean 本身的方法，比如通过配置文件定义的 <code>init-method</code> 方法和 <code>destroy-method</code> 方法，以及 bean 实现的 <code>InitializingBean</code>、<code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>DisposableBean</code> 等接口的方法。</p>
<p>容器级别的包括 bean 后置处理器 <code>BeanPostProcessor</code> 和 <code>InstantiationAwareBeanPostProcessor</code> 接口的方法，以及 bean 工厂后置处理器 <code>BeanFactoryPostProcessor</code> 接口的方法等。</p>
<p>如下表格列出的是 Spring Bean 的一般生命周期以及生命周期中的扩展方法，按照从上到下的顺序依次进行。需要注意两个单词：<code>Instantiation</code> 和 <code>Initialization</code>，它们分别对应了 Bean 的两个生命周期阶段：实例化阶段和初始化阶段。</p>
<table>
<thead>
<tr>
<th>方法或过程</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BeanFactoryPostProcessor.postProcessorBeanFactory</td>
<td>可以对 bean 的定义（配置元数据）进行处理</td>
</tr>
<tr>
<td>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</td>
<td>在 bean 实例化之前执行一些操作</td>
</tr>
<tr>
<td>构造器方法</td>
<td>调用 bean 的构造器进行实例化</td>
</tr>
<tr>
<td>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</td>
<td>在 bean 实例化之后执行一些操作</td>
</tr>
<tr>
<td>InstantiationAwareBeanPostProcessor.postProcessPropertyValues</td>
<td>完成其他定制依赖注入和依赖检查等</td>
</tr>
<tr>
<td>属性值注入</td>
<td></td>
</tr>
<tr>
<td>BeanNameAware.setBeanName</td>
<td>设置 beanName</td>
</tr>
<tr>
<td>BeanFactoryAware.setBeanFactory</td>
<td>设置 BeanFactory</td>
</tr>
<tr>
<td>ApplicationContextAware.setApplicationContext</td>
<td>设置 ApplicationContext</td>
</tr>
<tr>
<td>BeanPostProcessor.postProcessBeforeInitialization</td>
<td>在 bean 初始化之前执行一些操作</td>
</tr>
<tr>
<td>InitializingBean.afterPropertiesSet</td>
<td>执行一些初始化操作</td>
</tr>
<tr>
<td>init-method 属性指定的方法</td>
<td>执行一些初始化操作</td>
</tr>
<tr>
<td>BeanPostProcessor.postProcessAfterInitialization</td>
<td>在 bean 初始化之后执行一些操作</td>
</tr>
<tr>
<td>DisposableBean.destroy</td>
<td>在 Bean 销毁之前，执行一些销毁操作</td>
</tr>
<tr>
<td>destroy-method 属性指定的方法</td>
<td>在 Bean 销毁之前，执行一些销毁操作</td>
</tr>
</tbody></table>
<p>除了上述方法，还有一些方法也可以影响 Bean 生命周期中执行的操作。比如 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解，它们是 JSR 250 规范中定义的注解，Spring 也支持这些注解。被 <code>@PostConstruct</code> 注解标注的方法会在当前 Bean 完成依赖注入之后调用；被 <code>@PreDestroy</code> 注解标注的方法会在当前 Bean 销毁之前调用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《Spring 技术内幕：深入解析 Spring 架构与计原理 (第 2 版)》</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 工具类之 ConfigurationClassParser</title>
    <url>/2019/05/05/Spring%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20ConfigurationClassParser/</url>
    <content><![CDATA[<p>ConfigurationClassParser 类主要用于分析带有 @Configuration 注解的配置类，产生 ConfigurationClass 配置类对象（使用该工具的类为 ConfigurationClassPostProcessor，它是一个 BeanFactoryPostProcessor，会在 Spring 容器启动时被调用）。  </p>
<span id="more"></span>

<p>ConfigurationClassParser 的外部调用入口为 parse 方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* configCandidates 是一组需要被分析的配置类的集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;DeferredImportSelectorHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="comment">// 获取 BeanDefinition</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 是 AnnotatedBeanDefinition</span></span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                <span class="comment">// 是 AbstractBeanDefinition 并且指定了 beanClass</span></span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(String className, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="built_in">this</span>.metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(reader, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Class&lt;?&gt; clazz, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(clazz, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会分析一个配置类。该方法从配置类开始遍历其所有需要处理的父类，每个类都调用 doProcessConfigurationClass 来处理，直到该类已经被处理过或者该类为 JDK 提供的类（即类的全限定名以 java 开头，比如 java.lang.Object）。所有被处理过的类都会保存到 this.configurationClasses 中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分析配置类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据当前提供的配置类去已经处理过的配置类集合中寻找</span></span><br><span class="line">    <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果配置类是某些类通过 @Import 导入的</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="comment">// 如果已经处理过的该配置类同样也是其他类通过 @Import 导入的</span></span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">// 合并两者的 importedBy</span></span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">            <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="built_in">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;</span><br><span class="line">                <span class="keyword">if</span> (configClass.equals(it.next())) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">    <span class="comment">// 从当前配置类 configClass 开始向上沿着类继承结构逐层执行 doProcessConfigurationClass，</span></span><br><span class="line">    <span class="comment">// 直到遇到父类是由 JDK 提供的类时结束循环</span></span><br><span class="line">    <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doProcessConfigurationClass 才是真正处理配置类的方法，具体的处理如下：  </p>
<ul>
<li>配置类的成员类也可能是配置类，所以先遍历这些成员配置类，然后分别调用 doProcessConfigurationClass 方法。</li>
<li>处理配置类上的 @PropertySources 和 @PropertySource 注解。</li>
<li>处理配置类上的 @ComponentScans 和 @ComponentScan 注解。</li>
<li>处理配置类上的 @Import 注解。</li>
<li>处理配置类上的 @ImportResource 注解。</li>
<li>处理配置类中每个带有 @Bean 注解的方法。</li>
<li>处理配置类所实现的接口的缺省方法。</li>
<li>检查父类是否需要处理，如果父类需要处理则该方法会返回父类，否则返回 null。</li>
</ul>
<blockquote>
<p>返回父类表示当前配置类尚未处理完成，processConfigurationClass 方法会继续处理其父类；返回 null 才表示该配置类的已经处理完成。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">    <span class="comment">// 处理 @PropertySources 注解，解析属性文件，将解析出来的属性资源添加到 environment</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">            org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">    <span class="comment">// 处理 @ComponentScan 注解</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @Import annotations</span></span><br><span class="line">    <span class="comment">// 处理 @Import 注解</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">    <span class="comment">// 处理 @ImportResource 注解。获取 @ImportResource 注解的 locations 属性，得到资源文件的地址，</span></span><br><span class="line">    <span class="comment">// 然后遍历这些资源文件并把它们添加到配置类的 importedResources 属性中</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process individual @Bean methods</span></span><br><span class="line">    <span class="comment">// 处理 @Bean 注解，获取被 @Bean 注解修饰的方法，然后添加到配置类的 beanMethods 属性中</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process superclass, if any</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (!superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp; !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 处理配置类上搜集到的 <span class="doctag">@Import</span> 注解</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 参数 configClass 配置类</span></span><br><span class="line"><span class="comment">* 参数 currentSourceClass 当前源码类</span></span><br><span class="line"><span class="comment">* 参数 importCandidates 所有的 <span class="doctag">@Import</span> 注解的 value</span></span><br><span class="line"><span class="comment">* 参数 checkForCircularImports 是否检查循环导入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">        Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">        <span class="comment">// 如果检测到了循环依赖，则报告错误</span></span><br><span class="line">        <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环处理所有的 @Import</span></span><br><span class="line">            <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">                <span class="comment">// 如果使用 @Import 导入的是 ImportSelector 类型的类</span></span><br><span class="line">                <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            selector, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.deferredImportSelectors != <span class="literal">null</span> &amp;&amp; selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.deferredImportSelectors.add(</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorHolder</span>(configClass, (DeferredImportSelector) selector));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用 selectImports 方法</span></span><br><span class="line">                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">                        processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果使用 @Import 导入的是 ImportBeanDefinitionRegistrar 类型的类</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                    <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">                            BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            registrar, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                    <span class="comment">// process it as an @Configuration class</span></span><br><span class="line">                    <span class="comment">// 其他类型都当作配置类处理，也就是相当于使用了 @Configuration 注解的配置类</span></span><br><span class="line">                    <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                    processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">                    configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://blog.csdn.net/andy_zhang2007/article/details/78549773">Spring 工具类 ConfigurationClassParser 分析得到配置类</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解之 @Conditional</title>
    <url>/2020/03/18/Spring%20%E6%B3%A8%E8%A7%A3%E4%B9%8B%20@Conditional/</url>
    <content><![CDATA[<p><code>@Conditional</code> 是 Spring 4 提供的新注解，它的作用是按照一定的条件进行判断，当满足条件时会给容器注册 bean。举个例子，比如说我们有一个接口，这个接口有多个实现类，当我们将这个接口交给 Spring 容器管理时通常只能选择其中一个作为实现类，但是我们又希望能够根据不同的情况注册不同的实现类，此时就可以使用该注解。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All &#123;<span class="doctag">@link</span> Condition Conditions&#125; that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</span></span><br><span class="line"><span class="comment">     * in order for the component to be registered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Condition</span>&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该注解可以在类、接口、注解、枚举以及方法上使用，并且该注解在编译和运行时都有效。该注解在使用时需要传入一个 Class 数组，数组元素的类型要求必须是 <code>Condition</code> 类型或它的子类。接下来我们查看 <code>Condition</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the condition matches.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata metadata of the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是一个函数式接口，该接口只有一个 matches 方法，在它的参数列表中，context 是 Condition 的上下文，包含 BeanDefinitionRegistry、BeanFactory、Environment 等信息，AnnotatedTypeMetadata 是使用了 <code>@Conditional</code> 注解的类型或方法的元数据，比如有一个类 WebMvcAutoConfiguration，它使用了 <code>@Conditional</code> 注解，那么 metadata 参数就是 WebMvcAutoConfiguration 的元数据。</p>
<p>在 Spring 的整个体系当中，广泛使用 <code>@Conditional</code> 注解家族成员的就是 Spring Boot，因为 Spring Boot 包含大量的自动配置类，它们需要根据不同的条件选择性地注册到 Spring 容器当中。因此接下来我们就根据 Spring Boot 继续向下分析，先查看实现了 Condition 接口的类 SpringBootCondition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SpringBootCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据元数据获取当前类或者方法的名称</span></span><br><span class="line">    	<span class="type">String</span> <span class="variable">classOrMethodName</span> <span class="operator">=</span> getClassOrMethodName(metadata);</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取条件匹配的结果</span></span><br><span class="line">            <span class="type">ConditionOutcome</span> <span class="variable">outcome</span> <span class="operator">=</span> getMatchOutcome(context, metadata);</span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            logOutcome(classOrMethodName, outcome);</span><br><span class="line">            <span class="comment">// 暂存结果数据</span></span><br><span class="line">            recordEvaluation(context, classOrMethodName, outcome);</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> outcome.isMatch();</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (NoClassDefFoundError ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Could not evaluate condition on &quot;</span> + classOrMethodName + <span class="string">&quot; due to &quot;</span></span><br><span class="line">                    + ex.getMessage() + <span class="string">&quot; not &quot;</span> + <span class="string">&quot;found. Make sure your own configuration does not rely on &quot;</span></span><br><span class="line">                    + <span class="string">&quot;that class. This can also happen if you are &quot;</span></span><br><span class="line">                    + <span class="string">&quot;@ComponentScanning a springframework package (e.g. if you &quot;</span></span><br><span class="line">                    + <span class="string">&quot;put a @ComponentScan in the default package by mistake)&quot;</span>, ex);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Error processing condition on &quot;</span> + getName(metadata), ex);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recordEvaluation</span><span class="params">(ConditionContext context, String classOrMethodName, ConditionOutcome outcome)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (context.getBeanFactory() != <span class="literal">null</span>) &#123;</span><br><span class="line">            ConditionEvaluationReport.get(context.getBeanFactory()).recordConditionEvaluation(classOrMethodName, <span class="built_in">this</span>,</span><br><span class="line">                    outcome);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ConditionOutcome <span class="title function_">getMatchOutcome</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBootCondition 的实现类有很多，我们这里挑选一个比较常见的实现类 OnClassCondition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OnClassCondition</span> <span class="keyword">extends</span> <span class="title class_">FilteringSpringBootCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConditionOutcome <span class="title function_">getMatchOutcome</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">        <span class="type">ConditionMessage</span> <span class="variable">matchMessage</span> <span class="operator">=</span> ConditionMessage.empty();</span><br><span class="line">        <span class="comment">// 通过 metadata 获取 ConditionalOnClass 注解中的属性值</span></span><br><span class="line">        List&lt;String&gt; onClasses = getCandidates(metadata, ConditionalOnClass.class);</span><br><span class="line">        <span class="keyword">if</span> (onClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过使用类加载器尝试加载注解中的值来判断该值是否存在，missing 存放的是不存在的类型</span></span><br><span class="line">            List&lt;String&gt; missing = filter(onClasses, ClassNameFilter.MISSING, classLoader);</span><br><span class="line">            <span class="keyword">if</span> (!missing.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 创建不匹配的结果</span></span><br><span class="line">                <span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)</span><br><span class="line">                        .didNotFind(<span class="string">&quot;required class&quot;</span>, <span class="string">&quot;required classes&quot;</span>).items(Style.QUOTE, missing));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建匹配的结果</span></span><br><span class="line">            matchMessage = matchMessage.andCondition(ConditionalOnClass.class)</span><br><span class="line">                    .found(<span class="string">&quot;required class&quot;</span>, <span class="string">&quot;required classes&quot;</span>)</span><br><span class="line">                    .items(Style.QUOTE, filter(onClasses, ClassNameFilter.PRESENT, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; onMissingClasses = getCandidates(metadata, ConditionalOnMissingClass.class);</span><br><span class="line">        <span class="keyword">if</span> (onMissingClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;String&gt; present = filter(onMissingClasses, ClassNameFilter.PRESENT, classLoader);</span><br><span class="line">            <span class="keyword">if</span> (!present.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnMissingClass.class)</span><br><span class="line">                        .found(<span class="string">&quot;unwanted class&quot;</span>, <span class="string">&quot;unwanted classes&quot;</span>).items(Style.QUOTE, present));</span><br><span class="line">            &#125;</span><br><span class="line">            matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)</span><br><span class="line">                    .didNotFind(<span class="string">&quot;unwanted class&quot;</span>, <span class="string">&quot;unwanted classes&quot;</span>)</span><br><span class="line">                    .items(Style.QUOTE, filter(onMissingClasses, ClassNameFilter.MISSING, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConditionOutcome.match(matchMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ConditionalOnClass</code> 在注解值中所有的类都存在时（通过尝试使用类加载器加载指定类的方式判断）才会匹配，此时也就意味着使用该注解的类将被注册到容器中。同理还有很多类似的注解，比如 <code>ConditionalOnMissingClass</code> 会在注解中所有的值都不存在时才会匹配，<code>@ConditionalOnBean</code> 会在注解中所有的值都在容器中存在时才会匹配，<code>@ConditionalOnProperty</code> 注解稍微复杂一点，它包含 prefix、name、havingValue、matchIfMissing 等属性。其中 prefix 表示配置文件中配置的前缀，name 表示具体的配置属性名称，havingValue 表示属性的值，matchIfMissing 表示如果所有的值都不满足时是否匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(OnPropertyCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnProperty &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组，对应 property 名称的值，与 name 不可同时使用</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性名称的前缀，比如 spring.http.encoding</span></span><br><span class="line">  String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组，属性完整名称或部分名称</span></span><br><span class="line">  <span class="comment">// 可与 prefix 组合使用，组成完整的配置属性名称，与 value 不可同时使用</span></span><br><span class="line">  String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可与 name 组合使用，比较获取到的属性值与 havingValue 给定的值是否相同，相同才加载配置</span></span><br><span class="line">  String <span class="title function_">havingValue</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缺少该配置属性时是否可以加载。如果为 true，没有该配置属性时也会正常加载；反之则不会生效</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">matchIfMissing</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，假如我们的配置为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># storage</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="comment"># 默认使用本机文件系统</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">filesystem</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="comment"># 图片存放目录</span></span><br><span class="line">    <span class="attr">imgFolder:</span> <span class="string">$&#123;user.home&#125;/saber/</span></span><br><span class="line">    <span class="comment"># 图片缓存时间控制，可以带单位</span></span><br><span class="line">    <span class="attr">cacheTime:</span> <span class="string">7d</span></span><br></pre></td></tr></table></figure>

<p>我们的注解为 <code>@ConditionalOnProperty(name = &quot;storage.type&quot;, havingValue = &quot;filesystem&quot;)</code>，那么使用这个注解的类就可以被加载到容器当中。</p>
<p>大概说完了 <code>@Conditional</code> 注解，到了这里我们还有一个疑惑就是，Spring 是在什么时候什么地方处理 <code>@Conditional</code> 注解的呢？答案就是在 ConfigurationClassParser 类中，具体的位置是在 processConfigurationClass 方法中，这里就不具体展开了。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解之 @Import</title>
    <url>/2017/07/22/Spring%20%E6%B3%A8%E8%A7%A3%E4%B9%8B%20@Import/</url>
    <content><![CDATA[<p>在 Spring 中，使用 <code>&lt;import&gt;</code> 标签或者 <code>@Import</code> 注解能够向容器中导入配置类（使用 <code>@Configuration</code> 注解的类），利用这个功能可以很方便地实现模块化配置的效果。从 Spring 官方文档给出的说明了解到，在 Spring 4.2 版本以前，<code>@Import</code> 注解只支持导入配置类，在 Spring 4.2 及以后的版本，该注解支持导入普通的 Java 类。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>@Import</code> 注解可以放在类、接口、注解和枚举上，我们简单写点代码来试验一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;ConfigA.class, ConfigB.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigC</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigC.class);</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> context.getBean(A.class);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> context.getBean(B.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了导入配置类，<code>@Import</code> 注解还有一些更高级的用法，那就是导入实现了 ImportBeanDefinitionRegistrar 接口或者 ImportSelector 接口的类。在这之前，我们需要知道 Spring 容器最终是通过 ConfigurationClassParser 工具类来解析该注解的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">    Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">        <span class="comment">// 导入的类实现了 ImportSelector 接口</span></span><br><span class="line">        <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">          Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">          <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">          ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">              selector, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">          <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">            <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用接口的 selectImports 方法</span></span><br><span class="line">            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">            Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">            processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 导入的类实现了 ImportBeanDefinitionRegistrar 接口</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">          Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">          <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">              BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">          ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">              registrar, <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">          configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 当做配置类处理</span></span><br><span class="line">          <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">              currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">          processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">          configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果导入的是一个 ImportSelector，那么在这里会调用它的 selectImports 方法获取更多需要导入到容器的类，典型的比如 Spring Boot 的 <code>@EnableAutoConfiguration</code> 自动装配注解。</p>
<p>如果导入的是一个 ImportBeanDefinitionRegistrar，那么会在这里将它添加到配置类的 importBeanDefinitionRegistrars 属性中。Spring 容器在初始化时，会通过 ConfigurationClassBeanDefinitionReader 的 loadBeanDefinitions 方法获取所有的 BeanDefinition：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> &#123;</span><br><span class="line">  <span class="type">TrackedConditionEvaluator</span> <span class="variable">trackedConditionEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrackedConditionEvaluator</span>();</span><br><span class="line">  <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">    loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> configClass.getBeanName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">  <span class="comment">// 调用 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions 方法</span></span><br><span class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多第三方框架在集成 Spring 的时候，都会通过实现 ImportBeanDefinitionRegistrar 接口将自定义的 BeanDefinition 注册到 Spring 容器中，比如 MyBatis 的 <code>@MapperScan</code> 注解。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Server 和 Application Server</title>
    <url>/2017/08/01/Web%20Server%20%E5%92%8C%20Application%20Server/</url>
    <content><![CDATA[<h1 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h1><p>Web Server（Web 服务器）是一种运行在服务器上的软件，它通过绑定服务器上的 IP 地址并监听某个 TCP 端口来接收 HTTP 请求，并将文本文件作为 HTTP 响应返回给客户端。</p>
<span id="more"></span>

<p>我们常说的 HTTP Server 可以理解为就是 Web Server。一般的 Web Server 默认不支持生成动态页面文件，可以通过引入其他模块（Shell、PHP、Python 脚本程序）来支持。典型的 Web Server 有 Apache、Nginx、IIS 等。</p>
<p>apache 官网的说明：</p>
<blockquote>
<p>The Apache HTTP Server (“httpd”) was launched in 1995 and it has been the most popular web server on the Internet since April 1996.</p>
</blockquote>
<h1 id="Application-Server"><a href="#Application-Server" class="headerlink" title="Application Server"></a>Application Server</h1><p>Application Server（应用服务器）在 Java 领域是指具备处理 HTTP 请求的能力，支持 JavaEE 技术比如 JMS、DI、JPA、Transactions、Concurrency 等，同时包含了 Web Container 的应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/8Ry.png" alt="app_server"></p>
<p>与 Web Server 只提供简单的静态页面文件访问相比，App Server 为客户端提供访问业务逻辑的接口，客户端可以通过 HTTP 协议或其他协议来调用逻辑、获取返回的结果。典型的 App Server 有 WebLogic、WebSphere 等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际使用中，谁扮演了某个角色，谁就可以叫这个名字。比如我使用 WebLogic 作为 Web Server，那么它就是一个 Web Server。可以看出，其实 Tomcat 也是一种 Web Server，只不过它处理静态页面文件的能力不如 Apache，但是它可以作为 JSP 和 Servlet 的容器（Web Container）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/NAW.png" alt="tomcat"></p>
<p>在应对大型分布式应用时，我们可以选择使用 WebLogic、WebSphere 等 App Server，当然也完全可以搭配 Nginx 等来组合使用，如使用 Nginx + WebLogic。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/pPL.png" alt="组合 "></p>
<p>对于中小型的应用，我们可以使用 Tomcat 作为容器，配和第三方的框架（Spring、Hibernate 等）来组成一个 App Server，当然也可以搭配 Nginx 等来组合使用。</p>
<blockquote>
<p>动静分离：使用 Nginx 反向代理分发请求，所有动态资源的请求交给 Tomcat，静态资源的请求（音视频、CSS、JS 文件等）则直接由 Nginx 返回到浏览器，这样能大大减轻 Tomcat 的压力。</p>
</blockquote>
<blockquote>
<p>负载均衡：当一个 Tomcat 的实例不足以处理所有的请求时，可以启动多个 Tomcat 实例进行水平扩展，Nginx 的负载均衡可以把请求通过算法分发到各个不同的实例进行处理。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/32212996">tomcat 与 nginx，apache 的区别是什么？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Web Server</tag>
        <tag>Application Server</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 之在子组件中改变父组件的状态</title>
    <url>/2020/04/26/Vue%20%E4%B9%8B%E5%9C%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%94%B9%E5%8F%98%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>一个 Vue 应用是由一个通过 new Vue 创建的根实例和可选的嵌套的、可复用的组件树组成。比如，一个应用可能是这样的：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根实例</span><br><span class="line">└─ TodoList</span><br><span class="line">   ├─ TodoItem</span><br><span class="line">   │  ├─ DeleteTodoButton</span><br><span class="line">   │  └─ EditTodoButton</span><br><span class="line">   └─ TodoListFooter</span><br><span class="line">      ├─ ClearTodosButton</span><br><span class="line">      └─ TodoListStatistics</span><br></pre></td></tr></table></figure>

<p>在这里，组件树节点之间形成了上下级的关系，也就是存在父组件与子组件这样的关系。如果我们想将父组件中的某些状态（数据）传递到子组件中，那么可以使用 <code>v-bind</code> 指令（或者 <code>:</code> 缩写）将父组件中的值绑定到子组件上，子组件使用 props 属性来接收这些传过来的值。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child :foo=&quot;foo&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;./Child&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Parent&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &#x27;hello&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;I am a child component.&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Child&#x27;,</span><br><span class="line">  props: [&#x27;foo&#x27;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，父组件与子组件之间的数据是<strong>单向下行绑定的</strong>，即父组件数据的更新会自动向下流动到子组件中，但是反过来则不行。这样可以防止子组件意外变更父组件的状态，从而导致应用的数据流向难以理解。同时，每次父组件发生变更时，子组件中所有的 prop 都会刷新为最新的值，这意味着我们不应该在一个子组件中直接修改 prop，如果直接修改，Vue 也会在浏览器的控制台中发出警告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. </span><br><span class="line">Instead, use a data or computed property based on the prop&#x27;s value ...</span><br></pre></td></tr></table></figure>

<p>在 Vue 官网中给出了两种常见的试图变更一个 prop 的情形。其中一种情况是，porp 传递的是一个初始值，这个子组件在接下来希望将其作为一个本地的 prop 数据来使用，这时最好是定义一个本地的 data 属性并将这个 prop 用作其初始值，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">initialCounter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种情况是，prop 以一种原始的值传入且需要进行转换，这时最好使用这个 prop 的值来定义一个计算属性，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedSize</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，官网也给出了一个警告信息，这个信息很重要，笔者之前就在这上面狠狠摔了一跤。官网写道：</p>
<blockquote>
<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中变更这个对象或数组本身将会影响到父组件的状态。</p>
</blockquote>
<p>这句话的意思是说，如果父组件传递给子组件的值是一个对象或数组，那么如果在子组件中直接修改这个对象的属性或者数组的元素，父组件中的状态也会跟着变化。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件的值：&#123;&#123; foo &#125;&#125;</span><br><span class="line">    &lt;Child :foo=&quot;foo&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;./Child&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Parent&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &#123;</span><br><span class="line">        bar: &#x27;hello&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;我是子组件中的值：&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;input v-model=&quot;foo.bar&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Child&#x27;,</span><br><span class="line">  props: [&#x27;foo&#x27;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当然这种直接修改父组件值的方式也是不推荐使用的，因为这种方式直接破坏了我们单向数据流的设定，容易造成数据流向难以理解的问题。一种更清晰的方式是：在子组件想要修改父组件的状态时，通过事件通知的方式告诉父组件我要修改哪个值，以及新值是多少，在父组件中需要预先定义好事件触发时对应触发的修改值的方法。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件的值：&#123;&#123; foo &#125;&#125;</span><br><span class="line">    &lt;Child :foo=&quot;foo&quot; v-on:update:bar=&quot;updateBar&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;./Child&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Parent&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &#123;</span><br><span class="line">        bar: &#x27;hello&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 父组件提供的修改 bar 值的方法</span><br><span class="line">    updateBar(val) &#123;</span><br><span class="line">      this.foo.bar = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;我是子组件中的值：&#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;input v-model=&quot;obj.bar&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Child&#x27;,</span><br><span class="line">  props: [&#x27;foo&#x27;],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj: this.foo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#x27;obj.bar&#x27;: function(val) &#123;</span><br><span class="line">      // 监听 bar 值的变动，发生变动时触发当前实例上的 update:bar 事件</span><br><span class="line">      // 将新值传给事件监听器回调</span><br><span class="line">      this.$emit(&#x27;update:bar&#x27;, val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当然这里还有更简便的写法，就是直接将更新的逻辑写到绑定事件上，同时使用 <code>v-on</code> 的语法糖简化写法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件的值：&#123;&#123; foo &#125;&#125;</span><br><span class="line">    &lt;Child :foo=&quot;foo&quot; @update:bar=&quot;foo.bar = $event&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;./Child&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Parent&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &#123;</span><br><span class="line">        bar: &#x27;hello&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这种父子组件进行“双向绑定”的模式比较固定，因此在 vue 2.3.0 就专门给这种模式新增了一个语法糖，即 <code>.sync</code> 修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是父组件的值：&#123;&#123; foo &#125;&#125;</span><br><span class="line">    &lt;Child :foo.sync=&quot;foo&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;./Child&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Parent&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &#123;</span><br><span class="line">        bar: &#x27;hello&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这种写法可以在我们用一个对象给子组件同时设置多个 prop 的时候，把对象中的每一个属性（比如这里的 bar 属性）都作为独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>XML 解析</title>
    <url>/2017/07/02/XML%20%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>在 Java 中解析 XML，主流常用的方法有四种：<strong>DOM、SAX、JDOM</strong> 和 <strong>DOM4J</strong>。</p>
<p>其中，DOM 和 SAX 是两种不同的 XML 解析方式，JDK 已经提供了支持 DOM 方式和 SAX 方式的具体实现，因此可以不引入第三方 jar 包来使用这两种解析方式。</p>
<span id="more"></span>

<p>JAXP（<code>Java API for XML Processing</code>）：JAXP 类库是 JDK 的一部分，它由以下几个包及其子包组成：</p>
<ul>
<li><code>org.w3c.dom</code><br>提供 DOM 方式解析 XML 的标准接口。		</li>
<li><code>org.xml.sax</code><br>提供 SAX 方式解析 XML 的标准接口。		</li>
<li><code>javax.xml</code><br>提供 StAX 方式解析 XML 的标准接口和解析 XML 的类。</li>
</ul>
<p>JDOM 和 DOM4J 是在这两种方式的基础上发展出的 XML 解析类库，看名字就知道这是只能在 Java 平台使用的类库。</p>
<p><strong>需要注意的是：DOM 和 SAX 是两种解析 XML 的方式，这两种方式与编程语言无关，针对不同的编程语言都有具体的实现。而在 Java 中，针对这两种方式及衍生方式实现的类库有很多，有 JDK 自带的 DOM 解析类库、SAX 解析类库和 StAX 解析类库（和 SAX 类似但有区别），还有第三方的 DOM4J 解析类库和 JDOM 解析类库等。</strong></p>
<h1 id="DOM（Document-Object-Model）"><a href="#DOM（Document-Object-Model）" class="headerlink" title="DOM（Document Object Model）"></a>DOM（Document Object Model）</h1><p>DOM 是与平台和编程语言无关的 W3C 的标准，基于 DOM 文档树，在使用时需要加载和构建整个文档形成一棵 DOM 树放在内存当中。</p>
<ul>
<li><p><strong>优点</strong>  </p>
<blockquote>
<p>允许应用程序对数据和结构做出更改，即 CRUD 操作。<br>访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据。		</p>
</blockquote>
</li>
<li><p><strong>缺点</strong>  </p>
<blockquote>
<p>需要加载整个 XML 文档来构造层次结构，文档越大，消耗资源越多。</p>
</blockquote>
</li>
</ul>
<p>在使用 DOM 的方式解析 XML 之前，需要了解 DOM 中的节点类型：</p>
<blockquote>
<p>W3C XML DOM 节点类型：<a href="http://www.w3school.com.cn/xmldom/dom_nodetype.asp">http://www.w3school.com.cn/xmldom/dom_nodetype.asp</a></p>
<p>常用的节点：</p>
</blockquote>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>描述</th>
<th>NodeType</th>
<th>nodeName</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>Document</td>
<td>表示整个文档（DOM 树的根节点）</td>
<td>9</td>
<td>#document</td>
<td>null</td>
</tr>
<tr>
<td>Element</td>
<td>表示 element（元素）元素</td>
<td>1</td>
<td>element name</td>
<td>null</td>
</tr>
<tr>
<td>Attr</td>
<td>属性名称</td>
<td>2</td>
<td>属性名称</td>
<td>属性值</td>
</tr>
<tr>
<td>Text</td>
<td>表示元素或属性中的文本内容</td>
<td>3</td>
<td>#text</td>
<td>节点内容</td>
</tr>
<tr>
<td>Comment</td>
<td>表示注释</td>
<td>8</td>
<td>#comment</td>
<td>注释文本</td>
</tr>
</tbody></table>
<p>DOM 解析过程及常用方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911241944/2018/04/14/ROd.png" alt="DOM_XML1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911241944/2018/04/14/W0W.png" alt="DOM_XML2"></p>
<p>使用 JAXP 的 DOM 解析方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- this is comment --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animate</span> <span class="attr">id</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> 希德尼娅的骑士 <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">published</span>&gt;</span>2014.04<span class="tag">&lt;/<span class="name">published</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">animate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animate</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> 恶之华 <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">published</span>&gt;</span>2013.04<span class="tag">&lt;/<span class="name">published</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">animate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animate</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> 化物语 <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">published</span>&gt;</span>2009.07<span class="tag">&lt;/<span class="name">published</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">animate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animate</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> 穿越时空的少女 <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">published</span>&gt;</span>2006.07<span class="tag">&lt;/<span class="name">published</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">animate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by nekolr on 2017/7/2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DOMResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URI</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/target/classes/nekolr.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 创建一个 DocumentBuilderFactory 对象</span></span><br><span class="line">        <span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">        <span class="comment">// 2 通过 factory 构建一个 DocumentBuilder 对象</span></span><br><span class="line">        <span class="type">DocumentBuilder</span> <span class="variable">db</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line">        <span class="comment">// 3 解析 uri 构建 Document</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> db.parse(URI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 document 的根节点</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">        <span class="comment">// 获取 document 的第一个节点，在这个例子里是注释</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">comment</span> <span class="operator">=</span> doc.getFirstChild();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 TagName 获取 NodeList</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nodeList</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;animate&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = nodeList.getLength(); i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeList.item(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.hasAttributes())</span><br><span class="line">                <span class="comment">// 节点的全部属性</span></span><br><span class="line">                printNodeAttrs(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有子节点 打印 Text</span></span><br><span class="line">            <span class="keyword">if</span> (!node.hasChildNodes())</span><br><span class="line">                System.out.println(<span class="string">&quot;nodeName=&quot;</span> + node.getNodeName() + <span class="string">&quot;, Text=&quot;</span> + node.getTextContent());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 节点的所有子节点</span></span><br><span class="line">            getChildNodes(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印节点的所有属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNodeAttrs</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">NamedNodeMap</span> <span class="variable">attrs</span> <span class="operator">=</span> node.getAttributes();</span><br><span class="line">        <span class="keyword">if</span> (!Objects.isNull(attrs)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; attrs.getLength(); i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">attr</span> <span class="operator">=</span> attrs.item(i);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> attr.getNodeName();<span class="comment">// 属性名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> attr.getNodeValue();<span class="comment">// 属性值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;nodeName=&quot;</span> + node.getNodeName() + <span class="string">&quot;, attr=&quot;</span> + name + <span class="string">&quot;, value=&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点的子节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getChildNodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">childNodes</span> <span class="operator">=</span> node.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childNodes.getLength(); j++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">child</span> <span class="operator">=</span> childNodes.item(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.hasAttributes())</span><br><span class="line">                    <span class="comment">// 打印所有属性</span></span><br><span class="line">                    printNodeAttrs(child);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!child.hasChildNodes())</span><br><span class="line">                    <span class="comment">// 节点的 Text</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;nodeName=&quot;</span> + child.getNodeName() + <span class="string">&quot;, Text=&quot;</span> + child.getTextContent());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    getChildNodes(child);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNodeType() == Node.TEXT_NODE &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(child.getNodeValue().trim())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;nodeName=&quot;</span> + node.getNodeName() + <span class="string">&quot;, Text=&quot;</span> + child.getTextContent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SAX（Simple-API-for-XML）"><a href="#SAX（Simple-API-for-XML）" class="headerlink" title="SAX（Simple API for XML）"></a>SAX（Simple API for XML）</h1><p>与 DOM 的方式不同，SAX 方式不需要构建整个文档，基于流模型中的推（PUSH）模型，由事件驱动，从文档开始顺序扫描，每发现一个节点就引发一个事件，事件推给事件处理器，通过回调方法完成解析，因此读取文档的过程就是解析文档的过程。使用 SAX 需要两部分：SAX 解析器和事件处理器，其中事件处理器需要开发者提供，一般通过继承默认的事件处理器 DefaultHandler，重写需要的方法即可。</p>
<ul>
<li><p><strong>优点</strong>		</p>
<blockquote>
<p>不需要等待所有数据都被处理，分析就能立即开始。		<br>只在读取数据时检查数据，不需要保存在内存中。		<br>可以在某个条件得到满足时停止解析，不必解析整个文档。		<br>效率和性能较高，能解析大于系统内存的文档。		</p>
</blockquote>
</li>
<li><p><strong>缺点</strong>  </p>
<blockquote>
<p>需要应用程序自己负责节点的处理逻辑（例如维护父&#x2F;子关系等），文档越复杂程序就越复杂。<br>单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持 XPath。	<br>只能读取文档，不能进行其他操作（新增、修改和删除）。</p>
</blockquote>
</li>
</ul>
<p>SAX 解析过程及使用：		<br>		<br><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911241944/2018/04/14/LyR.png" alt="SAX_XML1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911241944/2018/04/14/Ay3.png" alt="SAX_XML2"></p>
<p>使用 JAXP 的 SAX 解析方式（解析的 xml 同上）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.xml.sax.Attributes;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by nekolr on 2017/7/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SAXParserHandler</span> <span class="keyword">extends</span> <span class="title class_">DefaultHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isName</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isPublished</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;******文档解析开始******&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;******文档解析结束******&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;animate&quot;</span>.equals(qName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nodeName=&quot;</span> + qName + <span class="string">&quot;, id=&quot;</span> + attributes.getValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;name&quot;</span>.equals(qName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start element &quot;</span> + qName);</span><br><span class="line">            isName = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;published&quot;</span>.equals(qName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start element &quot;</span> + qName);</span><br><span class="line">            isPublished = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;end element &quot;</span> + qName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ch 代表节点中的所有内容，即每次遇到一个标签调用 characters 方法时，数组 ch 实际就是整个 XML 文档的内容</span></span><br><span class="line"><span class="comment">     * 如何每次去调用 characters 方法时我们都可以获取不同的节点属性？</span></span><br><span class="line"><span class="comment">     * 这时就必须结合 start（开始节点）和 length（长度）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">characters</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> start, <span class="type">int</span> length)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isName) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(ch, start, length));</span><br><span class="line">            isName = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPublished) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(ch, start, length));</span><br><span class="line">            isPublished = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.SAXParser;</span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.SAXParserFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by nekolr on 2017/7/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SAXDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URI</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/target/classes/nekolr.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1 获取一个 SAXParserFactory 对象</span></span><br><span class="line">        <span class="type">SAXParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SAXParserFactory.newInstance();</span><br><span class="line">        <span class="comment">// 2 获取一个 SAXParser 解析类对象</span></span><br><span class="line">        <span class="type">SAXParser</span> <span class="variable">parser</span> <span class="operator">=</span> factory.newSAXParser();</span><br><span class="line">        <span class="comment">// 3 将处理器对象放入解析器中</span></span><br><span class="line">        parser.parse(URI, <span class="keyword">new</span> <span class="title class_">SAXParserHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDOM（Java-based-Document-Object-Model）"><a href="#JDOM（Java-based-Document-Object-Model）" class="headerlink" title="JDOM（Java-based Document Object Model）"></a>JDOM（Java-based Document Object Model）</h1><p>为了减少 DOM 和 SAX 的编码量出现了 JDOM，JDOM 致力于成为 Java 特定文档模型，它遵循二八定律，底层仍然使用 DOM 和 SAX（使用 SAX 解析文档），并大量使用了 JDK 的 Collections。与 DOM 类似，JDOM 也将解析的 XML 以 DOM 树的方式放入内存中。</p>
<ul>
<li><p><strong>优点</strong></p>
<blockquote>
<p>不使用接口，使用具体实现类，简化了 DOM 的 API。		<br>大量使用 Collections，对 Java 开发友好。		</p>
</blockquote>
</li>
<li><p><strong>缺点</strong></p>
<blockquote>
<p>由于与 DOM 类似的生成 DOM 树结构，使得 JDOM 在处理大型 XML 文档时性能较差。		<br>灵活性差，不支持 DOM 中某些遍历。</p>
</blockquote>
</li>
</ul>
<p>JDOM 的使用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911241944/2018/04/14/4KA.png" alt="JDOM_XML1"><br>		<br><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911241944/2018/04/14/drg.png" alt="JDOM_XML2"></p>
<p>使用 JDOM 解析之前的 XML 文档，因为是第三方类库，需要引入 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- jdom2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jdom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdom2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jdom2.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.jdom2.Document;</span><br><span class="line"><span class="keyword">import</span> org.jdom2.Element;</span><br><span class="line"><span class="keyword">import</span> org.jdom2.input.SAXBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by nekolr on 2017/7/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDOMDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URI</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/target/classes/nekolr.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1 构建 SAXBuilder 对象</span></span><br><span class="line">        <span class="type">SAXBuilder</span> <span class="variable">saxBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXBuilder</span>();</span><br><span class="line">        <span class="comment">// 2 使用包装流读取文件时指定编码，防止乱码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(URI), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 3 构建 Document</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> saxBuilder.build(in);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取根节点</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getRootElement();</span><br><span class="line">        <span class="comment">//获取所有子节点</span></span><br><span class="line">        List&lt;Element&gt; animates = root.getChildren();</span><br><span class="line">        <span class="keyword">for</span> (Element animate : animates) &#123;</span><br><span class="line">            <span class="type">Attribute</span> <span class="variable">id</span> <span class="operator">=</span> animate.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;nodeName=&quot;</span> + animate.getName() + <span class="string">&quot; ,id=&quot;</span> + id.getValue());</span><br><span class="line"></span><br><span class="line">            List&lt;Element&gt; children = animate.getChildren();</span><br><span class="line">            <span class="keyword">for</span> (Element child : children) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;nodeName=&quot;</span> + child.getName() + <span class="string">&quot;, Text=&quot;</span> + child.getText());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DOM4J（Document-Object-Model-for-Java）"><a href="#DOM4J（Document-Object-Model-for-Java）" class="headerlink" title="DOM4J（Document Object Model for Java）"></a>DOM4J（Document Object Model for Java）</h1><p>DOM4J 大量使用 JDK 的 Collections，同时也提供了一些高性能的替代方法。支持 DOM、SAX 和 JAXP，支持 XPath。使用接口和抽象类，牺牲了部分 API 的简易性来获得更高的灵活性，同时在解析大型文档时内存占用较低。具有性能优异、功能强大、灵活性高、易用性强等优点，被现在很多开源项目使用。</p>
<p>使用 DOM4J 解析之前的 XML 文档，引入第三方 jar：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- dom4j --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by nekolr on 2017/7/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DOM4JDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URI</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/target/classes/nekolr.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1 构建 SAXReader 对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 2 读取 XML 文档</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> saxReader.read(URI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取根节点</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getRootElement();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> root.elementIterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">Element</span> <span class="variable">animate</span> <span class="operator">=</span> (Element) iterator.next();</span><br><span class="line">            <span class="type">Attribute</span> <span class="variable">id</span> <span class="operator">=</span> animate.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;nodeName=&quot;</span> + animate.getName() + <span class="string">&quot; ,id=&quot;</span> + id.getValue());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> animate.elementIterator(); iter.hasNext(); ) &#123;</span><br><span class="line">                <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) iter.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;nodeName=&quot;</span> + ele.getName() + <span class="string">&quot;, Text=&quot;</span> + ele.getText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>本文部分图片引用自：<a href="http://www.cnblogs.com/Qian123/p/5231303.html">http://www.cnblogs.com/Qian123/p/5231303.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>XML</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery 之 Promise</title>
    <url>/2017/08/20/jQuery%20%E4%B9%8B%20Promise/</url>
    <content><![CDATA[<p>由于在 JavaScript 中所有的代码都是单线程执行的，因此一些耗时的操作（如网络 I&#x2F;O）都采用异步的方式执行。在以前的 JavaScript 中，异步通常通过回调函数来实现，比较常见的就是 AJAX 请求成功和失败的回调函数。  </p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://api.example.com/v1&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="comment">// 请求得到响应后执行该函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="comment">// 请求失败执行该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是回调函数有一个很大的缺陷就是当有多个回调嵌套调用时，很容易陷入我们常说的<strong>回调地狱</strong>中。比如我们可能需要发起多次 AJAX 请求，每次都需要依赖上一次 AJAX 请求返回的结果来发起下一次 AJAX 请求。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://api.example.com/v1/saber&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">status</span>) &#123;</span><br><span class="line">            $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">                <span class="attr">url</span>: <span class="string">&#x27;https://api.example.com/v1/avalon&#x27;</span>,</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">                <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="comment">// 请求失败执行该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，JavaScript 社区最早提出了一种更为优雅和强大的方案，它就是 Promise。一开始有很多第三方的开源实现，包括 jQuery 自己实现的 Promise，直到 ES6 它才正式作为规范的一部分被写进了语言标准中。  </p>
<h1 id="jQuery-的-Promise"><a href="#jQuery-的-Promise" class="headerlink" title="jQuery 的 Promise"></a>jQuery 的 Promise</h1><p>与 ES6 标准不同的是，jQuery 实现的能进行异步链式调用的对象称为 deferred（延迟）。</p>
<p>在使用 <code>$.ajax()</code> 时，如果在 jQuery 1.5.0 以前，它返回的是 XHR 对象，与我们平常使用的 AJAX 没有什么区别；而在更高的版本中，它返回的是一个 deferred 对象，可以进行链式操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(<span class="string">&quot;https://api.example.com/v1/saber&quot;</span>)</span><br><span class="line">    .<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 请求成功，相当于 success 回调方法</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 请求失败，相当于 error 回调方法</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h2><p>deferred 对象有三种执行状态，分别为未完成、已完成和已失败。如果执行状态是<strong>已完成</strong>，则 deferred 对象会立即调用 done() 方法指定的回调函数；如果执行状态为<strong>已失败</strong>，则会调用 fail() 方法指定的回调函数；如果执行状态为<strong>未完成</strong>，则会继续等待，或者调用 progress() 方法指定的回调函数。  </p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>使用 $.deferred() 可以创建一个 deferred 对象，deferred 对象的方法主要分为两种，一种是改变执行状态的方法，另一种是状态改变时会调用的方法。  </p>
<ul>
<li>deferred.resolve()<br>可以改变 deferred 对象的运行状态为已完成。</li>
<li>deferred.reject()<br>可以改变 deferred 对象的运行状态为已失败。</li>
<li>deferred.done()<br>指定当运行状态为已完成时需要执行的回调函数。</li>
<li>deferred.fail()<br>指定当运行状态为已失败时需要执行的回调函数。</li>
<li>deferred.then()<br>指定当运行状态为已完成或者已失败时需要执行的回调函数，它可以看作是 done() 方法和 fail() 方法的结合，有时为了省事可以只使用 then() 方法。如果 then() 方法有两个参数，那么第一个参数就是 done() 方法的回调函数，第二个参数就是 fail() 方法的回调函数；如果只有一个参数，那么它等同于 done()。</li>
<li>deferred.always()<br>不管运行状态为已完成还是已失败，它最终总是会执行。</li>
<li>deferred.promise()<br>它的作用是在原来的 deferred 对象上返回一个新的 deferred 对象，这个新对象只开放与改变状态无关的方法，比如 done() 和 fail() 方法。</li>
</ul>
<p>还有一个相关的方法为 $.when()，它能够为多个操作指定回调方法。  </p>
<h2 id="指定多个回调函数"><a href="#指定多个回调函数" class="headerlink" title="指定多个回调函数"></a>指定多个回调函数</h2><p>deferred 对象允许添加任意多个回调函数。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(<span class="string">&quot;https://api.example.com/v1/saber&quot;</span>)</span><br><span class="line">    .<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是第一个成功执行&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是第二个成功执行&quot;</span>);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="多个操作指定回调函数"><a href="#多个操作指定回调函数" class="headerlink" title="多个操作指定回调函数"></a>多个操作指定回调函数</h2><p>deferred 对象允许对多个操作指定回调函数，如果都成功了，才会执行 done 方法指定的回调函数；如果有一个失败了或都失败了，就会执行 fail 方法指定的回调函数。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">when</span>($.<span class="title function_">ajax</span>(<span class="string">&quot;https://api.example.com/v1/saber&quot;</span>), $.<span class="title function_">ajax</span>(<span class="string">&quot;https://api.example.com/v1/avalon&quot;</span>))</span><br><span class="line">    .<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功执行&quot;</span>);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="普通操作指定回调函数"><a href="#普通操作指定回调函数" class="headerlink" title="普通操作指定回调函数"></a>普通操作指定回调函数</h2><p>由于 $.when() 方法的参数必须是一个 deferred 对象，因此自定义的函数最后应该返回 deferred 对象。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $deferred = $.<span class="title function_">deferred</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exec task&#x27;</span>);</span><br><span class="line">        $deferred.<span class="title function_">resolve</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> $deferred;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">when</span>(<span class="title function_">wait</span>()).<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task finished&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task failed&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="deferred-promise"><a href="#deferred-promise" class="headerlink" title="deferred.promise()"></a>deferred.promise()</h2><p>由于 $.Deferred() 创建的对象开放了改变其状态的方法，因此我们可以从外部改变它，比如：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $deferred = $.<span class="title class_">Deferred</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exec task&#x27;</span>);</span><br><span class="line">        $deferred.<span class="title function_">resolve</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> $deferred;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">when</span>(<span class="title function_">wait</span>()).<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task finished&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task failed&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外部改变它的状态</span></span><br><span class="line">$deferred.<span class="title function_">resolve</span>();</span><br></pre></td></tr></table></figure>

<p>为了避免这种情况，我们可以使用 deferred.promise() 方法，比如：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $deferred = $.<span class="title class_">Deferred</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exec task&#x27;</span>);</span><br><span class="line">        $deferred.<span class="title function_">resolve</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> $deferred.<span class="title function_">promise</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">when</span>(w = <span class="title function_">wait</span>()).<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task finished&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task failed&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时在外部改变状态无效</span></span><br><span class="line">w.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="comment">// 但是还是可以改变 $deferred 的状态</span></span><br><span class="line">$deferred.<span class="title function_">resolve</span>();</span><br></pre></td></tr></table></figure>

<p>这种写法只是将异步操作的返回值修改为了 deferred.promise()，而 deferred 对象还是暴露在全局环境下，所以更好的写法是将 deferred 封装进异步操作中。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> $deferred = $.<span class="title class_">Deferred</span>();</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exec task&#x27;</span>);</span><br><span class="line">        $deferred.<span class="title function_">resolve</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> $deferred.<span class="title function_">promise</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">when</span>(w = <span class="title function_">wait</span>()).<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task finished&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task failed&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时在外部改变状态无效</span></span><br><span class="line">w.<span class="title function_">resolve</span>();</span><br></pre></td></tr></table></figure>

<p>$.Deferred() 还可以接收一个函数名作为参数，$.Deferred() 方法生成的 deferred 对象将作为这个函数的默认参数。因此，我们还可以这么写：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params">$deferred</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exec task&#x27;</span>);</span><br><span class="line">        $deferred.<span class="title function_">resolve</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">setTimeout</span>(task, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 此处不用返回任何值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.<span class="title class_">Deferred</span>(wait).<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task finished&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">fail</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;task failed&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html">jQuery 的 deferred 对象详解</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN Promise</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 入门</title>
    <url>/2018/12/14/ZooKeeper%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>ZooKeeper 是由雅虎开源的一个分布式协调服务，它是 Google Chubby 的开源实现，它对外提供一组简单的原语，分布式应用可以通过使用这些原语来实现一些更高级的服务，比如：数据发布与订阅（配置中心）、负载均衡、命名服务、分布式协调与通知、集群管理、Master 选举、分布式锁和分布式队列等。  </p>
<span id="more"></span>  

<h1 id="ZooKeeper-的基本概念"><a href="#ZooKeeper-的基本概念" class="headerlink" title="ZooKeeper 的基本概念"></a>ZooKeeper 的基本概念</h1><h2 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h2><p>ZooKeeper 集群有三种角色，Leader、Follower 和 Observer。一个 ZooKeeper 集群在同一时刻只有一个 Leader。Leader 会在一次选举中产生，为客户端提供读和写服务。其他的节点都是 Follower 或 Observer，它们只提供读服务，并负责把写请求转发给 Leader。  </p>
<p>ZooKeeper 增加 Observer 角色是为了能在不影响集群写性能的情况下扩展集群，从而提高集群的读性能。由于写入操作需要集群中超过一半的 Follower 节点更新成功才会真正写入，为了提高集群读性能而增加 Follower 节点会因为网络消耗等原因导致投票的成本增加，从而造成集群的写入性能下降，而 Observer 与 Follower 不同的是它不参与 Leader 的选举过程，也不参与写操作的过半写成功策略。Observer 另外的一个优势就是，由于不参与选举和投票，所以即使它们从集群中断开也不会影响集群的可用性。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/12/14/0g2.jpg" alt="ZooKeeper 集群">  </p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>ZooKeeper 的数据模型是一个 ZNode 节点树，与标准的文件系统非常类似，该数据模型的命名空间使用斜杠（&#x2F;）进行分隔，每一个节点都由路径来标识。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/12/14/2z0.jpg" alt="ZooKeeper 数据模型">  </p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话指的是客户端与服务器之间的一个 TCP 长连接，客户端与服务端的一切交互都是通过这个长连接进行的。会话会在客户端身份验证失败或与服务器断开连接后，在设置的 sessionTimeout 时间内没有重新建立连接后失效。  </p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>节点在 ZooKeeper 中有两层含义，一种是集群中的一台机器，我们称为机器节点；一种是 ZooKeeper 数据模型中的数据单元，我们称为数据节点（ZNode）。  </p>
<p>与文件系统不同的是，ZNode 既是一个文件也是一个文件夹，它可以有与之相关联的子节点，同时它自身还存储数据，并且它还维护着一个 Stat 结构的数据，里面存储着一些状态信息，如数据的版本号、ACL 的版本号等，Stat 结构自身也包含一个时间戳。每次 ZNode 节点数据更新，相应的版本号会递增，客户端读取数据时，也会获取到数据的版本号。每个 ZNode 节点数据的读写都是原子性的，读操作将读取整个节点的数据，写操作也将替换整个节点的数据，同时每个节点都有一个 ACL（访问控制列表），用来说明谁可以做什么。  </p>
<p>ZNode 节点类型可以细分为四种，持久节点（Persistent Nodes）、持久连续节点（Persistent Sequential Nodes）、临时节点（Ephemeral Nodes）和临时连续节点（Ephemeral Sequential Nodes）。持久节点是指一旦这个 ZNode 创建成功，除非主动移除，否则这个节点会一直保存在 ZooKeeper 上。而临时节点会在创建该节点的会话处于活动状态时存在，在会话结束时删除，并且临时节点不能有子节点。至于持久连续节点和临时连续节点，除了保持上述特性外，还会在节点路径末尾附加一个单调递增的计数器，这个计数器由它的父节点维护，相对于父节点来说是唯一的。  </p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>ZooKeeper 设计的目标之一就是将复杂的操作简化，对外提供简单的接口，因此它仅支持以下操作：  </p>
<table>
<thead>
<tr>
<th>接口</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建一个 ZNode 节点</td>
<td>如果创建子节点，则父节点必须已经存在</td>
</tr>
<tr>
<td>delete</td>
<td>删除一个 ZNode 节点</td>
<td>该节点必须没有子节点</td>
</tr>
<tr>
<td>exists</td>
<td>检查节点是否存在，如果存在则返回节点信息</td>
<td></td>
</tr>
<tr>
<td>getData&#x2F;setData</td>
<td>获取&#x2F;设置节点的数据</td>
<td></td>
</tr>
<tr>
<td>getACL&#x2F;setACL</td>
<td>获取&#x2F;设置节点的 ACL</td>
<td></td>
</tr>
<tr>
<td>getChildren</td>
<td>获取子节点列表</td>
<td></td>
</tr>
<tr>
<td>sync</td>
<td>强制将客户端所访问的 ZooKeeper 服务器上的数据同步到最新状态</td>
<td>ZooKeeper 的写操作是原子性的，一个成功的写操作只保证数据被持久化到大多数 ZooKeeper 的服务器存储上，所以读操作可能会读取不到最新的数据，这时通过 sync 操作可以让客户端所访问的数据与 Leader 强制同步到最新状态</td>
</tr>
</tbody></table>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>ZooKeeper 允许客户端在指定的节点上注册一些 Watcher，在某些特定的事件触发时 ZooKeeper 会通知这些客户端。Watcher 设置一次只会触发一次，在收到通知后如果希望继续观察，则需要再次设置 Watcher。  </p>
<p>我们可以在执行读操作 exists、getData 和 getChildren 时设置 Watcher，在执行写操作 create、delete 和 setData 时将会触发 Watcher 事件，当然也可以在执行写操作时选择不触发。  </p>
<p><strong>当观察的节点被创建、删除或其数据发生改变时，设置在 exists 上的 Watcher 会被触发；当观察的节点被删除或其数据发生改变时，设置在 getData 上的 Watcher 会被触发；当观察的节点的子节点被创建、删除或者节点自身被删除时，设置在 getChildren 上的 Watcher 会被触发，可以通过 Watcher 事件的类型来判断被删除的是子节点还是它自身。</strong>  </p>
<p>由于事件包含了触发事件的 ZNode 的 path，所以我们可以通过 NodeCreated 和 NodeDeleted 事件知道是哪个节点被创建或删除，如果我们想知道 NodeChildrenChanged 事件发生后哪个子节点被改变了，就需要调用 getChildren 来获取一个新的子节点列表。类似的，在 NodeDataChanged 事件发生后，我们需要调用 getData 来获取新的数据。  </p>
<p>关于 Watcher 需要注意的是，因为是它一次性触发，并且设置 Watcher 和事件通知之间存在延迟，所以可能会发生收到通知和再次设置 Watcher 时节点已经发生了多次变化的情况。同时，如果客户端与服务器断开，在重新建立连接之前客户端将不会获得任何通知。  </p>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>ZooKeeper 使用 ACL 来控制对 ZNode 访问，ACL 与 UNIX 文件访问权限很像，但不同的是 ZooKeeper 的节点不受用户、组和其他这种范围的限制，ZooKeeper 没有 ZNode 所有者的概念，同时 ACL 仅适用于特定的节点，子节点不会继承父节点的 ACL。比如：设置 &#x2F;app 只能通过 ip 地址 172.16.16.1 读取，而 &#x2F;app&#x2F;status 设置的是 world 可读的，那么任何人都可以读取 &#x2F;app&#x2F;status。  </p>
<p>ACL 由鉴权方式、鉴权方式的 ID 和一个 permission 的集合组成。比如：我们想设置通过 ip 地址为 10.0.0.1 的客户端读取一个 ZNode，那么我们选择鉴权方式为 IP，鉴权方式的 ID 为 10.0.0.1，只允许读权限。在 Java 中类似下面的代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ACL</span>(Perms.READ, <span class="keyword">new</span> <span class="title class_">Id</span>(<span class="string">&quot;ip&quot;</span>, <span class="string">&quot;10.0.0.1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>ZooKeeper 内置了四种鉴权方式，包括 world、auth、digest 和 ip。  </p>
<table>
<thead>
<tr>
<th>ACL 鉴权方式</th>
<th>ACL ID（授权对象）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>world</td>
<td>anyone</td>
<td>表示任何人都有权限</td>
</tr>
<tr>
<td>auth</td>
<td>不使用 ID</td>
<td>任何通过身份验证的客户端都有权限</td>
</tr>
<tr>
<td>digest</td>
<td>MD5(username:password)</td>
<td>以明文的形式发送用户名和密码进行身份验证，在 ACL 中使用时，表达式形式为 <code>username:BASE64(SHA1(username:password))</code></td>
</tr>
<tr>
<td>ip</td>
<td>ip 地址</td>
<td>在 ACL 中表达式为 <code>addr/bits</code>。可以设置具体的 IP，也可以是 IP&#x2F;bits 的格式，即 IP 转换为二进制，匹配前 bits 位，如 <code>192.168.0.0/16</code> 匹配 <code>192.168.*.*</code></td>
</tr>
</tbody></table>
<p>下面列出的是所有的 permission。需要注意的是，exists 不受 ACL 的控制，任何客户端都可以使用 exists 操作来获取 ZNode 的状态。  </p>
<table>
<thead>
<tr>
<th>ACL 权限</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE</td>
<td>创建节点</td>
</tr>
<tr>
<td>READ</td>
<td>getData、getChildren</td>
</tr>
<tr>
<td>WRITE</td>
<td>setData</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除节点，可以删除子节点（仅下一级节点）</td>
</tr>
<tr>
<td>ADMIN</td>
<td>setACL</td>
</tr>
</tbody></table>
<h1 id="ZooKeeper-运行模式"><a href="#ZooKeeper-运行模式" class="headerlink" title="ZooKeeper 运行模式"></a>ZooKeeper 运行模式</h1><p>ZooKeeper 有两种运行模式，<strong>独立模式（standalone mode）和复制模式（replicated mode）</strong>。  </p>
<p>独立模式下只有一个 ZooKeeper 服务器，比较适合测试环境，但是不能保证高可用和恢复性。在生产环境中通常使用复制模式，将 ZooKeeper 运行在一个集群上，这个集群被称为一个集合体（ensemble）。  </p>
<p>ZooKeeper 通过复制来实现高可用性，只要集合体中半数以上的的机器处于可用状态，ZooKeeper 集群就能提供服务。比如：在一个有 5 个节点的集群中，有 2 个节点脱离集群，则服务还是可用的，因为剩下的 3 个节点仍然能够产生超过集群半数的投票来选举 Leader。而在 6 个节点的集群中最多也只能容忍 2 个节点宕机，因为超过 2 个节点离线后，集群就无法产生超过半数的投票了。<strong>所以 ZooKeeper 集群的节点数量一般都是奇数。</strong>  </p>
<h1 id="ZooKeeper-一致性原理"><a href="#ZooKeeper-一致性原理" class="headerlink" title="ZooKeeper 一致性原理"></a>ZooKeeper 一致性原理</h1><p>ZooKeeper 的核心是原子广播协议，通过该协议保证了各个服务器之间的同步，该协议有两种模式，<strong>恢复模式和广播模式</strong>。  </p>
<p>在 ZooKeeper 服务刚启动、Leader 崩溃或者集群半数节点脱离集群时会进入恢复模式，当领导者被重新选举出来，且大多数服务器完成了和 Leader 的同步之后，恢复模式结束。  </p>
<p>一旦 Leader 已经和大多数 Follower 完成了状态同步后，它就可以开始广播消息了。这时如果一个新的节点加入，它会在恢复模式下启动，发现 Leader 并和 Leader 进行状态同步，等到同步结束，它也会参与到消息广播中。ZooKeeper 服务一直维持在广播状态，直到 Leader 崩溃或者大多数 Follower 离线。  </p>
<p>消息广播模式很像分布式事务中的 2pc。在该模式中，ZooKeeper 所有的事务请求都会交给 Leader 来处理，再由 Leader 广播给 Follower，当超过半数的 Follower 已经完成了数据的更新，Leader 才会将更新提交。  </p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>ZooKeeper 是一个分布式数据管理和协调框架，采用 ZAB 一致性协议来保证分布式环境中数据的一致性，这样的特性使它成为解决分布式一致性问题的利器。  </p>
<h2 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h2><p>发布与订阅模型，也就是所谓的配置中心。发布者将数据发布到 ZooKeeper 的数据节点上，供订阅者动态的获取数据，从而实现配置的集中式管理和动态更新。常见的比如全局的应用配置信息，服务框架的服务地址列表等都适用。  </p>
<p>将应用中用到的一些配置信息放到 ZooKeeper 进行集中式的管理，这类场景通常是：应用启动时主动获取一次配置，同时在节点上注册 Watcher，在配置变更时会通知客户端，这样就可以再次获取最新的配置信息了。  </p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>这里所说的负载均衡指的是软负载均衡，其中比较典型的就是消息中间件的生产者和消费者的负载均衡。  </p>
<h2 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h2><p>在分布式系统中，通过命名服务，客户端可以通过指定的名称来获取资源或者服务的地址，服务的提供者等信息，被命名的实体通常可以是集群中的机器，提供服务的地址、远程对象等，这些都可以称为名字（Name）。其中最常见的就是分布式服务框架中的服务地址列表，通过调用 ZooKeeper 的创建节点 API 就能够很容易地创建一个全局唯一的 path，这个 path 就可以作为一个名称。  </p>
<p>在 Dubbo 中，服务提供者会在启动时，会向 ZooKeeper 上的指定节点 &#x2F;dubbo&#x2F;${serviceName}&#x2F;providers 写下自己的 URL 地址，这就完成了服务的发布。  </p>
<h2 id="分布式通知与协调"><a href="#分布式通知与协调" class="headerlink" title="分布式通知与协调"></a>分布式通知与协调</h2><p>利用 ZooKeeper 的 Watcher 注册和异步通知机制，可以很好的实现分布式环境中不同系统之间的通知与协调，实现对数据变更的实时处理。  </p>
<h2 id="集群管理与-Master-选举"><a href="#集群管理与-Master-选举" class="headerlink" title="集群管理与 Master 选举"></a>集群管理与 Master 选举</h2><p>集群管理通常存在一个集群监控系统，用来实时监测集群机器的状态。过去的做法通常是通过某种手段，比如通过 ping 来定时检测每台机器，这种做法可行但是不够灵活，且存在一定的时延。而通过 ZooKeeper 的 Watcher 和临时节点这两个特性，就可以实时的监控集群。例如：监控系统在 &#x2F;clusterServers 节点上注册了 Watcher，以后每动态增加一台机器，就往 &#x2F;clusterServers 节点下创建一个临时节点 &#x2F;clusterServers&#x2F;${hostname}，这样就能够实时知道集群机器的增减情况了。  </p>
<p>Master 选举则是 ZooKeeper 在分布式环境中最经典的应用场景了，很多时候相同的业务应用分布在不同的机器上，而有些业务逻辑往往只需要让集群中的某台机器执行，其他机器共享结果即可。此时可以利用在同一时刻，同时有多个客户端请求创建同一个节点时，ZooKeeper 保证最终只会有一个客户端的请求能够创建成功的特性来选出一台 Master。  </p>
<p>在动态 Master 选举场景中，则可以利用 ZooKeeper 的临时顺序节点。比如，同样是多个客户端同时提交创建节点请求，但是由于创建的是顺序节点，所以所有的请求都能够成功，但是创建出来的节点会类似这种：&#x2F;currentMaster&#x2F;{sessionId}-1，&#x2F;currentMaster&#x2F;{sessionId}-2，&#x2F;currentMaster&#x2F;{sessionId}-3，这样每次选取序号最小的那台机器作为 Master，如果这台机器挂了，由于是临时节点，在会话结束就会自动删除，所以此时的 Master 就是之后的那台机器了。  </p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>通过 ZooKeeper 实现的分布式锁服务主要有两种，一种是独占锁，一种是时序锁。  </p>
<p>独占锁就是所有试图获取这个锁的客户端，最终只有一个能够成功获得这把锁。通常的做法是将 ZooKeeper 上的一个 ZNode 看作一把锁，通过创建临时节点来实现获取锁的操作，而没有获取到锁的客户端需要在该临时节点上通过 exists 注册 Watcher，当获取锁的客户端因为宕机或者主动删除临时节点释放锁时，其他客户端就可以收到通知，从而重新发送创建临时节点的请求来继续竞争锁。  </p>
<p>时序锁其实可以看作是一种改进的独占锁，它通过控制时序来避免惊群效应。具体的思路就是，所有试图获取锁的客户端会在一个已经存在的节点下创建临时顺序节点，这样所有的客户端都能够成功创建临时顺序节点，然后客户端通过调用 getChildren 来获取父节点下的子节点列表（此时不要设置任何 Watcher，避免惊群效应），如果发现自己创建的子节点的 path 中的序号是最小的，那么就认为该客户端成功获取到了锁；如果发现自己创建的节点的 path 中的序号不是最小的，说明还没有获取到锁，此时客户端需要找到比自己小的那个相邻节点，然后对其调用 exists，同时注册监听事件。之后，如果被监听的节点被删除，则客户端会收到通知，此时再次通过 getChildren 来判断序号大小，如果自己创建的节点的 path 中的序号是最小的，那么就获取到了锁，否则重复之前的步骤。  </p>
<h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>通过 ZooKeeper 实现的分布式队列也有两种，一种是常规的先进先出队列，另一种则要等待所有的队列成员都准备就绪时才会统一按顺序执行的队列。  </p>
<p>FIFO 队列的实现与分布式锁服务中控制时序的实现原理一致。而第二种队列，其实是第一种的增强。通常可以在 &#x2F;queue 这个节点下预先建立一个子节点 &#x2F;queue&#x2F;num，赋值为 n 表示队列的大小（也可以在 &#x2F;queue 上直接赋值）。之后每次有队列成员加入，就在 &#x2F;queue 下创建临时有序节点，然后判断一下当前队列是否已经装满来决定是否可以按时序执行处理。这种用法的典型场景是：在分布式环境中，一个大任务需要很多子任务完成（或条件就绪）的情况下才能进行。  </p>
<h1 id="ZooKeeper-与-CAP"><a href="#ZooKeeper-与-CAP" class="headerlink" title="ZooKeeper 与 CAP"></a>ZooKeeper 与 CAP</h1><p>ZooKeeper 是满足 CP 特性的，即任何时刻对 ZooKeeper 的访问请求都能够得到最新的数据，同时对于网络分割具备容错性，但是它不保证每次请求的可用性，在一些极端情况下，ZooKeeper 会丢弃一些请求，客户端需要重新请求才有可能获得结果。但是别忘了，ZooKeeper 是分布式协调服务，它的职责就是保证数据在其管辖下的所有服务之间保持同步、一致，所以也就不难理解它为什么被设计成 CP 而不是 AP 的了。    </p>
<blockquote>
<p>在一致性上，有人认为 ZooKeeper 提供的是强一致性（通过 sync 操作），有人认为它只满足单调一致性（更新时的过半写成功策略），还有人认为它是最终一致性的（顺序一致性）。</p>
</blockquote>
<h1 id="最好不要用作服务发现"><a href="#最好不要用作服务发现" class="headerlink" title="最好不要用作服务发现"></a>最好不要用作服务发现</h1><p>在 2010 年的 11 月份，ZooKeeper 从 Apache Hadoop 的子项目发展成为 Apache 的顶级项目。到了 2011 年，阿里开源了 Dubbo，为了剥离与阿里内部系统的关系，更好的开源，Dubbo 选择了 ZooKeeper 作为其注册中心，但其实早在 2008 年的时候淘宝就已经有了自己的服务注册中心 ConfigServer。经过长时间的实践，现在普遍认为 ZooKeeper 用作服务发现并不是最佳的选择，因为注册中心其实应该是一个 AP 系统。关于这方面可以参考《Eureka! Why You Shouldn’t Use ZooKeeper for Service Discovery》这篇文章。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://jm.taobao.org/2011/10/08/1232/">ZooKeeper 典型应用场景一览</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/599997">阿里巴巴为什么不用 ZooKeeper 做服务发现？</a>  </p>
</blockquote>
<blockquote>
<p><a href="http://www.importnew.com/23025.html">Zookeeper 入门</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 反代 frp</title>
    <url>/2019/04/22/nginx%20%E5%8F%8D%E4%BB%A3%20frp/</url>
    <content><![CDATA[<p>最近需要用到内网穿透服务，突然想到手头正好有一台主机挺闲的，用来搭内网穿透服务再合适不过了。于是在网上搜寻一番，发现使用较多的是 frp 和 ngrok，但是 ngrok 的源代码只停留在 1.x，2.x 版本以及更新的服务只能通过注册使用，于是放弃了它转而使用 frp。  </p>
<span id="more"></span>

<p>服务端和客户端同时安装 frp 程序，安装和配置的过程都比较简单。在对应的平台下载对应的 release 包后，修改配置文件，启动即可。由于这台主机对外只开放了 80 和 443 端口，使用 nginx 提供反向代理，隐藏了内部的各个系统，同样的，我需要使用 nginx 反代 frp 的服务。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/xGr.png" alt="大体流程图"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl http2;</span><br><span class="line">    server_name  nat.nekolr.com;</span><br><span class="line">    </span><br><span class="line">    ssl_protocols       TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_certificate      /etc/letsencrypt/live/nekolr.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key  /etc/letsencrypt/live/nekolr.com/privkey.pem;</span><br><span class="line">    ssl_trusted_certificate  /etc/letsencrypt/live/nekolr.com/chain.pem;</span><br><span class="line">    </span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_pass http://localhost:6081;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page  404              /404.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="comment"># 公网环境中主机对外提供 web 服务端口</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">6081</span></span><br><span class="line"><span class="attr">log_file</span> = ./frps.log</span><br><span class="line"><span class="attr">log_level</span> = info</span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = 公网环境中的主机 IP</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="comment"># 内网环境中主机 web 服务端口</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">8080</span></span><br><span class="line"><span class="attr">custom_domains</span> = nat.nekolr.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title>redo 和 undo 概述</title>
    <url>/2020/07/11/redo%20%E5%92%8C%20undo%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>MySQL 的隔离性是通过锁机制来保证的，而原子性、一致性和持久性则是通过数据库的预写式日志（Write-Ahead Logging，WAL），具体来说是 redo log 和 undo log 来保证的。</p>
<span id="more"></span>

<h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p>redo log 也就是重做日志，用来实现事务的持久性，即 ACID 中的 D。我们知道 InnoDB 存储引擎是以页为单位来管理存储空间的，我们的增删改查等操作本质上都是在访问和操作数据页，而在真正访问数据页之前，需要先把磁盘上的数据页读到内存中，具体来说是 Buffer Pool 中。为了保证持久性（就是对于一个已经提交的事务，即使系统发生了崩溃，这个事务对数据库所做的更改也不能丢失），需要把内存中的修改同步回磁盘（fsync），一个简单的做法就是在事务提交之前将该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有几个问题。</p>
<p>首先，刷新一个完整的数据页过于浪费。有时我们可能仅仅修改了数据页中的一个字节，但是在事务提交之前却不得不将一个完整的数据页从内存刷新到磁盘。其次，随机 IO 刷新比较慢。一个事务可能包含多条语句，即使是一条语句也有可能需要修改多个数据页，而且修改的这些页面也有可能并不相邻，这就意味着将它们刷新到磁盘时，需要进行很多随机 IO，而随机 IO 要比顺序 IO 慢很多。</p>
<p>其实我们没有必要在每次事务提交时就把内存中所有修改过的页面都刷新到磁盘上，我们只需要把修改了哪些东西记录一下即可。比方说某个事务将系统表空间的第 100 号页面中的偏移量为 1000 的那个字节的值由 1 改为了 2，我们只需要记录这个即可。这样即使系统突然崩溃了，在重启之后只要按照上述内容重新更新一下数据页，系统就能恢复该事务对数据库所做的修改。</p>
<p>这样做有很多好处。首先，redo 日志所占用的空间很小。存储表空间的 ID、页号、偏移量以及需要更新的值，这些内容所需要的存储空间很小。同时并发的事务共享 redo log 存储空间，它们的 redo log 按照语句的执行顺序，依次交替地记录在一起，以减少日志占用的空间。其次，redo 日志其实是批量写入的。事务对数据页所做的更改不会直接写入日志文件，而是先写入 redo log buffer，然后再将 buffer 中的数据以每秒钟一次的频率一并写入日志文件中。同时 redo log 只进行顺序追加的操作，也就是说它使用的是顺序 IO，因此性能更好。</p>
<h2 id="数据丢失的问题"><a href="#数据丢失的问题" class="headerlink" title="数据丢失的问题"></a>数据丢失的问题</h2><p>对于随机写性能差的情况，常见的优化方法有两个：一个是先写日志，将随机写优化为顺序写；另一个就是将单次写优化为批量写。既然要实现批量写，就需要引入缓存。这里使用沈剑老师的图来展示 redo log 的三层架构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007131611/2020/07/13/yA2.png" alt="redo log 架构"></p>
<p>redo log 最终落盘的流程为：首先，事务提交时，会将对数据页的修改写入 log buffer。接着只有当 MySQL 发起系统调用写文件时，log buffer 中的数据才会写到系统缓存中。最后在写文件的系统调用完成后，还需要调用 fsync 方法落盘，这也是最慢的一步。如果不进行 flush，那么什么时候落盘是由操作系统决定的。</p>
<p>在 redo log 的三层架构中，MySQL 做了一次批量写优化，操作系统也做了一次批量写优化，这样确实能够提升性能，但是缺点也很明显。MySQL 在事务提交时，将 redo log 写入缓存中后，就会认为事务提交成功。如果 MySQL 在 log buffer 中的数据在写入操作系统缓存之前就崩溃了，那么就会出现数据丢失。同样的，如果在操作系统的缓存没有落盘之前，系统崩溃，那么也会出现数据丢失。</p>
<p>对于有的业务来说，可能允许性能较低但不允许数据丢失；而有的业务可能必须要高性能高吞吐，但是可以能够容忍少量的数据丢失。MySQL 提供了一个 <code>innodb_flush_log_at_trx_commit</code> 参数，通过它可以控制事务提交时 redo log 的刷新策略，从而适应不同的业务需要。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>目的</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>最佳性能</td>
<td>此时每隔一秒才会将 log buffer 中的数据批量地写入到操作系统缓存中，同时 MySQL 会主动调用 fsync。如果数据库发生崩溃，这种策略可能会导致 1 秒的数据丢失</td>
</tr>
<tr>
<td>1</td>
<td>强一致性</td>
<td>每次事务提交时，都会将 log buffer 中的数据写入到操作系统缓存中，同时 MySQL 会主动调用 fsync。<strong>这种策略是 MySQL 默认的策略</strong></td>
</tr>
<tr>
<td>2</td>
<td>平衡性能与一致性</td>
<td>每次事务提交时，都会将 log buffer 中的数据写入到操作系统缓存中，然后每隔一秒主动调用 fsync 将操作系统缓存落盘，由于操作系统也会不定时地调用 fsync，所以在这种策略下，如果操作系统崩溃，那么最多也就丢失 1 秒的数据，而操作系统与数据库相比，出现崩溃的概率更低</td>
</tr>
</tbody></table>
<h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>重做日志记录了事务的行为，通过它可以对数据页进行重做操作。但是事务有时还需要进行回滚，这时就需要记录回滚前的状态，比如插入一条记录，那么至少要把这条记录的主键值记录下来；修改一条记录，至少要把修改前的旧值记录下来。因此在对数据库进行修改时，InnoDB 存储引擎不但会产生 redo，还会产生一定量的 undo。这样如果用户执行的事务或者语句由于某种原因失败了，又或者用户使用 ROLLBACK 语句请求回滚，就可以利用这些 undo 信息将数据回滚到修改之前的状态。</p>
<p>undo 存放在数据库内部的一个特殊段（segment）中，这个段叫做 undo 段（undo segment）。默认情况下，undo 段位于共享表空间内，当然也可以通过配置将部分段放到自定义的 undo 表空间中，不过只能在系统初始化（创建数据目录）的时候指定。</p>
<p>事实上 undo 只是逻辑日志，使用它并不能将数据库物理地恢复到执行语句或事务之前的状态，只能将数据库逻辑地恢复到之前的状态，所有的修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。这是因为实际上可能会有数十、数百甚至上千个并发事务在访问数据库，可能一个事务在修改当前页的某几条记录，而同时还有别的事务也在修改同一页的其他几条记录，因此不能将一个数据页回滚到事务开始的状态，这样会影响其他事务正在进行的工作。比如用户执行了一个新增 10 万条记录的事务，这个事务会导致分配一个新的段，即表空间会增大。在用户执行 ROLLBACK 之后，会将插入的数据全部删除，但是表空间并不会因此而收缩。</p>
<p>除了回滚操作，undo 的另外一个作用是 MVCC。即在 InnoDB 存储引擎中 MVCC 是通过 undo 来完成的。当用户读取一条记录时，如果该记录已经被其他事务占用，当前事务可以通过 undo 来读取之前的版本的行信息，以此实现非锁定读取。</p>
<p>需要注意的是，undo log 也会产生 redo log，这是因为 undo log 也需要持久性的保证。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&chksm=bd2d0bdb8a5a82cd50bc155ed2ba57f105bfd76ff78992823ed85214b5c767eef17e691a2255&idx=1&mid=2651962887&scene=21&sn=4806f481448b1c3ddfbbd53e732a7bb5">事务已提交，数据却丢了，赶紧检查下这个配置！！！</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>一次 Git 踩坑记录</title>
    <url>/2018/09/14/%E4%B8%80%E6%AC%A1%20Git%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>在不同的操作系统下，文本文件使用的换行符是不一样的。UNIX&#x2F;Linux 使用的是 LF，对应的十六进制编码为 0x0A，而 DOS&#x2F;Windows 使用的是 CRLF，对应的十六进制编码为 0x0D0A。一般的开源项目，源代码都是使用 UNIX&#x2F;Linux 风格保存的，这么做是为了统一文本风格，使源代码不论在哪个平台下，显示都是一致的。这在多人协作开发，尤其是团队成员使用的平台不同时尤为重要。</p>
<span id="more"></span>

<p>由于我使用的开发平台是 Windows，因此就犯了提交的代码文本风格全部为 CRLF 的错误。这些代码在 UNIX&#x2F;Linux 平台使用 vim 打开时，就会是以下的样子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/09/14/Lkp.png" alt="错误的文本风格"></p>
<p>可以看到，所有应该是回车的地方都多出来了 ^M（如果使用 vim 打开不是这样的，可以输入 :e ++ff&#x3D;UNIX 调整显示）。</p>
<p>那么该如何统一规范呢？首先说第一种情况。</p>
<h2 id="Git-仓库中源代码为-CRLF-风格"><a href="#Git-仓库中源代码为-CRLF-风格" class="headerlink" title="Git 仓库中源代码为 CRLF 风格"></a>Git 仓库中源代码为 CRLF 风格</h2><p>此时为了统一成 LF 风格，我们需要借助一些工具来将仓库中的所有代码文本中的 ^M 替换掉。在 Linux 中有一个工具特别好用：dos2unix。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dos2unix [options] [file ...] [-n infile outfile ...]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-k：保持输出文件的日期不变 </span><br><span class="line">-q：安静模式，不提示任何警告信息</span><br><span class="line">-V：查看版本</span><br><span class="line">-c：转换模式，模式有：ASCII, 7bit, ISO, Mac, 默认是：ASCII</span><br><span class="line">-o：写入到源文件</span><br><span class="line">-n：写入到新文件</span><br></pre></td></tr></table></figure>

<p>由于 dos2unix 替换文件只能通过枚举的方式，所以再借助 <code>xargs</code> 命令来实现批量替换。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 查找 demo 目录下的所有后缀为 java 的文件替换</span><br><span class="line">find demo/ -name &quot;*.java&quot; | xargs dos2unix -o</span><br><span class="line"></span><br><span class="line">:: 查找 demo 目录下的所有的文件替换</span><br><span class="line">find demo/ -type f | xargs dos2unix -o</span><br></pre></td></tr></table></figure>

<p>将所有文件替换好后提交到 Git 仓库中。</p>
<h2 id="Git-仓库中源代码为-LF-风格"><a href="#Git-仓库中源代码为-LF-风格" class="headerlink" title="Git 仓库中源代码为 LF 风格"></a>Git 仓库中源代码为 LF 风格</h2><p>这样的情况肯定是好的，接下来我们该做的就是规范我们的提交。</p>
<p>一种方式是依赖于 Git 客户端提供的自动转换功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf true</span><br></pre></td></tr></table></figure>

<p>这样设置，在提交代码时，会自动将 CRLF 转换成 LF，在 checkout 回本地时，会自动将 LF 转换成 CRLF。</p>
<p>如果你使用的是 Linux 或者是 Mac，可以进行如下的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>

<p>这样在提交代码时会自动将 CRLF 转换成 LF，而在 checkout 时则不会进行转换。</p>
<p>另一种方式就比较严格了。首先关闭 Git 客户端的自动转换，同时设置 IDE 的换行符为 UNIX&#x2F;Linux 风格。比如在 IDEA 下：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/09/14/4kd.png" alt="UNIX 风格换行"></p>
<h2 id="统一规范（仅参考）"><a href="#统一规范（仅参考）" class="headerlink" title="统一规范（仅参考）"></a>统一规范（仅参考）</h2><ul>
<li>关闭 Git 客户端自动转换。</li>
<li>设置 IDE 换行为 UNIX&#x2F;Linux 风格。</li>
<li>设置项目编码为 UTF-8 without BOM。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/09/14/lqv.png" alt="utf-8"></p>
<ul>
<li>如果是 maven 项目，自定义合适的配置。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/09/14/dy8.png" alt="maven"></p>
<ul>
<li>设置 Tab 为四个空格。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/cssmagic/blog/issues/22">GitHub 第一坑：换行符自动转换</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>为何匿名内部类的参数引用要用 final 修饰</title>
    <url>/2018/05/29/%E4%B8%BA%E4%BD%95%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E8%A6%81%E7%94%A8%20final%20%E4%BF%AE%E9%A5%B0/</url>
    <content><![CDATA[<p>在 JDK 8 中，我们已经可以不用使用 <code>final</code> 修饰了，这是因为引入了 <code>effectively final</code> 的概念，实际上还是不能在匿名内部类中修改自由变量的值，Lambda 表达式也一样。上一篇文章“Java 闭包”中已经说明了原因，这里针对 Java 中自由变量的位置详细分析一下。</p>
<span id="more"></span>  

<p>匿名内部类（或 Lambda 表达式）中，引用外部环境中的自由变量，这个自由变量可能是：外部类的成员变量、外部类方法参数或方法体中的局部变量。</p>
<h2 id="外部类的成员变量"><a href="#外部类的成员变量" class="headerlink" title="外部类的成员变量"></a>外部类的成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> w;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里可以修改外部环境中的变量</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setW</span><span class="params">()</span> &#123;</span><br><span class="line">                w = <span class="number">12</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚说过匿名内部类中不能修改外部环境中的自由变量，这么快就打脸了？并不是，查看匿名内部类编译后的代码为：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">implements</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    Outer$<span class="number">1</span>(Outer <span class="built_in">this</span>$<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0.</span>w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setW</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0.</span>w = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，匿名内部类中持有一个外部类的引用，而自由变量 w 又是外部类的成员变量，所以完全可以通过外部类的引用来获取这个变量，然后对这个变量进行任何操作。  </p>
<h2 id="外部类的方法参数或局部变量"><a href="#外部类的方法参数或局部变量" class="headerlink" title="外部类的方法参数或局部变量"></a>外部类的方法参数或局部变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> x + y + z;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里会报错</span></span><br><span class="line">            <span class="comment">// Variable &#x27;x&#x27; is accessed from within inner class, </span></span><br><span class="line">            <span class="comment">// needs to be final or effectively final</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">()</span> &#123;</span><br><span class="line">                x = <span class="number">12</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，反编译查看编译后的匿名内部类，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">implements</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    Outer$<span class="number">1</span>(Outer <span class="built_in">this</span>$<span class="number">0</span>, <span class="type">int</span> var2, <span class="type">int</span> var3) &#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.val$x = var2;</span><br><span class="line">        <span class="built_in">this</span>.val$y = var3;</span><br><span class="line">        <span class="built_in">this</span>.z = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val$x + <span class="built_in">this</span>.val$y + <span class="built_in">this</span>.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，匿名内部类中持有外部类的一个引用 <code>this$0</code>，同时，Java 编译器将匿名内部类依赖的外部环境，具体是外部类方法参数和方法体中的局部变量拷贝了一份传入匿名内部类中。  </p>
<p>我们知道，Java 是值传递的。当值是基本类型时，传递的是值的拷贝；当值是引用类型时，传递的是引用的拷贝，无论你怎么改变这个新的引用的指向，原来的引用的指向不变，如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">(String name, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Inner&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, number=&quot;</span> + number +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeRef</span><span class="params">(Inner inner)</span> &#123;</span><br><span class="line">        <span class="comment">// 引用的拷贝指向的对象和原来的引用指向的对象是同一个</span></span><br><span class="line">        System.out.println(inner.number = <span class="number">2333</span>);</span><br><span class="line">        <span class="comment">// 改变引用的拷贝的指向，原来的引用指向的对象不会改变</span></span><br><span class="line">        inner = <span class="keyword">new</span> <span class="title class_">Inner</span>(<span class="string">&quot;saber&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(inner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>(<span class="string">&quot;avalon&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        changeRef(inner);</span><br><span class="line">        System.out.println(inner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2333</span><br><span class="line">Inner&#123;name=&#x27;saber&#x27;, number=1&#125;</span><br><span class="line">Inner&#123;name=&#x27;avalon&#x27;, number=2333&#125;</span><br></pre></td></tr></table></figure>

<p>回归正题，因为 Java 只实现了值捕获，所以匿名内部类中使用的自由变量是原来的自由变量值的一个副本（基本类型是值的副本，引用类型是引用地址值的副本），修改它们的值并不会影响外部环境中的自由变量，为了让使用者使用起来感觉和引用捕获一样，Java 干脆做了限制：在 JDK 8 以前，必须使用 <code>final</code> 修饰，在 JDK 8 以后，可以不用 <code>final</code> 修饰，但是变量必须是有效只读的，即 <code>effectively final</code> 的。这样大家一看是 <code>final</code> 的，就不会去修改它了，即便修改也会编译器报错。即使以后 Java 实现了引用捕获，也不会和已有的代码发生不兼容。  </p>
<blockquote>
<p>注：虽说匿名内部类中不能修改外部环境中的自由变量的值，但如果自由变量是引用类型的，我们可以修改引用指向的对象的属性。  </p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.zhihu.com/question/21395848">java 为什么匿名内部类的参数引用时 final？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/06/05/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式也叫做委托模式，许多其他的模式，比如状态模式、策略模式、访问者模式等本质上都是在更加特殊的场景中采用了委托模式。有时候我们可能会把代理模式与装饰器模式搞混，简单来说，装饰器模式更加专注于向对象动态地添加或增强功能，而代理模式则更专注于控制对对象的访问。装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能，但是增强后的你还是你，只不过能力更强了而已。代理模式则强调要让别人帮你去做一些与你本身没有太大关联的职责，比如记录日志、设置缓存等。</p>
<span id="more"></span>

<p>有的时候我们可能不能直接访问一个对象，只能通过代理来间接访问，比如这个对象在另外一台机器，这其实就是 RPC，我们在本地访问的是远程对象的代理。或者对象被持久化了，比如 MyBatis 的 mapperProxy，通过 mapper 文件自动生成代理类。从编译器的角度来看，装饰器模式无法在编译期就确定一个对象的功能，需要在运行时动态地给对象添加职责，因为这些功能都是使用者在使用时动态配置的；而代理模式在编译期就已经确定了和代理对象的关联。</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202006052151/2020/06/05/l3k.png" alt="代理模式"></p>
<p>在代理模式中，Subject 抽象主题角色可以是抽象类也可以是接口，它是一个最普通的业务类型定义。RealSubject 是具体的主题角色，继承或实现了抽象主题角色，是业务逻辑的具体执行者，同时也是被代理的角色。Proxy 代理类负责把抽象主题类中定义的方法委托给具体主题类来实现，并在具体主题类的方法前后做预处理和善后处理工作。</p>
<p>这种代理模式也叫做静态代理，从 UML 图中可以看出，要代理的目标类和代理类都实现或继承了一个接口或抽象类，代理类持有一个目标类的对象，在执行操作时，其实是调用的目标对象的方法。静态代理类的作用类似一个中介，然而为了一个中介我们就要创建一个类，如果在系统中大量使用静态代理，就会造成系统中类的规模增大，导致系统比较臃肿。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理的出现就是为了弥补静态代理为了使用代理就要真实创建代理类的缺陷，动态代理只需要有 Subject 和 RealSubject 就可以产生代理类并将它加载到内存当中，不需要我们手动创建。目前常见的动态代理有两种，包括 JDK 动态代理和 cglib 动态代理。</p>
<p>在面向对象的编程当中，如果我们想约定 Proxy 类与 RealSubject 类要实现相同的功能，一般有两种方式：其中一种就是定义一个业务接口，然后让 Proxy 和 RealSubject 都实现这个接口；另一种就是让 Proxy 类直接继承 RealSubject 类，这样 Proxy 类就拥有了 RealSubject 的功能。JDK 动态代理使用的就是第一种方式，即面向接口的代理；而 cglib 使用的是第二种方式，即通过操纵字节码来继承要代理的类，因此这种方式有一个缺陷就是无法代理被 final 修饰的类。</p>
<h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2><p>我们不牵扯业务，就单纯以 Subject 主题为例，看看 JDK 的动态代理是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;operation...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 目标实例</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 调用前置处理</span></span><br><span class="line">        <span class="built_in">this</span>.before();</span><br><span class="line">        <span class="comment">// 调用目标实例指定的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(<span class="built_in">this</span>.target, args);</span><br><span class="line">        <span class="comment">// 调用后置处理</span></span><br><span class="line">        <span class="built_in">this</span>.after();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个主题</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        <span class="comment">// 创建 Handler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(subject);</span><br><span class="line">        <span class="comment">// 获取类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> subject.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 获取接口数组</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = subject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 创建主题的代理对象</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">proxySubject</span> <span class="operator">=</span> (Subject) Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxySubject.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来分析源码，可以看到代理对象是通过 Proxy.newProxyInstance() 方法创建的，这是 JDK 动态代理的关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取代理类的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取代理类的构造函数</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过构造函数创建代理类的实例，创建实例时传入 InvocationHandler 对象</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Proxy.newInstance() 方法首先获取了代理类的 Class 对象，然后通过这个 Class 对象获取代理类的构造函数，最后通过构造函数创建了一个代理类的实例，在创建代理类实例时还传入了一个 InvocationHandler 对象。接下来再看看它是如何获取代理类的 Class 对象的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中取。如果缓存中不存在就使用 ProxyClassFactory 生成</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key, P parameter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply 方法是创建代理对象的关键</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">subKey</span> <span class="operator">=</span> Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 省略以下部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">    <span class="comment">// 省略以上部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是生成 Class 文件的代码</span></span><br><span class="line">    <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">        proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                            proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，Proxy 类中定义了一个名称为 proxyClassCache 的 WeakCache。也就是说，在调用 get 方法获取代理类的 Class 对象的时候，如果缓存中有，则直接取出，如果没有，则使用 ProxyClassFactory 的 apply 方法创建一个。而在 apply 方法中，有一个方法非常重要，它就是 generateProxyClass 方法，该方法会生成代理类的二进制字节码文件，然后使用对应的类加载器加载这个字节码文件，就可以得到对应的 Class 对象。由于我很好奇通过这种方式生成的 Class 文件到底是什么样子的，于是就写了下面一个小工具，将生成的字节码文件持久化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateProxyClassFile</span><span class="params">(Class clazz, String proxyName)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> clazz.getResource(<span class="string">&quot;.&quot;</span>).getPath();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">output</span> <span class="operator">=</span></span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path + proxyName + <span class="string">&quot;.class&quot;</span>))) &#123;</span><br><span class="line">            output.write(proxyClassFile);</span><br><span class="line">            output.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generateProxyClassFile(RealSubject.class, <span class="string">&quot;SubjectProxy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SubjectProxy</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubjectProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.github.nekolr.Subject&quot;</span>).getMethod(<span class="string">&quot;operation&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该代理类有几个特征：实现了 Subject 接口，继承 Proxy 类。构造函数中有形参 InvocationHandler，这就是为什么在 Proxy.newProxyInstance 方法中，通过构造函数创建代理类的实例时传入了一个 InvocationHandler 对象。代理类中实现的接口方法都是通过最终都通过 InvocationHandler 来处理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/41988550">Java 中“装饰模式”和“代理模式”有啥区别？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 HSDB 调试 HotSpot</title>
    <url>/2018/04/17/%E4%BD%BF%E7%94%A8%20HSDB%20%E8%B0%83%E8%AF%95%20HotSpot/</url>
    <content><![CDATA[<p>环境说明：</p>
<ul>
<li>OS：Windows 10</li>
<li>JDK：Oracle JDK 1.8.0_144</li>
</ul>
<span id="more"></span>

<p>使用以下代码进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HotSpot VM 运行时数据区测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Test2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">    <span class="type">Test2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Test2</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><p>首先需要确保环境变量 JAVA_HOME、PATH 和 CLASSPATH 配置成功。</p>
<h1 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/Xzp.png" alt="编译代码"></p>
<h1 id="启动-jdb"><a href="#启动-jdb" class="headerlink" title="启动 jdb"></a>启动 jdb</h1><p>我们在使用 IDE 时，可以很方便地在代码中打上断点进行调试，如果不依赖 IDE，我们可以使用 Oracle JDK 自带的 <code>jdb</code> 工具来完成这项任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/PPk.png" alt="启动 jdb"></p>
<p>启动 <code>jdb</code> 时，设定 java 程序使用 <code>Serial GC</code> 和 10MB 的堆内存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/y2j.png" alt="设置断点"></p>
<p>使用 <code>stop in</code> 命令在指定的 java 方法入口处设置断点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/zry.png" alt="run"></p>
<p>使用 <code>run</code> 命令指定主类来启动 Java 程序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/x38.png" alt="next"></p>
<p>使用 <code>next</code>、<code>step</code> 等命令来控制前进。</p>
<h1 id="使用-jps-查看进程-id"><a href="#使用-jps-查看进程-id" class="headerlink" title="使用 jps 查看进程 id"></a>使用 jps 查看进程 id</h1><p>另起一个终端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/rgG.png" alt="jps"></p>
<h1 id="启动-HSDB"><a href="#启动-HSDB" class="headerlink" title="启动 HSDB"></a>启动 HSDB</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp &quot;.;%JAVA_HOME%/lib/sa-jdi.jar&quot; sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>

<p>这时就会启动 HSDB 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/baN.png" alt="HSDB"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/a6e.png" alt="attach"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/O2w.png"></p>
<p>输入 Main 程序的进程 id。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/GPL.png" alt="进程信息"></p>
<p>这里是线程信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/17/Kbq.png" alt="栈内存信息"></p>
<p>选中主线程，然后选择 <code>Stack Memory</code> 一栏，会显示 main 线程的栈信息。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://rednaxelafx.iteye.com/blog/1847971">借 HSDB 来探索 HotSpot VM 的运行时数据 </a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 pipenv</title>
    <url>/2019/11/26/%E4%BD%BF%E7%94%A8%20pipenv/</url>
    <content><![CDATA[<p>首先需要安装 Python 环境，同时将安装目录和安装目录下的 Scripts 目录添加到 PATH 环境变量中。</p>
<span id="more"></span>

<h1 id="安装-pipenv"><a href="#安装-pipenv" class="headerlink" title="安装 pipenv"></a>安装 pipenv</h1><p>接下来开始安装 pipenv，使用以下命令将 pipenv 安装到用户基础目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pipenv --user -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>

<h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>接着需要使用 <code>py -m site --user-site</code> 命令获取用户基础目录，假设获取到的路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\nekolr\AppData\Roaming\Python\Python38\site-packages</span><br></pre></td></tr></table></figure>

<p>将 <code>site-packages</code> 去掉并加上 <code>Scripts</code> 组成以下路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\nekolr\AppData\Roaming\Python\Python38\Scripts</span><br></pre></td></tr></table></figure>

<p>这个就是 pipenv 安装的目录，将这个路径添加到 PATH 环境变量中，这样我们就可以在命令行中使用 pipenv 命令了。</p>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>接下来就可以新建一个 Python 项目，然后进入到项目目录下，使用 <code>pipenv install</code> 命令来新建一个虚拟环境。pipenv 会在项目目录中创建一个 Pipfile 和一个 Pipfile.lock 文件，用于跟踪项目中安装的依赖，在项目提交时，可将 Pipfile 文件和 Pipfile.lock 文件一并提交。</p>
<p>假如我们需要安装一个依赖库 requests，则使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipenv install requests</span><br></pre></td></tr></table></figure>

<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>编写以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://httpbin.org/ip&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Your IP is &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(response.json()[<span class="string">&#x27;origin&#x27;</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有两种方式来运行代码，一种是通过 <code>pipenv run python main.py</code> 命令来运行，另一种是启动虚拟环境的 shell 来运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动虚拟环境的 shell</span></span><br><span class="line">pipenv shell</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">python3 main.py</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 PyCharm 作为开发工具，可以在 settings 中搜索 pipenv 并设置它的安装路径，这样在新建项目时 IDE 就会直接帮我们新建并初始化虚拟环境了，非常方便。</p>
</blockquote>
<h1 id="pipenv-常用命令"><a href="#pipenv-常用命令" class="headerlink" title="pipenv 常用命令"></a>pipenv 常用命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipenv --<span class="built_in">where</span>                 <span class="comment"># 列出本地工程路径</span></span><br><span class="line">pipenv --venv                  <span class="comment"># 列出虚拟环境路径</span></span><br><span class="line">pipenv --py                    <span class="comment"># 列出虚拟环境的 Python 可执行文件</span></span><br><span class="line">pipenv install                 <span class="comment"># 创建虚拟环境</span></span><br><span class="line">pipenv isntall [moduel]        <span class="comment"># 安装包</span></span><br><span class="line">pipenv install [moduel] --dev  <span class="comment"># 安装包到开发环境</span></span><br><span class="line">pipenv uninstall[module]       <span class="comment"># 卸载包</span></span><br><span class="line">pipenv uninstall --all         <span class="comment"># 卸载所有包</span></span><br><span class="line">pipenv graph                   <span class="comment"># 查看包依赖</span></span><br><span class="line">pipenv lock                    <span class="comment"># 生成 lockfile</span></span><br><span class="line">pipenv run python [pyfile]     <span class="comment"># 运行 python 文件</span></span><br><span class="line">pipenv --<span class="built_in">rm</span>                    <span class="comment"># 删除虚拟环境</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 underscore.template 扩展 jQuery</title>
    <url>/2017/12/02/%E4%BD%BF%E7%94%A8%20underscore.template%20%E6%89%A9%E5%B1%95%20jQuery/</url>
    <content><![CDATA[<p>最近在接触了一些前端模板框架后，突然觉得以前在 AJAX 操作中拼接组装大量 DOM 对象是多么笨。在了解了 underscore 库的 template 方法后，准备在公司项目中来使用它，但是公司还在用 jQuery，因此准备拿它扩展 jQuery。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 underscore.template 扩展 jquery</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> <span class="variable">nekolr</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> escapes = &#123;</span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span>:      <span class="string">&quot;&#x27;&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;\\&#x27;</span>:     <span class="string">&#x27;\\&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\r&#x27;</span>:     <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\n&#x27;</span>:     <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\u2028&#x27;</span>: <span class="string">&#x27;u2028&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\u2029&#x27;</span>: <span class="string">&#x27;u2029&#x27;</span></span><br><span class="line">    &#125;, escapeMap = &#123;</span><br><span class="line">        <span class="string">&#x27;&amp;&#x27;</span>: <span class="string">&#x27;&amp;amp;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&lt;&#x27;</span>: <span class="string">&#x27;&amp;lt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&gt;&#x27;</span>: <span class="string">&#x27;&amp;gt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span>: <span class="string">&#x27;&amp;quot;&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span>: <span class="string">&#x27;&amp;#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;`&#x27;</span>: <span class="string">&#x27;&amp;#x60;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> escapeChar = <span class="keyword">function</span>(<span class="params">match</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\\&#x27;</span> + escapes[match];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> createEscaper = <span class="keyword">function</span>(<span class="params">map</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> escaper = <span class="keyword">function</span>(<span class="params">match</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map[match];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> source = <span class="string">&quot;(?:&amp;|&lt;|&gt;|\&quot;|&#x27;|`)&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> testRegexp = <span class="title class_">RegExp</span>(source);</span><br><span class="line">        <span class="keyword">var</span> replaceRegexp = <span class="title class_">RegExp</span>(source, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">string</span>) &#123;</span><br><span class="line">            string = string == <span class="literal">null</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;&#x27;</span> + string;</span><br><span class="line">            <span class="keyword">return</span> testRegexp.<span class="title function_">test</span>(string) ? string.<span class="title function_">replace</span>(replaceRegexp, escaper) : string;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">escape</span> = <span class="title function_">createEscaper</span>(escapeMap);</span><br><span class="line">    $.<span class="title function_">extend</span>(&#123;</span><br><span class="line">        <span class="attr">templateSettings</span>: &#123;</span><br><span class="line">            <span class="attr">escape</span>: <span class="regexp">/&#123;&#123;-([\s\S]+?)&#125;&#125;/g</span>,</span><br><span class="line">            interpolate : <span class="regexp">/&#123;&#123;=([\s\S]+?)&#125;&#125;/g</span>,</span><br><span class="line">            <span class="attr">evaluate</span>: <span class="regexp">/&#123;&#123;([\s\S]+?)&#125;&#125;/g</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">escapeHtml</span>: <span class="built_in">escape</span>,</span><br><span class="line">        <span class="attr">template</span>: <span class="keyword">function</span> (<span class="params">text, settings</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> options = $.<span class="title function_">extend</span>(<span class="literal">true</span>, &#123;&#125;, <span class="variable language_">this</span>.<span class="property">templateSettings</span>, settings);</span><br><span class="line">            <span class="keyword">var</span> matcher = <span class="title class_">RegExp</span>([options.<span class="property">escape</span>.<span class="property">source</span>,</span><br><span class="line">			options.<span class="property">interpolate</span>.<span class="property">source</span>,</span><br><span class="line">			options.<span class="property">evaluate</span>.<span class="property">source</span>].<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) + <span class="string">&#x27;|$&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="string">&quot;__p+=&#x27;&quot;</span>;</span><br><span class="line">            text.<span class="title function_">replace</span>(matcher, <span class="keyword">function</span>(<span class="params">match, <span class="built_in">escape</span>, interpolate, evaluate, offset</span>) &#123;</span><br><span class="line">                source += text.<span class="title function_">slice</span>(index, offset).<span class="title function_">replace</span>(<span class="regexp">/\\|&#x27;|\r|\n|\u2028|\u2029/g</span>, escapeChar);</span><br><span class="line">                index = offset + match.<span class="property">length</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">escape</span>) &#123;</span><br><span class="line">                    source += <span class="string">&quot;&#x27;+\n((__t=(&quot;</span> + <span class="built_in">escape</span> + <span class="string">&quot;))==null?&#x27;&#x27;:$.escapeHtml(__t))+\n&#x27;&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interpolate) &#123;</span><br><span class="line">                    source += <span class="string">&quot;&#x27;+\n((__t=(&quot;</span> + interpolate + <span class="string">&quot;))==null?&#x27;&#x27;:__t)+\n&#x27;&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evaluate) &#123;</span><br><span class="line">                    source += <span class="string">&quot;&#x27;;\n&quot;</span> + evaluate + <span class="string">&quot;\n__p+=&#x27;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> match;</span><br><span class="line">            &#125;);</span><br><span class="line">            source += <span class="string">&quot;&#x27;;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!options.<span class="property">variable</span>) source = <span class="string">&#x27;with(obj||&#123;&#125;)&#123;\n&#x27;</span> + source + <span class="string">&#x27;&#125;\n&#x27;</span>;</span><br><span class="line">            source = <span class="string">&quot;var __t,__p=&#x27;&#x27;,__j=Array.prototype.join,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;print=function()&#123;__p+=__j.call(arguments,&#x27;&#x27;);&#125;;\n&quot;</span> +</span><br><span class="line">                source + <span class="string">&#x27;return __p;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> render = <span class="keyword">new</span> <span class="title class_">Function</span>(options.<span class="property">variable</span> || <span class="string">&#x27;obj&#x27;</span>, source);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                e.<span class="property">source</span> = source;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> template = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> render.<span class="title function_">call</span>(<span class="variable language_">this</span>, data);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">var</span> argument = options.<span class="property">variable</span> || <span class="string">&#x27;obj&#x27;</span>;</span><br><span class="line">            template.<span class="property">source</span> = <span class="string">&#x27;function(&#x27;</span> + argument + <span class="string">&#x27;)&#123;\n&#x27;</span> + source + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> template;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>

<p>简单写个栗子来看看怎么使用吧。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tpl&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    </span><span class="template-variable">&#123;&#123; <span class="name">for</span>(<span class="name">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123; &#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;resource/img/list.jpg&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;<span class="name">h5</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com?tokenId=</span></span></span><span class="template-variable">&#123;&#123;= <span class="name">tokenId</span> &#125;&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;= <span class="name">list</span>[i].subject &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123;= <span class="name">list</span>[i].description &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;data&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;supe-data&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;resource/img/data.png&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;= <span class="name">list</span>[i].date &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;resource/img/zan.png&quot;</span>&gt;</span> 赞 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;resource/img/ly.png&quot;</span>&gt;</span> 回复 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">                <span class="tag">&lt;<span class="name">span</span>&gt;</span> 已阅 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    </span><span class="template-variable">&#123;&#123; &#125; &#125;&#125;</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;resource/js/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/template.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    function loadAjax() &#123;</span><br><span class="line">        var tokenId = getQueryString(&#x27;tokenId&#x27;);</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &#x27;http://test.php&#x27;,</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            dataType: &#x27;json&#x27;,</span><br><span class="line">            async: true,</span><br><span class="line">            success: function(msg) &#123;</span><br><span class="line">                var list = msg.list;</span><br><span class="line">                var compiled = $.template($(&quot;#tpl&quot;).text());</span><br><span class="line">                if(list.length &gt; 0) &#123;</span><br><span class="line">                    var result = compiled(&#123;</span><br><span class="line">                        list:list,</span><br><span class="line">                        tokenId: tokenId</span><br><span class="line">                    &#125;);</span><br><span class="line">                    $(&quot;body&quot;).append($(result));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (jqXHR, textStatus, errorThrown) &#123;</span><br><span class="line">                if (console) &#123;</span><br><span class="line">                    console.log(&#x27; 响应状态：[&#x27; + jqXHR.status + &#x27;], </span><br><span class="line">					textStatus 状态：[&#x27; + textStatus + &quot;], 异常信息：&quot; + errorThrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $(function () &#123;</span><br><span class="line">        loadAjax();</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>underscore.js</tag>
      </tags>
  </entry>
  <entry>
    <title>转：内存地址转换与分段</title>
    <url>/2018/11/08/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%88%86%E6%AE%B5/</url>
    <content><![CDATA[<p>本文是 Intel 兼容计算机（x86）的内存与保护系列文章的第一篇，延续了启动引导系列文章的主题，进一步分析操作系统内核的工作流程。与以前一样，我将引用 Linux 内核的源代码，但对 Windows 只给出示例（抱歉，我忽略了 BSD，Mac 等系统，但大部分的讨论对它们一样适用）。文中如果有错误，请不吝赐教。  </p>
<span id="more"></span>  

<p>在支持 Intel 的主板芯片组上，CPU 对内存的访问是通过连接着 CPU 和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址，编号从 0 开始一直到可用物理内存的最高端。这些数字被北桥映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查。然而，在 CPU 内部，程序所使用的是逻辑内存地址，它必须被转换成物理地址后，才能用于实际内存访问。从概念上讲，地址转换的过程如下图所示：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/XRg.png" alt="x86 开启分页后的内存地址转换">  </p>
<p>此图并未指出详实的转换方式，它仅仅描述了在 CPU 的分页功能开启的情况下内存地址的转换过程。如果 CPU 关闭了分页功能，或运行于 16 位实模式，那么从分段单元（segmentation unit）输出的就是最终的物理地址了。当 CPU 要执行一条引用了内存地址的指令时，转换过程就开始了。第一步是把逻辑地址转换成线性地址。但是，为什么不跳过这一步，而让软件直接使用线性地址（或物理地址呢？）其理由与：“人类为何要长有阑尾？它的主要作用仅仅是被感染发炎而已”大致相同。这是进化过程中产生的奇特构造。要真正理解 x86 分段功能的设计，我们就必须回溯到 1978 年。  </p>
<p>最初的 8086 处理器的寄存器是 16 位的，其指令集大多使用 8 位或 16 位的操作数。这使得代码可以控制 2^16 个字节（或 64KB）的内存。然而 Intel 的工程师们想要让 CPU 可以使用更多的内存，而又不用扩展寄存器和指令的位宽。于是他们引入了段寄存器（segment register），用来告诉 CPU 一条程序指令将操作哪一个 64K 的内存区块。一个合理的解决方案是：你先加载段寄存器，相当于说“这儿！我打算操作开始于 X 处的内存区块”；之后，再用 16 位的内存地址来表示相对于那个内存区块（或段）的偏移量。总共有 4 个段寄存器：一个用于栈（ss），一个用于程序代码（cs），两个用于数据（ds，es）。在那个年代，大部分程序的栈、代码、数据都可以塞进对应的段中，每段 64KB 长，所以分段功能经常是透明的。  </p>
<p>现今，分段功能依然存在，一直被 x86 处理器所使用着。每一条会访问内存的指令都隐式的使用了段寄存器。比如，一条跳转指令会用到代码段寄存器（cs），一条压栈指令（stack push instruction）会使用到堆栈段寄存器（ss）。在大部分情况下你可以使用指令明确的改写段寄存器的值。段寄存器存储了一个 16 位的段选择符（segment selector）；它们可以经由机器指令（比如 MOV）被直接加载。唯一的例外是代码段寄存器（cs），它只能被影响程序执行顺序的指令所改变，比如 CALL 或 JMP 指令。虽然分段功能一直是开启的，但其在实模式与保护模式下的运作方式并不相同的。  </p>
<p>在实模式下，比如在引导启动的初期，段选择符是一个 16 位的数值，指示出一个段的开始处的物理内存地址。这个数值必须被以某种方式放大，否则它也会受限于 64K 当中，分段就没有意义了。比如，CPU 可能会把这个段选择符当作物理内存地址的高 16 位（只需将之左移 16 位，也就是乘以 2^16）。这个简单的规则使得：可以按 64K 的段为单位，一块块的将 4GB 的内存都寻址到。遗憾的是，Intel 做了一个很诡异的设计，让段选择符仅仅乘以 2^4（或 16），一举将寻址范围限制在了 1MB，还引入了过度复杂的转换过程。下述图例显示了一条跳转指令，cs 的值是 0x1000：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/PLo.png" alt="实模式分段功能">  </p>
<p>实模式的段地址以 16 个字节为步长，从 0 开始编号一直到 0xFFFF0（即 1MB）。你可以将一个从 0 到 0xFFFF 的 16 位偏移量（逻辑地址）加在段地址上。在这个规则下，对于同一个内存地址，会有多个段地址&#x2F;偏移量的组合与之对应，而且物理地址可以超过 1MB 的边界，只要你的段地址足够高（参见臭名昭著的 A20 线）。同样的，在实模式的 C 语言代码中，一个远指针（far pointer）既包含了段选择符又包含了逻辑地址，用于寻址 1MB 的内存范围。真够“远”的啊。随着程序变得越来越大，超出了 64K 的段，分段功能以及它古怪的处理方式，使得 x86 平台的软件开发变得非常复杂。这种设定可能听起来有些诡异，但它却把当时的程序员推进了令人崩溃的深渊。  </p>
<p>在 32 位保护模式下，段选择符不再是一个单纯的数值，取而代之的是一个索引编号，用于引用段描述符表中的表项。这个表为一个简单的数组，元素长度为 8 字节，每个元素描述一个段。看起来如下：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/ymW.png" alt="段描述符">  </p>
<p>有三种类型的段：代码，数据，系统。为了简洁明了，只有描述符的共有特征被绘制出来。基地址（base address）是一个 32 位的线性地址，指向段的开始；段界限（limit）指出这个段有多大。将基地址加到逻辑地址上就形成了线性地址。DPL 是描述符的特权级（privilege level），其值从 0（最高特权，内核模式）到 3（最低特权，用户模式），用于控制对段的访问。  </p>
<p>这些段描述符被保存在两个表中：全局描述符表（GDT）和局部描述符表（LDT）。电脑中的每一个 CPU（或一个处理核心）都含有一个叫做 gdtr 的寄存器，用于保存 GDT 的首个字节所在的线性内存地址。为了选出一个段，你必须向段寄存器加载符合以下格式的段选择符：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/zJq.png" alt="段选择符">  </p>
<p>对 GDT，TI 位为 0；对 LDT，TI 位为 1；index 指出想要表中哪一个段描述符（译注：原文是段选择符，应该是笔误）。对于 RPL，请求特权级（Requested Privilege Level），以后我们还会详细讨论。现在，需要好好想想了。当 CPU 运行于 32 位模式时，不管怎样，寄存器和指令都可以寻址整个线性地址空间，所以根本就不需要再去使用基地址或其他什么鬼东西。那为什么不干脆将基地址设成 0，好让逻辑地址与线性地址一致呢？Intel 的文档将之称为“扁平模型”（flat model），而且在现代的 x86 系统内核中就是这么做的（特别指出，它们使用的是基本扁平模型）。基本扁平模型（basic flat model）等价于在转换地址时关闭了分段功能。如此一来多么美好啊。就让我们来看看 32 位保护模式下执行一个跳转指令的例子，其中的数值来自一个实际的 Linux 用户模式应用程序：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/xJr.png" alt="保护模式的分段">  </p>
<p>段描述符的内容一旦被访问，就会被 cache（缓存），所以在随后的访问中，就不再需要去实际读取 GDT 了，否则会有损性能。每个段寄存器都有一个隐藏部分用于缓存段选择符所对应的那个段描述符。如果你想了解更多细节，包括关于 LDT 的更多信息，请参阅《Intel System Programming Guide》3A 卷的第三章。2A 和 2B 卷讲述了每一个 x86 指令，同时也指明了 x86 寻址时所使用的各种类型的操作数：16 位，16 位加段描述符（可被用于实现远指针），32 位，等等。  </p>
<p>在 Linux 上，只有 3 个段描述符在引导启动过程被使用。他们使用 GDT_ENTRY 宏来定义并存储在 boot_gdt 数组中。其中两个段是扁平的，可对整个 32 位空间寻址：一个是代码段，加载到 cs 中，一个是数据段，加载到其他段寄存器中。第三个段是系统段，称为任务状态段（Task State Segment）。在完成引导启动以后，每一个 CPU 都拥有一份属于自己的 GDT。其中大部分内容是相同的，只有少数表项依赖于正在运行的进程。你可以从 segment.h 看到 Linux GDT 的布局以及其实际的样子。这里有 4 个主要的 GDT 表项：2 个是扁平的，用于内核模式的代码和数据，另两个用于用户模式。在看这个 Linux GDT 时，请留意那些用于确保数据与 CPU 缓存线对齐的填充字节——目的是克服冯·诺依曼瓶颈。最后要说说，那个经典的 UNIX 错误信息“Segmentation fault”（分段错误）并不是由 x86 风格的段所引起的，而是由于分页单元检测到了非法的内存地址。唉呀，下次再讨论这个话题吧。  </p>
<p>Intel 巧妙的绕过了他们原先设计的那个拼拼凑凑的分段方法，而是提供了一种富于弹性的方式来让我们选择是使用段还是使用扁平模型。由于很容易将逻辑地址与线性地址合二为一，于是这成为了标准，比如现在在 64 位模式中就强制使用扁平的线性地址空间了。但是即使是在扁平模型中，段对于 x86 的保护机制也十分重要。保护机制用于抵御用户模式进程对系统内核的非法内存访问，或各个进程之间的非法内存访问，否则系统将会进入一个狗咬狗的世界！在下一篇文章中，我们将窥视保护级别以及如何用段来实现这些保护功能。  </p>
<blockquote>
<p>转载地址：<a href="https://blog.csdn.net/drshenlei/article/details/4261909">https://blog.csdn.net/drshenlei/article/details/4261909</a>  </p>
</blockquote>
<blockquote>
<p>原文地址：<a href="https://manybutfinite.com/post/memory-translation-and-segmentation/">https://manybutfinite.com/post/memory-translation-and-segmentation/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统与一致性模型</title>
    <url>/2020/08/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>对于一致性模型的研究从共享内存的多核并行计算就开始了，然后又顺理成章的推广到了基于网络通信的多节点协同系统中。</p>
<span id="more"></span>

<p>一致性的定义应该来源于并行系统，而我们平常所关注的分布式系统其实只是并行系统的一部分。当然，关于分布式系统的定义众说纷纭。Lamport 在 1983 年的 PODC 会议上指出，广义上的分布式系统是一个相对的概念，不同的实体所看到的会有所不同。</p>
<p>由于分布式系统存在多个节点或多个副本的特点，因此会有一致性的问题。从系统的角度来看，一致性关注的是不同节点之间的数据或状态的一致程度；而从使用者的角度来看，一致性反映的是系统对外提供的服务所表现出来的特征，同时一致性也不光是各个节点最终对一个值的结果保持一致，很多时候还需要对这个值的变化历史在各个节点上保持一致。</p>
<h1 id="线性一致性（Linearizability）"><a href="#线性一致性（Linearizability）" class="headerlink" title="线性一致性（Linearizability）"></a>线性一致性（Linearizability）</h1><p>Herlihy 和 Wing 在 1990 年发表的一篇论文：<a href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">Linearizability: A Correctness Condition for Concurrent Objects</a> 中提出了线性一致性的概念。论文中的线性一致性是一个单对象（single-object）模型，但是对象的范围可能有所不同，比如对象是整个分布式系统，也可以是键值存储系统中的各个键。</p>
<p>比如在一个分布式数据库中，我们可以把整个系统看作一个对象，如果该系统支持线性一致性，那么客户端对于该数据库的单个读写操作就需要满足：每个客户端的每个读操作都必须返回最近一次写操作的值。其中的最近一次表明读写的先后顺序是由一个统一的实际事件来决定的。比如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/07/5JM.png" alt="线性一致性1"></p>
<p>其中 Inv(W) 代表 W 操作的开始，Res(W) 代表 W 操作的结束。P1 和 P2 两个进程都是先调用 W 操作来写变量 x，然后再调用 R 操作读 x。P1 与 P2 的操作在时间上彼此互不重叠，因此“最近的一次操作”一目了然。</p>
<p>但在真实的系统中，不同进程间并发的读写操作必然会出现时间上的重叠，针对这种情况又该如何定义“最近”这个概念呢？我们首先要知道一点就是：任何读操作或者写操作必然在操作开始和结束的之间某个点生效，在写操作生效后的读操作必然会读到该写操作的值。因此对于所有的客户端而言，这就好像采用了某种顺序来串行地（并非通过锁形成的串行）执行所有进程的读写操作。比如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/07/kzQ.png" alt="线性一致性2"></p>
<p>线性一致性总结起来就是要求系统表现的如同一个单一的副本，然后按照某种时间顺序来串行地执行所有进程的读写操作。需要注意的是，这里的操作并没有使用锁等方式来限制并发，但是所有的操作最终会在时间轴上连成一串。</p>
<h1 id="顺序一致性（Sequential-Consistency）"><a href="#顺序一致性（Sequential-Consistency）" class="headerlink" title="顺序一致性（Sequential Consistency）"></a>顺序一致性（Sequential Consistency）</h1><p>早在 1979 年，Lamport 就在一篇论文：<a href="http://lamport.azurewebsites.net/pubs/multi.pdf">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Program</a> 中提出了顺序一致性的概念：</p>
<blockquote>
<p>A multiprocessor system is sequentially consistent if the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>
</blockquote>
<p>上述定义基于共享内存的多处理器系统，但是我们可以将这种系统理解成一个同步分布式模型，从而扩展该定义到分布式领域。用通俗的语言来说，这个定义包含两部分：<strong>第一是事件的历史在各个进程来看是全局一致的，即各个进程对于事件的历史观点一致；第二是单个进程的事件历史在全局历史上应符合编程的顺序（program order），即单个进程上发生的事件放到全局来看也应该保持相同的顺序。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/08/Eqd.png" alt="顺序一致性1"></p>
<p>在上图中，明显例子 A 是符合顺序一致性定义的，不过例子 B 也同样符合顺序一致性的定义。虽然在例子 B 中进程 P2 和 P3 对于 x 历史顺序的认知与真实时间发生的不一致，但是至少它们“错”的一致，这是符合定义的。如果对于 x 的两次写入都发生在同一个进程，比如 P0，那么例子 B 中出现的顺序不符合定义的第二条，即它不满足顺序一致性。而对于下图中的例子，明显不符合顺序一致性的定义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/08/ekQ.png" alt="顺序一致性2"></p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>顺序一致性与线性一致性相比，最大的不同就是它放松了对于一致性的要求，不再要求操作的顺序严格按照时间进行，只要求存在一致的全序关系即可。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://jepsen.io/consistency">Consistency Models</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.bailis.org/blog/linearizability-versus-serializability/">Linearizability versus Serializability</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式唯一 ID 生成</title>
    <url>/2020/05/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80%20ID%20%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>在很多分布式系统中，常常需要对大量的数据和消息进行唯一标识。在分库分表的应用中，由于数据库从原先的单一节点切分到了多个节点上，因此数据库自身的主键生成机制就不能再使用了，因为我们无法保证某个分片上的数据库生成的主键在全局上是唯一的。这个时候一个分布式（全局唯一）的主键生成系统就很有必要了。</p>
<span id="more"></span>

<p>一般的分布式主键生成系统需要满足以下要求。首先是全局唯一，这是最基本的要求。其次要求生成的主键为单调递增或者趋势递增。所谓趋势递增是指从整体上看是递增的趋势，但是有时可能出现两个相邻生成的 ID 是递减的。由于很多关系型数据库都采用 B+ 树来存储索引，主键趋势递增或者单调递增可以充分利用 B+ 树的优势，提高主键的读取和写入性能。最后还有安全性的要求，比如 UUID 可能存在 MAC 地址泄露的风险，或者如果 ID 是单调连续的，那么就很容易被恶意利用，如果是订单号就更危险了，竞争对手可以在两天的相同时间下单，然后通过订单号相减就能够大概知道我们一天的订单量。</p>
<h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><p>常见的全局唯一主键生成方案中，UUID 是最简单的一个。标准的 UUID 包含 32 个 16 进制数字，以 8-4-4-4-12 的形式分为五段，比如：550e8400-e29b-41d4-a716-446655440000，目前业界共有五种生成 UUID 的方式，详情请见 IETF 发布的 UUID 规范：<a href="https://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a>。UUID 的优点是通过本地生成，没有网络消耗，性能非常高，缺点是长度过长不容易存储，且可能存在信息安全问题（基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露）。MySQL 官方对于主键的建议是越短越好，UUID 不符合要求，同时在 InnoDB 引擎中，UUID 的无序性可能会引起数据位置的频繁变动，严重影响性能。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>使用单一的数据库进行主键生成，所有的服务都通过该数据库获取唯一主键。在这种方案中可以使用数据库自带的自增机制，或者通过数据库维护一个 sequence 表，表结构类似于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `SEQUENCE` (</span><br><span class="line">    `table_name` <span class="type">varchar</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `next_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`table_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>当需要为某个表生成 ID 时，就从 sequence 表中取出对应表的 next_id，并将 next_id 的值增加 1 后更新到数据库中以备下次使用。这个方案实现简单，但是缺点也很明显，因为所有的插入操作都需要访问这张表，因此该表很容易成为性能瓶颈，同时它也存在单点问题。</p>
<h1 id="多数据库实例"><a href="#多数据库实例" class="headerlink" title="多数据库实例"></a>多数据库实例</h1><p>针对数据库的单点问题，一个优化方案就是提供多台机器部署，每台机器设置不同的初始值，且步长和机器数目相同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202005182226/2020/05/17/RrE.png" alt="多数据库实例"></p>
<p>这种方案解决了单点问题，但是系统的水平扩展比较困难，在步长确定的情况下，很难通过增加机器实现扩容。同时由于每次获取 ID 都需要读取一次数据库，这对数据库来说压力还是很大。</p>
<h1 id="Leaf-segment"><a href="#Leaf-segment" class="headerlink" title="Leaf-segment"></a>Leaf-segment</h1><p>在数据库方案中，每次获取 ID 都需要读写一次数据库，这对数据库来说压力太大。美团开源的 <a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a> 在数据库方案的基础上进行了改进，每次都获取一个号段（segment）的值，比如 1 到 1000，当这个号段的 ID 全部使用完毕后再去数据库获取新的号段，通过这种方式可以大大减轻数据库的压力。对应的数据库表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+--------------+------+-----+-------------------+-----------------------------+</span><br><span class="line">| Field       | Type         | Null | Key | Default           | Extra                       |</span><br><span class="line">+-------------+--------------+------+-----+-------------------+-----------------------------+</span><br><span class="line">| biz_tag     | varchar(128) | NO   | PRI |                   |                             |</span><br><span class="line">| max_id      | bigint(20)   | NO   |     | 1                 |                             |</span><br><span class="line">| step        | int(11)      | NO   |     | NULL              |                             |</span><br><span class="line">| desc        | varchar(256) | YES  |     | NULL              |                             |</span><br><span class="line">| update_time | timestamp    | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |</span><br><span class="line">+-------------+--------------+------+-----+-------------------+-----------------------------+</span><br></pre></td></tr></table></figure>

<p>其中 biz_tag 是业务名，比如用户业务、订单业务等，max_id 表示当前该业务已经分配的 ID 号段的最大值，step 代表每次分配的号段长度。我们只需要将 step 设置得足够大，比如 1000，那么只有当这 1000 个 ID 被全部消费后才会再次读写数据库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202005182226/2020/05/18/wPp.png" alt="Leaf-segment"></p>
<p>这种方案的优点就是，Leaf 服务可以很方便的线性扩展，因为 Leaf 的状态主要通过数据库来维护，所以 Leaf 可以根据需要扩展出多个一起提供服务。这种本地 JVM 缓存的方式即使在数据库宕机时也能够在短时间内对外提供服务，同时由于 max_id 可以根据需要进行初始化，我们就可以很方便地把业务从原有的 ID 的生成方式上迁移过来。当然缺点也很明显，就是生成的 ID 不够随机，可能存在安全隐患。同时在号段使用完毕后采用同步的方式来读写数据库，这时应用会阻塞在更新数据库的 IO 上，根据网络和数据库的状况，阻塞时间的长短可能会出现较大的波动，如果网络发生抖动，或者数据库产生慢查询都会导致整个系统的响应时间拉长。针对这种情况，Leaf-segment 做了相应的优化，即将获取号段的时机提前，不在号段消耗完毕时去获取，而是当号段消费到某个点（比如 10%）时就异步地把下一个号段加载到内存中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202005182226/2020/05/18/nDW.png" alt="双 buffer 优化"></p>
<p>这种方案采用了双 buffer 的方式，即维护两个 segment 缓存区，在当前号段已经消费 10% 时，如果下一个号段还没有更新，就启动一个线程去更新下一个号段。在当前号段全部消费完毕后，如果下一个号段已经准备完毕，那么就将当前的 segment 缓冲区切换为下一个号段的 segment 缓冲区，如此往复。Leaf 官方推荐将 segment 的长度设置为 QPS 的 600 倍，这样即使数据库宕机，Leaf 仍然可以保证 10 到 20 分钟的可用。</p>
<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p>snowflake 算法是 twitter 开源的分布式 ID 生成算法，它生成的是一个 64 位的二进制正整数，其中高位的第一位是符号位（sign），我们不使用它，它的值始终是 0。接着是 41 位的时间戳（delta seconds），它存储的不是当前的时间戳，而是从生成器开始使用到当前时间的毫秒差值。接着是 10 位机器标识码（worker node id），意味着可以将该服务部署到 1024 台机器上，如果机器是分机房（IDC）部署的，那么这 10 位可以再拆分成机房 ID + 机器 ID。剩下的 12 位是序列号（sequence），这表示一台机器每毫秒能够产生 4096 个 ID。</p>
<blockquote>
<p>我们一般取的时间戳是从 1970 年 01 月 01 日 00 时 00 分 00 秒到现在的时间差，如果我们能确定我们取的时间都是某个时间点以后的时间，那么可以将时间戳的起始点设置成这个时间点，从而延长服务的时间。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202005182226/2020/05/18/mYz.png" alt="雪花算法"></p>
<p>雪花算法的优点是性能较高，理论上每秒能够产生 409.6 万个 ID。由于时间戳在高位，自增序列在低位，从整体上看 ID 是趋势递增的（之所以不是单调递增的是因为节点 ID 这个因素的影响，比如在同一毫秒内，节点 ID 为 2 的机器先于节点 ID 为 1 的机器生成了的 ID，那么很明显前者大于后者）。同时我们可以根据自身业务的需求，在雪花算法的基础上调整 bit 位的划分。比如我们的单机高峰 QPS 为 10W，那么平均每毫秒的并发量为 100 左右，序列号的位置可以只分配 7 位。雪花算法的缺点是强依赖机器的时钟，如果机器的时钟出现回拨（NTP 时间校准，以及其他因素都有可能导致服务器时钟回拨），就很有可能导致重复 ID 的生成。twitter 官方没有对此给出解决方案，而是简单地抛出了异常。如果只是出现了短暂的回拨，比如 5 毫秒，那么可以等待时钟追回，但是如果出现了大步回拨，那么服务就会出现长时间的不可用。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">  exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">  log.error(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidSystemClock</span>(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>.format(lastTimestamp - timestamp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leaf-snowflake"><a href="#Leaf-snowflake" class="headerlink" title="Leaf-snowflake"></a>Leaf-snowflake</h1><p>根据最新的代码库，Leaf 对于机器时钟回拨的处理很有限。由于 Leaf 在美团的服务规模较大，在每台机器手动配置 workId 的成本太高，于是他们引入了 Zookeeper，在 Leaf 服务初始化的时候，通过创建持久连续节点的方式为每台机器和端口号分配一个唯一的 workId，同时在机器的临时文件中缓存一份 workId，保证 Leaf 在 ZooKeeper 出现问题时仍能够正常运行。同时每台机器上的 Leaf 服务会每隔 3 秒定时将系统的时间戳更新到 Zookeeper 对应的节点中，在每次获取 ID 时都会检查当前时间与 3 秒前上报的时间，如果出现回拨会抛出异常，但是从代码来看，实际并没有对这个回拨做任何其他处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前时间是否小于之前上报的时间，如果是则直接抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (!checkInitTimeStamp(curator, zk_AddressNode)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CheckLastTimeException</span>(<span class="string">&quot;init timestamp check error,forever node timestamp gt this node time&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;Start node ERROR &#123;&#125;&quot;</span>, e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Zookeeper 初始化失败时使用机器临时目录中的配置文件的 workId</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(PROP_PATH.replace(<span class="string">&quot;&#123;port&#125;&quot;</span>, port + <span class="string">&quot;&quot;</span>))));</span><br><span class="line">            workerID = Integer.valueOf(properties.getProperty(<span class="string">&quot;workerID&quot;</span>));</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;START FAILED ,use local node file properties workerID-&#123;&#125;&quot;</span>, workerID);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Read file error &quot;</span>, e1);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正处理回拨的地方是在获取 ID 时，如果时间回拨的偏差不超过 5 毫秒，可以在此处等待 2 倍的偏差时间来等待时钟追回，让上游服务最多多等待 10 毫秒是可以接受的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出现时钟回拨</span></span><br><span class="line"><span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> lastTimestamp - timestamp;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 偏差不超过 5 ms，等待两倍时间</span></span><br><span class="line">            wait(offset &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">            <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(-<span class="number">1</span>, Status.EXCEPTION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;wait interrupted&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(-<span class="number">2</span>, Status.EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(-<span class="number">3</span>, Status.EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="新思路"><a href="#新思路" class="headerlink" title="新思路"></a>新思路</h1><p>理论上 snowflake 可以实现单机每秒产生 409.6 万个 ID，实际上大部分的业务都不太可能有如此高的并发，因此可能会有大量的时间戳被浪费掉，可能在某一毫秒内只生成了几个 ID，此时如果发生了时间回拨，这些被浪费的资源是不是可以利用起来，而不是直接在时钟出现回拨时直接抛出异常。</p>
<p>如果在内存中建立一个数组，数组给一个固定的长度，比如 256（最好是 2 的倍数，方便取模），那么这个数组就可以存储所有最近（256 毫秒内）生成过的 ID 值，如果发生时钟回拨，只需要将回拨后的时间戳对数组长度取模，得到当前位置最近一次生成过的 ID 值，将该值的序列号自增后生成的新 ID 作为当前时间的 ID 值。举个例子，假如当前时间是系统运行的第 768 毫秒，生成过 ID，之后时间回拨到了第 512 毫秒，那么第 512 毫秒有没有生成过 ID 已经不得而知了，但是我们知道第 768 毫秒时生成过 ID，那么直接拿着该 ID 的序列号 + 1 即可得到新 ID 值。再举一个例子，假如还是第 768 毫秒，这个时间可能是最新的时间，也可能是回拨后的时间，但是我们不用去管它，只需要查看第 768 毫秒有没有生成过 ID，也就是去 0 号坑位查看，如果该位置没有值，那么直接用该毫秒生成新值；如果该位置有值，值为第 512 毫秒时生成的 ID，那么直接用第 512 毫秒时生成的 ID 的序列号自增即可；如果该位置有值，值为第 1024 毫秒生成的 ID，那么说明当前出现了时钟回拨，不用管，直接用第 1024 毫秒生成的 ID 的序列号自增即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202005201255/2020/05/20/6qQ.png" alt="新思路"></p>
<p>当然这种方案也并不是完美的，它假定了一个前提就是服务的 QPS 并不是特别高，在这个前提下，当出现了时钟回退时，它能够在时钟回退到时钟追回这段时间内再多提供 2^12 * 256 &#x3D; 1048576 个 ID 生成。这里列举一个极限的例子，比如在第 768 毫秒生成的 sequence 为 4095，同时在第 769 毫秒生成的 sequence 为 0，这时发生了时钟回拨，回拨到了第 768 毫秒之前，那么在时间重新到达第 768 毫秒时，由于最近一次生成的 ID 的 sequence 进行自增操作后变成了 0，此时使用下一毫秒的时间和 sequence 来生成 ID 就会出现重复。</p>
<h1 id="备用机器-ID"><a href="#备用机器-ID" class="headerlink" title="备用机器 ID"></a>备用机器 ID</h1><p>很多时候我们都用不了 1024 台机器，那么我们就可以将这部分空闲的资源利用起来，比如限制最大只能支持 512 台机器提供服务，另外 512 个机器 ID 作为这些机器的备用 ID，即一台机器一个备用 ID。在发生时钟回拨时，如果回拨时间较短，可以通过等待追回的方式处理；如果回拨时间较长，那么可以启用备用机器 ID。如果在使用备用机器 ID 的时候再次发生回拨，可以根据回拨的长短处理，回拨较短可以等待追回；回拨较长可以抛出异常。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf —— 美团点评分布式 ID 生成系统</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5eaea4f4f265da7b991c4c31">美团分布式 ID 生成框架 Leaf 源码分析及优化改进</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/b1124283fc43">关于分布式唯一 ID，snowflake 的一些思考及改进(完美解决时钟回拨问题)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统相关概念</title>
    <url>/2020/08/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>主要简单概括一下分布式系统中的网络和故障模型、共识问题、拜占庭将军问题、FLP 定理等等。</p>
<span id="more"></span>

<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p>更确切的说是<strong>交互模型</strong>。在分布式系统中，很难对进程执行、消息传递以及时钟漂移的时间设置限制，所以两种截然相反的观点提供了一对简单的模型：同步分布式系统和异步分布式系统。</p>
<p>Hadzilacos 和 Toueg 在 1994 年定义了一个同步分布式系统，它满足以下约束：</p>
<ul>
<li>进程执行的每一步操作都有时间上限和下限。</li>
<li>消息会在一个已知的时间范围内被接收到。</li>
<li>每个进程的本地时钟与实际时间的偏移率在一个已知的范围内。</li>
</ul>
<p>在同步分布式系统中，由于所有的节点的时间偏移有上限，消息的传输延迟也有上限，节点会在指定的时间内完成计算，所以一旦超过一定的时间还没有收到消息的应答，我们就可以断定要么网络中断，要么节点 crash。与同步分布式系统相反，异步分布式系统中进程的执行速度是变化的，消息的传递延迟无上限，进程内时钟的漂移不可预知，在这种模型中，发送给一个节点的消息很久都没有接收到应答，可能是因为这个节点的计算比较慢、也有可能是节点宕机、也有可能是网络延迟或网络中断，很难判断到底是发生了什么故障。因此，可以简单将同步分布式系统和异步分布式系统的最大区别理解为故障是否可以检测。</p>
<h1 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h1><p>在分布式系统中，故障可能发生在节点或者通信链路上，按照出现的范围和困难程度可以将故障模型划分为以下几个类型：</p>
<ol>
<li><p><strong>byzantine failure（拜占庭故障，随机故障）</strong><br>这是最难处理的情况，它可能出现在进程中，也可能出现在网络上，此时可能发生任何类型的错误。进程的随机故障是指进程随机地省略一些必要的步骤或者执行一些不需要的步骤，即进程根本不按照程序的逻辑执行，对它的调用会返回随意的或者错误的结果。进程的随机故障不能通过查看进程是否应答调用来检测，因为它可能会随机地遗漏应答。网络也会出现随机故障，比如消息内容被破坏、传递不存在的消息，也有可能多次传递同一个消息。网络的随机故障通常很少，因为通信软件能够识别这类故障并拒绝出错的消息。</p>
</li>
<li><p><strong>crash-recovery failure（崩溃-恢复）</strong><br>对拜占庭故障增加了一个限制，那就是节点总是会按照程序逻辑执行，进程结果是正确的，但是不保证消息返回的时间。原因可能是节点 crash 后又重新拉起了，或者网络中断了，或者网络延迟很高。而对于 crash 还要分为健忘的和非健忘的两种。健忘的是指 crash 的节点丢失了之前的状态；而非健忘的是指节点在 crash 之前已经将状态持久化了，重启后会恢复之前的状态。比如 Basic Paxos 中要求节点必须把 ballot number 持久化，一旦 crash，重启后可以恢复。</p>
</li>
<li><p><strong>omission failure（遗漏故障）</strong><br>它比 crash-recovery 多了一个限制，就是发生故障后，消息不会恢复。典型的就是由于网络故障造成的消息丢失。</p>
</li>
<li><p><strong>crash-stop failure（崩溃-停止）</strong><br>也可以认为是 crash failure 或者 fail-stop failure，它比 omission failure 更容易处理，因为这种就是 crash 故障，且故障后不会恢复。比如一个节点 crash 后立即停止接收和发送消息。</p>
</li>
</ol>
<p>分布式系统中的故障模型还有其他分类的方式，有的还会加入 performance failure，有的则把 crash 与 fail-stop 分开，这里提供的只是其中一种使用较为广泛的分类方式，它们的关系如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008131351/2020/08/11/PBq.png" alt="故障模型"></p>
<h1 id="liveness-和-safety"><a href="#liveness-和-safety" class="headerlink" title="liveness 和 safety"></a>liveness 和 safety</h1><p>liveness 和 safety 的概念最早由 Lamport 提出，这两个属性是分布式系统中非常基础的属性，其他属性都可以被分解为这两个属性。</p>
<ul>
<li>safety: something “bad” will never happen</li>
<li>liveness: something “good” will must happen (but we don’t know when)</li>
</ul>
<p>用更加通俗的话来说，safety 属性是指程序不会进入非预期的状态，而 liveness 属性是指程序预期的状态一定会达到。比如最终一致性就是 liveness 的，如果算法能在有限的步骤内完成，那么系统一定是 liveness 的。虽然它们俩是正交的概念，但是在设计分布式系统的时候，我们需要同时考虑这两个属性，只具备其中之一属性的系统是没有意义的。</p>
<h1 id="Consensus"><a href="#Consensus" class="headerlink" title="Consensus"></a>Consensus</h1><p>共识问题是分布式系统中最基础也是最重要的问题之一，而关于共识的定义主要包含三个部分：</p>
<ul>
<li>终止性（termination）：每个进程最终会在有限的步骤中结束并决定一个值，算法不会无尽地执行下去。</li>
<li>协定性（agreement）：所有的非故障进程决定的值都相同。</li>
<li>完整性或有效性（validity）：如果所有非故障的进程都提议一个值，那么最终所有非故障进程都会选择该值。</li>
</ul>
<p>根据应用的不同，完整性的定义也会有所变化。比如，一种较弱的完整性是决定值等于某些非故障进程提议的值，而不必是所有进程提议的值。在这共识问题的三要素中，termination 是 liveness 的保证，agreement 和 validity 则是 safety 的保证，liveness 和 safety 就像一对死对头。</p>
<p>一般来说，很多在拜占庭故障模型下的共识算法都是在同步网络的假设下设计的，因为同步网络使得故障检测成为了可能。而在异步网络中，想要同时保证 liveness 和 safety 是很困难的，如果是拜占庭式的故障，Paxos 和 Raft 是没有办法解决的，直到 PBFT（Practical Byzantine Fault Tolerance）的提出，我们才可以在放松 liveness 的情况下来解决此类问题。对于一般的应用来说，出现拜占庭故障的概率太低但是解决的成本却过高，所以我们通常不考虑拜占庭式的故障，我们主要关注的是 crash-recovery failure 模型下的异步网络，此时根据 FLP 理论，只要有一个故障节点，Paxos 和 Raft 都是有可能进入无限循环而无法结束，但是如果我们放松 liveness 的要求，这个问题还是可以解决的。</p>
<h1 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h1><p>1982 年 Lamport 和另外两位科学家发表了名为：<a href="http://lamport.azurewebsites.net/pubs/byz.pdf">The Byzantine Generals Problem</a> 的论文，文中提供了一个共识问题的情景化的描述：拜占庭帝国的几个师在攻打敌军，每个师都有一个将军，将军们只能通过信使沟通。他们的行动计划有两种：进攻和撤退，并且只有在超过半数以上的将军发起进攻时才能取得最终胜利。然而，其中的一些将军可能是叛徒，为了阻止其他将军达成一致的行动计划，可能会传递错误的消息。更糟糕的是，负责传递消息的信使也有可能是叛徒，他们也有可能篡改或伪造消息，也可能丢失消息。</p>
<p>我们将这个场景放到分布式系统中来看，这种情况意味着不仅网络会出故障，节点本身也可能不会按照逻辑执行。完整的拜占庭将军问题比较复杂，必须加上一些特定的假设才能解决，比如同步网络，即：<strong>在同步网络中，如果有 m 个故障节点，那么至少需要 3m + 1 个节点才能最终达成一致的行动方案</strong>。</p>
<p>我们可以考虑一种最基本的情况，假设有三个将军，只有一个是叛徒，比如 C，那么 C 可能会给 B 发送进攻指令，给 A 发送撤退指令，这个时候 A 收到了足够多的撤退指令，而 B 收到了足够多的进攻指令，从而导致 B 选择进攻，最终战败。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008131351/2020/08/13/9lo.png" alt="拜占庭将军问题"></p>
<h1 id="FLP-定理"><a href="#FLP-定理" class="headerlink" title="FLP 定理"></a>FLP 定理</h1><p>1985 年，一篇名为 <a href="https://dl.acm.org/doi/10.1145/3149.214121">Impossibility of distributed consensus with one faulty process</a> 的论文告诉了我们一个重要的事实，即：</p>
<blockquote>
<p>No completely asynchronous consensus protocol can tolerate even a single unannounced process death.</p>
</blockquote>
<p>用简单的话来说就是，在异步网络环境中，即使只有一个进程出现故障，也无法实现任何安全的共识算法。这里的 unannounced process death 是指一个进程停止工作了，但是其他节点并不知道，其他节点认为可能是消息延迟或者这个进程计算较慢。FLP 定理假设节点的故障只限于 crash failure，并不考虑拜占庭故障（do not consider Byzantine failures），同时假定消息通道是可靠的，消息可能延迟但不会丢失，且只会被传递一次（the message system is reliable, it delivers all messages correctly and exactly once）。</p>
<p>FLP 中假定的模型是一个比现实情况更加可靠的模型，因此，如果连相对可靠的模型下都做不到一致性，那么在现实中就更加不可能了。因此这个定理的重要性不言而喻，他终止了多年的争论，现在已经没有必要再去试图设计一个能在异步网络环境下能够容忍各种故障同时又能保证一致性的系统了。</p>
<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>这里简单将共识算法分为两大类：一类是故障容错算法（Crash Fault Tolerance），也就是非拜占庭容错算法；另一类是拜占庭容错算法。</p>
<p>非拜占庭容错算法解决的是分布式系统中存在故障（crash failure），但是不存在恶意攻击等场景下的共识问题，也就是说，消息可能丢失或者重复，但是消息不会被篡改或者伪造。一般用于局域网场景下的分布式系统，比如分布式数据库等。常见的此类算法有：Paxos、Raft 和 ZAB 等。</p>
<p>拜占庭容错算法可以解决分布式系统中即存在故障，有存在恶意攻击的场景下的共识问题，一般用于互联网场景下的分布式系统，比如数字货币中的区块链技术。常见的此类算法有：PBFT、PoW 等。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁的实现</title>
    <url>/2019/02/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在单机多线程环境中，JDK 提供了很多线程同步的工具，包括 synchronized 和 Lock 来帮助我们解决线程间代码同步的问题。但是现在的系统多是分布式的，这意味着我们需要一种能够处理进程级别的代码同步的工具，即常说的分布式锁。  </p>
<span id="more"></span>  

<p>分布式锁应该满足的几个特征：  </p>
<ul>
<li><p>互斥性<br>在分布式环境下同一时间只有一个客户端能够获取到锁，也就是保证不同节点的不同线程的互斥。  </p>
</li>
<li><p>高性能、高可用<br>必须能够高性能、高可用地获取和释放锁。  </p>
</li>
<li><p>可重入<br>必须是可重入锁，即同一个节点同一个线程可以多次获取锁。  </p>
</li>
<li><p>超时<br>应该具备锁失效的机制，防止死锁的发生。  </p>
</li>
<li><p>阻塞或非阻塞<br>应该提供类似 ReentrantLock 的阻塞获取锁的 lock 方法和非阻塞获取锁的 tryLock 方法。</p>
</li>
</ul>
<p>目前常见的实现分布式锁的方式有：基于数据库、基于缓存（Redis、Memcached）和基于 ZooKeeper。  </p>
<h1 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h1><p>基于数据库的实现方式有很多种，其中比较常见的就是利用数据库的唯一约束，成功插入记录就表示获取到了锁，插入失败则表示没有获取到锁。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `resource_lock`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `resource_lock` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `resource_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的资源&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;默认自动生成的时间戳&#x27;</span>,</span><br><span class="line">  `count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;统计重入的次数&#x27;</span>,</span><br><span class="line">  `node_info` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;机器和线程信息&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_method_name` (`method_name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;锁定中的资源&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>创建类似的一张表，如果在使用某个资源时想获取锁，则向数据库中插入一条记录。因为资源名做了唯一性校验，如果有多个请求同时提交到数据库，则只会有一个成功，那么操作成功的我们就认为获取到了锁。在资源使用完后，通过删除该条记录来释放锁。同时为了实现可重入的特性，在表中增加一列用于记录获得锁的主机和线程信息，在下次获取锁时检查当前机器的主机和线程信息与表中数据是否一致，如果一致则可以直接分配锁。  </p>
<p>这种方式的优点是实现简单，当然相对的，缺点也很多。因为该方式重度依赖数据库，所以数据库的可用性和性能将直接影响分布式锁，这时可以通过数据库双机部署、主从同步来避免单点问题。为了支持超时释放锁，可以使用定时任务，定时清理超时的锁数据。当然这些优化只是一种补救措施，实际使用中并不推荐通过数据库实现分布式锁。  </p>
<h1 id="基于缓存"><a href="#基于缓存" class="headerlink" title="基于缓存"></a>基于缓存</h1><p>常用的缓存中间件有 Redis、Memcached 等，其中 Redis 使用较为广泛。Redis 的操作大部分都是基于内存的，所以性能很高，同时所有的单个操作都是原子性的，也支持主从同步，具备高可用性。  </p>
<p>Redis 提供了一个命令可以很好地实现锁的功能，这个命令就是 <code>SETNX</code>（SET if Not eXists），调用该命令需要提供一个 key&#x2F;value 对，只有在 key 不存在时才会设置 value，设置成功后返回 1，失败则返回 0。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; SETNX lan <span class="string">&quot;Java&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SETNX lan <span class="string">&quot;Ruby&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>只有 <code>SETNX</code> 可不行，我们还需要实现超时锁失效的机制，因此就需要用到另一个命令 <code>EXPIRE</code>，用法为 <code>EXPIRE key timeout</code>。当超时时间到时，Redis 会自动删除 key。  </p>
<p>有了这些命令，我们的思路就是在获取锁时使用 <code>SETNX</code> 命令，设置的 value 值为一个全局唯一的值（如 UUID），这么做是为了确保释放的是自己的锁。同时还要使用 <code>EXPIRE</code> 命令为锁添加一个超时时间，超时则会自动释放锁。在释放锁时使用 <code>DELETE</code> 命令，并判断 value 值是否一致，一致则进行删除。因此我们的实现可能类似这样（使用 Jedis）：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, uuid);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将会发生死锁</span></span><br><span class="line">    jedis.expire(lockKey, expireTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是很遗憾，这种实现在程序意外崩溃时会导致锁无法释放，引发死锁。在 Redis 2.6.12 版本之前，我们可以利用 Redis 的事务特性来处理。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">transaction.setnx(lockKey, uuid);</span><br><span class="line">transaction.expire(lockKey, expireTime);</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">transaction.exec();</span><br></pre></td></tr></table></figure>

<p>但是这里有一个问题就是，如果有多个客户端的请求同时到达，虽然 <code>SETNX</code> 命令只会有一个客户端执行成功，但是 <code>EXPIRE</code> 命令所有的客户端都可以执行成功，这会导致锁的超时时间一直延长。在 Redis 2.6.12 版本及以后，SET 命令可以通过设置参数实现上面所有的效果并避免超时时间延长的问题。  </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>使用</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EX seconds</td>
<td>SET key value EX seconds</td>
<td>设置键的过期时间，单位秒，效果等同于 SETEX key seconds value</td>
</tr>
<tr>
<td>PX milliseconds</td>
<td>SET key value PX milliseconds</td>
<td>设置键的过期时间，单位毫秒，效果等同于 PSETEX key milliseconds value</td>
</tr>
<tr>
<td>NX</td>
<td>SET key value NX</td>
<td>只有在键不存在时才会设置 value 值，效果等同于 SETNX key value</td>
</tr>
<tr>
<td>XX</td>
<td>SET key value XX</td>
<td>只有在键存在时才会设置 value 值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, uuid, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">    <span class="comment">// 设置成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 释放锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">LuaScript</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> + </span><br><span class="line">        <span class="string">&quot;then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 第一个参数是脚本文本，第二个参数是一个 key 的集合，第三个参数是参数集合</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(LuaScript, Collections.singletonList(lockKey),</span><br><span class="line">        Collections.singletonList(uuid));</span><br><span class="line"><span class="keyword">if</span> (result.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line">    <span class="comment">// 删除成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要解释的就是释放锁，luaScript 是一段 Lua 脚本，它首先获取 key 对应的 value 值并与传入的 uuid 比较，如果相同则执行删除 key，否则返回 0。之所以使用 Lua 脚本是因为 eval 命令在执行 Lua 脚本时会把它当成一个命令去执行，并且直到 eval 执行完成后 Redis 才能执行其他命令，这就确保了整个过程的原子性。  </p>
<h1 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h1><p>为了保证 Redis 服务的高可用，一般会使用主从 + 哨兵的架构，当主节点宕机能够自动进行故障切换，这个时候如果使用上面提到的分布式锁就可能存在一个问题。</p>
<p>举个例子，假如客户端 A 在主节点拿到了锁，然后主节点在把客户端 A 创建的 key 写入到从节点之前就宕机了。此时由于故障切换，从节点变成了主节点，但是又有一个客户端 B 来申请锁，由于原来的从节点里没有客户端 A 持有的锁信息，所以客户端 B 也获取到了锁。这就违背了分布式锁在同一时间只能有一个客户端获取到锁的原则。</p>
<p>为了解决这个问题，Redis 提出了 Redlock 算法。该算法假设我们有 N 个主节点，这些节点都是完全独立的，不使用任何复制或者其他分布式协调算法。然后继续使用上面提到的获取锁的方式分别在每个节点上获取锁和释放锁。我们假设 N 为 5，也就是说我们有五个独立的主节点，一个客户端具体需要做出以下操作来获取锁：</p>
<ol>
<li><p>获取当前时间（单位是毫秒）。</p>
</li>
<li><p>使用 SET 设置相同的过期键和唯一值的方式在 5 个节点上请求锁，超时时间的设置需要比总的锁释放时间小的多，比如如果总的锁释放时间是 10 秒钟，那么每个节点锁请求的超时时间可能是 0 到 50 毫秒的范围，这样可以防止一个客户端在某个宕掉的主节点上阻塞过长的时间，如果一个主节点不可用了，我们应该尽快尝试下一个主节点。</p>
</li>
<li><p>只有当客户端在超过半数的主节点上成功获取到了锁（此处为 3 个或 3 个以上），并且总共消耗的时间不超过总的锁释放时间，我们才认为该客户端真正获取到了锁。</p>
</li>
<li><p>从成功获取锁开始，锁自动释放的时间就是设定的总的锁释放时间减去之前获取锁消耗的时间。</p>
</li>
<li><p>如果锁获取失败了，不管是因为获取成功的锁没有达到半数以上，还是因为总消耗时间超过了总的锁释放时间，客户端都会到每个节点上释放锁，即便是那些它认为没有获取成功的锁。</p>
</li>
</ol>
<blockquote>
<p>从 Redlock 算法的描述中，我们可以明白为什么该算法需要 N 个独立的节点。假如采用主从架构，客户端在请求到主节点的锁后，在请求从节点的锁时，很有可能该键已经同步到从节点，因此会获取锁失败。而假如是集群架构，由于 Redis 的集群通过划分槽的方式进行数据库分片，客户端使用相同的键请求集群来获取锁时会始终被分配到某一个主节点。</p>
</blockquote>
<p><a href="https://github.com/redisson/redisson">redisson</a> 中提供了 Redlock 的 Java 实现。</p>
<h1 id="基于-ZooKeeper"><a href="#基于-ZooKeeper" class="headerlink" title="基于 ZooKeeper"></a>基于 ZooKeeper</h1><p>ZooKeeper 是一个 CP 系统，因此天生就能够用来解决分布式一致性问题。基于 ZooKeeper 实现分布式锁的思路是：将 ZooKeeper 上的一个 ZNode 看作一把锁，通过创建临时节点来实现获取锁的操作，而没有获取到锁的客户端需要在该临时节点上通过 exists 注册 Watcher，当获取锁的客户端因为宕机或者主动删除临时节点释放锁时，其他客户端就可以收到通知，从而重新发送创建临时节点的请求来继续竞争锁。  </p>
<p>这种实现思路有一个问题就是在释放锁后会发生惊群效应，所有客户端都会去竞争锁，这里我们使用一种更好的方式。首先需要创建一个父节点，这个节点是 PERSISTENT 类型的。然后在获取锁时在父节点下创建 EPHEMERAL_SEQUENTIAL 类型（临时的、有序的）的节点，如果有多个客户端同时请求获取锁，那么它们都能够成功创建节点。接着客户端在父节点上调用 getChildren()，但是此时不要设置监听，避免惊群效应。将获取到的所有子节点按照节点顺序排序，序号最小的节点就表示获取到了锁，客户端需要判断该节点是否是自己创建的，如果是则该客户端获取到了锁，如果不是此时客户端需要找到序号比自己小的那个<strong>相邻节点</strong>，然后对其调用 exists 同时设置监听，之后如果被监听的节点被删除，则客户端会收到通知，此时再调用 getChildren() 并排序比较序号，如果自己创建的节点是序号最小的，那么就获取到了锁，否则重复之前的步骤。  </p>
<p>操作 ZooKeeper 最常用的第三方实现就是 Apache Curator，它与 ZooKeeper 的关系就像 Google Guava 与 Java。Curator 为我们提供了 <code>curator-recipes</code> 包，里面有很多常用的功能，包括分布式锁、分布式栅栏（Barrier）、分布式队列等。  </p>
<p>Curator 实现的分布式锁包括：  </p>
<ul>
<li><p>InterProcessMutex<br>分布式可重入锁共享锁，在任意时刻只能有一个客户端获取到锁，可重入。</p>
</li>
<li><p>InterProcessSemaphoreMutex<br>分布式共享锁，与 InterProcessMutex 区别就是不可重入。</p>
</li>
<li><p>InterProcessReadWriteLock<br>分布式可重入读写锁，读写锁保持一对相关的锁，一个用于只读操作，一个用于写入操作。可以有多个客户端获取到读锁，而写锁是独占的。</p>
</li>
<li><p>InterProcessMultiLock<br>多共享锁，将多个锁作为单个实体进行管理的容器，acquire() 方法会获取所有的锁，release() 方法会释放所有的锁。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/79036337">分布式锁简单入门以及三种实现方式介绍</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/austinspark-jessylu/p/8043726.html">分布式锁的几种实现方式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表的学习</title>
    <url>/2019/08/09/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>通常来说，数据库是比较容易成为系统瓶颈的，因为它本身是<strong>有状态</strong>的，相对于 Web 和应用服务器来说，比较难于<strong>横向扩展</strong>。而数据库的单机存储量、连接数和处理能力都是有限的，因此当一个数据库的单表数据达到一定的量级后，即使进行多种优化，比如添加从库、优化索引等，可能性能仍然下降严重，此时就需要考虑对其进行分库分表的操作了。</p>
<p>分库分表是拆分数据库和拆分数据表的统称，一般情况下会根据业务情况来决定是分库还是分表，或者是二者相结合。而根据拆分方式的不同，又分为垂直拆分和水平拆分。</p>
<span id="more"></span>

<h1 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h1><p>垂直分表的通常情况就是：由于某个表中字段较多，我们可以通过新建一张扩展表，将不经常使用或者长度较大的字段拆分出去放到扩展表中。这种做法可以使日常的开发和维护更加方便，并且在某些数据库（比如 MySQL、SQL Server 等）中还可以避免跨页的问题。但是缺点也很明显：主键出现冗余，在某些查询时可能需要 JOIN 操作，并且事务处理也变得复杂了。垂直分表的操作一般在数据库的设计阶段就应该做好，如果在后续阶段中进行拆分，很有可能需要改写以前的查询语句，造成额外的麻烦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/11/2Le.png" alt="垂直分表"></p>
<h1 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h1><p>垂直分库就是将数据库中关系紧密的一些表拆分出来放到一个独立的数据库服务中，这些关系紧密的表在业务上通常也是关系紧密的，因此垂直分库一般需要业务层面上的模块划分，比如将某个系统划分成用户模块、订单模块和商品模块等。</p>
<p>因为微服务的盛行，垂直分库在今天已经非常普及了。在高并发和海量数据的场景下，垂直切分可以从一定程度上突破单机数据库的 I&#x2F;O、连接数等硬件资源的瓶颈。但是垂直分库的缺点也有很多，比如可能面临跨库 JOIN 查询，这时需要通过接口聚合的方式将数据在内存中完成关联，复杂度提高。如果某一类型的业务骤增，会造成对应业务的数据库压力增大，可能还会面临单机数据库的性能瓶颈问题。与此同时，跨库事务的一致性，也就是分布式事务处理起来也很麻烦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/11/y73.png" alt="垂直分库"></p>
<h1 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h1><p>水平分表就是将表中不同的数据行按照一定的规律拆分到不同的表中，这种做法可以降低单表的数据量，优化查询性能，但是由于所有的表都存储在同一个库中，所以还是会面临单机数据库的性能瓶颈问题。</p>
<h1 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h1><p>水平分库分表与水平分表的思路相同，唯一的区别就是水平分库分表需要将拆分出来的表存放在不同的数据库服务中。在高并发和海量数据的场景下，水平分库分表可以有效地缓解单机数据库的性能问题，但是与此同时也引入了很多复杂的技术难点，接下来会详细分析。</p>
<h2 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h2><p>分片策略决定的是按照怎样的规则将表中不同的数据行进行拆分，常见的分片策略有 <code>Range</code> 和 <code>Hash + Mod</code> 等。</p>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>Range 按照区间划分表中不同的数据行，可能会是时间区间、ID 区间等。比如我们可以按照日期字段将不同年份月份甚至是每天的数据行划分到不同的库中，或者根据 ID 值的范围将 1 到 10000 的记录划分到第一个库，将 10001 到 20000 的记录划分到第二个库，以此类推。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/11/qP9.png" alt="时间区间"></p>
<p>这种划分方式的优点在于：其天然便于水平扩展，如果后期需要对集群进行扩容，只需要增加节点即可，无需对其他分片的数据进行迁移。在使用分片字段进行范围查找时，连续的分片可以快速地定位和查询，有效避免跨分片的问题。当然缺点也同样存在：某些分片可能会在某个时间段内被大量的读写，从而造成数据分布不均匀，热点数据成为性能瓶颈。</p>
<blockquote>
<p>如果我们选择具有周期性的区间进行数据划分，那么在需要扩容时，不可避免的需要进行数据的迁移。比如，按照日期字段将不同月份的数据划分到不同的库中，即 monthOfYear，那么共有 12 个库，在下次需要扩容时，可能需要按照日期字段将不同日期的数据划分到不同的库中，即 dayOfMonth，那么可能共有 31 个库，这时就需要进行数据迁移。</p>
</blockquote>
<h3 id="Hash-Mod"><a href="#Hash-Mod" class="headerlink" title="Hash + Mod"></a>Hash + Mod</h3><p>Hash + Mod 就是对所有的数据库节点进行编号，比如一共有 4 台数据库服务节点，则编号 0 ~ 3，然后对原始数据行中某个字段的值进行一次 Hash 运算，结果需要是一个整型数值，然后对这个整型数值取模 Mod，得到的值就是对应数据库的编号。</p>
<blockquote>
<p>这种分片策略中的分片字段一般会选择 ID 字段，因为对唯一字段的值进行 Hash 运算，结果会比较均匀分散，这样不容易出现热点数据的问题。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/11/4oa.png" alt="Hash+Mod"></p>
<p>这种划分方式可以有效避免热点数据的产生，但是比较容易面临跨分片查询的问题，并且在后期扩容时还会面临数据迁移的问题。比如初期共有 4 台服务器，数据行需要经过 Hash % 4 得到节点值，如果后期又增加了 3 台服务器，那么数据行需要重新经过 Hash % 7 计算节点值，而这个值很有可能会与开始计算的值不同，因此需要进行数据迁移。</p>
<h1 id="分库分表面临的问题"><a href="#分库分表面临的问题" class="headerlink" title="分库分表面临的问题"></a>分库分表面临的问题</h1><p>不管是分库还是分表，是垂直切分还是水平切分，都会面临一系列的问题，这些问题有的可以通过设计时的调整解决，有的可能需要引入更加复杂的工具来处理。</p>
<h2 id="跨节点-JOIN"><a href="#跨节点-JOIN" class="headerlink" title="跨节点 JOIN"></a>跨节点 JOIN</h2><p>在数据切分之前，关联查询可以直接通过 SQL JOIN 来完成，但是切分之后，数据可能分布在不同的节点上，此时进行关联查询就比较复杂了，一般应该尽量避免关联查询。</p>
<blockquote>
<p>在互联网业务系统中，本来在一开始就应该避免关联查询，如果存在关联查询，有很大的可能是因为设计的不够合理或者技术选型有误。报表类的系统在 BI 时代都是通过 OLAP、数据仓库等来实现的（现在更多的借助于离线分析、流式计算等），而不应该在数据库中直接执行大量的 JOIN 查询来进行统计和分析。</p>
</blockquote>
<p>在无法避免跨节点 JOIN 操作时，一般普遍的做法是将查询分为两次，在第一次查询时找出关联数据的 ID，然后根据这些 ID 发起第二次查询得到关联数据。</p>
<h2 id="跨节点分页排序"><a href="#跨节点分页排序" class="headerlink" title="跨节点分页排序"></a>跨节点分页排序</h2><p>一般情况下，分页都需要对数据进行排序。当排序字段就是分片字段时，通过分片规则我们可以比较容易地定位到具体的分片上，而当排序字段不是分片字段的时候，就需要在不同的分片中分别将数据进行排序，然后把结果集进行汇总并再次进行排序。</p>
<p>简单的，比如要获取日期倒叙的前 10 条数据，那么就需要进行如下图的操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/22/9RZ.png" alt="倒序前10条"></p>
<p>而复杂的，可能需要获取第 10 页的数据（每页 10 条记录），此时需要对每个分片的数据进行排序和分页，分别取前 100 条数据，这么做是为了确保最终需要的数据一定会在这些结果集中，然后再将这些数据汇总，再次进行排序和分页，取第 10 页的数据。这些操作很显然需要消耗更多的资源，并且越往后翻页性能会越差。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/22/Y3D.png" alt="倒序第十页"></p>
<h2 id="跨节点排序、分组和聚合操作"><a href="#跨节点排序、分组和聚合操作" class="headerlink" title="跨节点排序、分组和聚合操作"></a>跨节点排序、分组和聚合操作</h2><p>与跨节点分页排序类似，多数的 sharding 组件都不会对这些操作（order by、group by、count、avg 等）自动进行合并，需要手工在各个节点上得到结果集，然后在应用中进行合并，内存消耗严重。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>在没有分库分表之前，数据库的事务都是在本地进行的。而在进行了分库分表以后，原先一次业务中的事务可能会涉及到多个数据库节点。举例来说，假如有一项消费业务，在用户选购完商品进行结算时，需要扣减用户余额，用户的积分和优惠券，而用户的积分和优惠券信息可能位于其他节点的数据库中，此时我们需要保证在结算时同时扣除余额、积分和优惠券，这一系列动作需要作为一个整体，也就是一个事务进行，这个事务就是分布式事务。</p>
<p>分布式事务常见的解决方案有：基于 XA 的 2PC（两阶段提交），以及 2PC 的改进版本 3PC、TCC（Try-Confirm-Cancel，事务补偿），性能出色的 Best Efforts 1PC 和基于消息队列的最终一致性方案等。</p>
<p>由于基于 XA 的标准分布式事务过于严格，在提交事务时需要多个节点之间进行协调，很大程度上延长了事务的执行时间，这会导致访问共享资源时发生冲突和死锁的概率增大，并且这种趋势会随着节点的增多而越发明显，从而成为系统在数据库层面上进行水平伸缩的枷锁，这也是很多 sharding 系统不使用标准分布式事务的原因。与之相对的，Best Efforts 1PC 具有出色的性能优势，同时实现的方式也比较简单，因此被大多数 sharding 系统所采用。</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>当数据库被切分到多个节点上时，我们就不能再以来数据库自身的主键生成机制了，因为我们无法保证某个分片上的数据库生成的 ID 在全局上是唯一的，同时我们的应用在插入数据前需要先获取 ID，以便进行 SQL 的路由。</p>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>常见的全局唯一主键生成方案中，UUID 是最简单的一个。标准的 UUID 包含 32 个 16 进制数字，以 <code>8-4-4-4-12</code> 的形式分为五段，比如：<code>550e8400-e29b-41d4-a716-446655440000</code>，目前业界共有五种生成 UUID 的方式，详情请见 IETF 发布的 UUID 规范：<a href="https://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</a>。UUID 的优点是通过本地生成，没有网络消耗，性能非常高，缺点是长度过长不容易存储，且可能存在信息安全问题（基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露）。MySQL 官方对于主键的建议是越短越好，UUID 不符合要求，同时在 InnoDB 引擎中，UUID 的无序性可能会引起数据位置的频繁变动，严重影响性能。</p>
<h3 id="sequence-表"><a href="#sequence-表" class="headerlink" title="sequence 表"></a>sequence 表</h3><p>通过数据库维护一个 sequence 表，表结构类似于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `SEQUENCE` (</span><br><span class="line">    `table_name` <span class="type">varchar</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `next_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`table_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>当需要为某个表生成 ID 时，就从 sequence 表中取出对应表的 next_id，并将 next_id 的值增加 1 后更新到数据库中以备下次使用。这个方案实现简单，但是缺点也很明显，因为所有的插入操作都需要访问这张表，因此该表很容易成为性能瓶颈，同时它也存在单点问题。</p>
<h3 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h3><p>snowflake 是 twitter 的分布式自增 ID 算法，又称雪花算法。这种算法的好处是整个 ID 是趋势递增的，性能很高也很灵活，但是由于强依赖机器的时钟，如果机器上的时钟回拨，会导致重复发号的问题。</p>
<p>还有一些是在雪花算法的基础上做了优化，比如百度的 <a href="https://github.com/baidu/uid-generator">uid-generator</a> 和美团的 <a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a>。</p>
<h2 id="数据迁移、扩容等问题"><a href="#数据迁移、扩容等问题" class="headerlink" title="数据迁移、扩容等问题"></a>数据迁移、扩容等问题</h2><p>由于扩容后路由规则发生变化，扩容前的数据行很有可能需要进行数据迁移。在进行数据迁移时，一般是不允许停机的，因此理想的扩容方式就是避免数据迁移。</p>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>目前分库分表的中间件主要分为两大类，一类是客户端架构，一类是代理架构。</p>
<p>客户端架构的中间件需要在应用中进行整合，中间件一般会以 jar 包的形式提供。通过修改应用的数据访问层（JDBC 或者以 JDBC 为基础的 ORM 框架）的方式对应用内产生的 SQL 进行解析、重写、路由、执行，并对结果集进行归并。这种架构的优点是无需对业务进行改造，简单且成本较低，但是缺点是中间件与应用绑定，对应用有一定的侵入性，不支持复杂的需求，并且对应用数据访问层的实现有限制。比较有代表性的产品为 <a href="https://github.com/apache/incubator-shardingsphere">ShardingSphere</a> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/26/vpl.png" alt="客户端架构"></p>
<p>代理架构的中间件一般是一个独立的服务，相当于实现了一个支持对应数据库协议的代理服务器。以 MySQL 为例，用户可以使用 MySQL 客户端工具或者命令行访问该中间件，中间件会使用 MySQL 协议与多个 MySQL 数据库服务器进行通信。这种架构的优点是能够处理非常复杂的需求，对应用数据访问层的实现没有限制，对于应用服务透明不会增加任何额外的负载，但是缺点是由于需要独立部署，增加了运维成本，同时应用需要经过一层代理才可以访问数据库，在网络上多了一跳，影响性能并可能会有额外的风险。比较有代表性的产品有 <a href="https://github.com/MyCATApache/Mycat-Server">MyCat</a> 和 <a href="https://github.com/alibaba/cobar">Cobar</a>。</p>
<p><strong>不管是哪种架构，几个核心的步骤都是一样：SQL 解析，重写，路由，执行和结果归并。</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.cnblogs.com/jshen/p/7682502.html">分库分表的基本思想</a></p>
</blockquote>
<blockquote>
<p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf —— 美团点评分布式 ID 生成系统</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/tommyli/p/3767362.html">一种可以避免数据迁移的分库分表 scale-out 扩容方式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Keepalived</title>
    <url>/2019/08/16/%E5%88%9D%E8%AF%86%20Keepalived/</url>
    <content><![CDATA[<p>在初步了解了 keepalived 的作用后，手痒难耐，于是动手实践部署了一个 Nginx + keepalived + Tomcat 组合的双主高可用负载均衡集群。</p>
<span id="more"></span>

<h1 id="实现-VIP-漂移"><a href="#实现-VIP-漂移" class="headerlink" title="实现 VIP 漂移"></a>实现 VIP 漂移</h1><p>在搭建集群之前，先简单使用 keepalived 实现 VIP 漂移。准备两台服务器（<code>10.5.96.3</code> 和 <code>10.5.96.4</code>），两台机器都要安装 keepalived。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum install -y openssl openssl-devel gcc gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载解压 keepalived</span></span><br><span class="line">wget https://www.keepalived.org/software/keepalived-2.0.18.tar.gz &amp;&amp; tar xf keepalived-2.0.18.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/keepalived &amp;&amp; <span class="built_in">cd</span> keepalived-2.0.18 &amp;&amp; ./configure prefix=/usr/local/keepalived/</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制配置文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/keepalived &amp;&amp; <span class="built_in">cp</span> /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line"><span class="built_in">cp</span> /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/keepalived</span><br></pre></td></tr></table></figure>

<p>接下来需要修改 keepalived 的配置文件，我选择将 <code>10.5.96.3</code> 作为主，<code>10.5.96.4</code> 作为备，虚拟 IP 地址设置成 <code>10.5.96.7</code>。主的配置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line"># 实例配置</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 指定为 master 主机</span><br><span class="line">    state MASTER</span><br><span class="line">    # VIP 绑定的网卡设备，用来发送 VRRP 包做心跳检测</span><br><span class="line">    interface eth1</span><br><span class="line">    # 虚拟路由 id，是一个唯一值，取值 0 到 255 之间</span><br><span class="line">    # 相同的组（主备）之间配置须一致，不同的组需要设置不同的值</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    # 优先级，在选举 master 时会使用该值，如果要成为 master，这个选项的值最好高于其他机器 50 个点</span><br><span class="line">    priority 100</span><br><span class="line">    # 健康检查时间间隔，即每隔 1 秒发起一次 VRRP 组播</span><br><span class="line">    advert_int 1</span><br><span class="line">    # 虚拟 IP 地址</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.5.96.7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备的配置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line"># 实例配置</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 指定为 backup 主机</span><br><span class="line">    state BACKUP</span><br><span class="line">    # VIP 绑定的网卡设备，用来发送 VRRP 包做心跳检测</span><br><span class="line">    interface eth1</span><br><span class="line">    # 虚拟路由 id，是一个唯一值，取值 0 到 255 之间</span><br><span class="line">    # 相同的组（主备）之间配置须一致，不同的组需要设置不同的值</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    # 优先级，在选举 master 时会使用该值，如果要成为 master，这个选项的值最好高于其他机器 50 个点</span><br><span class="line">    priority 50</span><br><span class="line">    # 健康检查时间间隔，即每隔 1 秒发起一次 VRRP 组播</span><br><span class="line">    advert_int 1</span><br><span class="line">    # 虚拟 IP 地址</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.5.96.7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来启动两台机器分别使用命令 <code>systemctl start keepalived</code> 启动 keepalived，然后使用 <code>ip ad</code> 命令观察网络配置情况。</p>
<p>Master 的网络配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/16/kxY.png" alt="Master"></p>
<p>Backup 的网络配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/16/5Lk.png" alt="Backup"></p>
<p>接下来停掉 Master 的 keepalived，再观察 Backup 的网络配置，会发现 VIP 漂移到了该机器上。然后重新启动 Master 的 keepalived，再次观察，会发现 VIP 又重新漂移到了主机器上。</p>
<h2 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h2><p>主备同时获取到了 VIP 地址，也就是脑裂现象。keepalived 默认需要使用 D 类多播地址 <code>224.0.0.18</code> 进行心跳通信，因此需要修改防火墙的规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加规则</span></span><br><span class="line">firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface eth0 --destination 224.0.0.18 --protocol vrrp -j ACCEPT</span><br><span class="line">firewall-cmd --direct --permanent --add-rule ipv4 filter OUTPUT 0 --out-interface eth0 --destination 224.0.0.18 --protocol vrrp -j ACCEPT</span><br><span class="line"><span class="comment"># 重载配置</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 重启 keepalived</span></span><br><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure>

<h1 id="实现双主高可用负载均衡集群"><a href="#实现双主高可用负载均衡集群" class="headerlink" title="实现双主高可用负载均衡集群"></a>实现双主高可用负载均衡集群</h1><p>双机高可用一般分为两种。一种是主从模式，即一台机器为主，另一台机器为从。正常情况下，主服务器绑定一个公网虚拟 IP，作为流量入口提供负载均衡服务，而热备服务器则处于空闲状态。当主服务器发生故障时，VIP 发生漂移，热备服务器接管主服务器的公网虚拟 IP，继续提供负载均衡服务。这种方式永远会有一台服务器处于空间状态，浪费资源。另一种就是双主模式，即两台服务器互为主备，同时处于活动状态，各自绑定一个公网虚拟 IP。当其中一台发生故障时，另一台接管发生故障的服务器的公网虚拟 IP，承担所有的请求。</p>
<blockquote>
<p>公网虚拟 IP 其实就是公网 IP，只不过我们将它用作 VIP。很多云服务厂商提供的弹性公网 IP 服务就可以满足我们的需求。双主是两个 Ningx 同时提供服务，因此系统对外会有两个 IP 地址，此时配合 <strong>DNS 轮询</strong>可以将一个域名的流量打到两台 Nginx 服务机器上。</p>
</blockquote>
<p>接下来一共需要四台服务器，其中两台（<code>10.5.96.3</code> 和 <code>10.5.96.4</code>）使用 Nginx 做负载均衡，另外两台（<code>10.5.96.5</code> 和 <code>10.5.96.6</code>）作为真实节点服务器，运行 Tomcat 容器，两个 VIP 分别设置为 <code>10.5.96.7</code> 和 <code>10.5.96.8</code>。首先在两台真实节点服务器上安装 JDK 和 Tomcat，安装完毕后简单编写一个测试的 jsp 页面。然后在两台负载均衡服务器上安装 Nginx 并添加配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#gzip  on;</span><br><span class="line">upstream tomcat &#123;</span><br><span class="line">    server 10.5.96.5:8080 weight=1 max_fails=1 fail_timeout=10s;</span><br><span class="line">    server 10.5.96.6:8080 weight=1 max_fails=1 fail_timeout=10s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        proxy_pass http://tomcat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要在两台负载均衡机器上分别安装 keepalived，用于实现故障切换，<code>10.5.96.3</code> 的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script &quot;/root/nginx.sh&quot;</span><br><span class="line">    interval 2</span><br><span class="line">    weight 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth1</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.5.96.7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth1</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.5.96.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>10.5.96.4</code> 的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script &quot;/root/nginx.sh&quot;</span><br><span class="line">    interval 2</span><br><span class="line">    weight 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth1</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.5.96.7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth1</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.5.96.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>nginx.sh</code> 是 Nginx 进程状态检测脚本。设置该脚本后，keepalived 会定期执行该脚本，在 Nginx 服务没有启动或者出现问题关闭时重新启动 Nginx 服务，在重启失败后会关闭该机器上的 keepalived 服务，从而导致 VIP 漂移，实现故障切换。</p>
<blockquote>
<p>keepalived 会根据脚本执行的结果动态调整 vrrp_instance 的优先级（可能是降低或者提高），从而引发新一轮的 Master 选举。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 检测进程脚本</span></span><br><span class="line">jc=`ps -C nginx --no-header|<span class="built_in">wc</span> -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$jc</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    /usr/local/nginx/sbin/nginx</span><br><span class="line">    <span class="built_in">sleep</span> 2</span><br><span class="line">    <span class="comment"># 如果尝试启动 nginx 失败，则关闭 keepalived 服务，进行 VIP 漂移</span></span><br><span class="line">    jc2=`ps -C nginx -no-header|<span class="built_in">wc</span> -l`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$jc2</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        systemctl stop keepalived</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>一切准备就绪后，分别启动两台机器上的 Nginx 服务和 keepalived 服务。查看网络配置情况，其中 <code>10.5.96.3</code> 的配置如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/18/E3E.png" alt="3号机器配置"></p>
<p><code>10.5.96.4</code> 的配置如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/18/eyg.png" alt="4号机器配置"></p>
<p>当某一台机器发生故障时，VIP 漂移，另一个机器就会同时接管这两个 VIP，当机器故障恢复后，VIP 又会漂移回去，恢复到一开始的配置。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Spring Boot</title>
    <url>/2017/07/18/%E5%88%9D%E8%AF%86%20Spring%20Boot/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在脚本语言和敏捷开发流行的当前，Java 开发显得很笨重，即便是在传统的 J2EE 开发中引入了 Spring，整合和配置的繁琐还是一直饱受诟病，为了解决这个问题，Spring Boot 应运而生。Spring Boot 并没有创造新的技术，它基于“习惯优于配置”，即内部有一套默认的配置，使你无需手动配置便可使用 Spring 平台的产品。  </p>
<span id="more"></span>

<p>Spring Boot 有很多重要的特性，这里简单列举几个具有代表性的：</p>
<ul>
<li><strong>独立运行</strong><br>可以以 jar 包的形式独立运行，使用命令 java -jar xxx.jar。</li>
<li><strong>内置 Servlet 容器</strong><br>内置 Servlet 容器，同时有多种容器可以选择，这样就无需部署 war 包。</li>
<li><strong>自动配置</strong><br>考虑了大多数开发场景，为项目 jar 包中的类自动配置 Bean 并纳入容器，同时支持自定义的配置。</li>
<li><strong>无 xml 配置，无代码生成</strong><br>如果只是代替我们将代码生成，Spring Boot 也就没有这么神奇了。Spring Boot 使用条件注解，同时可以通过 Java 类配置和注解结合，避免使用 xml。</li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>如果使用 eclipse 等 IDE 可以安装 <a href="https://spring.io/tools/">Spring Tool Suite</a> 插件，这里使用 IDEA 作为 IDE。</p>
<p>首先第一步是创建一个新项目，填写项目相关信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911251055/2018/04/14/k4z.png" alt="create new project1">		<br>		<br><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911251055/2018/04/14/8RB.png" alt="create new project2">		<br>		<br>接下来需要选择项目的依赖，比如 Web 开发可能需要 Web 模块、Spring Data JPA 模块等。<br>		<br><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911251055/2019/11/25/4yb.png" alt="dependencies">		<br>		<br>最后耐心等待。IDEA 会自动执行新建项目的操作（包括下载依赖包、索引项目文件等），新建好的项目结构如下图。	<br>		<br><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911251055/2018/04/14/NAr.png" alt="project archive">		
		</p>
<h3 id="pom-xml-分析"><a href="#pom-xml-分析" class="headerlink" title="pom.xml 分析"></a>pom.xml 分析</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.nekolr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>分析 pom.xml，其中有一个父级依赖：<code>spring-boot-starter-parent</code>，它的父级依赖 spring-boot-dependencies 里定义了常用的 jar 包和版本，免去了配置依赖 jar 包。dependencies 中定义了 web 和 test 的 starter，这样就添加了 web 开发依赖和测试依赖。 <code>spring-boot-maven-plugin</code> 是 Spring Boot 的编译插件，用来将项目打包成一个可运行的 jar。  </p>
<h3 id="入口类分析"><a href="#入口类分析" class="headerlink" title="入口类分析"></a>入口类分析</h3><p>创建完成的 Spring Boot 项目通常会有一个名为 *Application 的入口类，入口类有个 Java 标准的 main 方法，在 main 方法中运行如 <code>SpringApplication.run(DemoApplication.class, args)</code> 的代码来启动项目。  </p>
<p>入口类一般带有 <code>@SpringBootApplication</code> 注解，查看注解源：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = EnableAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;exclude&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = EnableAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;excludeName&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = ComponentScan.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;basePackages&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = ComponentScan.class,</span></span><br><span class="line"><span class="meta">        attribute = &quot;basePackageClasses&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@SpringBootApplication 是一个组合注解，它包含 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan 注解。<br>		<br>其中，@EnableAutoConfiguration 可以让 Spring Boot 根据类路径中依赖的 jar 包为项目自动配置。比如添加了 <code>spring-boot-starter-web</code> 依赖，则会自动添加 tomcat 和 Spring MVC 依赖，同时自动配置 tomcat 和 Spring MVC。  </p>
<p>使用 exclude 可以在扫描时过滤某些类，如 <code>@SpringBootApplication(exclude=CacheAutoConfiguration.class)</code>。Spring Boot 会自动扫描 <code>@SpringBootApplication</code> 所在类同级或下级包中的 Bean，因此入口类最好放在 <code>groupId.artifactId</code> 包下。</p>
<h3 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h3><p>在 <code>src/main/resources</code> 下添加 banner.txt 文件，在 <a href="http://patorjk.com/software/taag">http://patorjk.com/software/taag</a> 中选择 banner 样式并复制到 banner.txt 文件中。当然可以选择不显示 banner。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(DemoApplication.class);</span><br><span class="line">		app.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">		app.run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(DemoApplication.class)</span><br><span class="line">                .bannerMode(Banner.Mode.OFF)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>如果不想使用默认的 jar 版本，可以在 pom.xml 中使用 properties 添加版本以覆盖默认的版本。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认的 <code>spring-boot-starter-parent</code> 不一定适合所有的场景，可以使用自定义的父级依赖。如果不想使用默认的 <code>spring-boot-starter-parent</code>，又想使用默认的依赖管理，可以使用 import，并在 pom.xml 中如下配置：  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述配置不能通过 properties 修改默认的依赖版本，只能在 dependencyManagement 中指定版本。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Srping Boot 提供了很多起始依赖（starter pom），具体参考：<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-starter">spring boot starter pom</a>。同时可以选择不同的 Servlet 容器，如 <code>spring-boot-starter-jetty</code> 和 <code>spring-boot-starter-undertow</code>。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 排除 tomcat starter --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jetty container --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot-DevTools"><a href="#Spring-Boot-DevTools" class="headerlink" title="Spring Boot DevTools"></a>Spring Boot DevTools</h3><p>spring-boot-devtools 是为开发者提供的一个热部署工具，当我们修改了项目 classpath 下的文件时，Spring Boot 会重启应用，当然这个启动很快。原理就是使用了两个类加载器，一个为 base 类加载器，用来加载一般不会改变的类，如第三方 jar 包等；一个为 restart 类加载器，用来加载经常改变的类，如我们正在开发的类，应用重启时，原先的 restart 加载器被丢弃，重新创建 restart 加载器加载修改过的文件。		<br>		<br>如果觉得 restart 不够快，还可以尝试使用<a href="https://jrebel.com/software/jrebel/"> JRebel </a> 或<a href="https://github.com/spring-projects/spring-loaded"> Spring Loaded </a>。  </p>
<h4 id="配置-devtools-dependency"><a href="#配置-devtools-dependency" class="headerlink" title="配置 devtools dependency"></a>配置 devtools dependency</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- optional 为 true 表示该依赖不会传递，即该项目依赖 devtools，</span></span><br><span class="line"><span class="comment">    别的项目再依赖该项目时，需要手动再配置 devtools --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="触发重启"><a href="#触发重启" class="headerlink" title="触发重启"></a>触发重启</h4><p>只要 classpath 中的文件发生改变就会触发。在使用 IDE 时，如果是 eclipse，只需编辑后保存即可（eclipse 默认开启了 build automatically）。如果是 IDEA，一般情况下可能没有设置自动 build，此时需要手动 build 项目。  </p>
<p>当然，某些文件的改变并不会重启应用，而是重新加载资源。查看 <code>DevToolsProperties</code> 类的源码会发现，默认不重启应用的目录和文件为：  </p>
<ul>
<li><code>META-INF/maven/**</code></li>
<li><code>META-INF/resources/**</code></li>
<li><code>resources/**</code></li>
<li><code>static/**</code></li>
<li><code>public/**</code></li>
<li><code>templates/**</code></li>
<li><code>**/*Test.class</code></li>
<li><code>**/*Tests.class</code></li>
<li><code>git.properties</code></li>
<li><code>META-INF/build-info.properties</code></li>
</ul>
<p>（其中 static、public、templates 都是 resources 下目录）。可以在全局配置文件中选择排除某些目录：  </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用该配置后，static 和 public 目录下的资源修改不会重启应用</span></span><br><span class="line"><span class="attr">spring.devtools.restart.exclude</span>=<span class="string">static/**,public/**</span></span><br></pre></td></tr></table></figure>

<p>如果想保留默认配置并添加额外的排除配置，可以使用 <code>spring.devtools.restart.additional-exclude</code>。对于不在 classpath 下的文件，也可以使用 <code>spring.devtools.restart.additional-paths</code> 设置目录以监视其更改。</p>
<h4 id="关闭热部署"><a href="#关闭热部署" class="headerlink" title="关闭热部署"></a>关闭热部署</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在全局配置中加入以下配置，restart 类加载器还是会初始化，但不会再监视文件修改</span></span><br><span class="line"><span class="attr">spring.devtools.restart.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="comment">// 关闭热部署功能</span></span><br><span class="line">   System.setProperty(<span class="string">&quot;spring.devtools.restart.enabled&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(DemoApplication.class)</span><br><span class="line">            .bannerMode(Banner.Mode.OFF)</span><br><span class="line">            .run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置触发文件"><a href="#设置触发文件" class="headerlink" title="设置触发文件"></a>设置触发文件</h4><p>有的时候我们会频繁修改某些文件，我们希望能够在某个时机来重启。通过设置触发文件，在想要重启时，修改触发文件来达到触发重启的目的。  </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.devtools.restart.trigger-file</span>=<span class="string">某个文件</span></span><br></pre></td></tr></table></figure>

<h4 id="Live-Reload-插件"><a href="#Live-Reload-插件" class="headerlink" title="Live Reload 插件"></a>Live Reload 插件</h4><p>Devtools 内置了一个 Live Reload 服务，可以在资源发生改变时来刷新浏览器页面，这个功能需要配合<a href="http://livereload.com/"> Live Reload </a>，也可以在 Chrome 应用商店中搜索 LiveReload 插件安装。  </p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在 Spring Boot 中，可以通过 properties 文件、YAML 文件、环境变量和命令行参数来设置参数，然后使用 <code>@Value</code> 注解从 Spring 的 Environment 获取参数值，也可以通过 <code>@ConfigurationProperties</code> 注解将值绑定到 Bean 上。  </p>
<h4 id="参数取值途径"><a href="#参数取值途径" class="headerlink" title="参数取值途径"></a>参数取值途径</h4><p>以下配置覆盖的优先级顺序由高到低，高优先级的可以覆盖低优先级的形成互补。</p>
<ul>
<li>当 devtools 激活时，全局配置 <code>~/.spring-boot-devtools.properties</code></li>
<li><code>@TestPropertySource</code> 测试注解</li>
<li><code>@SpringBootTest#properties</code> 测试注解属性</li>
<li>命令行参数</li>
<li><code>SPRING_APPLICATION_JSON</code> 中的属性		<br>(通过 <code>$ SPRING_APPLICATION_JSON=&#39;&#123;&quot;foo&quot;:&#123;&quot;bar&quot;:&quot;spam&quot;&#125;&#125;&#39; java -jar xxx.jar</code> 设置)</li>
<li>ServletConfig 初始化参数</li>
<li>ServletContext 初始化参数</li>
<li><code>java:comp/env</code> 中的 JNDI 属性</li>
<li>Java 系统属性 (<code>System.getProperties()</code>)</li>
<li>系统环境变量</li>
<li><code>RandomValuePropertySource</code> 提供的随机值</li>
<li>应用之外的 <code>application-&#123;profile&#125;.properties</code>、<code>application.properties</code> 和 YAML 文件</li>
<li>应用内部的 <code>application-&#123;profile&#125;.properties</code>、<code>application.properties</code> 和 YAML 文件</li>
<li>带 <code>@Configuration</code> 注解的配置类的 <code>@PropertySource</code> 注解</li>
<li>通过 <code>SpringApplication.setDefaultProperties</code> 指定的默认属性</li>
</ul>
<h4 id="Value-注解"><a href="#Value-注解" class="headerlink" title="@Value 注解"></a>@Value 注解</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">com.nekolr.name</span>=<span class="string">nekolr</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;com.nekolr.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绑定到-bean"><a href="#绑定到-bean" class="headerlink" title="绑定到 bean"></a>绑定到 bean</h4><p>一个一个绑定到对应属性比较麻烦，可以选择直接绑定到 bean 上。  </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">com.nekolr.name</span>=<span class="string">nekolr</span></span><br><span class="line"><span class="attr">com.nekolr.address</span>=<span class="string">nekolr.com</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;com.nekolr&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置好配置类后，还需要将配置类添加到入口类上。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(DemoApplication.class)</span><br><span class="line">                .bannerMode(Banner.Mode.OFF)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在需要用到配置类的地方，注入即可使用。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ConfigBean configBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is index &quot;</span> + configBean.getName() </span><br><span class="line">                + <span class="string">&quot; &quot;</span> + configBean.getAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(DemoApplication.class)</span><br><span class="line">                .bannerMode(Banner.Mode.OFF)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="随机值"><a href="#随机值" class="headerlink" title="随机值"></a>随机值</h4><p>Spring Boot 的 <code>RandomValuePropertySource</code> 提供了一些随机值生成，方便开发使用。  </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="attr">bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="attr">uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="attr">number.less.than.ten</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="attr">number.in.range</span>=<span class="string">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="参数引用"><a href="#参数引用" class="headerlink" title="参数引用"></a>参数引用</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">com.nekolr.name</span>=<span class="string">nekolr</span></span><br><span class="line"><span class="attr">com.nekolr.address</span>=<span class="string">$&#123;com.nekolr.name&#125;.com</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h4><p>可以不将配置放在 applcation.properties 文件，使用 <code>PropertySource</code> 指定自定义的配置文件。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;com.nekolr&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:custom.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Profile-多环境"><a href="#Profile-多环境" class="headerlink" title="Profile 多环境"></a>Profile 多环境</h4><p>我们知道，在开发时和应用上线运行时，应用具体的配置可能会有所不同，每次修改替换配置文件比较麻烦，此时可以使用 profile 多环境配置。  </p>
<p>除了 application.properties 文件外，还可以设置特定的配置文件，文件的格式为：application-${profile}.properties，比如：application-dev.properties，在 application.properties 中设置 spring.profiles.active&#x3D;dev 或者通过命令行 <code>java -jar xxx.jar --spring.profiles.active=dev</code> 来指定当前激活的是哪个特定的配置文件。  </p>
<p>也可以使用 <code>@Profile</code> 注解来表明当前配置属于哪个 profile，然后在 application.properties 中设置当前激活哪个环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:db.properties&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;db.user&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String user;</span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">  <span class="meta">@Bean(&quot;test&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">testDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.test.url&#125;&quot;)</span> String url)</span> &#123;</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    dataSource.setUser(user);</span><br><span class="line">    dataSource.setPassword(password);</span><br><span class="line">    dataSource.setUrl(url);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">  <span class="meta">@Bean(&quot;dev&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> DataSource <span class="title function_">devDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.dev.url&#125;&quot;)</span> String url)</span> &#123;</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    dataSource.setUser(user);</span><br><span class="line">    dataSource.setPassword(password);</span><br><span class="line">    dataSource.setUrl(url);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">Spring Boot 常用配置汇总</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>动静分离与 AJP 协议</title>
    <url>/2020/06/18/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E4%B8%8E%20AJP%20%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>像 Tomcat、Jetty、Undertow 等这些 Web 容器（也可以看作是 Servlet 容器），它们既可以运行动态程序（Servlet&#x2F;JSP），又可以处理静态资源，但是一般情况下，它们处理静态资源的能力与 Apache、Nginx 等这些 HTTP Server 相比要弱很多，因此在很多系统中会采用动静分离的设计，即使用 HTTP Server 作为入口网关，所有的静态资源由 HTTP Server 直接处理，而其他的动态内容则转发给 Servlet 容器。</p>
<span id="more"></span>

<p>使用 Apache HTTP Server 作为入口网关，与 Servlet 容器建立关系一般有两种方式：HTTP 代理和 AJP 代理。利用 Apache 自带的 <code>mod_proxy</code> 和 <code>mod_proxy_http</code> 模块配合，就可以实现 HTTP 代理。而要实现 AJP 代理，可以使用 Apache 自带的 <code>mod_proxy</code> 和 <code>mod_proxy_ajp</code> 模块配合，或者使用 <code>mod_jk</code> 模块，JK 模块稳定性强，但是配置较为复杂。</p>
<p>下面需要多说一下 AJP 协议，也就是 Apache JServ Protocol version 1.3（简称 ajp13）。AJP13 是一个定向包（面向数据包的）协议，出于性能考虑，它采用了更具可读性的纯文本的二进制格式传输数据。<strong>通过该协议，HTTP Server 能够直接与 Servlet 容器进行通信</strong>。实现了该协议的 HTTP Server 会与 Servlet 容器建立 TCP 连接，为了减少进程反复创建 Socket 造成的资源消耗，它们之间会尝试保持持久性的 TCP 连接（长连接），一个 HTTP Server 一般会与一个 Servlet 容器维持多个 TCP 连接（TCP 连接池）。对于多个请求&#x2F;响应会重用一个连接，一旦连接分配给一个特定的请求，在请求处理周期结束之前该连接将不再响应其他任何请求。换句话说，请求不会通过连接进行多路复用，这么做可以使连接两端的编码变得简单，但是可能会导致某一时刻同时打开大量的连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202006190013/2020/06/18/Aa1.png" alt="AJP"></p>
<p>使用 HTTP 代理只能保持短时间内的连接，可能需要经常进行 TCP 的三次握手和四次挥手，而使用 AJP 代理可以长时间保持 TCP 连接，理论上来说性能更好。但是在目前 Nginx 为主流的大环境下，AJP 几乎没有应用环境（Nginx 官方不支持 AJP 协议），因此我们在使用 Tomcat 的时候一般会选择关闭 AJP 连接器。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2018/07/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式是相对比较简单的设计模式，也是 Java 中常用常见的设计模式。</p>
<span id="more"></span>

<h1 id="饥饿模式（线程安全）"><a href="#饥饿模式（线程安全）" class="headerlink" title="饥饿模式（线程安全）"></a>饥饿模式（线程安全）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饥饿模式也叫饿汉式，由 static 保证对象实例只在类加载时创建一次，说它线程安全是因为类的初始化是由 ClassLoader 完成的，而加载类的 loadClass 方法是通过 <code>synchronized</code> 修饰的。对于大对象来说，这种方式还是比较浪费内存的，因此可以通过懒加载的方式来创建。</p>
<h1 id="懒加载（线程不安全，不推荐）"><a href="#懒加载（线程不安全，不推荐）" class="headerlink" title="懒加载（线程不安全，不推荐）"></a>懒加载（线程不安全，不推荐）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">lazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒加载也叫懒汉模式，只有在真正要用到对象实例时才创建对象。但是这带来了新的问题，即由于线程不安全导致单例可能会变成多例，比较简单的处理方式就是加入同步。</p>
<h1 id="线程安全的懒加载"><a href="#线程安全的懒加载" class="headerlink" title="线程安全的懒加载"></a>线程安全的懒加载</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">lazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入同步固然能够保证线程安全，但是为了性能考量，又引入了一种新的方式：双重检查锁模式。</p>
<h1 id="双重检查锁模式（只为了演示，不推荐使用）"><a href="#双重检查锁模式（只为了演示，不推荐使用）" class="headerlink" title="双重检查锁模式（只为了演示，不推荐使用）"></a>双重检查锁模式（只为了演示，不推荐使用）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">lazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检查锁模式首先检查实例是否被创建，如果已创建则返回；没有则进入临界区，再次检查实例是否被创建，没有则会创建对象。第一重检查是为了提高性能，通过空判断避免每次都进入临界区，只有在需要创建对象时才进入。这个优化看起来是很完美的，然而实际上它是存在隐患的。</p>
<p>JVM 在创建对象时会分为如下三步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配内存空间</span></span><br><span class="line">memory = allocate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行构造方法，初始化对象</span></span><br><span class="line">ctorInstance(memory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 instance 指向分配的内存空间</span></span><br><span class="line">instance = memory;</span><br></pre></td></tr></table></figure>

<p>可以看到，第二行和第三行代码依赖于第一行的结果，但是第二行和第三行代码之间不存在依赖性，并且我们知道 <code>synchronized</code> 的有序性是指加锁之前必须解锁，它无法做到像 volatile 一样禁止指令重排序，所以在代码 <code>instance = new LazySingleton()</code> 部分可能会发生以下情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate memory for Singleton object.</span></span><br><span class="line"><span class="comment">// 为对象分配内存</span></span><br><span class="line">memory = allocate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that instance is now non-null, but has not been initialized.</span></span><br><span class="line"><span class="comment">// 将 instance 指向分配的内存空间，此时还没完成实例的初始化</span></span><br><span class="line">instance = memory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke constructor for Singleton passing instance.</span></span><br><span class="line"><span class="comment">// 传递实例，执行构造方法</span></span><br><span class="line">ctorSingleton(instance);</span><br></pre></td></tr></table></figure>

<p>这在一些 JIT 编译器上是会真实发生的，这种重排序带来的问题就是如果一个线程在执行完内存分配以及部分初始化后，其他线程访问获取实例的方法，此时的实例对象已经非空了，所以该线程将会获取到一个还未初始化完成的对象。为了避免这种问题的发生，可以使用 volatile 改造。</p>
<h1 id="优化双重检查锁"><a href="#优化双重检查锁" class="headerlink" title="优化双重检查锁"></a>优化双重检查锁</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">lazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先行发生原则中指出，对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。因此使用 volatile 可以保证实例变量在未完全初始化之前不会被读取。</p>
<h1 id="Initialization-On-Demand-Holder"><a href="#Initialization-On-Demand-Holder" class="headerlink" title="Initialization On Demand Holder"></a>Initialization On Demand Holder</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式使用内部类来做到延迟加载对象，同时在初始化这个内部类的时候，由 JLS（Java Language Sepcification）保证这个类的线程安全，详情可以查看我在参考中附加的链接。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    SINGLETON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举不仅能够避免多线程同步问题，还能<strong>防止反射和反序列化</strong>重新创建新对象，被《Effective Java》的作者 Josh Bloch 所提倡，详情可以查看我在参考中附加的链接。</p>
<h1 id="单例的三个问题"><a href="#单例的三个问题" class="headerlink" title="单例的三个问题"></a>单例的三个问题</h1><h2 id="反射会破坏单例"><a href="#反射会破坏单例" class="headerlink" title="反射会破坏单例"></a>反射会破坏单例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; type = Singleton.class;</span><br><span class="line">        Constructor&lt;?&gt; constructor = type.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 暴力获取权限</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1 == instance2); <span class="comment">// 返回 false，说明不是同一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前笔者所知的处理手段就是使用枚举实现单例，可以避免反射攻击。</p>
<h2 id="序列化会破坏单例"><a href="#序列化会破坏单例" class="headerlink" title="序列化会破坏单例"></a>序列化会破坏单例</h2><p>如果单例类实现了 <code>java.io.Serializable</code> 接口，那么这个类的实例就可能被序列化破坏（能够通过反序列化来复原多个实例从而变成多例，原因是序列化会通过反射调用无参数的构造方法来创建一个新的对象）。解决方法就是在单例类中添加一个 <code>readResolve</code> 方法始终返回同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用不同的类加载器加载会破坏单例"><a href="#使用不同的类加载器加载会破坏单例" class="headerlink" title="使用不同的类加载器加载会破坏单例"></a>使用不同的类加载器加载会破坏单例</h2><p>如果单例类由不同的类加载器加载，可能就会存在多个单例类的实例，比如一些 Servlet 容器对每个 Servlet 使用完全不同的类加载器，如果 Servlet 中使用单例类，就会造成每个 Servlet 使用的都不是同一个单例对象。解决方法留待以后探究。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129/">Java 单例模式中双重检查锁的问题</a></p>
</blockquote>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F">双重检查锁定模式</a></p>
</blockquote>
<blockquote>
<p><a href="http://gee.cs.oswego.edu/dl/cpj/updates.html">Updates for J2SE 5.0 (aka 1.5, Tiger)</a></p>
</blockquote>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom">Initialization-on-demand holder idiom</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.hollischuang.com/archives/197">深度分析 Java 的枚举类型—-枚举的线程安全性及序列化问题</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.hollischuang.com/archives/1144">单例与序列化的那些事儿</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器简介</title>
    <url>/2020/08/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对于垃圾收集器应该如何实现并没有规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都有可能不同。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/6E7.png" alt="垃圾收集器汇总"></p>
<p>图中是 HotSpot 虚拟机中的垃圾收集器，它们作用于不同分代，如果两个收集器之间存在连线，那么就代表它们可以搭配使用。在 JDK 8 中，它们常见的搭配组合如下：</p>
<table>
<thead>
<tr>
<th>新生代</th>
<th>老年代</th>
<th>JVM Options</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>Serial Old</td>
<td>-XX:+UseSerialGC</td>
</tr>
<tr>
<td>Parallel New</td>
<td>CMS</td>
<td>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td>-XX:+UseParallelGC -XX:+UseParallelOldGC</td>
</tr>
<tr>
<td>G1</td>
<td>G1</td>
<td>-XX:+UseG1GC</td>
</tr>
</tbody></table>
<h1 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h1><p>Serial 是最基本、发展历史最长的垃圾收集器，在 JDK 1.3.1 之前是新生代垃圾收集的唯一选择。它是一个单线程的收集器，同时它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/3Je.png" alt="Serial"></p>
<p>虽然 Serial 是一个串行的收集器，但是它简单而高效（相对于其他收集器的单线程来说），对于单个 CPU 的环境来说，Serial 收集器由于没有线程切换的开销，专心做垃圾收集可以获得较高的收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p>
<h1 id="Parallel-New"><a href="#Parallel-New" class="headerlink" title="Parallel New"></a>Parallel New</h1><p>ParNew 垃圾收集器其实就是 Serial 垃圾收集器的多线程版本，除此之外并没有太多创新之处，很多运行在 Server 模式的虚拟机选择使用它作为新生代垃圾收集器的一个很重要的原因就是，除了 Serial 收集器外，只有它能够与 CMS 收集器配合工作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/ooa.png" alt="ParNew"></p>
<p>ParNew 收集器在单 CPU 环境中比 Serial 收集器效果差，但是当 CPU 数量增加时，它可以在 GC 时更有效地利用系统资源。它默认开启的收集线程数与 CPU 的数量相当，当然也可以通过参数 <code>-XX:ParallelGCThreads</code> 自定义垃圾收集的线程数。</p>
<h1 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h1><p>Parallel Scavenge 也是新生代的垃圾收集器，它同样使用的是复制算法，同时也是并行的多线程收集器，但是它的关注点与其他收集器不同，像 CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 的目的则是为了达到一个可控制的吞吐量（Throughout）。所谓吞吐量是指 CPU 用于运行用户代码的时间与 CPU 总的消耗时间的比值，即吞吐量 &#x3D; 运行用户代码的时间 &#x2F; (运行用户代码的时间 + 垃圾收集的时间)，如果虚拟机总共运行了 100 分钟，其中垃圾收集花费了 1 分钟，那么吞吐量就是 99 %。</p>
<p>它提供了两个参数用于精确控制吞吐量，一个是用于控制最大垃圾收集停顿时间（<code>-XX:MaxGCPauseMillis</code>）的参数和一个直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数。MaxGCPauseMillis 可以是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过该值，但是我们需要明白 GC 停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的，比如我们把新生代设置的小一点，将原先的 500 MB 设置为 300 MB，这样垃圾收集的速度肯定快了，但是这也可能导致新生代由于内存空间不足而垃圾收集更加频繁，原来 10 秒收集一次，每次停顿 100 毫秒，现在变成了 5 秒收集一次，每次停顿 70 毫秒，停顿时间是下降了，但是吞吐量也跟着下降了。</p>
<p>GCTimeRatio 参数应当是一个大于 0 且小于 100 的整数 N，它将垃圾回收时间与应用程序运行的总时间的比率设置为 1 &#x2F; (1 + N)，所以当 N 为 19 时，表示垃圾回收的时间占总时间的比率为 5 %。N 的默认值为 99，即只有 1 % 的时间用于垃圾收集。</p>
<p>除了这两个参数外，还有一个 <code>-XX:UseAdaptiveSizePolicy</code> 参数，当该参数开启时，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 的比例（-XX:SurvivorRatio）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态地调整这些参数，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。</p>
<h1 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h1><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程的收集器，使用“标记-整理”算法，它对于运行在 Client 模式下的虚拟机的来说是一个很好的选择，而在 Server 模式下，它可以在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，或者作为 CMS 收集器的后备预案。</p>
<h1 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h1><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用“标记-整理”算法，在 JDK 1.6 才开始提供，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态，因为它除了和 Serial Old 收集器搭配外别无选择。由于老年代的 Serial Old 收集器在服务端性能上的“拖累”，使得即使是使用了 Parallel Scavenge 收集器也未必能在整体上获得吞吐量最大化的效果。</p>
<h1 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h1><p>CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器，它基于“标记-清除”算法实现，它的运作过程相对于前面的几种收集器来说更为复杂，整个过程分为四个步骤：初始标记（CMS initial mark）、并发标记（CMS concurrent mark）、重新标记（CMS remark）和并发清除（CMS concurrent sweep），其中初始标记和重新标记都需要“Stop The World”。</p>
<p>初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing 的过程，而重新标记则是为了修正并发标记期间因用户程序继续执行而导致标记产生变动的哪些对象的标记，这个阶段停顿的时间一般比初始标记要稍长，但又远比并发标记时间短。整个过程中，并发标记和并发清除阶段的收集器线程都可以与用户线程同时运行，所以总体上来说，CMS 收集器的内存回收过程几乎是与用户线程一起并发执行的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/B7e.png" alt="CMS"></p>
<p>CMS 是一款优秀的垃圾收集器，它可以并发收集，能够做到低停顿，但是它有几个明显的缺点，比如对于 CPU 资源非常敏感（面向并发设计的程序对于 CPU 资源都比较敏感）。CMS 默认启动的回收线程数为(CPU 数 + 3) &#x2F; 4，在并发阶段，它虽然不会导致用户线程停顿，但是有可能会因为占用了一部分 CPU 资源而导致用户程序变慢。</p>
<p>还有就是它无法处理浮动垃圾（Floating Garbage），可能会导致出现 Concurrent Mode Failure 从而引发一次 Full GC。由于在 CMS 在并发清除阶段用户线程还在运行，自然就会有新的垃圾不断产生，这部分垃圾出现在标记过程之后，CMS 无法在当次集中回收它们，只好等待下一次 GC。因此，CMS 收集器不能像其他收集器那样在老年代快要填满时才进行收集，它需要预留一部分空间给并发收集期间的用户线程使用。通过 <code>-XX:CMSInitiatingOccupancyFraction</code> 参数可以调整触发收集时老年代的使用比例。在 JDK 1.5 中，该阈值为 68 %，而在 JDK 1.6 中则提高到了 92 %，并且如果 CMS 运行期间预留的内存无法满足需要时，会出现 Concurrent Mode Failure 并启动预备方案：临时启动 Serial Old 重新进行老年代的垃圾收集。</p>
<p>由于 CMS 是基于“标记-清除”算法实现的，这就意味着垃圾收集后可能会产生大量的内存空间碎片，这会给后来的大对象内存分配带来麻烦，可能老年代还有很大的内存空间剩余，但是却无法找到足够大的连续空间进行分配，从而不得不提前触发一次 Full GC。为了解决这个问题，CMS 提供了内存碎片合并整理的功能，但是整理的过程是无法并发的，碎片问题没有了，但是停顿时间也增加了。</p>
<h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>G1 在 JDK 1.7 中正式发布，它的使命是替换掉 JDK 1.5 中发布的 CMS 收集器。G1（Garbage First）是一款分代、增量、并行、大部分时间并发的垃圾收集器，从整体上看它是基于“标记-整理”算法。</p>
<p>G1 中虽然还有分代的概念，但是它进行垃圾收集的范围却是整个堆，它将堆划分为多个大小相等的独立区域（Region），每个 Region 内都是一些连续的虚拟内存。Region 是进行内存分配和回收的基本单位，在某个特定的时间点，一个 Region 可能是空闲的（图中浅灰色区域），也有可能被分配到了某个分代（generation）中，可能是新生代或者老年代。当收到内存分配的请求时，内存管理器就会将空闲的 Region 分配给某个分代，然后将它们作为可分配自身的可用空间返回给应用程序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/30/lV9.png" alt="G1 Heap Layout"></p>
<p>图中的红色区域和标有 S 的红色区域分别为新生代的 Eden 区和 Survivor 区，这些 Region 在内存中通常是物理上不连续的。浅蓝色的 Region 组成了老年代，标有 H 的浅蓝色区域代表的是大对象（Humongous）Region，这些对象可以横跨多个 Region。</p>
<p>G1 进行垃圾收集的生命周期可以分为两个阶段：Young-only 阶段和 Space-reclamation 阶段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/30/jjL.png" alt="G1 垃圾收集的生命周期"></p>
<p>Young-only 阶段从新生代的一些 Young GC 开始。Young GC 采用复制算法，并行收集，垃圾收集时会发生 STW 暂停，活跃的对象被复制到 Survivor 区域，如果达到晋升的阈值，对象会晋升到老年代的区域。与其他垃圾收集器不同的是，G1 会根据预测的停顿时间动态地调整新生代的大小。当老年代空间的占用率达到一个阈值时（具体来说是整个堆的空间占用达到一个阈值，该阈值通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 参数控制，默认为 45，即 45 %）就会开始 Young-only 阶段到 space-reclamation 阶段的转换，这个过程的第一个子阶段就是 Concurrent Start。</p>
<p>在 Concurrent Start 阶段，G1 除了会进行 Young GC 外，还会根据新生代 Survivor 区以及老年代的 Remembered Set（记录对象的引用关系，加快活跃对象的遍历）开始并发标记的过程，此时会启动多个并发的标记线程，每个线程每次只扫描一个 Region，标记出存活对象。这个过程不需要 STW，因此用户线程可以与标记线程并发执行。</p>
<blockquote>
<p>这里需要说明的是，在并发标记之前的 Young GC 其实也是初始标记的过程，因为在 Young GC 的过程中，首先会查找直接可达的一些根对象（栈对象、全局对象、JNI 对象等），然后暂停用户线程进行初始标记并进行内存回收。其实混合回收（Mixed GC）就是借用了新生代回收的结果，即将新生代进行垃圾回收后的 Survivor 区作为根。</p>
</blockquote>
<p>接下来就是 Remark 阶段，在这个阶段中 G1 需要 STW，找出所有未被访问的存活对象，做全局的引用处理和类卸载，回收全空的 Region 并清理内部的数据结构，计算老年代可回收的空间，最终结束并发标记的过程。然后就是清理阶段（Cleanup），该阶段也需要 STW，并在该停顿中决定是否要开始 Space-reclamation 阶段。</p>
<p>Space-reclamation 阶段由多个 Mixed GC 组成，Mixed GC 不光回收新生代的 Region，同时也会回收老年代的 Region。当 G1 发现无法回收更多的老年代内存时，该阶段就结束了，接着会重新回到 Young-only 阶段开始一个新的回收周期。同时为了以防万一，在收集存活对象的时候，如果应用内存耗尽了，G1 也会像其他收集器那样进行整个堆的 STW 压缩，即 Full GC。</p>
<h1 id="ZGC-和-Shenandoah"><a href="#ZGC-和-Shenandoah" class="headerlink" title="ZGC 和 Shenandoah"></a>ZGC 和 Shenandoah</h1><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><table>
<thead>
<tr>
<th>JDK 版本</th>
<th>默认的垃圾收集器</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 7</td>
<td>Parallel Scavenge + Parallel Old</td>
</tr>
<tr>
<td>JDK 8</td>
<td>Parallel Scavenge + Parallel Old</td>
</tr>
<tr>
<td>JDK 9</td>
<td>G1</td>
</tr>
<tr>
<td>JDK 11</td>
<td>G1</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep">GC Algorithms: Implementations</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/aspirant/p/8663872.html">G1 垃圾收集器架构和如何做到可预测的停顿</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>如何构建自定义的 jQuery</title>
    <url>/2018/03/23/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%20jQuery/</url>
    <content><![CDATA[<p>在我大三的时候就开始使用 jQuery 了，到今天这才不过两三年的时间，前端已经发生巨大的变化：ES 标准不断改进，各种框架、工具层出不穷等等。一些新的项目，新的需求已经完全不需要依赖 jQuery 了。</p>
<span id="more"></span>

<p>回想我用 jQuery 的原因，我简单总结如下：  </p>
<ul>
<li>强大的选择器</li>
<li>简化了 DOM 操作</li>
<li>处理了令人头疼的浏览器兼容性问题</li>
<li>封装良好的 AJAX</li>
<li>丰富的插件支持</li>
</ul>
<p>但是随着 ES 标准的发展，各个浏览器厂商的支持，jQuery 时代遇到的这些问题在现在都几乎不是问题了。新的 DOM 标准借鉴 jQuery 加入许多新的方法；IE6 等浏览器逐渐退出历史舞台，以及主流浏览器对 ES 标准的支持，即便有兼容性问题，也可以使用 <code>polyfill/shim</code> 实现来解决。况且新的框架如 React、Angular 取代 jQuery 是完全不在同一层面的。</p>
<p>总的来说，jQuery 虽然已经过时，但是老当益壮，我们仍然可以拿来解决生产问题，当然我们这时就可以很大胆的思考是否有比 jQuery 更好的方案。</p>
<p>前面说了这么多，更多的是缅怀，接下来开始看问题。我们经常吐槽 jQuery 的庞大（也许与 Ext 相比反而很轻量）。最新的版本 jquery-3.3.1.js 大小有 265KB 之多，即便是压缩后的文件也有 80 多 KB。当然如果服务器开启 gzip，文件大小会小很多，但是有没有别的方式来缩减 jquery 的大小呢，比如说砍掉部分 jquery 的功能？</p>
<p>不瞒你说，博主之前还尝试过提取 jquery 的 ajax 方法，但是里面牵扯甚多，最终不得不放弃。一个偶然的机会发现 jquery 可以选择剔除自己不需要的模块，自己构建 jquery，在这里记录一下。</p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>在开始前，你要先了解 <code>git</code>、<code>node.js</code>、<code>npm</code> 和 <code>grunt</code>，当然只需要了解它们是做什么的并安装在你的系统中就可以了。</p>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><ul>
<li>将 jquery 的仓库 clone 到本地</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 npm 安装依赖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd jquery &amp;&amp; npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<ul>
<li>安装 grunt，或者直接使用命令 <code>npm run build</code> 会自动安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g grunt-cli --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 grunt 命令去掉不需要的模块，这里用 ajax 举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grunt custom:-ajax</span><br></pre></td></tr></table></figure>

<p>现在你可以去 dist 目录看看了，你会发现构建出来的 jQuery 代码少了很多，至于可以剔除哪些模块，可以看 jQuery 的 github 仓库的说明：<a href="https://github.com/jquery/jquery">https://github.com/jquery/jquery</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/ppg.png" alt="缩减前"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/Nkr.png" alt="缩减后"></p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>如何统计所有线程执行耗时</title>
    <url>/2017/08/14/%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6/</url>
    <content><![CDATA[<p>想法一：在 main 线程中打印当前时间，设置一个守护线程，在所有线程结束后获取当前时间减去初始时间。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;所有线程执行耗时(ms)：&quot;</span> + (System.currentTimeMillis() - start)));</span><br><span class="line"></span><br><span class="line">        daemon.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        daemon.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">90000000</span>; j++)&#123;</span><br><span class="line">                    count+=j;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想法二：使用线程的 join() 方法，统计 main 线程从开始到结束的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">90000000</span>; j++) &#123;</span><br><span class="line">                    count += j;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">            &#125;, <span class="string">&quot;thread&quot;</span> + i);</span><br><span class="line">            threads.add(t);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程执行耗时(ms)：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想法三：使用 <code>java.util.concurrent</code> 包下的同步辅助类 <code>CountDownLatch</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">90000000</span>; j++) &#123;</span><br><span class="line">                    count += j;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();<span class="comment">// 当前线程阻塞</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程执行耗时(ms)：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java 多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获取 InnoDB 树的高度</title>
    <url>/2019/09/12/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%20InnoDB%20%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<p>磁盘存储数据的最小单元是扇区，一般一个扇区的大小是 512 字节，计算机操作系统为了更好地与磁盘通信，抽象出了簇或块的概念，一般大小为 4K。InnoDB 存储引擎也有自己的最小存储单元——页，默认页的大小为 16K，我们可以通过以下命令查看该值。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;innodb_page_size&#x27;</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure>

<p>InnoDB 中所有的表空间文件的大小都是 16K 的整数倍。在 InnoDB 的表空间文件（这里说的不是共享的表空间，而是每个表独立的表空间）中，页号为 3 的页是主键索引的根页，其它索引的页号为 4，该值可以通过以下命令查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">b.name, a.name, index_id, <span class="built_in">type</span>, a.space, a.PAGE_NO</span><br><span class="line">FROM</span><br><span class="line">information_schema.INNODB_SYS_INDEXES a,</span><br><span class="line">information_schema.INNODB_SYS_TABLES b</span><br><span class="line">WHERE</span><br><span class="line">a.table_id = b.table_id AND a.space &lt;&gt; 0;</span><br><span class="line">+--------------------------------------------+---------------------------------------+----------+------+-------+---------+</span><br><span class="line">| name                                       | name                                  | index_id | <span class="built_in">type</span> | space | PAGE_NO |</span><br><span class="line">+--------------------------------------------+---------------------------------------+----------+------+-------+---------+</span><br><span class="line">| demo/t_certification                       | PRIMARY                               |       79 |    3 |    48 |       3 |</span><br><span class="line">| demo/t_certification                       | t_certification_idx                   |       80 |    0 |    48 |       4 |</span><br><span class="line">| demo/t_company_abstract                    | PRIMARY                               |       72 |    3 |    43 |       3 |</span><br><span class="line">| demo/t_company_location                    | PRIMARY                               |       73 |    3 |    44 |       3 |</span><br><span class="line">| demo/t_copyrights_copyright                | PRIMARY                               |       81 |    3 |    49 |       3 |</span><br><span class="line">+--------------------------------------------+---------------------------------------+----------+------+-------+---------+</span><br></pre></td></tr></table></figure>

<p>因为主键索引 B+树的根页在整个表空间文件中的第 3 页，所以我们可以计算出它在文件中的偏移量为：<code>16384 byte * 3 = 49152 byte</code>。根据《MySQL技术内幕：InnoDB存储引擎》的描述，MySQL 的数据页中，前 38 个字节为 File Header，紧接着的 56 个字节为 Page Header。在 Page Header 中，第 27 到 28 两个字节为 PAGE_LEVEL，代表当前页在索引树中的位置，值 0x00 表示当前页为叶子节点，<strong>叶子节点总是在第 0 层</strong>。由此我们可以推断出，只要拿到主键索引的根页中 PAGE_LEVEL 的值就可以计算整棵树的高度。具体来说就是根页中第 65 到 66 这两个字节的值。我们首先计算整体的偏移量为：<code>49152 byte + 64 byte = 49216 byte</code>。接下来我们使用 <code>hexdump</code> 查看表空间文件指定偏移量上的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认使用两字节十六进制表示，-C 采用单字节十六进制</span></span><br><span class="line">&gt; hexdump -C -s 49216 -n 10 ../data/demo/t_eci_company.ibd</span><br><span class="line">0000c040  00 03 00 00 00 00 00 00  00 29</span><br><span class="line">0000c04a</span><br><span class="line">&gt; hexdump -C -s 49216 -n 10 ../data/demo/t_eci_count.ibd</span><br><span class="line">0000c040  00 02 00 00 00 00 00 00  00 4a</span><br><span class="line">0000c04a</span><br></pre></td></tr></table></figure>

<p>可以看到例子中表 <code>t_eci_company</code> 的 PAGE_LEVEL 为 3，<code>t_eci_count</code> 的 PAGE_LEVEL 为 2，所以它们的树高分别为 4 和 3。</p>
<p>除了手工分析，我们还可以借助于工具。<a href="https://github.com/jeremycole/innodb_ruby">innodb_ruby</a> 就是一款可以分析 innoDB 文件的工具，使用 ruby 编写。在安装完 ruby 后，使用 ruby 的包管理工具直接下载该工具，然后我们简单使用一下，可以看到它的结果与我们的分析是一致的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; innodb_space -f ../data/demo/t_eci_company.ibd space-index-pages-summary | <span class="built_in">head</span> -n 10</span><br><span class="line">page        index   level   data    free    records</span><br><span class="line">3           41      3       92      16160   2</span><br><span class="line">4           41      0       14339   1909    16</span><br><span class="line">5           41      0       15117   1131    16</span><br><span class="line">6           41      0       8617    7633    9</span><br><span class="line">7           41      0       12208   4042    12</span><br><span class="line">8           41      0       9232    7018    9</span><br><span class="line">9           41      0       12755   3495    13</span><br><span class="line">10          41      0       7846    8404    8</span><br><span class="line">11          41      0       14079   2169    15</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://dev.mysql.com/doc/internals/en/innodb-page-overview.html">MySQL Internals Manual: High-Altitude View</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 Dubbo 之前：应用架构演变</title>
    <url>/2018/05/07/%E5%AD%A6%E4%B9%A0%20Dubbo%20%E4%B9%8B%E5%89%8D%EF%BC%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<p>今天在学习 Dubbo 时，看到 Dubbo 官方文档中对应用架构演变作了一个说明。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/KBb.png" alt="架构演变"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/0d7.png" alt="架构演变解释"></p>
<p>这是从大的阶段划分的，下面针对每个阶段大概分析一下，不涉及过多的细节。  </p>
<h1 id="单一应用架构演变"><a href="#单一应用架构演变" class="headerlink" title="单一应用架构演变"></a>单一应用架构演变</h1><p>一个小网站，一台服务器就足够了，文件服务、数据库服务和应用都部署在一起，俗称 All In One。随着用户增多，流量增大，硬盘、CPU 和内存吃紧，一台服务器已经不能满足了。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/28e.png" alt="单一应用架构"></p>
<h2 id="升级：硬件服务分离"><a href="#升级：硬件服务分离" class="headerlink" title="升级：硬件服务分离"></a>升级：硬件服务分离</h2><p>一台服务器不行了，常规的思路就是加机器，将硬件服务分开。一台服务器部署应用，一台作为文件服务器，一台作为数据库服务器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/Vzz.png" alt="硬件服务分离"></p>
<h2 id="升级：数据缓存"><a href="#升级：数据缓存" class="headerlink" title="升级：数据缓存"></a>升级：数据缓存</h2><p>单机模式下，常见的性能瓶颈往往在数据库查询，也就是 ORM 的工作。常见的手段是 SQL 优化、加入缓存。SQL 优化需要专业人员根据业务热点定位，具体优化。与之相比，采用缓存一般是更直接和高效的方式，可以选择增加数据库查询缓存，当然，这也就引入了新的复杂度。</p>
<blockquote>
<p><strong>思考</strong>：缓存从来不是数据库查询的特权，根据 28 原则，只要是应用中被大量访问的数据，我们都可以将它们缓存下来，然后看场景选择存放在本地（Local Cache）还是其他地方（Remote Cache）、是集中式存放还是分布式存放（Distributed Cache）。  </p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/gnd.png" alt="缓存"></p>
<h2 id="升级：读写分离、分库分表"><a href="#升级：读写分离、分库分表" class="headerlink" title="升级：读写分离、分库分表"></a>升级：读写分离、分库分表</h2><p>读写分离即将对数据库的读操作和写操作分离开，读操作一个数据库，写操作另一个数据库（分成主从数据库），写操作完成后同步到另一个数据库。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/jqN.jpg" alt="读写分离"></p>
<p>当业务增长到一定规模，数据库软件管理了大量的数据库表和数据，数据库操作开始变慢，这时候通常采用的方式就是分库分表。大量的数据在数据库中一般表现为，大量的数据分散到大量的表中造成表数量巨大或者是表数量并不是很多但每张表的数据量巨大，因此分库分表大体上有两种方式：一种是垂直拆分，即把关系紧密（比如一个模块）的表拆分出来放在一个单独的数据库中；一种是水平拆分，即把表中的数据按照某种规则（例如散列）拆分到多个数据库中。当然，很多时候需要根据实际情况进行混合拆分。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/qG7.jpg" alt="垂直拆分"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/07/v4m.jpg" alt="水平拆分"></p>
<h2 id="升级：动静分离"><a href="#升级：动静分离" class="headerlink" title="升级：动静分离"></a>升级：动静分离</h2><p>将用户请求的资源分为两种：静态资源和动态资源。静态资源如：图片、js 文件、css 文件等，动态资源如：jsp、php 等需要服务器端程序处理后才返回的资源。动静分离要求将对这两种资源的请求分开处理，之所以这么分，一是可以缓解单一 Web 服务器的压力；二是可以对静态资源使用 CDN 加速。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004181107/2020/04/18/ezr.png" alt="动静分离"></p>
<h2 id="升级：负载均衡"><a href="#升级：负载均衡" class="headerlink" title="升级：负载均衡"></a>升级：负载均衡</h2><p>每台服务器的进程是有限的，我们不能无限扩展服务器的配置，因此有必要将多个服务器组合起来处理业务。通常采用负载均衡技术，根据每台服务器的状态来判断用户的请求交由哪个服务器处理。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004181107/2020/04/18/Pra.png" alt="负载均衡"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上面的这些升级方案，很多并不是单一应用架构专属，它们很多是在架构演变的过程中产生，在一些分布式架构广泛使用。架构方案有很多共通点，我们只需要关注它们所解决的问题就可以了，有的方案并不是必须的，很多时候需要根据业务需求来决定。  </p>
<h1 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h1><p>我们在应用的外部环境做了太多的努力，是时候关注一下应用本身了。我们的应用本身也许设计的就不合理。垂直应用架构简单来说就是将以前的单体应用拆分成几个互不相干的应用。比如人人网在之前，因为是社交网站，就把应用拆分成了 SNS，UGC 和各个游戏子应用。  </p>
<blockquote>
<p><strong>思考</strong>：在垂直应用架构中，流量能够分散到各个子应用中，这从一定程度上解决了单一应用架构存在的扩容难题，但是对单体应用拆分，也就意味着很多具有相同逻辑的代码在各个子应用中无法复用。其实这很容易理解：在单体应用中，我们一般会将公共的逻辑代码提取封装，以供其他逻辑进行调用；然而到了垂直应用中，这就行不通了，我们没有办法让各个子应用去调用这个公共的逻辑部分，子应用之间相互隔离，无法交互。  </p>
</blockquote>
<h1 id="分布式应用架构"><a href="#分布式应用架构" class="headerlink" title="分布式应用架构"></a>分布式应用架构</h1><p>当我们的垂直应用越来越多，业务上的跨应用交互不可避免，此时就需要一种能够远程调用其他应用中的方法的手段。</p>
<p>在不考虑 RPC 之前，我们可以自己设想怎样才能在一个应用中调用另一个应用中的某个方法。</p>
<ul>
<li><p>首先需要解决的就是网络传输，也就是<strong>通信问题</strong>，很明显，这两个应用之间肯定需要建立某种连接来进行通信交互。  </p>
</li>
<li><p>好了，我们假设两个应用已经能够互相交互了，但是我们怎么知道要调用哪个方法呢？在本地的时候，我们可以很容易的调用某个对象的某个方法，但是远程的应用就不行了，因为这两个应用，具体来说是这两个进程的地址空间是完全不同的。所以此时需要解决的问题是<strong>寻址问题</strong>，也就是找到具体是调用哪个主机的哪个端口的哪个方法。  </p>
</li>
<li><p>好了，我们可以找到这个方法了，但是不可能每次都调用空参数的方法啊。如果方法需要传参，怎么办？我们的参数需要经过网络传输，所以必须是二进制数据，而参数是在内存中的，因此我们需要将内存中的<strong>参数序列化</strong>成二进制的形式。  </p>
</li>
<li><p>远程应用收到方法的调用请求，并拿到了我们传输的参数，此时还需要将<strong>参数反序列化</strong>成内存的表示形式传入方法中执行，执行结束后将结果返回。返回的结果同样需要序列化传输，本地应用接收到返回的数据后再反序列化成内存中的表示方式。</p>
</li>
</ul>
<p>解决了以上的问题，也就解决了远程方法调用的问题，解决这些问题的实现被称为 RPC（远程过程调用）。PRC 有早期的 CORBA、Java RMI，还有基于 XML 的 XML-PRC、Web Service、SOAP，基于 JSON 的 JSON-RPC，以及 Hessian、Thrift、GRPC、hprose 等等。  </p>
<p>有了 PRC，分布式应用架构的主要难题也就解决了。在分布式应用架构中，将核心业务抽取出来作为单独的服务对外提供发布，并逐渐形成稳定的服务中心，各个子应用通过 RPC 去消费这些服务。  </p>
<h1 id="流动计算应用架构"><a href="#流动计算应用架构" class="headerlink" title="流动计算应用架构"></a>流动计算应用架构</h1><p>当服务越来越多，容量的评估、小服务资源的浪费、交互的越发复杂成为新的问题，此时需要增加一个调度中心基于访问压力进行实时的集群资源调度和服务治理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/25536695">知乎：谁能用通俗的语言解释一下什么是 RPC 框架？</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/q/1010000003064904?_ea=298208">RPC 协议的区别 </a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的 RPC</title>
    <url>/2020/06/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%20RPC/</url>
    <content><![CDATA[<p>一个最简单的 RPC 需要满足几个基本的要求。首先是<strong>通信</strong>，一般可选的有 HTTP 和 TCP，这里选择 TCP，直接使用 Java Socket 处理通信。然后就是<strong>寻址</strong>，也就是如何找到要调用的方法。这里根据服务消费者提供的基本调用信息，然后利用 Java 的反射机制进行调用。服务消费者在进行远程调用时就像调用本地方法一样的效果则依靠 Java 的动态代理机制来实现。最后是<strong>参数序列化和反序列化</strong>，这里使用最简单的 Java 原生的序列化机制。</p>
<span id="more"></span>

<p>首先我们需要一个注册中心，所有的服务提供者都需要先向注册中心进行服务注册，这样服务消费者才能“发现”并进行消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt; serviceInterface, Class&lt;?&gt; impl)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryCenter</span> <span class="keyword">implements</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Class&gt; serviceRegistry = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegistryCenter</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="built_in">this</span>.port);</span><br><span class="line">            System.out.println(<span class="string">&quot;Registry Center Start...&quot;</span>);</span><br><span class="line">            <span class="comment">// 服务端需要在 accept 方法上自旋</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 有一个请求就创建一个线程去处理</span></span><br><span class="line">                <span class="built_in">this</span>.executor.execute(<span class="keyword">new</span> <span class="title class_">ServiceTask</span>(<span class="built_in">this</span>.serverSocket.accept()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.serverSocket != <span class="literal">null</span>) <span class="built_in">this</span>.serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt; serviceInterface, Class&lt;?&gt; impl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceRegistry.put(serviceInterface.getName(), impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServiceTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ServiceTask</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="built_in">this</span>.socket.getInputStream())) &#123;</span><br><span class="line">                <span class="comment">// 反序列化</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> input.readUTF();</span><br><span class="line">                Class&lt;?&gt;[] paramTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class="line">                Object[] arguments = (Object[]) input.readObject();</span><br><span class="line">                Class&lt;?&gt; serviceClass = serviceRegistry.get(serviceName);</span><br><span class="line">                <span class="keyword">if</span> (serviceClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(serviceName + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用指定类的方法</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> serviceClass.getMethod(methodName, paramTypes);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(serviceClass.newInstance(), arguments);</span><br><span class="line">                <span class="comment">// 将结果传输给客户端</span></span><br><span class="line">                <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="built_in">this</span>.socket.getOutputStream())) &#123;</span><br><span class="line">                    output.writeObject(result);</span><br><span class="line">                    output.flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册中心应该是一个服务端，需要长期在某个端口进行监听，在有客户端连接过来时就分出一个线程去处理。将消费者提供的序列化后的服务名称、方法名称、方法参数类型和参数进行反序列化，然后利用反射机制调用对应的服务，并将调用结果序列化后传输给消费者（客户端）。</p>
<p>在客户端，当我们调用接口的一个方法时，接口的实现类需要将我们的调用信息通过网络传递给注册中心，然后等待调用结束后再接收调用结果返回，如果为每个接口都创建这么一个类，显然是不合适的，因此最好的方式就是使用动态代理机制。我们创建一个工具类，提供一个获取远程对象的方法，在该方法中实现 InvocationHandler 接口，将实现类的上述逻辑放在其中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getRemoteProxyInstance</span><span class="params">(Class&lt;T&gt; serviceInterface, InetSocketAddress address)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;serviceInterface&#125;,</span><br><span class="line">                ((proxy, method, args) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>()) &#123;</span><br><span class="line">                        socket.connect(address);</span><br><span class="line">                        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream())) &#123;</span><br><span class="line">                            <span class="comment">// 序列化</span></span><br><span class="line">                            output.writeUTF(serviceInterface.getName());</span><br><span class="line">                            output.writeUTF(method.getName());</span><br><span class="line">                            output.writeObject(method.getParameterTypes());</span><br><span class="line">                            output.writeObject(args);</span><br><span class="line">                            output.flush();</span><br><span class="line">                            <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream())) &#123;</span><br><span class="line">                                <span class="comment">// 阻塞读</span></span><br><span class="line">                                <span class="keyword">return</span> input.readObject();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以开始使用了，使用时有一点要特别注意，由于我们使用的是 Java 原生的序列化和反序列化机制，因此我们方法的参数和返回值都需要实现 <code>java.io.Serializable</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String id, String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;saber&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryCenter</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        registry.register(UserService.class, UserServiceImpl.class);</span><br><span class="line">        <span class="comment">// 另起一个线程运行注册中心</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; registry.start(), <span class="string">&quot;server&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ProxyUtil.getRemoteProxyInstance(UserService.class, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserById(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭注册中心</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        registry.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2019/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>布隆过滤器（Bloom Filter）由布隆于 1970 年提出，它实际上由一个很长的二进制向量和一系列随机映射函数组成。布隆过滤器可以用于查询一个元素是否在一个集合中，它的优点是空间和时间效率都远超一般的算法，缺点是会有一定的误判和删除困难。</p>
<span id="more"></span>

<p>当明白了 Bitmap 的原理后，布隆过滤器就很好理解了。布隆过滤器与 Bitmap 的不同之处在于：布隆过滤器使用了 k 个 Hash 函数，每个元素都需要通过 k 个 Hash 函数完成映射，这就降低了冲突的概率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/30/6Pn.png" alt="布隆过滤器"></p>
<h1 id="布隆过滤器参数的确定"><a href="#布隆过滤器参数的确定" class="headerlink" title="布隆过滤器参数的确定"></a>布隆过滤器参数的确定</h1><p>如果布隆过滤器的长度太小，所有的 bit 位很快就会被用完，此时任何查询都会返回“可能存在”；如果布隆过滤器的长度太大，那么误判的概率会很小，但是内存空间浪费严重。类似的，哈希函数的个数越多，则布隆过滤器的 bit 位被占用的速度越快；哈希函数的个数越少，则误判的概率又会上升。因此，布隆过滤器的长度和哈希函数的个数需要根据业务场景来权衡。</p>
<p>我们假设 k 为哈希函数的个数，m 为布隆过滤器的长度，n 为插入元素的个数（需要处理的数据个数），p 为误报率，则：</p>
<blockquote>
<p>插入单个元素，某一 bit 位没有被置为 1 的概率为 1 - $\frac{1}{m}$</p>
</blockquote>
<blockquote>
<p>k 次哈希运算后，某一 bit 位没有被置为 1 的概率为 $(1 - \frac{1}{m})^k$</p>
</blockquote>
<blockquote>
<p>插入 n 个元素后，某一 bit 位被置为 1 的概率为 1 - $(1 - \frac{1}{m})^{nk}$</p>
</blockquote>
<blockquote>
<p>在查询时，如果某个待查询的元素对应的 k 个 bit 位都被置为了 1，则算法会判定该元素在集合中。因此，误判的概率上限为 $(1 - (1 - \frac{1}{m})^{nk})^k$</p>
</blockquote>
<blockquote>
<p>由于 $\lim_{x \to 0}(1 + x)^\frac{1}{x}&#x3D;e$，并且当 m 很大时，$-\frac{1}{m}$ 趋近于 0，所以 1 - $(1 - \frac{1}{m})^{nk}$ &#x3D; 1 - $(1 - \frac{1}{m})^{-m\frac{-nk}{m}}\approx$ 1 - $e^{-\frac{nk}{m}}$，因此 $(1 - (1 - \frac{1}{m})^{nk})^k \approx$ $(1 - e^{-\frac{nk}{m}})^k$</p>
</blockquote>
<blockquote>
<p>如果给定 m 和 n，求 k 为何值时可以使误判率最低。设误判率为 k 的函数 f(k) &#x3D; $(1 - e^{-\frac{nk}{m}})^k$，最终得到当 k &#x3D; $ln2\frac{m}{n}$ 时误判率最低，此时的误判率为 p &#x3D; $(1 - \frac{1}{2})^k$ &#x3D; $2^{-k}$ &#x3D; $2^{-ln2\frac{m}{n}} \approx$ $0.6185^{\frac{m}{n}}$</p>
</blockquote>
<blockquote>
<p>由 p &#x3D; $(1 - \frac{1}{2})^k$ &#x3D; $2^{-k}$ &#x3D; $2^{-ln2\frac{m}{n}}$ 得到 m &#x3D; $\frac{lnp^{-1}}{(ln2)^2}n$ &#x3D; $-\frac{nlnp}{(ln2)^2}$</p>
</blockquote>
<p>综合上面的推导，我们得到了 m 和 k 的公式：</p>
<p>$m &#x3D; - \frac{nlnp}{(ln2)^2}$</p>
<p>$k &#x3D; ln2\frac{m}{n}$</p>
<h1 id="哈希函数的选择"><a href="#哈希函数的选择" class="headerlink" title="哈希函数的选择"></a>哈希函数的选择</h1><p>选择 k 个不同的哈希函数是比较麻烦的，一般的方式都是选择一个哈希函数，然后传递 k 个不同的参数。</p>
<h1 id="布隆过滤器的缺陷"><a href="#布隆过滤器的缺陷" class="headerlink" title="布隆过滤器的缺陷"></a>布隆过滤器的缺陷</h1><p>布隆过滤器存在误判的可能，针对这种情况，可以建立一个列表，用来存储可能会误判的元素。同时，布隆过滤器存在删除困难的问题，因为删除时不能简单的将一个元素所有的映射位置重置为 0，这样可能会影响到其它元素，针对这种情况，可以使用 Counting Bloom Filter。</p>
<h1 id="布隆过滤器的实现"><a href="#布隆过滤器的实现" class="headerlink" title="布隆过滤器的实现"></a>布隆过滤器的实现</h1><p>布隆过滤器有很多开源的实现，常见的就是 Google Guava 中的 <code>com.google.common.hash.BloomFilter</code>。查看源码会发现其中 m 和 k 值的计算符合我们推导的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 计算 m 的值，即布隆过滤器的 bit 位数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;See http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives for the</span></span><br><span class="line"><span class="comment">* formula.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 预期元素数量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> p 误判率 (must be 0 &lt; p &lt; 1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">optimalNumOfBits</span><span class="params">(<span class="type">long</span> n, <span class="type">double</span> p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        p = Double.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) (-n * Math.log(p) / (Math.log(<span class="number">2</span>) * Math.log(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 计算 k 的值，即每个元素的哈希个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;See http://en.wikipedia.org/wiki/File:Bloom_filter_fp_probability.svg for the formula.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 预期元素数量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> m 布隆过滤器 bit 位数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">optimalNumOfHashFunctions</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> m)</span> &#123;</span><br><span class="line">    <span class="comment">// (m / n) * log(2), but avoid truncation due to division!</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">1</span>, (<span class="type">int</span>) Math.round((<span class="type">double</span>) m / n * Math.log(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.cnblogs.com/z941030/p/9218356.html">大数据量下的集合过滤 —— Bloom Filter</a></p>
</blockquote>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/03/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>快速排序是冒泡排序的一种改进。它的基本思想是通过一趟排序，将要排序的数据分成两部分，其中一部分的所有数据都比另一部分的所有数据要小，然后再按照此方法对这两部分数据分别进行快速排序。根据描述，整个排序过程完全可以通过递归的方式实现。  </p>
<span id="more"></span>  

<p>快速排序采用了一种分治的策略，通常称为分治法，但是为了便于理解，这里根据 <strong>MoreWindows</strong> 的说法，将快速排序概括为：挖坑填数 + 分治法。下面通过一个例子来说明这种思想。  </p>
<p>有一个初始的数组为：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/OLo.png" alt="初始数组"></p>
<p>先设置左右遍历的指针，i &#x3D; 0，j &#x3D; 9，取一个基准数（也就是所说的挖坑），这里就取数组第一个数 72。此时 72 已经从数组中挖出了，所以 index &#x3D; 0 的位置为空。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/GlK.png" alt="挖出基准数"></p>
<p>接下来进行第一趟遍历，首先从右往左比较，将比基准数 72 小的数填到坑里，这里是 48 这个数。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/Kpz.png" alt="48 填到坑里"></p>
<p>此时 i &#x3D; 0，j &#x3D; 8，index &#x3D; 8 的位置为空。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/0x2.png" alt="索引为 8 的位置空了"></p>
<p>接着在从左往右比较，将比基准数 72 大的数填到坑里，这里发现是 88 这个数。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/gkP.png" alt="把 88 填到坑里"></p>
<p>此时 i &#x3D; 3，j &#x3D; 8，index &#x3D; 3 的位置为空。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/270.png" alt="索引为 3 的位置空了"></p>
<p>然后继续从右往左比较，将比基准数 72 小的数填到坑里，这里发现是 42 这个数。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/VNe.png" alt="将 42 填到坑里"></p>
<p>此时 i &#x3D; 3，j &#x3D; 5，index &#x3D; 5 的位置为空。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/bYl.png" alt="索引为 5 的位置空了"></p>
<p>接下来继续从左往右比较，将比基准数 72 大的数填到坑里。当遍历到 i &#x3D; 5 时，发现左右指针都是 5，这也就意味着在此时这个位置上，左侧所有的数据比右侧的都要小，此时将基准数 72 填到这个坑里，完成第一趟遍历。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/18/aWj.png" alt="完成第一趟遍历"></p>
<p>接下来还是按照上面的思路，分别对索引区间为 <code>0 ~ 4</code> 和 <code>6 ~ 9</code> 的两部分重复上面的操作。  </p>
<p>通过上面的分析，每一趟的算法可以比较容易地写出来。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 调整数组的算法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> l   起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> r   结束位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 调整后的基准数的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">adjustArray</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="comment">// 基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[l];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找比 x 小的数</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= x)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左往右寻找大于等于 x 的数</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; x)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后 i = j 时，将 x 填入</span></span><br><span class="line">    arr[i] = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以通过递归实现快排了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分治法快排，使用递归</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> l   起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> r   结束位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> adjustArray(arr, l, r);</span><br><span class="line">        quick_sort(arr, l, i - <span class="number">1</span>);</span><br><span class="line">        quick_sort(arr, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来将两部分代码优化合并一下。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 快速排序算法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> l   起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> r   结束位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="comment">// 基准数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 从右往左寻找比 x 小的数</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= x)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从左往右寻找大于等于 x 的数</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; x)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后 i = j 时，将 x 填入</span></span><br><span class="line">        arr[i] = x;</span><br><span class="line">        quick_sort(arr, l, i - <span class="number">1</span>);</span><br><span class="line">        quick_sort(arr, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://blog.csdn.net/MoreWindows/article/details/6684558">白话经典算法系列之六 快速排序 快速搞定</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>打包 JavaFX 程序</title>
    <url>/2018/10/31/%E6%89%93%E5%8C%85%20JavaFX%20%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>公司有一个项目在发布更新时，一直是由开发人员手工选择修改过的源代码文件编译后打包发给实施人员，然后由实施人员到测试环境去替换，如果修改的文件较多，开发人员一个个去查找会比较麻烦，还容易出错，所以就开发了一个小工具，帮助开发人员自动生成增量更新包。  </p>
<span id="more"></span>  

<p>这个小工具大体的思路是，根据 <code>svn log</code> 命令生成一个 changelog 文件，读取这个文件来收集被修改过的文件，然后去本地已经编译过的项目中寻找对应的文件，然后打包。这个小工具已经发布到了 Github 上，链接是：<a href="https://github.com/nekolr/sirius-inc">https://github.com/nekolr/sirius-inc</a>。在写完大体逻辑后，又使用 JavaFX Scene Builder 构建了程序的界面。不同于之前的 Swing，JavaFX 的布局和逻辑代码完全分离，代码更清晰也更容易编写。前面的过程都还算顺利，在最终打包阶段遇到了不小的麻烦，不过也一点点解决掉了，在这里记录一下打包的过程。  </p>
<p>首先在 IDEA 中打开项目的 Project Structure，选择 Artifacts 新建一个 JavaFX Application 构件。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/31/LgX.png" alt="new JavaFX Application">  </p>
<p>在这里将 sirius-inc_main 和 sirius-inc_test 都加入到 jar 包下。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/31/4e4.png" alt="加入到 jar 包中">  </p>
<p>这里需要注意的是，如果源代码目录下有 resources 资源目录，则需要手工将该目录加入到 jar 包下。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/31/l2q.png" alt="加入资源目录">  </p>
<p>选择到 Java FX 标签页，配置主程序入口和本地包类型（如 exe）。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/31/dMM.png" alt="javafx 配置">  </p>
<p>这些都配置好后，选择 Build 中的 Build Artifacts 来生成构件，等待完成后就可以在 bundles 目录下的项目目录中找到 exe 可执行文件。  </p>
<blockquote>
<p>通过这种方式在生成 exe 的同时，还会生成 Java 运行环境，所以整个目录的体积较大。  </p>
</blockquote>
<p>在打包完成后，其实又遇到了一个新的问题，那就是程序的图标不能自定义。一开始尝试使用 launch4j 来打包，虽然可以自定义图标，但是不知道什么原因，程序只有外壳，逻辑无法执行。最后没办法，只能使用 eclipse 配合 e(fx)clipse、ant 来打包，这里同样记录一下过程。  </p>
<p>首先 eclipse 要安装 e(fx)clipse 插件，然后通过 eclipse 新建一个 JavaFX 项目，eclipse 会在项目目录中生成一个 build.fxbuild 文件，打开该文件，填写配置。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/01/Rl6.png" alt="build.fxbuild">  </p>
<p>配置好后，点击右侧的 Generate ant build.xml only 来生成 build 目录和文件。  </p>
<p>在 build 目录下新建一个 package 目录，并在 package 目录下创建 macos 和 windows 目录，这两个目录用来放置程序的图标，图标名称要与 build.fxbuild 文件中的程序名相同。  </p>
<p>修改 build.xml 文件，在 <code>&lt;path id=&quot;fxant&quot;&gt;</code> 的文件列表中添加一行 <code>&lt;file name=&quot;$&#123;basedir&#125;&quot;/&gt;</code> 用来包含资源文件，如图标。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/01/AGN.png" alt="指定资源文件">  </p>
<p>修改程序的版本。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/01/9by.png" alt="修改版本">  </p>
<p>修改完毕后，右键 build.xml 文件 Run as Ant build 来打包。等待打包完毕后，会在 build&#x2F;deploy 目录生成可执行文件，目录结构与通过 IDEA 打包生成的结构一致，唯一不同的是程序的图标已经变成自定义的了。  </p>
]]></content>
      <categories>
        <category>JavaFX</category>
      </categories>
      <tags>
        <tag>JavaFX</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统的发展和现状</title>
    <url>/2018/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<p>按照国外一个比较权威的网站 <a href="https://db-engines.com/en/ranking">DB-Engines</a> 的分类，目前的数据库系统大概有 14 种之多，包括传统的关系型数据库、键值对存储数据库、文档型存储数据库、时间序列数据库、面向对象数据库、搜索引擎、图形数据库和列存储数据库等等。它们大致上可以简单划分为三大类：SQL、NoSQL 和 NewSQL。  </p>
<span id="more"></span>  

<h1 id="单机数据库时代"><a href="#单机数据库时代" class="headerlink" title="单机数据库时代"></a>单机数据库时代</h1><p>自从 1970 年 E.F.Codd 博士在《Communication of the ACM》上发表《A Relational Model of Data for Large Shared Data Banks》论文，提出关系模型的概念，关系型数据库系统经过几十年的发展，技术已经比较成熟和完善。其中比较有代表性的产品包括甲骨文公司的 Oracle，微软公司的 SQL Server，IBM 公司的 Db2 以及惨遭收购的 MySQL。  </p>
<p>在很长一段时间内，关系型数据库一直是大公司的专利，数据库市场一度被 Oracle、Db2 等企业数据库瓜分。直到上个世纪九十年代，MySQL 的第一个版本诞生，关系型数据库才终于有了一个开源免费的实现。虽然 MySQL 相对于 Oracle 这样的大型商业数据库来说规模较小、功能较弱，但这丝毫不影响它的受欢迎程度。甚至在 2010 年以前，互联网上流行的网站架构 LAMP 就将 MySQL 作为默认使用的数据库软件。  </p>
<p>在 MySQL 之后，还有一个值得一提的关系型数据库系统，它就是 PostgreSQL。作为差不多和 MySQL 同期的开源关系型数据库系统，PostgreSQL 不管是代码的质量还是对 SQL 的支持都要优于 MySQL。  </p>
<h1 id="分布式数据库时代"><a href="#分布式数据库时代" class="headerlink" title="分布式数据库时代"></a>分布式数据库时代</h1><p>随着互联网的蓬勃发展，网络服务的大流量、高并发将传统关系型数据库的弊端暴露了出来。传统关系型数据库最大的优点就是能够通过 SQL 实现复杂的查询以及对 ACID 事务的支持，这使它能够适用于那些对一致性要求很高的系统，如：银行系统、OA 系统等。但是互联网的发展以及移动互联网的兴起使得很多网络服务，例如微博、facebook 等，对于这种一致性的要求已经不是那么严格，它们更多的要求并发读写和海量存储，而传统的关系型数据库为了维护一致性所付出的代价就是读写性能较差，同时传统的关系型数据库还有一个很大的缺陷就是难以水平扩展，为了提高数据库的性能，最简单的方式就是纵向扩展，即通过升级硬件来提高磁盘 I&#x2F;O 和数据库的并发性能，但是硬件升级所带来的成本提升让企业越来越难以接受，于是人们又不得不再去寻找水平扩展的方案，目前业内主流的一些做法或多或少都存在一些问题（部署、管理和配置复杂，使用限制较多，可能存在单点故障的风险等）。这时，人们急切需要一种并发读写性能强劲、具有较高伸缩性和扩展性、支持海量数据存储的数据存储系统，于是 NoSQL 应运而生。  </p>
<p>提到 NoSQL，就不得不提及两个公司，一个是 Google，另一个就是 Amazon。  </p>
<p>Google 应该算是最早将分布式存储技术应用到大规模生产环境的公司，目前业界的很多分布式系统的思想和实践大都来源于 Google。2003 年，Google 公布了自家使用的分布式文件系统 GFS 的一些技术细节，2006 年又发表了基于 GFS 的分布式键值对存储系统 BigTable 的论文，直接催生了 Hadoop 的生态。  </p>
<p>Amazon 在 2007 年发表了关于 Dynamo 的论文，文中引入了最终一致性的概念、NRW 的模型以及向量时钟的应用，同时将一致性 Hash、Merkle tree 等在当时很新潮的一些技术整合起来，这些技术对后来的非关系型数据库有很大的影响，可以说是正式标志着 NoSQL 的诞生。  </p>
<p>在 2006 年前后至今，一个比较重要的思潮就是数据库（持久化）和缓存开始有明确的分离。随着业务并发的提升，以及内存价格越来越便宜，基于内存的存储方案也逐渐普及。内存缓存也经历了从单机到分布式的过程，只不过这个过程要比关系型数据库的进化快的多，这是因为 NoSQL 从当时互联网业务模型相对简单的实际出发，抛弃了关系模型，选择了更为简单的键值对和文档类型进行存储，数据结构和查询接口更加简单，没有了复杂 SQL 以及 ACID 事务的历史包袱，灵活性和弹性扩展能力更强。  </p>
<p>NoSQL 中的缓存方案具有代表性的就是 memcached 和 Redis。memcached 在 2009 年之前一度成为开源缓存事实上的标准，但是 Redis 的出现颠覆了缓存市场，现在大多数的缓存业务几乎都使用的是 Redis，memcached 基本上退出了历史舞台。后来因为单机 Redis 已经不能满足业务发展需求，人们又开始寻找扩展 Redis 的方案，这方面比较有代表性的就是 twitter 开源的 twemproxy，Redis 官方难产了好久才发布的 Redis Cluster 以及 2014 年国内的一个团队开源的 Codis。在缓存上，开源社区现在基本上是围绕着 Redis 及其周边扩展发展。  </p>
<p>NoSQL 中的持久化方案比较有代表性的就是 MongoDB、HBase 和 Cassandra 了。MongoDB 在早期因为没有使用存储引擎，所以性能并不太好，但是它 Schema-less 的特性适合很多轻量级和快速变更的互联网业务，并且由于它基本上做到了开箱即用，因此使用者众多。2014 年 MongoDB 收购了 WiredTiger 并将它作为默认的存储引擎，因此性能和稳定性都有了很大的提升。HBase 作为 GFS 的正统实现，严格上来说算是一个 CP 系统，底层依赖 HDFS，能够很好地处理海量、小的、结构化数据的插入、更新以及随机读请求，但是没有提供 ACID 的跨行事务支持，并且易用性也不佳。Cassandra 是 Dynamo 的开源实现，早期由 Facebook 开发并开源，但是由于 bug 较多而被 Facebook 放弃，后来由 DataStax 重新维护并商业化。作为一个 AP 系统，Cassandra 在易用性上要优于 HBase，并且由于它的数据直接存储在磁盘上，并不依赖于分布式文件系统，各个存储节点之间自己维护复制关系，因此减少了一层 RPC 调用，延迟上要比 HBase 更有优势。  </p>
<h1 id="NewSQL"><a href="#NewSQL" class="headerlink" title="NewSQL"></a>NewSQL</h1><p>NewSQL 指的是一类现代关系型数据库系统，它不光能够为 OLTP（联机事务处理）提供类似 NoSQL 那样的高度扩展性，还能够提供类似传统关系型数据库的 ACID 事务的支持。  </p>
<p>2012 年，Google 在 OSDI 上发表了 Spanner 的论文，2013 年，又在 SIGMOD 上发表了 F1 的论文。这两篇论文让业界第一次看到了关系模型和 NoSQL 的扩展性在超大规模集群上融合的可能性。  </p>
<p>Spanner 的创新之处在于通过 GPS 和原子钟来解决时钟同步的问题。在分布式系统中，时钟是最头疼的问题，这也是为什么 Cassandra 不是一个强一致性系统的原因。Spanner 的厉害之处在于即使两个数据中心相隔很远，它们之间也不需要通信（通信代价太大，理想状态下也只是光速）就能够保证 TrueTime API 的时钟误差在一个很小的范围内（10 ms）。F1 构建在 Spanner 之上，对外提供了更加丰富的 SQL 语法，它本身并不存储数据，而是将客户端的 SQL 翻译成类似 MapReduce 的任务，通过调用 Spanner 来完成请求。总的来说，Spanner 和 F1 有以下几个特点：  </p>
<ol>
<li>完整的 SQL 以及 ACID 事务支持。  </li>
<li>良好的弹性伸缩能力。  </li>
<li>自动的故障转移和故障恢复，多机房异地灾备。</li>
</ol>
<p>Google 论文的发表鼓舞了开源社区，许多团队争相开始实现，其中比较有代表性的包括 Ignite、VoltDB、CockroachDB、Altibase、GridGain、TiDB 等等。CockroachDB 选择了 HLC（Hybrid logical clock），也就是 NTP + 逻辑时钟来代替 TrueTime，使用 Raft 代替 Paxos 实现复制和自动容灾，底层存储依赖 RocksDB 的实现，对外接口选用 PostgreSQL 的 SQL 子集。TiDB 是国内团队 PingCAP 的开源实现，它并不像 CockroachDB 那样选择将 SQL 和 Key-Value 融合，而是像 Spanner 和 F1 一样选择分离，同时由于选择了 MySQL 协议和语法的兼容，因此很多 MySQL 社区的 ORM 框架和运维工具都可以直接应用在 TiDB 上。  </p>
<p>其实 NewSQL 可以松散的划分为三大类，其中第一类也就是主流的就是上面说到的新的关系型数据库系统，另一类就是针对 SQL 进行了高度优化的存储引擎。这些引擎提供与 SQL 相同的编程接口，但同时提供了比内置引擎（如：InnoDB）更好的扩展性。这些新的存储引擎包括：Google 开源的 Bigtable 底层存储引擎 LevelDB、Facebook 维护并改进的 LevelDB 分支 RocksDB、Facebook 使用 RocksDB 实现的全新的 MySQL 存储引擎 MyRocks、MySQL Cluster、MariaDB Columnstore 以及具有极高压缩比的 TokuDB 等等。  </p>
<p>还有一类是可以透明分片（Transparent sharding）的中间件，它支持跨多个节点自动拆分数据库，具有代表性的就是 ScaleBase、Vitess 和 Postgres-XC，它们差不多就是数据库分库分表中间件的尽头了。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distrib uted Storage System for Structur ed Data</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo: Amazon’s Highly Available Key-value Store</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.infoq.cn/article/situation-of-the-open-source-database">「企业上云」系列之开源数据库的现状</a>  </p>
</blockquote>
<blockquote>
<p><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">Spanner: Google’s Globally-Distributed Database</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构中的树</title>
    <url>/2019/02/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p>数据结构中的树有很多种，常见的树包括二叉树、自平衡二叉查找树和 B 树。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/3pB.png" alt="树"></p>
<h1 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h1><ul>
<li>节点的度：一个节点包含的子树的个数。</li>
<li>叶子节点或终端节点：度为 0 的节点。</li>
<li>树的度：树内度最大的节点的度。</li>
<li>高度：对于任意节点 n，n 的高度为从 n 到一个叶子节点的最长路径长，所有的叶子节点高度都为 0。</li>
<li>深度：对于任意节点 n，n 的深度为从根节点到 n 的唯一路径长，根的深度为 0。</li>
<li>节点的层次：从根节点开始，根为第一层，根的子节点为第二层，以此类推。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/o34.png" alt="树的例子"></p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树又叫二叉搜索树、有序二叉树或者排序二叉树，它是指一棵空树或者具有下列性质：</p>
<ol>
<li>若任意节点的左子树不为空，则左子树上所有节点的值均小于它根节点的值。</li>
<li>若任意节点的右子树不为空，则右子树上所有节点的值均大于它根节点的值。</li>
<li>任意节点的左、右子树也分别为二叉查找树。</li>
<li>没有键值相等的节点。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/BMN.png" alt="二叉查找树"></p>
<p>二叉查找树利用二分查找的思想，其查找、插入和删除的平均时间复杂度为 O(logN)，其中 N 为节点个数。<strong>其实这里的时间复杂度就是树的高度</strong>，理想状态下的时间复杂度为 O(logN)，最坏的情况下，二叉查找树会退化成线性表，此时的时间复杂度为 O(N)。很多改进版的二叉查找树可以使树高维持在 O(logN)，从而使最坏情况下的时间复杂度仍为 O(logN)，比如 AVL 树、红黑树等。</p>
<h1 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h1><p>AVL 树是最早被发明的自平衡二叉查找树，AVL 树的任意一个节点对应的两棵子树的最大高度差（或者叫做平衡因子，Balance Factor）为 1，因此它也被称为高度平衡树。AVL 树的查找、插入和删除在平均和最坏情况下的时间复杂度都为 O(logN)。插入和删除元素可能会使平衡因子大于 1，此时需要对树进行一次或者多次旋转，从而实现树的重新平衡。</p>
<p>插入和删除元素可能会引起树的失衡，可将情况分为四种。我们约定其中 Root 表示失衡树的根节点，Pivot 为旋转后重新平衡的树的根节点。</p>
<h2 id="LL-型"><a href="#LL-型" class="headerlink" title="LL 型"></a>LL 型</h2><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/dy1.png" alt="LL"></p>
<p>LL 型，也就是左左型，失衡的原因可能是在 Pivot 的左子树上插入节点。调整过程为一次右旋，即以 Pivot 为轴心，Root 节点右旋成为 Pivot 的右子树，Root 的左子树由 Pivot 的右子树代替。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/AqD.png" alt="LL右旋"></p>
<h2 id="RR-型"><a href="#RR-型" class="headerlink" title="RR 型"></a>RR 型</h2><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/1OD.png" alt="RR"></p>
<p>RR 型，也就是右右型，失衡的原因可能是在 Pivot 的右子树上插入节点。调整过程为一次左旋，即以 Pivot 为轴心，Root 节点左旋称为 Pivot 的左子树，Root 的右子树由 Pivot 的左子树代替。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/Zvb.png" alt="RR左旋"></p>
<h2 id="LR-型"><a href="#LR-型" class="headerlink" title="LR 型"></a>LR 型</h2><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/NWJ.png" alt="LR"></p>
<p>LR 型，也就是左右型，失衡的原因可能是在 Pivot 的右子树上插入节点。调整过程为一次左旋加一次右旋，即以 Pivot 为轴心，Root 节点左旋成为 Pivot 的左子树，Root 的右子树由 Pivot 的左子树代替，这样就将 LR 型转换成了 LL 型，然后再按照 LL 型的方法右旋即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/77L.png" alt="第一次旋转"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/bbw.png" alt="第二次旋转"></p>
<h2 id="RL-型"><a href="#RL-型" class="headerlink" title="RL 型"></a>RL 型</h2><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/BBg.png" alt="RL"></p>
<p>RL 型，也就是右左型，失衡的原因可能是在 Pivot 的左子树上插入节点。调整过程为一次右旋加一次左旋，即以 Pivot 为轴心，Root 节点右旋成为 Pivot 的右子树，Root 的左子树由 Pivot 的右子树代替，这样就将 RL 型转成了 RR 型，然后再按照 RR 型的方法左旋即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/lgk.png" alt="第一次旋转"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/03/jeY.png" alt="第二次旋转"></p>
<h2 id="AVL-树的局限性"><a href="#AVL-树的局限性" class="headerlink" title="AVL 树的局限性"></a>AVL 树的局限性</h2><p>由于维护这种高度平衡需要付出很大的代价，因此 AVL 的实际应用不多，更多的是采用追求局部而不是非常严格的整体平衡的红黑树。如果应用场景中插入和删除不频繁而查找频繁，那么 AVL 树还是优于红黑树的。</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种自平衡二叉查找树，与普通的二叉查找树不同的是，它的每个节点都带有颜色属性，颜色有红色或黑色两种。红黑树除了具有二叉查找树的性质外，还具有以下性质：</p>
<ol>
<li>节点是黑色或者红色。</li>
<li>根是黑色的。</li>
<li>所有的叶子节点（实际上就是 NULL 指针）都是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点都是黑色的（也就是说，不能有两个相邻的红色节点）。</li>
<li>从任意一个节点到其每个叶子节点的所有简单路径中都包含相同数目的黑色节点。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/04/zMg.png" alt="红黑树"></p>
<p>红黑树的数据项只能存储在内部节点（internal node）中，叶子节点在其父节点中仅仅作为一个 NULL 指针表示，将它也看作一个节点有助于描述红黑树的插入和删除算法。以上性质决定了从根节点到叶子节点的最长路径的长度不会超过任何其他路径长度的两倍。比如有一棵红黑树，它的根节点到叶子节点的路径中黑色节点数为 3，从根节点到叶子节点的最短路径长为 2（黑 - 黑 - 黑），那么最长路径也只可能为 4（黑 - 红 - 黑 - 红 -黑）。</p>
<p>一个拥有 N 个内部节点的红黑树的树高 $h &lt;&#x3D; 2log(N + 1)$。</p>
<h2 id="红黑树与-AVL-树比较"><a href="#红黑树与-AVL-树比较" class="headerlink" title="红黑树与 AVL 树比较"></a>红黑树与 AVL 树比较</h2><p>红黑树并不追求高度平衡，即不像 AVL 树那样要求 $BF &lt;&#x3D; 1$，它只要求部分达到平衡，通过这种非严格的平衡来换取插入和删除节点时旋转次数的降低。在插入节点导致树失衡时，AVL 树和红黑树都可以通过最多两次旋转来实现树的重新平衡，旋转的时间复杂度为 O(1)。在删除节点导致树失衡时，AVL 树需要维护从被删除节点到根节点这条路径上所有节点的平衡，旋转的时间复杂度为 O(logN)，而红黑树最多只需要 3 次旋转就可以实现树的重新平衡。</p>
<p>红黑树的查询性能稍逊于 AVL 树。在具有相同节点的情况下，红黑树的高度最多会比 AVL 树多 1。</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>B 树也表示为 B-树，是一种自平衡的树，概括来说，它是一种一般化的二叉查找树，一个节点可以拥有 2 个以上的子节点，因此又被称为平衡多路查找树。在 B 树中，查找、插入和删除等的时间复杂度都为 O(logN)。</p>
<p>当数据被插入或者从一个节点中移除，它的子节点的数量发生了变化，为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。因为子节点的数量有一定的范围，所以 B 树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，所以可能浪费了一些空间。子节点数量的上界和下界依据特定的实现而设置，比如在一个 2-3 B 树（简称 2-3 树）中，每一个内部节点只能有 2 个或 3 个子节点。</p>
<p>B 树中每一个内部节点会包含一定数量的键，键将节点的子树分开。例如，如果一个内部节点有 3 个子节点（子树），那么它就必须有两个键：a1 和 a2。左子树的所有值都必须小于 a1，中间子树的所有值都必须在 a1 和 a2 之间，右子树的所有值都必须大于 a2。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/09/NWY.png" alt="2-3树"></p>
<p>通常，键的数量被选定在 d 和 2d 之间。其中 d 是键的最小数量，d + 1 是树最小的度或分支因子。在实际中，键值占用了节点中大部分的空间。因数 2 将保证节点可以被拆分或组合。如果一个内部节点有 2d 个键，那么要添加一个键值给此节点，只需要拆分这 2d + 1 个键为 2 个拥有 d 个键的节点，并把中间值节点移动到父节点。每一个拆分的节点需要拥有足够数目的键。相似地，如果一个内部节点和他的邻居两者都有 d 个键，那么将通过它与邻居的合并来删除一个键。删除此键将导致此节点拥有 d - 1 个键，与邻居的合并则加上 d 个键，再加上从邻居节点的父节点移来的一个键值，结果为完全填充的 2d 个键。</p>
<p>下面演示一个 B 树插入的例子，该 B 树为 3 阶，节点最多有 3 个孩子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/09/77e.png" alt="插入例子"></p>
<p>根据 Knuth 的定义，一个 m 阶（m 阶代表一个节点最多有 m 个查找路径，m &#x3D; 2 是二叉树，m &#x3D; 3 是三叉树）的 B 树是一个有以下属性的树：</p>
<ol>
<li>每个节点最多有 m 个子节点。</li>
<li>每个非叶子节点（除根节点外）最少有 <code>ceil(m/2)</code> 个子节点。</li>
<li>如果根节点不是叶子节点，那么它至少有 2 个子节点。</li>
<li>有 k 个子节点的非叶子节点拥有 k - 1 个键。</li>
<li>所有的叶子节点都在同一层。</li>
</ol>
<h2 id="AVL-树与-B-树比较"><a href="#AVL-树与-B-树比较" class="headerlink" title="AVL 树与 B-树比较"></a>AVL 树与 B-树比较</h2><p>在多级存储系统（将多级存储器结合起来的系统，比如在计算机系统中，高速缓存、内存和硬盘就组成一个多级存储系统）中，在速度相对较慢的外部设备上存储数据可以使用 B 树，这在查找数据时将大大减少 I&#x2F;O 次数。下面我们分析为什么使用 B 树，这里使用 AVL 树来作比较是因为它高度平衡，树高较矮。</p>
<p>假如有 $10^9$ 条数据，将它们插入到一棵 AVL 树中，那么树高大约为 $\log_2(10^9)\approx30$，这表示每次查找最多需要进行 30 次 I&#x2F;O 操作，一次 I&#x2F;O 操作只能读取一个值。</p>
<p>如果使用 B 树存储这些数据，我们可以充分利用外存的预读机制（一次 I&#x2F;O 操作会读取一页或几页数据），将 B 树一个节点的大小设置为内存中一页的大小，这样一次 I&#x2F;O 操作就可以读取到整个节点上的键值。每个节点上存储 m 个键，每个键除了存储键值，还需要存储数据和指针，因此 m 的计算公式大概为 <code>m = pagesize/(keysize + datasize + pointsize)</code>，假设求出 m 的值为 256，也就是说这是一棵 256 阶的 B 树，则每次查找最多只需要 $log(256,10^9) &lt;&#x3D; 4$ 次 I&#x2F;O 操作。当定位到数据所在的节点后，接下来只需要在内存中查找即可（整个节点的数据都读到内存中了），相比磁盘 I&#x2F;O 要快很多。</p>
<h2 id="数据库使用-B-树作为索引结构的原因"><a href="#数据库使用-B-树作为索引结构的原因" class="headerlink" title="数据库使用 B 树作为索引结构的原因"></a>数据库使用 B 树作为索引结构的原因</h2><p>数据库索引是存储在磁盘上的，当数据量比较大的时候，索引文件可能有几个 G 甚至更多，数据库利用索引进行查询的时候，肯定不能将整个索引文件读取加载到内存中，数据库能做的就是加载一部分数据到内存，如果使用普通的二叉查找树或者是自平衡二叉查找树，由于索引数量众多造成树高较高，同时查找数据时不能很好地利用磁盘的预读机制，造成 I&#x2F;O 次数过多，从而影响效率。</p>
<p>数据库使用 B 树存储数据时，可以巧妙地利用磁盘预读机制，将一个节点的大小设置为一个内存页的大小，这样每个节点只需要一次 I&#x2F;O 就可以完全加载到内存。在实际实现时，数据库每次新建节点都需要申请一个页的内存空间，这样就保证一个节点物理上也存储在一个页中，加上计算机存储分配时都是按页对齐的，这样就实现了一个节点只需要一次 I&#x2F;O。</p>
<p>B-树一次检索的时间复杂度为 $log_mN$，其中 m 就是 B 树的阶，一般 m 是一个非常大的数字，通常是超过 100 的，因此 $log_mN$ 的值一般不超过 3。</p>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是 B-树的变体，它与 B-树的不同之处在于：</p>
<ol>
<li>所有的键都会在叶子节点中出现。</li>
<li>内部节点不存储数据，叶子节点存储数据。</li>
<li>所有的叶子节点都有一个链指针，指向相邻叶子节点。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/10/bbg.png" alt="B+树"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/10/DjE.png" alt="B+树"></p>
<h2 id="MySQL-的索引结构为什么使用-B-树"><a href="#MySQL-的索引结构为什么使用-B-树" class="headerlink" title="MySQL 的索引结构为什么使用 B+树"></a>MySQL 的索引结构为什么使用 B+树</h2><ol>
<li>由于 B+树的内部节点不存储数据，所以单个节点可以存储更多的键，这也就意味着 B+树单次磁盘 I&#x2F;O 能够获取到更多的键。</li>
<li>通常关系型数据库中，区间访问是很常见的，B+树的叶子节点增加了链指针，这样就增强了区间可访问性，可以实现区间范围的查询，而 B-树的每个节点都会存储 key 和 data，无法实现区间访问。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.cnblogs.com/xyxxs/p/4440187.html?spm=a2c4e.10696291.0.0.fac819a4EZsPre">数据库为什么要用 B+树结构 —— MySQL 索引结构的实现</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000004690721?spm=a2c4e.10696291.0.0.667919a4gQXYCr">由 B-&#x2F;B+树看 MySQL 索引结构</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">Data Structure Visualizations: B-Trees</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">Data Structure Visualizations: B+ Trees</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态机</title>
    <url>/2020/09/21/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<p>有限状态机和行为树在游戏 AI 领域比较常见，当然很多涉及到流程控制的逻辑都可以使用它们来降低复杂性并创建更具可读性的程序。</p>
<span id="more"></span>

<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p>假如我们正在开发一款 RPG 游戏，游戏中的敌人在遇到玩家后会发起攻击，而玩家不在攻击范围内就进行巡逻。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (视野范围内有目标) &#123;</span><br><span class="line">  攻击</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  巡逻</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写不会有啥问题，并且也很容易实现。但是随着开发的深入，游戏逻辑越来越复杂，经过几次修改，游戏逻辑可能会变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (视野范围有目标) &#123;</span><br><span class="line">    if (血量 &gt; 10) &#123;</span><br><span class="line">        if (超过攻击距离) &#123;</span><br><span class="line">            追逐</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            攻击</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (没有遇到同伴) &#123;</span><br><span class="line">            逃跑</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            一起攻击</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    巡逻</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也许你会说，这点逻辑我还能应对，但是我们不能保证后续是否还有更复杂的条件和逻辑需要添加，到时候我们还需要回到这里，继续修改和添加代码逻辑。随着时间的推移，这里的代码可以预见的会越来越复杂，难以维护。现在，是时候思考应该怎样拆分它了。</p>
<p>在上面的这个例子中，像攻击、追逐、逃跑等，可以抽象为<strong>状态</strong>，而视野范围内有目标、血量小于 10 等这些都是进入某个状态的<strong>触发条件</strong>，所以在这些逻辑当中，真正不断发生变化的是状态、触发条件以及它们之间的对应关系。通过分析，我们可以把上面例子中的逻辑（有些逻辑没有使用）总结为一个<strong>状态转换表</strong>：</p>
<table>
<thead>
<tr>
<th>当前状态</th>
<th>触发条件</th>
<th>目标状态</th>
</tr>
</thead>
<tbody><tr>
<td>巡逻</td>
<td>血量为 0</td>
<td>死亡</td>
</tr>
<tr>
<td>巡逻</td>
<td>发现目标</td>
<td>追逐</td>
</tr>
<tr>
<td>追逐</td>
<td>血量为 0</td>
<td>死亡</td>
</tr>
<tr>
<td>追逐</td>
<td>目标进入攻击范围</td>
<td>攻击</td>
</tr>
<tr>
<td>追逐</td>
<td>丢失目标</td>
<td>巡逻</td>
</tr>
<tr>
<td>攻击</td>
<td>血量为 0</td>
<td>死亡</td>
</tr>
<tr>
<td>攻击</td>
<td>目标离开攻击范围</td>
<td>追逐</td>
</tr>
<tr>
<td>攻击</td>
<td>目标血量为 0</td>
<td>巡逻</td>
</tr>
<tr>
<td>死亡</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>根据当前逻辑，在罗列了所有可能的状态以及状态切换的触发条件之后，我们可以为每个状态和每个触发条件都创建一个对应的类，比如攻击状态就是 AttackState，血量为 0 的条件类就是 HPIsZero，它们都有一个对应的父类（或者接口），比如 AbstractState 和 AbstractCondition。状态接口主要提供进入状态、在状态中以及退出状态时需要执行的函数，而条件接口主要提供的是一个检测触发条件是否满足的函数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在状态中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 进入状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Enter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 退出状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractCondition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检测条件是否满足</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">Predicate</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这些状态类和条件类，接下来的工作就是将它们组合起来，覆盖上述状态转换表，形成完整的逻辑。为此，我们还需要创建一个容器，这个容器负责存储和管理所有的状态、条件以及它们之间的映射关系，同时还需要提供进行状态切换的函数。这个容器就是我们所说的有限状态机（Finite State Machine）。当然，状态机的实现方式多种多样，有的会把映射关系维护到状态中。有的可能不会将触发条件独立出来，而是选择放到状态内部。</p>
<p>这大概就是实现一个有限状态机的完整过程，到这里，我们应该都对有限状态机是什么有了一个自己的答案。对于我来说，有限状态机就是一个能够在有限的状态内实现状态转换的数学计算模型。通过有限状态机，我们可以实现类似流程控制的逻辑，但是与一般的流程控制不同，使用有限状态机可以将流程控制语句与对应的处理逻辑分离，从而使程序的可读性和可维护性更好。</p>
<p>当然，有限状态机也是有缺陷的。首先它的可维护性并不好，添加或删除一个状态时，所有之前定义的状态、条件和映射关系可能都需要重新检查和修改。然后可扩展性也不高，当状态特别多的时候，可以想象应该需要一张很大的状态转换表，尤其是在 Unity 中，Animator 控制器的大量状态盒子和箭头就是一个噩梦。最后，对于当前状态来说，我并不能知道我的转换历史，也就是说，我很难知道我为什么会在这个状态里，这也是为什么现在主流的 AI 选择使用行为树的原因之一。</p>
<h1 id="并发状态机"><a href="#并发状态机" class="headerlink" title="并发状态机"></a>并发状态机</h1><p>关于有限状态机，它有一个隐含的特点就是：同一时刻只能处于一个状态中。然而很多时候，使用有限状态机的事物需要在同一时刻处于多种不同的状态中。比如一个角色，我们定义了静止、奔跑、跳跃等状态，同时我们赋予了角色使用枪支的能力，我们需要它在射击的时候能够自由选择静止、奔跑或者跳跃。如果我们坚持只使用一个状态机，那么我们需要再添加一些状态：静止射击、奔跑射击、跳跃射击等，对于每个现有的状态，我们都需要再添加一个状态来在它射击的时候做同样的事。这样状态数量会迅速膨胀，同时会有大量的冗余代码。</p>
<p>此时，一个很明显的解决方案就是：保留原有的状态机，然后为它携带的枪支提供一个单独的状态机。这样角色将持有两个状态机的引用，在同一时刻，玩家的操作都会传入两个状态机中，两个状态机会根据玩家的行为做出相应的响应动作，比如一边奔跑一边射击。</p>
<p>当两组状态大部分都是互不相关的时候，这种实现方式很合适。但是在实际开发中，两组状态确实可能会出现相互影响的情况，比如角色不能在跳跃的时候进行射击。一个不太优雅的解决方法就是在状态类（或者条件类）中对另一个状态机的当前状态进行判断。</p>
<h1 id="分层状态机"><a href="#分层状态机" class="headerlink" title="分层状态机"></a>分层状态机</h1><p>很多时候，把一个事物具象化以后，可能会有很多“相似”的状态。比如一个玩家角色，它可能有站立、步行、奔跑和滑行等状态，当处在这些状态中的任何一个状态时，玩家都可以进行跳跃和下蹲的操作。如果使用常规的有限状态机，我们就需要给每个状态都添加这部分代码，一种常规的改进方式就是使用继承。我们可以将具有“相似”之处的状态分为一类，总结为一种新的状态，比如这里的站立、步行、奔跑和滑行等可以定义为“在地面上”这个新状态，然后之前的这些状态都继承它。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">OnTheGroundState</span> : <span class="title">IState</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleInput</span>(<span class="params">Player player, Input input</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == PRESS_JUMP) &#123;</span><br><span class="line">      <span class="comment">// change state to jump</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input == PRESS_DOWN) &#123;</span><br><span class="line">      <span class="comment">// change state to duck</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">RunState</span> : <span class="title">OnTheGroundState</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">handleInput</span>(<span class="params">Player player, Input input</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == PRESS_RUN) &#123;</span><br><span class="line">      <span class="comment">// change state to run</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      OnTheGroundState::handleInput(player, input);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子就用到了分层状态机的思想。我们再来列举一个例子，这个例子是从别处看到的，是一个决策小狗行为的例子。我们对小狗定义了很多状态，比如吃饭、睡觉、奔跑、咆哮、撒娇和摇尾巴等，如果使用常规的状态机，我们就需要考量每个状态之间的关系，定义所有可能的转换。但是如果使用分层状态机，我们可以对小狗的行为进一步“分类”，比如我们定义疲劳、开心和愤怒三个状态，然后在这些状态中再定义一些小状态。比如在开心的状态中，就有撒娇、摇尾巴等小状态。这样在外部我们只需要关心三个大状态的转换，在每个大状态的内部则只需要关心自己的小状态的转换即可。这就大大降低了状态机的复杂度，状态之间的转换数量也就相应地减少了。</p>
<p>从上面的两个例子可以看出，在分层状态机中会有一些超级状态，超级状态间也可以进行转换。利用超级状态，我们可以实现仅仅将状态转换应用到超级状态一次，而不用分别为每个状态应用一次状态转换。需要注意的是，分层状态机中每一层都是一个状态机，这意味着超级状态的内部也是一个独立的状态机。只要满足某一层（某个超级状态）的转移触发条件，就可以不用管其内部的子状态，直接进行状态切换，但是在退出该层之前需要依次执行每个子状态的退出逻辑。</p>
<p>使用分层状态机，我们可以重用部分代码（本质上是重用状态转换），从而减少状态转换的数量，但是它仍然不是一种比较理想的解决方案，因为重用转换并不容易，为此我们需要进行大量的思考。</p>
<h1 id="下推状态机"><a href="#下推状态机" class="headerlink" title="下推状态机"></a>下推状态机</h1><p>简单来说就是通过栈结构来存储一系列的状态对象。比如在一个射击游戏中，玩家角色处于站立的状态，那么栈顶的状态就是站立，执行的也是站立的逻辑。突然遇到敌人，玩家选择开火攻击，于是入栈一个射击的状态，此时会执行射击的逻辑。当敌人死亡，开火结束，为了恢复到开火前的上一个状态，选择弹出栈顶状态，此时就恢复到了之前的站立状态。总的来说，下推状态机适用于那些需要记忆状态的状态机。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://gameprogrammingpatterns.com/state.html">State</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.aisharing.com/archives/393">层次化状态机的讨论</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/31845498">状态机编程思想？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器集群技术概述</title>
    <url>/2019/08/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>当前很多大型的应用系统都使用了服务器集群技术，集群将相同的服务部署在多台服务器上构成一个整体来对外提供服务，这些集群有的是 Web 应用服务器集群，有的是数据库服务器集群等等。而在 Web 应用服务器集群的最前端，一般总会有一台负载均衡服务器，作为客户端流量的入口，负责将客户端的请求转发给合适的服务器来处理。</p>
<span id="more"></span>

<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡器一般分为硬件和软件两种。商用的负载均衡硬件常见的有 F5、绿盟、梭子鱼等，一般价格比较高昂，普通企业难以承受，而负载均衡软件价格则相对便宜，它们很多甚至是开源免费的，因此受到了许多企业的青睐，常见的有 LVS、Nginx、HAProxy 等。</p>
<h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>LVS 全名 Linux Virtual Server，意为 Linux 虚拟服务器，它是一个虚拟的服务器集群系统，主要用于服务器集群的负载均衡。由于它工作在 OSI 的第四层，也就是网络层，因此我们通常称它为<strong>四层负载均衡</strong>。LVS 的抗负载能力很强，因为 LVS 只负责分发请求，流量并不经过它，这个特点决定了它在负载均衡软件中性能是最强的。同时，LVS 的应用范围也比较广，因为工作在第四层，所以它几乎可以对所有的应用做负载均衡。当然，LVS 的缺点也有很多：比如对网络稳定性要求高，不支持动静分离、正则处理等，在大型网站中实施复杂，维护成本也很高。</p>
<p>在 LVS 中，具体提供 IP 负载均衡功能的模块是 IPVS（IP Virtual Server，IP 虚拟服务器），由于其工作在第四层，因此与 iptables 操作的 netfilter 一样，是直接工作在内核空间上的。在 Linux 2.4 以前，使用 LVS 需要重新编译内核以支持 LVS 的功能，但是从 Linux 2.4 开始，内核已经集成了 LVS 的各个功能模块，因此我们可以直接使用它了。目前主流的 Linux 发行版中默认都集成了 LVS 的各个功能模块。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx 的用途比较广泛，它不光是一个高性能的 HTTP 服务器，同时也支持反向代理和负载均衡。它工作在 OSI 的第七层，也就是我们常说的应用层，它可以针对 HTTP 应用做一些分流的策略，比如可以针对域名、目录结构等，安装配置简单且对网络稳定性要求较小，基本只要能够 PING 通就可以进行负载均衡，但是它仅支持 HTTP、HTTPS 和 Email 协议，适用范围就要比 LVS 小很多，并且也不支持 Session 会话和 Cookie 引导。</p>
<h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>HAProxy 使用简单，它支持两种工作模式，分别工作在 OSI 的第四层和第七层。与 Nginx 不同的是，它的主要功能就是负载均衡。它的出现弥补了 Nginx 不支持 Session 会话和 Cookie 引导的不足，并且在负载均衡的处理速度和并发上要优于 Nginx。</p>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>只有一个负载均衡节点的集群会存在单点问题，也就是说，负载均衡节点可能会因为一些原因宕机，此时客户端流量无法被转发，从而导致服务不可用。因此，一般的负载均衡节点至少需要两个，可以是一主一备，也可以是双主。接下来还需要通过某种方式，使集群能够及时发现和剔除出现问题的负载均衡节点，同时使所有的流量切换到正常的负载均衡节点上，从而实现负载均衡与集群的高可用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/19/PJO.gif" alt="主备切换动图"></p>
<h2 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h2><p>Keepalived 是目前比较常用的高可用组件。起初它是专为 LVS 设计的，用来管理并监控 LVS 集群系统中各个服务节点的状态，后来又加入了可以实现高可用的 VRRP 功能，可以作为其他服务的高可用组件使用。</p>
<p>VRRP 全称 Virtual Router Redundancy Protocol，意为<strong>虚拟路由冗余协议</strong>，是由 IETF 提出的用于解决局域网中静态网关单点失效问题的路由协议，在 1998 年正式成为标准，协议编号为：RFC2338。通过 VRRP 协议，可以把几台路由设备联合组成一台虚拟的路由设备，并将虚拟路由设备的 IP 地址（VIP，Virtual IP Address，虚拟 IP 地址）作为用户的默认网关与外部网络进行通信。在正常情况下，主设备需要处理两个主要任务，一个是负责转发数据流，另一个就是周期性的发送 VRRP 协议报文，而作为备组的设备则主要负责接收 VRRP 报文。当主设备遇到问题时，备组将无法接收到报文，此时备组中优先级较高的设备将被选举出来作为主设备继续负责转发，从而实现网关的冗余备份功能和链路的冗余功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/08/16/xrm.png" alt="VRRP"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://aokunsang.iteye.com/blog/2053719">浅谈 web 应用的负载均衡、集群、高可用 (HA) 解决方案</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.elecfans.com/d/700023.html">keepalived 及 LVS 概述, KeepAlived 工作原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>查找某个 jar 包是如何被引入的</title>
    <url>/2019/03/08/%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%20jar%20%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%BC%95%E5%85%A5%E7%9A%84/</url>
    <content><![CDATA[<p>公司项目使用 Maven 进行包依赖管理，一个项目少说得有上百个包，如何找到某个包是如何被引入的呢？可以有两种方式来定位。  </p>
<span id="more"></span>

<p>第一种就是通过开发工具查找。  </p>
<p>我使用的是 IDEA。点开 Maven Projects（一般在 IDEA 右侧），然后选择某个 Module，然后右键选择 Show Dependencies，IDEA 会打开一个视图。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/19/2x3.png" alt="依赖视图">  </p>
<p>使用 <code>Ctrl + F</code> 搜索需要寻找的包名，然后就可以看到该包是通过哪个其他的 jar 包引入的。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/06/19/VYD.png" alt="定位包">  </p>
<p>第二种方式就是通过 Maven 命令去查找。  </p>
<p>使用 <code>mvn dependency:tree -Dverbose -Dincludes=com.google.code.gson:gson</code> 命令查找。这里的 dependency:tree 表示通过树状显示所有的依赖项，<code>Dverbose</code> 表示显示所有的引用，包括因为多次引用而重复的。<code>Dincludes</code> 表示被引用的包。</p>
]]></content>
      <categories>
        <category>问题集</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Java</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端 WebSocket API</title>
    <url>/2018/01/06/%E6%9C%8D%E5%8A%A1%E7%AB%AF%20WebSocket%20API/</url>
    <content><![CDATA[<p>抛开别的语言不谈，使用 Java 实现的 WebSocket API 由 Oracle 制定，并已经成为 Java EE 7 的一部分，我们先使用该 API 简单实现一个 WebSocket 通信的 demo。</p>
<span id="more"></span>

<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><p>JDK 需要大于等于 7、servlet-api 3.1、websocket-api 1.1 以及实现了 <a href="https://github.com/javaee/websocket-spec">JSR356</a> 规范的 Web 容器。  </p>
<blockquote>
<p>Tomcat 7 及以上版本都可以，Tomcat 7 以前的版本提供了 Tomcat 自己的 WebSocketServlet，在 Tomcat 7 中 <code>deprecated</code>，在 Tomcat 8 中移除。  </p>
</blockquote>
<h1 id="基于-JSR356-WebSocket-API-的-demo"><a href="#基于-JSR356-WebSocket-API-的-demo" class="headerlink" title="基于 JSR356 WebSocket API 的 demo"></a>基于 JSR356 WebSocket API 的 demo</h1><p>页面的代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 210px;height: 110px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;connect&quot;</span>&gt;</span> 新建连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;send&quot;</span>&gt;</span> 发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;close&quot;</span>&gt;</span> 断开连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/websocket.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* websocket.js */</span></span><br><span class="line"><span class="keyword">var</span> $ = <span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> txt = $(<span class="string">&quot;#txt&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> connect = $(<span class="string">&quot;#connect&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> send = $(<span class="string">&quot;#send&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> close = $(<span class="string">&quot;#close&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> info = $(<span class="string">&quot;#info&quot;</span>);</span><br><span class="line"></span><br><span class="line">connect.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080/web/websocket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ws.<span class="title function_">addEventListener</span>(<span class="string">&quot;open&quot;</span>, <span class="keyword">function</span> (<span class="params">open</span>) &#123;</span><br><span class="line">        info.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;p&gt;&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; 连接建立 &lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">        info.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;p&gt;&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; 服务器返回消息：&quot;</span> + message.<span class="property">data</span> + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        info.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;p&gt;&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; 出错 &lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.<span class="title function_">addEventListener</span>(<span class="string">&quot;close&quot;</span>, <span class="keyword">function</span> (<span class="params">close</span>) &#123;</span><br><span class="line">        info.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;p&gt;&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; 连接关闭：&quot;</span> + close.<span class="property">code</span> + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">send.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (txt.<span class="property">value</span>.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; ws) ws.<span class="title function_">send</span>(txt.<span class="property">value</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">close.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">        ws.<span class="title function_">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>后端 Java 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/web/websocket&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 后续可以将 session 维护进内存中，并建立相关联的 key，根据这个 key 查找出对应的 session，并往该 session 输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------连接建立------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Session session, String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(session.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(text);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    session.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------连接关闭------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用注解的方式，也可以通过继承 Endpoint 来实现，在这之前，需要先写一个配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.Endpoint;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpointConfig;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">ServerApplicationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法在容器启动后会扫描实现 Endpoint 的类，传入 set</span></span><br><span class="line"><span class="comment">     * 因此可以在该方法中过滤，自定义哪些可以部署</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set 扫描到的处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可以部署的处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ServerEndpointConfig&gt; <span class="title function_">getEndpointConfigs</span><span class="params">(Set&lt;Class&lt;? extends Endpoint&gt;&gt; set)</span> &#123;</span><br><span class="line">        Set&lt;ServerEndpointConfig&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Endpoint</span>&gt; ep : set) &#123;</span><br><span class="line">            result.add(ServerEndpointConfig.Builder.create(ep, <span class="string">&quot;/web/websocket&quot;</span>).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法在容器启动后会扫描带有 Endpoint 注解的类，传入 set</span></span><br><span class="line"><span class="comment">     * 因此可以在该方法中过滤，自定义哪些可以部署</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set 扫描到的处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可以部署的处理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getAnnotatedEndpointClasses(Set&lt;Class&lt;?&gt;&gt; set) &#123;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonEndpoint</span> <span class="keyword">extends</span> <span class="title class_">Endpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, EndpointConfig endpointConfig)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------连接建立------&quot;</span>);</span><br><span class="line">        session.addMessageHandler(<span class="keyword">new</span> <span class="title class_">NekoMessageHandler</span>(session.getBasicRemote()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------连接关闭------&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.onClose(session, closeReason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NekoMessageHandler</span> <span class="keyword">implements</span> <span class="title class_">MessageHandler</span>.Whole&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> RemoteEndpoint.Basic remoteEndpointBasic;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">NekoMessageHandler</span><span class="params">(RemoteEndpoint.Basic remoteEndpointBasic)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.remoteEndpointBasic = remoteEndpointBasic;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (remoteEndpointBasic != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    remoteEndpointBasic.sendText(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-的实现"><a href="#Spring-的实现" class="headerlink" title="Spring 的实现"></a>Spring 的实现</h1><p>Spring 从 4.0 版本后开始支持 JSR356 WebSocket API，同时也提供了一套 Spring 的 WebSocket API。</p>
<p>我们在使用 JSR356 WebSocket API 时，是通过 Servlet 容器扫描来部署 Endpoint 处理类的，现在我们使用 Spring 来处理这个过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRegistration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Web 启动初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(javax.servlet.ServletContext servletContext)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 注册配置类</span></span><br><span class="line">        ctx.register(MvcConfig.class, NekoEndpointConfig.class);</span><br><span class="line">        ctx.setServletContext(servletContext);</span><br><span class="line">        <span class="comment">// 添加 Servlet（相当于 web.xml 的 servlet 配置）</span></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">servlet</span> <span class="operator">=</span> servletContext.addServlet(<span class="string">&quot;mvc&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(ctx));</span><br><span class="line">        servlet.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;com.nekolr&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射静态资源文件目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/views/**&quot;</span>).addResourceLocations(<span class="string">&quot;/WEB-INF/views/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源映射器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerMapping <span class="title function_">getHandlerMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.resourceHandlerMapping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointRegistration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NekoEndpointConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了让 Spring 管理 Endpoint，需要注入 ServerEndpointExporter，</span></span><br><span class="line"><span class="comment">     * 该 bean 会自动注册使用了<span class="doctag">@ServerEndpoint</span> 注解声明的 Endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">endpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 ServerEndpointRegistration 发布 Endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointRegistration <span class="title function_">registration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointRegistration</span>(<span class="string">&quot;/web/websocket&quot;</span>, NekoEndpoint.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NekoEndpoint</span> <span class="keyword">extends</span> <span class="title class_">Endpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, EndpointConfig endpointConfig)</span> &#123;</span><br><span class="line">        session.addMessageHandler(<span class="keyword">new</span> <span class="title class_">MessageHandler</span>.Whole&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    session.getBasicRemote().sendText(s);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onClose(session, closeReason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们再使用 Spring 提供的一套 API 来实现，同时，我们在页面使用 SockJS，Spring 对 SockJS 有很好的支持。与 JSR356 WebSocket API 的 Endpoint 不同，使用 Spring WebSocket API，Endpoint 变成了 WebSocketHandler，同时也更容易理解了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring-context --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.23.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring-web --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.23.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring-webmvc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.23.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring-websocket --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.23.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一定加上这个包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NekoWebSocketHandler</span> <span class="keyword">implements</span> <span class="title class_">WebSocketHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession webSocketSession)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------连接建立------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(WebSocketSession webSocketSession, WebSocketMessage&lt;?&gt; webSocketMessage)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TextMessage</span> <span class="variable">returnMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>(webSocketMessage.getPayload().toString());</span><br><span class="line">        System.out.println(webSocketSession.getHandshakeHeaders().getFirst(<span class="string">&quot;Cookie&quot;</span>));</span><br><span class="line">        webSocketSession.sendMessage(returnMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession webSocketSession, Throwable throwable)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(webSocketSession.isOpen()) &#123;</span><br><span class="line">            webSocketSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------连接出错------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession webSocketSession, CloseStatus closeStatus)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------连接断开------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsPartialMessages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时还可以写拦截器来过滤握手请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以在此拦截器中实现限制某些握手请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NekoHandshakeInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HttpSessionHandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> </span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getHeaders().containsKey(<span class="string">&quot;Sec-WebSocket-Extensions&quot;</span>)) &#123;</span><br><span class="line">            request.getHeaders().set(<span class="string">&quot;Sec-WebSocket-Extensions&quot;</span>, <span class="string">&quot;permessage-deflate&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.beforeHandshake(request, response, wsHandler, attributes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response, </span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterHandshake(request, response, wsHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时还需要写一个配置类来部署这些处理器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该类配置将启用哪些 WebSocketHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NekoWebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry webSocketHandlerRegistry)</span> &#123;</span><br><span class="line">        <span class="comment">// withSockJS() 表示启用 SockJS 支持</span></span><br><span class="line">        webSocketHandlerRegistry.addHandler(nekoWebSocketHandler(), <span class="string">&quot;/web/websocket&quot;</span>)</span><br><span class="line">                .addInterceptors(nekoHandshakeInterceptor()).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebSocketHandler <span class="title function_">nekoWebSocketHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NekoWebSocketHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandshakeInterceptor <span class="title function_">nekoHandshakeInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NekoHandshakeInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于没有使用 Spring 的 xml 配置文件（同时也没有使用 web.xml），所以要写配置类。如果 Spring 是通过 xml 文件来配置的话，可以参考下面的写法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">websocket:handlers</span> <span class="attr">allowed-origins</span>=<span class="string">&quot;*&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/web/websocket&quot;</span> <span class="attr">handler</span>=<span class="string">&quot;nekoWebSocketHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handshake-interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.nekolr.NekoHandshakeInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handshake-interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:sockjs</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;nekoWebSocketHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.nekolr.NekoWebSocketHandler&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>MvcConfig 与之前的写法一样，WebInitializer 需要将 NekoWebSocketConfig 加入并注册。与此同时，页面需要引入 sockjs.js 并将 <code>new WebSocket</code> 修改为 <code>new SockJS</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/7vn.gif" alt="演示"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html">JSR 356, Java API for WebSocket</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/javaee/websocket-spec">websocket-spec</a></p>
</blockquote>
<blockquote>
<p><a href="http://tomcat.apache.org/tomcat-7.0-doc/api/org/apache/catalina/websocket/WebSocketServlet.html">WebSocketServlet (Apache Tomcat 7.0.94 API Documentation)</a></p>
</blockquote>
<blockquote>
<p><a href="http://wu1g119.iteye.com/blog/2220452">spring4 websocket + sockjs 遇到的坑</a></p>
</blockquote>
<blockquote>
<p><a href="http://wiselyman.iteye.com/blog/2003336">Spring 4.0 系列 9 - websocket 简单应用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 ConcurrentHashMap</title>
    <url>/2020/05/30/%E6%B5%85%E8%B0%88%20ConcurrentHashMap/</url>
    <content><![CDATA[<p>我们知道，HashMap 是非线程安全的，在多线程环境下我们可能需要使用线程安全的 Map 容器，可选的有 HashTable 和 ConcurrentHashMap。HashTable 将所有可能出现线程安全问题的方法都使用 synchronized 来修饰，这种做法虽然简单粗暴，但是由于锁的粒度较大（所有访问 HashTable 的线程都在竞争同一把锁），导致它的并发性能较差。而 ConcurrentHashMap 则不同，在 JDK 7 中，它将锁细化为多把锁，每一把锁只用于锁定容器中的一部分数据，那么当多线程访问容器中不同数据段的数据时，线程之间是不存在锁竞争的，这就是我们常说的锁分段技术。但是到了 JDK 8，ConcurrentHashMap 又出现了很大的变化，最大的变化就是不再使用锁分段技术，转而使用 CAS 和 synchronized，这在文章中会具体介绍。</p>
<span id="more"></span>

<h1 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h1><p>在 JDK 7 中，ConcurrentHashMap 主要是由 Segment 数组和 HashEntry 数组构成。Segment 继承自 ReentrantLock，因此它扮演的是独占锁的角色。HashEntry 类似于 HashMap 中的 <code>HashMap$Entry&lt;K,V&gt;</code>，用于存储键值对数据。一个 ConcurrentHashMap 包含一个 Segment 数组，这个数组可以理解成类似 HashMap 中的 table 数组，同时一个 Segment 又包含一个 HashEntry 数组，每个 HashEntry 不仅存储键值对数据，同时还维护着指向下一节点的引用，从而形成一个链表。每个 Segment 都守护着各自的 HashEntry 数组元素，当需要对数组元素进行修改时，必须首先获得与之对应的 Segment 锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202006011913/2020/06/01/oPL.png" alt="ConcurrentHashMap"></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>通过设置初始化容量 initialCapacity、负载因子 loadFactor、预估的并发更新线程数 concurrencyLevel 等几个参数来初始化 Segment 数组、段偏移量 segmentShift、段掩码 segmentMask 和每个 Segment 中的 HashEntry 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                          <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// cap 最小为 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建 segments 数组并初始化第一个数组元素</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                          (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Segment 数组的长度 ssize 是通过 concurrencyLevel 计算得出的，为了能够实现按位与运算来定位 Segment 数组的索引，必须保证数组的长度是 2 的 N 次方，因此不管传入的 concurrencyLevel 是多少，总能够计算出一个大于或者等于 concurrencyLevel 的最小的 2 的 N 次方的值来作为 Segment 数组的长度。如果 concurrencyLevel 为 14、15 或者 16，那么计算出的数组长度就是 16。需要注意的是，Segment 数组在初始化之后就是固定的，无法扩容，同时 concurrencyLevel 的最大值是 65536，对应的二进制是 16 位。</p>
<p>默认情况下 concurrencyLevel 为 16，此时 ssize 的值也是 16，而 sshift 等于 ssize 从 1 向左移位的次数，因此默认情况下 sshift 的值为 4。segmentShift 的作用是定位参与计算索引的 hash 值的位数，同时由于 hash() 方法返回值的类型是 int，这就意味着 hash 值是 32 位的，因此 segmentShift 等于 32 - sshift，也就是说在默认情况下 hash 值在参与计算数组索引时需要右移 28 位，即在计算索引时只使用 hash 值的高 4 位参与运算。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 计算 segments 数组索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 对应的 Segment 如果没有初始化会进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">          (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 定位 HashEntry 数组的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 获取对应索引位置的 HashEntry</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">// 当前位置已经被占用</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// 根据 key 的情况决定是否覆盖新值</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">// 扩容方法</span></span><br><span class="line">                    <span class="comment">// 只对某个 Segment 进行两倍扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                  (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">              e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 操作不需要加锁，原因是用于存储值的 value 是使用 volatile 修饰的，根据 Java 内存模型的 happens-before 原则，对 volatile 字段的写入操作先于读取操作，所以我们总能读到最新的值。</p>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>如果要统计整个 ConcurrentHashMap 的大小，就必须统计所有 Segment 里元素的个数后求和。Segment 中的成员变量 count 存储的就是 Segment 中元素的个数，同时它还使用 volatile 进行了修饰，那么我们是不是将所有 Segment 中的 count 相加就可以了呢？答案是不行，虽然我们在相加时可以获取到 count 的最新值，但是可能会出现在相加的过程中已经使用过的 count 值发生变化，那么统计结果就不准确了。因此最安全的做法就是在统计 size 的时候锁住所有可能引起 size 变化的方法，比如 put、remove 等，但是这种做法显然不够理想。现实中在累加 count 的过程中出现使用过的 count 发生变化的几率很小，因此 ConcurrentHashMap 的做法是先尝试 2 次不通过锁住 Segment 的方式来统计各个 Segment 的大小，如果统计过程中容器的 count 的发生了变化（通过检查 modCount 是否发生变化来实现，在 put、remove 和 clean 方法中操作元素前都会将 modCount 加 1），那么再通过加锁的方式来统计所有 Segment 的大小。</p>
<h1 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h1><p>在 JDK 8 中，ConcurrentHashMap 不再使用 Segment（保留了相关的代码以实现序列化时的兼容性），而是采用 CAS + synchronized 来保证并发情况下的线程安全。其中一个原因是分段锁比较浪费内存空间，毕竟比普通的 Map 多了一个 Segment 数组。同时在生产环境中，同一时刻多个线程竞争同一把锁的概率非常小，这也就意味着同一时刻数组的某个位置被多个线程竞争的概率非常小。</p>
<h2 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许插入为 null 的键和值，HashMap 允许插入</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 初始化 table</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 定位元素的位置，如果该位置上没有元素，则通过 CAS 进行添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                          <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查到内部是否正在进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 协助进行扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 锁住链表或者红黑树的头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 表示这是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 存在该节点，则更新 value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                  (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 不存在则在链表尾部添加节点</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 是红黑树的节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表节点个数超过阈值 8，则将链表转化成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 size 的数量加 1，并在其中检查是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果索引位置没有元素，则直接通过 CAS 自旋的方式确保链表的首节点一定能成功添加，而只有在索引位置存在元素时才会进行加锁，锁对象是该位置的链表或红黑树的头节点。当 table 的容量不足时需要对 table 进行扩容，整个扩容分为两步。第一步是创建一个 nextTable，大小为 table 的两倍。第二步就是将 table 中的数据复制到 nextTable 中。在单线程环境下要实现这两个步骤是很容易的，但是在多线程环境下实现起来就比较麻烦，因为扩容也有可能出现并发执行的情况，因此创建和初始化数组的操作必然只能由一个线程来执行，而数据复制则可以支持并发复制，这样性能可以提升很多，但是相对的复杂度也提升了。</p>
]]></content>
      <categories>
        <category>Java 集合框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 JDBC</title>
    <url>/2020/06/02/%E6%B5%85%E8%B0%88%20JDBC/</url>
    <content><![CDATA[<p>应用程序与数据库软件进行交互可以有多种方式，其中常见的就是 JDBC 和 ODBC，它们都是在 X&#x2F;Open SQL CLI（Call Level Interface）的基础上完成，但是 JDBC 更适合在 Java 应用中使用。JDBC 提供了一套用于 Java 程序与 DBMS 进行交互的 API，即只是制定了这个规范，具体的实现则交给了不同的数据库软件厂商。</p>
<span id="more"></span>

<h1 id="JDBC-1-0"><a href="#JDBC-1-0" class="headerlink" title="JDBC 1.0"></a>JDBC 1.0</h1><p>JDBC 的第一个版本是跟随 JDK 1.1 一起发布的，相关的接口和类位于 java.sql 包中，包含了 DriverManager 类、Driver 接口、Connection 接口、Statement 接口、ResultSet 接口、SQLException 类等。在这一时期，我们需要手动加载 JDBC 驱动，然后通过 DriverManager 来获取数据库连接，比较典型的使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 加载数据库驱动</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="comment">// 2 通过驱动管理类获取数据库连接</span></span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            <span class="comment">// 3 定义 sql 语句，? 表示占位符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ?&quot;</span>;</span><br><span class="line">            <span class="comment">// 4 获取预处理 statement</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            <span class="comment">// 5 设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的参数值</span></span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;saber&quot;</span>);</span><br><span class="line">            <span class="comment">// 6 向数据库发出 sql 执行查询，查询出结果集</span></span><br><span class="line">            resultSet = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">// 7 遍历查询结果集</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                System.out.println(resultSet.getString(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 8 释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preparedStatement != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    preparedStatement.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDBC-2-0"><a href="#JDBC-2-0" class="headerlink" title="JDBC 2.0"></a>JDBC 2.0</h1><p>JDBC 2.0 的最大变化大概就是引入了 <code>javax.sql.DataSource</code>。在 JDBC 1.0 的时候，我们只能通过 DriverManager 来创建数据库连接，而在 JDBC 2.0 中，我们可以使用 DataSource 直接获取数据库连接。一个 DataSource 对象代表一个真正的数据源，在使用 DataSource 时，我们可以不必编写加载驱动的代码，只需要将数据库连接信息作为参数传入即可，DataSource 会负责连接数据库的工作。同时应用程序可以直接连接到多个数据源，我们只需要修改 DataSource 的属性即可，不需要修改应用程序的代码，与 DriverManager 相比，我们的代码会变的更加简洁，也更容易控制。</p>
<p>DataSource 大致有三种类型的实现，其中一种是最基本的实现，即生成标准的 Connection 对象。另一种是基于连接池的实现，即在 DataSource 中集成了连接池技术，生成的 Connection 对象是自动参与连接池的。还有一种就是分布式事务的实现，在这种实现中，一般会使用连接池和事务管理器，生成的 Connection 对象可以用于分布式事务。</p>
<p>DataSource 可以与 JNDI 一起工作，这样就可以把 DataSource 对象的创建、部署和管理与应用程序分开了，提高了应用程序的可移植性和可维护性。系统管理员或者具有相应权限的人来配置 DataSource 对象，包括设定 DataSource 的属性，然后将它注册到 JNDI 服务中去。在注册 DataSource 对象的的过程中，系统管理员需要把 DataSource 对象和一个逻辑名称关联起来。名称可以是任意的，通常选择能够代表数据源并且容易记忆的名称。</p>
<p>我们可以在 Java Web 项目的 META-INF 目录下新建一个 context.xml 文件，然后添加以下内容，然后修改 WEB-INF&#x2F;web.xml 配置文件。或者直接在 Tomcat 中修改 conf&#x2F;context.xml 文件，添加一个 Resource。直接修改 Tomcat 配置文件的这种方式，需要将用到的 jar 包拷贝到 Tomcat 安装目录下的 lib 目录中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Resource</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;jdbc/druid-test&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSourceFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;javax.sql.DataSource&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxActive</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxIdle</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxWait</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">password</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">            <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) context.lookup(<span class="string">&quot;java:comp/env/jdbc/druid-test&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDBC-4-0"><a href="#JDBC-4-0" class="headerlink" title="JDBC 4.0"></a>JDBC 4.0</h1><p>JDBC 4.0 随着 JDK 6 一起发布，值得一说的是，在 JDK 6 中，使用 DriverManager 获取连接之前可以不再显式地加载驱动。<code>java.sql.DriverManager</code> 的内部实现机制决定了只有先通过 Class.forName() 方法找到特定驱动的 class 文件，DriverManager.getConnection() 方法才能顺利地获得数据库连接。这样的代码为编写程序增加了不必要的负担，JDK 的开发者也意识到了这一点。从 JDK 6 开始，应用程序不再需要显式地加载驱动程序了，DriverManager 开始能够自动地承担这项任务。这主要得益于 Java 的 SPI 机制。JDBC 4.0 的规范规定，所有的驱动 jar 包必须在 META-INF&#x2F;services 目录下包含一个名称为 java.sql.Driver 的文本文件，这个文件里的一行便对应一个驱动类。有了这样的描述，DriverManager 就可以从当前的 CLASSPATH 中找到对应的驱动文件。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 MySQL 索引的实现</title>
    <url>/2019/09/10/%E6%B5%85%E8%B0%88%20MySQL%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>索引本质上是一种数据结构，能够帮助数据库高效地获取数据。我们都知道 MySQL 数据库使用 B+树作为索引的实现，那么具体是如何实现的呢，下面进行详细的探究。</p>
<span id="more"></span>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/10/WyW.png" alt="索引结构"></p>
<p>这是一种可能的索引方式，左边是数据表，共有两列七条记录，最左侧是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树（实际环境中不会使用二叉查找树作为索引结构，这里只是简单演示），每个节点包含索引键和一个指向对应数据记录的物理地址的指针。</p>
<h1 id="MyISAM-引擎的索引实现"><a href="#MyISAM-引擎的索引实现" class="headerlink" title="MyISAM 引擎的索引实现"></a>MyISAM 引擎的索引实现</h1><p>在 MySQL 5.1 以前，MyISAM 是默认的存储引擎，每个 MyISAM 在磁盘上存储成三个文件，每个文件的名称均以表的名称开始，扩展字段指出文件类型，其中 <code>.frm</code> 文件存储表的定义，<code>.MYD</code>（MYData）文件存储表的数据，<code>.MYI</code>（MYIndex）文件存储表的索引。</p>
<p>MyISAM 引擎使用 B+树作为索引结构，叶子节点的 data 域存放的是数据记录的地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/11/L3R.png" alt="MyISAM 索引"></p>
<p>这里的表有三列，假如 Col1 为主键，则上图就是一个通过主键建立的索引。在 MyISAM 中，主键索引和非聚集索引（辅助索引）在结构上没有任何区别，只是主键索引要求 key 是唯一的，而辅助索引的 key 可以重复。</p>
<blockquote>
<p>因为 MyISAM 中没有聚集索引，所以主键的索引我们就叫它主键索引，与普通的索引（辅助索引）相区分。MyISAM 中的表可以没有主键。</p>
</blockquote>
<h1 id="InnoDB-引擎的索引实现"><a href="#InnoDB-引擎的索引实现" class="headerlink" title="InnoDB 引擎的索引实现"></a>InnoDB 引擎的索引实现</h1><p>在 MySQL 5.1 以后，InnoDB 是默认的存储引擎，在创建 InnoDB 表时，MySQL 会在数据目录下的数据库目录中创建一个 <code>.frm</code> 文件存储表的定义，还会创建一个 <code>.ibd</code> 的表空间文件，存储表的索引和数据。</p>
<p>InnoDB 引擎同样使用 B+树作为索引结构，但是与 MyISAM 引擎不同的是，它的主键索引是聚集索引，叶子节点存储的是完整的数据记录，它的辅助索引（非聚集索引）中，叶子节点存储的是主键的值而不是地址值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/11/rzj.png" alt="聚集索引"></p>
<p>上图是 InnoDB 主键索引的结构，叶子节点存储的是完整的数据记录。如果数据表没有显式指定主键同时表中也不存在合适的 unique 索引，则 InnoDB 会自动为该表生成一个隐藏的列作为主键，该列是一个 6 字节的长整型字段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/11/gPa.png" alt="非聚集索引"></p>
<p>上图在 Col2 上添加了索引，这就是 InnoDB 辅助索引的结构，叶子节点存储的是主键的值。辅助索引使用主键值来实现类似指针的效果，虽然会让辅助索引占用更多的空间，但是换来的好处就是当移动行时无需更新辅助索引中的这个“指针”。</p>
<p>使用辅助索引搜索时需要检索两遍索引：首先检索辅助索引获得主键，然后通过主键到主键索引中检索获得记录。由于 InnoDB 中所有的辅助索引都会引用主键，所以过长的主键会令辅助索引变得很大，这也是为什么推荐使用自增主键而不是业务相关的其他随机字符串作为主键的一个原因。同时，推荐使用单调递增的字段作为主键可以避免在插入新记录时数据文件为了维持 B+树的特性而频繁地分裂调整。</p>
<h1 id="主键的选择"><a href="#主键的选择" class="headerlink" title="主键的选择"></a>主键的选择</h1><p>在使用 InnoDB 时，如果没有特殊的原因，推荐使用与业务无关的自增字段作为主键。因为 InnoDB 的索引是聚集索引，这就要求同一个叶子节点内的各条数据记录按照主键的顺序存放。每当有一条新的记录插入时，MySQL 会根据其主键将其插入到适当的节点和位置，如果页面达到装载因子（InnoDB 默认为 15&#x2F;16），则会开辟一个新的节点（页）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满后，自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时不需要移动已有的数据，同时索引的维护开销很小，因此效率很高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/11/QWv.png" alt="自增插入"></p>
<p>如果使用非自增主键，由于每次插入主键的值近似于随机，每次新纪录都要插入到现有索引页中间的某个位置。此时 MySQL 不得不为了新纪录插入到合适的位置而移动数据，甚至目标页面可能已经被写回到磁盘中而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁地移动、分页操作造成了大量的碎片，得到的索引结构不够紧凑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/11/OWQ.png" alt="非自增插入"></p>
<h1 id="索引树高度计算"><a href="#索引树高度计算" class="headerlink" title="索引树高度计算"></a>索引树高度计算</h1><p>假如一张 InnoDB 表有 3000 万条记录，使用一列占用 8 个字节的字段建立索引，索引树的高度是多少？</p>
<p>要计算索引树的高度，需要先知道每个节点的大小。我们知道，现代的数据库一般会利用磁盘的预读机制，每个索引节点的大小一般是操作系统内存页的整数倍，操作系统页的大小一般是 4K，而 InnoDB 的页大小默认为 16K。接下来需要知道一个节点能够存放多少个键。非聚集索引中，节点包含键值、指针和主键数据，根据 <code>pagesize/(keysize + datasize + pointsize)</code> 公式我们可以得到键的数量，假设主键字段的大小为 6 个字节，指针大小为 4 个字节，则 16K&#x2F;(8 byte + 6 byte + 4 byte) $\approx$ 910。然后根据树的高度计算公式求出树高大约为 $log(2^{10},2^{25})\approx$ 2.5。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列中间件</title>
    <url>/2019/11/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>从命名上看，消息队列可以简单理解为存放消息的队列（Queue），而队列是一种常见的数据结构，在 Java 中的 <code>java.util.Queue</code> 接口下就有大量的队列实现。在一些业务场景中，我们可以使用 JDK 以及第三方包提供的队列实现，但是有些场景我们就不得不引入独立的队列组件，这有点类似 <code>java.util.HashMap</code> 与 Redis 的关系，它们都是以 key&#x2F;value 的形式将数据存储到内存，但是在很多场景中我们需要使用 Redis 来替换 HashMap。</p>
<span id="more"></span>

<blockquote>
<p>消息队列更为准确的描述是存放消息的容器，消息的生产者将消息放入容器，消费者可以从容器中取出消息进行消费。</p>
</blockquote>
<h1 id="为什么要使用消息队列"><a href="#为什么要使用消息队列" class="headerlink" title="为什么要使用消息队列"></a>为什么要使用消息队列</h1><p>使用消息队列可以实现异步、解耦、削峰和流控等，同时分布式系统中也可以使用消息队列来实现最终一致性。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>我们可以根据传递方式的不同将消息划分为同步消息和异步消息。同步消息中比较有代表性的就是 RPC 调用，而异步消息中比较有代表性的就是使用消息队列。异步消息一般不怎么关心消息执行的结果，如果希望了解异步消息的执行情况，通常有<strong>轮询和通知</strong>两种方式。轮询具体是指在消息执行完毕后向其他设备（比如一个阻塞队列等）刷新执行结果，由主调方轮询查看结果；而通知则可以通过注册回调的方式实现。</p>
<p>假如系统中有一个耗时操作，我们正常调用该操作时，需要等待该操作结束后才能得到返回结果并继续向下执行，如果此时我们在系统中引入消息队列，将耗时操作需要的参数发送给消息队列，由队列代为执行，则可以不用等待耗时操作结束就可以直接返回。</p>
<h2 id="削峰-流控"><a href="#削峰-流控" class="headerlink" title="削峰&#x2F;流控"></a>削峰&#x2F;流控</h2><p>使用消息队列实现的异步处理可以延伸出一个比较常用的功能，那就是削峰和流控。比如一个系统，在不使用消息队列的时候，用户的请求数据经过处理后直接写入到数据库中，在请求量突然增大的情况下，数据库的压力也会骤然增大，使得整个系统的响应速度变慢。在使用了消息队列之后，用户的请求数据会直接发送给消息队列后立即返回，消息队列的消费者进程会从消息队列中获取数据并写入到数据库中。由于消息队列的消息处理能力一般高于数据库，同时消息队列的伸缩性也优于数据库，因此整个系统的响应速度会得到大幅提升。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912031751/2019/12/03/5Qe.png" alt="削峰"></p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>有一个比较常见的业务场景，比如一个模块或系统，我们称为 A。A 需要将产生的数据传递给其他模块或系统，因此我们在 A 中直接调用其他模块或系统的方法来传递数据，而当其中的某个模块或系统不再需要该数据时，我们还需要再去修改 A 的逻辑，去掉向该模块或系统传递数据的方法。在这种场景下，如果业务频繁变更，我们需要不断修改 A 的逻辑，系统的可扩展性较差。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SystemB</span> <span class="variable">systemB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SystemC</span> <span class="variable">systemC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemC</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// execute A&#x27;s logic</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliverData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">data</span> <span class="operator">=</span> <span class="built_in">this</span>.doSomething();</span><br><span class="line">        systemB.needToDo(data);</span><br><span class="line">        systemC.needToDo(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道如果模块之间不存在直接调用，那么添加或修改模块就不会对其他模块产生较大的影响，这样系统的可扩展性无疑会更好。在这种思想的指导下一般我们会引入一个中间者，作为它们之间沟通和协调的枢纽。这个枢纽在这里就是消息队列，并且结合业务的特点，我们可以使用消息队列的发布&#x2F;订阅模式，消息的发送者（生产者）发送消息，一个或多个消息接收者（消费者）订阅消息，这样消息发送者和消息接收者之间就避免了直接耦合，从而达到解耦的目的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912091502/2019/12/09/kKd.png" alt="解耦"></p>
<h1 id="消息队列的本质"><a href="#消息队列的本质" class="headerlink" title="消息队列的本质"></a>消息队列的本质</h1><p>RPC 大多都是基于请求&#x2F;响应模型的，这也包括响应式范式。一般需要点对点通信、强事务保证以及延迟敏感的服务大多使用 RPC 而不是消息队列。从某种意义上讲，消息队列可以看做是一种异步的 RPC，它把一次 RPC 拆分成了两次 RPC 加一次转储，如果需要消费者最终做消费确认则是三次 RPC。在消息队列中，消息发送者将消息投递到服务端（或者叫做 Broker），服务端需要考虑如何承载消息的堆积，然后在合适的时机再将消息转发给消息接收者。</p>
<h1 id="常见的消息队列协议"><a href="#常见的消息队列协议" class="headerlink" title="常见的消息队列协议"></a>常见的消息队列协议</h1><p>在消息队列中，消息的发送者需要知道如何构造消息，消息的接收者需要知道如何解析消息，它们需要按照一种统一的格式描述消息，这种统一的格式被称为消息协议。常见的消息队列通信协议包括 STOMP、AMQP、MQTT、OpenWire（ActiveMQ）、HTTP、XMPP 等，也有很多消息中间件使用自定义的通信协议，比如 RocketMQ、Kafka 等。</p>
<h2 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h2><p>STOMP 的全称为 The Simple (or Streaming) Text Oriented Messaging Protocol，意为<strong>简单（或流式）面向文本的消息协议</strong>。它是一种基于文本的协议，同时它也是一种基于帧的协议，帧的结构效仿了 HTTP 报文的格式，简单明了，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure>

<p>STOMP 提供了能够协作的报文格式，因此 STOMP 客户端可以与任何 STOMP 消息代理（Broker）进行通信。该协议的优点就是简单且易于实现，几乎所有的编程语言都有 STOMP 的客户端实现，缺点也很明显，它在消息大小和处理速度方面并无优势。比较典型的实现了该协议的消息队列就是 Apache ActiveMQ 和 Apache ActiveMQ Artemis。</p>
<p>很多时候，我们在使用 WebSocket 时通常会配合 STOMP 协议来实现实时通信的功能，也就是使用 STOMP over Websocket。这是因为 WebSocket 只定义了两种类型的消息：文本和二进制，但是它们的内容和格式并没有定义。因此我们需要在客户端与服务端之间定义一种更高级别的消息协议，将它使用在 WebSocket 之上去定义每次发送消息的类别、格式和内容等信息。而 STOMP 可用于任何可靠的双向流网络协议之上，比如 TCP 和 WebSocket，因此在 WebSocket 协议之上使用 STOMP 协议也就顺理成章了。</p>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP 协议的全称为 Advanced Message Queuing Protocol，意为<strong>高级消息队列协议</strong>。它是一种二进制的应用层协议，规范了消息传递方和消息接收方的行为，以使消息在不同的提供商之间实现互操作。与 JMS 在特定的 API 接口层面和实现行为上进行统一不同，AMQP 更关注于各种消息如何以字节流的形式传递，因此任何实现了该协议的应用程序之间都可以进行消息的接收和传递。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912121531/2019/12/12/Ezg.png" alt="AMQP"></p>
<p>AMQP 协议比较全面且功能强大，但是实现比较复杂。典型的实现了该协议的消息队列就是 RabbitMQ。</p>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>严格来说将 JMS 归为消息通信协议是不严谨的，但是我们又不得不提到 JMS。JMS 全称 Java Message Service，即 Java 消息服务。它是 Java 平台提供的面向消息中间件的 API，没有定义通信方式和报文格式等细节。这有点类似于 JDBC，由 JCP 组织发布 JDBC 规范，然后具体的数据库厂商来实现这套规范，比如 MySQL JDBC Driver。因此为了便于理解，我们可以将 JMS 看作 JDBC，将不同的消息队列看作是不同的数据库软件，如果某个消息中间件厂商实现了 JMS 规范，我们就可以直接使用 JMS API 来操作它。从这一点来讲，JMS 协议就不像 AMQP 和 MQTT 这种操作级的协议，直接定义了所有的交互细节，这样就可以只通过一个客户端来操作不同的实现了对应协议的消息中间件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/MyE.png" alt="JMS API"></p>
<p>JMS 中有两个重要的概念需要解释清楚，一个是 Provider，另一个是 Destination。其中 Provider 是消息的中转者，负责消息的存储和转发，在 ActiveMQ 中又叫做 Broker。比如一个 ActiveMQ 服务就是一个 Broker 或 Provider。而 Destination 则指明了消息发送的目的地以及客户端接收消息的来源，在 JMS 有两种目的地：队列（Queue）和主题（Topic）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/ebr.png" alt="JMS"></p>
<p>JMS 支持两种消息传送模型，一种是点对点（P2P）模型，一种是发布&#x2F;订阅（Pub&#x2F;Sub）模型。</p>
<p>点对点（PTP）消息模型也可称之为队列模式，特定的一条消息只能被一个消费者消费。生产者将消息发送到指定的 Queue 当中，Broker（中间件）针对消息是否需要持久化进行持久化存储后通知消费者进行处理，消费者处理完毕后发送一个回执（Acknowledge）给 Broker，Broker 认为该消息已被正常消费，于是从持久化存储中删除该条消息。回执的发送逻辑内嵌在 MQ 的 API 中，无需主动调用。消费者通常可以通过两种方式获取新消息：PUSH 和 PULL。PUSH 方式，由 MQ 收到消息后主动调用消费者的新消息通知接口，需要消耗 MQ 宝贵的线程资源，同时消费者只能被动等待消息通知；PULL 方式，由消费者轮询调用 MQ API 去获取新消息，对应于 ActiveMQ 中的 consumer.receive()，不消耗 MQ 线程，消费者更加主动，相对的消费者的处理逻辑会变得稍稍复杂。两种方式的根本区别在于线程消耗问题，由于 MQ 的线程资源相对客户端更加宝贵，PUSH 方式会占用 MQ 过多的线程从而难以适应高并发的消息场景。同时当某一消费者离线一段时间再次上线后，大量积压消息处理会消耗大量 MQ 线程从而拖累其它消费者的消息处理，所以 PULL 方式相对来说更好。Kafka 已经抛弃了 PUSH 模式，全面拥抱 PULL 模式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/9JP.png" alt="PTP"></p>
<p>发布&#x2F;订阅模式（Pub&#x2F;Sub）也可称之为主题模式，特定的一条消息可以被多个消费者所接收，只要消费者订阅了该主题。消息生产者（发布者）将消息发送到某个称为主题（Topic）的虚拟通道中，Topic 可以被多个消费者订阅，因此该模式类似于广播的方式。发布&#x2F;订阅模式采用 PUSH 的方式传送消息，Subscriber 只需保持在线即可。Subscriber 分为临时性的和持久性的，当 Sub 离线时，MQ 会为持久性的 Sub 持久化消息，当 Sub 恢复时会重新收到消息。但是既然采用 Pub&#x2F;Sub 模式就表明允许部分消费者接收不到消息，所以通常会采用临时性的 Subscriber 而不是持久性的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/Ywy.png" alt="Pub&#x2F;Sub"></p>
<h1 id="使用消息队列带来的问题"><a href="#使用消息队列带来的问题" class="headerlink" title="使用消息队列带来的问题"></a>使用消息队列带来的问题</h1><p>引入消息队列后，系统的可用性在某种程度上会下降，同时系统的复杂度也会提升。因为在引入消息队列之前，我们无需考虑消息队列挂掉的情况，但是在引入以后，我们就需要考虑这种情况，为此可能需要引入主从甚至是分布式消息队列，系统的复杂度无疑增加了很多，同时在引入了消息队列以后，我们还需要保证消息没有被重复消费和消息传递的顺序性，同时还要处理消息可能面临的丢失等问题，如果消费者没有正确消费消息，还有可能造成数据不一致的情况。</p>
<h2 id="如何确保消息不丢失"><a href="#如何确保消息不丢失" class="headerlink" title="如何确保消息不丢失"></a>如何确保消息不丢失</h2><p>消息从生产到消费经过了生产、转储和消费三个阶段，每一个阶段都有可能出现消息丢失的情况。</p>
<p>生产阶段可以通过确认机制来保证消息的可靠传递。当生产者使用客户端发送消息后，消息会被转发到 Broker，Broker 在接收到消息后会给客户端返回一个确认消息，只要生产者接收到了这个确认消息，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没有收到发送消息的确认响应时，会自动进行重试，如果再次失败则会返回异常，因此在编写代码时需要考虑异常的情况。</p>
<p>转储阶段则可以通过开启消息队列持久化，防止当意外发生，消息队列宕机重启后消息丢失。</p>
<p>消费阶段出现消息丢失一般是消息队列开启了 auto ack 选项，消费者在收到消息后还未完成处理，此时消费者服务出现意外宕机，由于开启了自动响应，Broker 会认为消息已经被成功消费，从而将消息从队列中移除，当消费者服务恢复后也就收不到该消息了。处理方式就是将自动响应改为手动响应，在消费者将消息接收并处理完毕后再向 Broker 发送确认消息，Broker 在收到确认消息后才会将消息移除。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912171721/2019/12/17/v1j.png" alt="确认机制"></p>
<h2 id="如何确保顺序消费"><a href="#如何确保顺序消费" class="headerlink" title="如何确保顺序消费"></a>如何确保顺序消费</h2><p>顺序消费是指消息从生产到消费都是按照顺序来进行的，也就是消费者处理消息的顺序与生产者投放消息的顺序是一致的。比如一笔订单先后产生了三条消息，分别是订单创建、订单付款和订单完成，消费者只有严格按照顺序消费才不会出错。由于很多分布式消息队列都存在分区的情况，所以顺序消费大体上又可以分为全局顺序消费和分区顺序消费。</p>
<p>全局顺序消费是指不管分区是否存在，消息都会严格按照顺序生产、存储和消费。在有多个分区的情况下，要实现绝对的顺序消费几乎是不可能的，因此通常能够实现严格顺序消费的简单可行的方法就是只有一个分区（或者是不存在分区），然后还要保证生产者和消费者都是单线程的，也就是说生产者、Broker 和消费者这三者是一对一对一的关系。这样做虽然简单有效，但是却带来了很严重的问题，首先就是系统并发性能严重下降，其次我们需要花费更多的精力来处理消费端出现的异常，因为全局顺序消费下，消费端的任何异常都有可能导致整个处理流程阻塞。</p>
<blockquote>
<p>实现全局顺序消费还可以使用锁来实现，但是相对较复杂。</p>
</blockquote>
<p>分区顺序消费是指消息在同一个分区中是按照顺序生产、存储和消费的。要实现分区顺序消费，首先消息需要具有一个业务 ID，然后我们可以通过算法将相关联的业务消息路由到同一个分区中，比如订单消息就可以根据订单 ID 进行哈希，然后路由到同一个分区中。接下来消费端需要实现顺序消费，最简单的方式就是单线程消费，但是同样会面临全局顺序消费需要面临的问题。</p>
<blockquote>
<p>需要说明的是，应用需要严格按照消息顺序进行消费的场景其实很少，大部分的应用都可以容忍短暂的乱序。通常来说消息队列只负责消息入队和出队的顺序性，而不会保证消息消费的顺序性。消息消费的顺序性一般需要消费端自行处理。</p>
</blockquote>
<h2 id="如何避免重复消费"><a href="#如何避免重复消费" class="headerlink" title="如何避免重复消费"></a>如何避免重复消费</h2><p>一般来说，一个主流的消息队列的设计范式是在不丢消息的前提下，尽量减少重复消息，但是不保证消息的投递顺序。但是我们使用消息队列难免会遇到如网络延迟、服务意外宕机等情况，这都有可能导致消息的重复投递，因此避免重复消费这个工作应该交给消费端来处理，总结来说就是消费端应该保证消息处理的幂等性。</p>
<p>首先为了鉴别重复消息，每个消息都应该有一个全局唯一的 ID，然后我们可以借助一些组件来完成重复的鉴定，组件可以是 Key&#x2F;Value 数据库比如 Redis，也可以是布隆过滤器，当然也可以通过数据库的唯一键来鉴别。完成了重复消息的鉴别，接下来的处理就比较简单了，可以根据业务具体来定。比如消费一条消息是向数据库中插入一条数据，那么当出现重复消息时，可以只更新数据而不进行插入。</p>
<h2 id="消息异常处理"><a href="#消息异常处理" class="headerlink" title="消息异常处理"></a>消息异常处理</h2><p>当生产者将消息正常地投递到消费者手中，如果消费者在消费的过程中发生了异常，一般都需要进行重试操作，即 Broker 会根据重试机制重新投递消息给消费者消费。有时候消费出现异常是因为消费者本身业务缺陷或故障造成的，这时就会导致 Broker 不断进行重试，这是不必要的，因此重试一般都会有一个阈值，当重试次数超过该阈值时，消息可能会被投递到死信队列中。</p>
<p>当消费者无法处理接收到的消息时，可以将这个消息重新投递到另外一个队列（也就是死信队列）中，等待后续的处理（比如人工干预）。在 RabbitMQ 中，当消息被拒绝（<code>basic.reject</code> 或 <code>basic.nack</code>）并且 <code>requeue=false</code>，消息 TTL 过期，队列达到最大长度（队列满）时，消息都会被投递到死信队列中。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/21649950">消息队列设计精要</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/52773169">新手也能看懂，消息队列其实很简单</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/KimmKing/article/details/6577021">JMS 介绍：我对 JMS 的理解和认识</a></p>
</blockquote>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 LinkedHashMap</title>
    <url>/2018/10/23/%E6%B7%B1%E5%85%A5%20LinkedHashMap/</url>
    <content><![CDATA[<p>LinkedHashMap 继承自 HashMap，在 HashMap 的基础上，通过维护一条双向链表，解决了 HashMap 遍历顺序与插入顺序不一致的问题，除此之外还对访问顺序提供了支持，这在一些场景下是很有用的，比如缓存。  </p>
<span id="more"></span>  

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/24/RlO.png" alt="LinkedHashMap"></p>
<h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><p>其实 LinkedHashMap 的节点并没有什么特别的地方，因为继承自 HashMap，节点类型继承自 HashMap 也是可以理解的。需要说明的是 HashMap 的树节点类型。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/24/WRd.png" alt="节点继承关系"></p>
<p>LinkedHashMap 在 HashMap 节点的基础上又增加了两个属性 before 和 after，通过这两个属性就可以维护一条按照插入顺序排列的双向链表。但是 HashMap 的树节点继承自 LinkedHashMap 的节点就有点奇怪了，我们在使用 HashMap 的红黑树时，并不需要树节点具有组成双向链表的能力，这样做肯定会造成空间上的浪费。在 HashMap 的源代码中这样一段注释：  </p>
<blockquote>
<p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD. And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  </p>
</blockquote>
<p>大致的意思是 TreeNode 对象的大小大约是常规 Node 对象的 2 倍，所以我们仅在桶数组中包含足够多的键值对时才使用（TREEIFY_THRESHOLD 的限制）。当桶中的键值对数量变少时（删除元素或者是扩容），TreeNode 会转换成 Node。用户在使用分布均匀的 hashCode 时，红黑树是很少使用的。  </p>
<p>通过这段注释我们可以了解到，只要 hashCode 的实现不太糟糕，Node 是很少会转换成 TreeNode 的，并且如果 TreeNode 继承自 Node，当它想具备组成双向链表的能力时，就需要 Node 去继承 LinkedHashMap.Entry，这个时候才是得不偿失的。  </p>
<h1 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h1><p>由于继承自 HashMap，因此插入的逻辑大部分是一样的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 回调方法，在要添加的键值对存在，并且新值进行了覆盖的情况下调用</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 回调方法，新节点插入后调用</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是 HashMap 创建新节点的逻辑</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是 LinkedHashMap 创建新节点的逻辑</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链接链表的最后一个节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存尾节点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    <span class="comment">// 修改尾节点为新节点</span></span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">// 如果尾节点为空则表示是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 链接新节点的上一个节点，即之前的尾节点</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        <span class="comment">// 之前的尾节点的下一个节点为当前节点</span></span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除节点后的处理方法</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HashMap 的实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 的实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 置空</span></span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果没有前置节点，则表示该节点就是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将该节点的前置节点的 after 置为该节点的后置节点</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// 如果没有后置节点，则表示该节点就是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将该节点的后置节点的 before 置为该节点的前置节点</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="访问顺序"><a href="#访问顺序" class="headerlink" title="访问顺序"></a>访问顺序</h1><p>LinkedHashMap 中维护了一个成员变量 <code>accessOrder</code>，默认值为 false，可以在调用构造方法时指定。当它为 true 时，LinkedHashMap 将会按照元素访问的顺序来维护链表；当它为 false 时，会按照元素插入（添加）顺序维护链表。按照元素访问顺序维护链表其实就是在我们调用 <code>get()</code>、<code>getOrDefault()</code> 等方法时将这些方法访问的节点移动到链表的尾部即可。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用 HashMap 的 getNode() 方法</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果为 true，移动当前访问的元素到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 当前访问的节点不是尾节点才继续执行下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">// 将当前节点的后置节点置空</span></span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点的 before 为空，表示当前节点就是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 将当前节点的前置节点的 after 置为当前节点的后置节点</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">// 当前节点的后置节点不为空，则将当前节点的后置节点的 before 置为</span></span><br><span class="line">        <span class="comment">// 当前节点的前置节点</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 存疑！</span></span><br><span class="line">            <span class="comment">// 当前节点后置节点为空，表示当前节点是尾节点</span></span><br><span class="line">            <span class="comment">// 将 last 指定为尾节点的前一个节点</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="comment">// 前置节点不为空</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将当前节点的 before 链接到尾节点的上一个节点</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            <span class="comment">// 尾节点的上一个节点的 after 链接为当前节点</span></span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将尾节点置为当前节点</span></span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历的效果如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;China&quot;</span>, <span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;India&quot;</span>, <span class="string">&quot;Delhi&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Korea&quot;</span>, <span class="string">&quot;Seoul&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Japan&quot;</span>, <span class="string">&quot;Tokyo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.get(<span class="string">&quot;China&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key=India value=Delhi</span><br><span class="line">key=Korea value=Seoul</span><br><span class="line">key=Japan value=Tokyo</span><br><span class="line">key=China value=Beijing</span><br></pre></td></tr></table></figure>

<h1 id="LRU-缓存实现"><a href="#LRU-缓存实现" class="headerlink" title="LRU 缓存实现"></a>LRU 缓存实现</h1><p>在插入元素的代码中有一段执行了一个回调方法 <code>afterNodeInsertion()</code>，实现的是在元素插入后执行的操作，该方法在 LinkedHashMap 中的实现为：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在继承 LinkedHashMap 时重写该方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>accessOrder</code> 设置为 true 时，LinkedHashMap 中的头节点就变成了最近最少使用的节点，<code>afterNodeInsertion()</code> 方法删除的就是头节点，因此可以通过继承 LinkedHashMap 来实现一个简单的 LRU 缓存。在重写 <code>removeEldestEntry()</code> 方法时，可以根据当前节点的数量来决定是否要删除最近最少使用的节点，也可以根据节点的存活时间等其他方式来决定。  </p>
<p>下面是通过继承 LinkedHashMap 实现的一个简单的 LRU 策略的缓存。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限制最大元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleCache</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(limit, <span class="number">0.75F</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java 集合框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 HashMap</title>
    <url>/2018/10/17/%E6%B7%B1%E5%85%A5%20HashMap/</url>
    <content><![CDATA[<p>在 JDK 1.8 之前，HashMap 底层使用数组 + 链表的方式实现，在 JDK 1.8 中引入了红黑树来优化链表过长的问题，底层结构就变成了数组 + 链表 + 红黑树。  </p>
<span id="more"></span>  

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/10/23/NWp.png" alt="HashMap"></p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>默认的容量为 16，必须是 2 的幂（与 HashMap 的哈希算法有关）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>容量必须是 2 的幂，同时上限为 2^30。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<p>默认的负载因子为 0.75。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>默认桶内数据结构由链表转换成树的阈值为 8（即桶内 bin 个数达到 8 个）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>默认桶内数据结构由树转换成链表的阈值为 6。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>在转换成树之前，还需要判断键值对的数量，只有数量大于 64 才会转换，数量小于 64 会执行 resize() 进行扩容。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而造成不必要的转化（因为初期完全可以靠扩容解决）。  </p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>在 HashMap 中维护着一个名称为 table 的数组，元素类型为 HashMap$Node&lt;K,V&gt;，Node&lt;K,V&gt; 是 HashMap 的静态内部类，实现了 Map&lt;K,V&gt; 接口的内部接口 Map$Entry&lt;K,V&gt;（在以前的 JDK 版本中，table 数组的元素类型为 HashMap$Entry&lt;K,V&gt;，同样实现了 Map$Entry&lt;K,V&gt; 接口）。  </p>
<p>这个数组中的每个元素的位置我们称为“桶（bucket）”，它储存链表的第一个元素或者是树的根节点。。当放入元素的 key 的 hash 值与数组中某个元素的相同，并且 key 值 equals 为 false 时，将该元素挂在这个位置的元素后面，形成类似链表的结构；如果 key 值 equals 为 true，则直接更新 value。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<p>这个 size 表示的是 HashMap 中键值对的个数（包含桶结构上的节点）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>负载因子是哈希表在其容量自动增长之前可以达到多满的一个尺度，它衡量的是一个散列表的空间使用程度，负载因子越大（最大 1）表示散列表的装填程度越高。  </p>
<p>对于使用链表的散列表来说，负载因子越大，空间利用程度越高，但是相对的冲突的可能性增大，查找的效率会降低（最坏的情况是全部冲突，退化成线性查找，时间复杂度为 O(n)）；负载因子越小，空间利用程度越低，但是冲突的可能性减小，查找的效率会提高（最好的情况是没有冲突，这样时间复杂度为 O(1)）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure>
<p>要调整容量大小的下一个阈值（通过 capacity * loadFactor 可以计算得出）。  </p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>HashMap 共有四个构造函数。  </p>
<ul>
<li>第一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用无参构造函数，会初始化负载因子为默认的 0.75。在初次放入元素时，会调用 resize() 方法，初始化容量为默认的 16，阈值为 16 * 0.75 &#x3D; 12，然后创建一个长度为 16 的 HashMap$Node&lt;K,V&gt; 数组赋给 table。  </p>
<ul>
<li>第二个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>threshold</code> 并不是使用 <code>capacity * loadFactor</code> 计算得到的，而是通过 <code>tableSizeFor()</code> 方法得到的。   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代入值，比如代入 2^29 + 1，计算得出 n + 1 的值为 2^30。所以这个方法是找到大于或者等于 capacity 的最小 2 的幂值。  </p>
<ul>
<li>第三个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用默认的负载因子大小 0.75，指定初始容量，当然这个容量会在第一次放入元素时，通过 resize() 方法赋成在构造方法中计算出的 <code>threshold</code> 的值。即不管指定的容量是多少，都会被重新计算并赋值为初始容量的最小 2 的幂值。  </p>
<ul>
<li>第四个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此构造方法使用默认的负载因子，将通过一个指定的 Map 构造出一个新的 HashMap。  </p>
<h1 id="计算元素位置"><a href="#计算元素位置" class="headerlink" title="计算元素位置"></a>计算元素位置</h1><p>我们在 HashMap 中要找到某个元素，需要先找到数组的下标，而 <code>key.hashCode()</code> 得到的是 JDK 提供的键的 hash 值，是一个 int 类型的散列值，考虑到 int 值的范围是从 - 2^31 到 2^31 - 1，这个值肯定不能直接作为数组下标使用。  </p>
<p>我们期望这个 HashMap 中的元素分布尽量均匀，最好是每个位置只有一个元素，这样我们通过算法得到的索引位置的元素一定就是我们要找的元素，而不需要再去查找链表或者树。  </p>
<p>我们首先想到的就是将 hash 值对数组长度取模，这样元素的分布相对来说比较均匀，但是取模运算的消耗较大，所以 JDK 中采用如下方式：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源码是 JDK 1.6 中的，但是在 JDK 1.8 中还是采用的这种方式。因为 HashMap 保证数组的长度一定是 2 的幂，这种情况下数组的长度减一正好相当于一个<strong>低位掩码</strong>，与操作的结果就是散列值的高位全部归零，只保留低位值作为数组的下标。比如当数组长度为 16 时，和某个散列值进行与运算：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    11010101 11010011 01011010 00101101</span><br><span class="line">&amp;   00000000 00000000 00000000 00001111</span><br><span class="line">---------------------------------------</span><br><span class="line">    00000000 00000000 00000000 00001101</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实当数组长度为 2 的幂时，<code>h % length</code> 与 <code>h &amp; (length - 1)</code> 等价。  </p>
</blockquote>
<p>但是如果我们只使用到了散列值的最后几位的话，即使散列值再松散，碰撞也会很严重，这个时候就需要使用<strong>扰动函数</strong>了。JDK 1.8 中的扰动函数如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如下面这个例子：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h               11010101 11010011 01011010 00101101</span><br><span class="line">h &gt;&gt;&gt; 16        00000000 00000000 11010101 11010011</span><br><span class="line">h ^ (h &gt;&gt;&gt; 16)  11000101 11010011 10001111 11111110</span><br></pre></td></tr></table></figure>

<p>由于 int 类型长度为 32 位，所以右移 16 位，正好是 32 位的一半，高位与低位进行异或运算，目的是<strong>为了混合原始哈希值的高位和低位，以此来加大低位的随机性</strong>。混合后的低位混合了部分高位的特征，这样高位的信息也就被变相的保留了下来。  </p>
<p>同时，如果重写了 key 的 hashCode() 方法，可能会因为写法不合理造成 hashCode 分布不均匀导致哈希冲突比较严重，通过移位异或运算，可以让 hash 值变得更加复杂，进而影响 hash 值的分布性。  </p>
<h1 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 计算索引位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 hash 值相同，并且两个键的内存地址相同或者是两个键 equals 为 true，</span></span><br><span class="line">        <span class="comment">// 则表示找到了该 key</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 否则，查找它是否有下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是树节点，则使用获取树节点的方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表，直到找到该 key</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组没有初始化，则通过 resize() 方法进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算键值对将要放入的位置，如果该位置没有其他节点则通过</span></span><br><span class="line">    <span class="comment">// newNode() 方法创建节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 如果该位置上有其他节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 hash 值相同，并且是同一个键对象或者两个键 equals 为 true</span></span><br><span class="line">        <span class="comment">// 表示当前 HashMap 已经存在要插入的键值对</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该位置上是树形节点，则调用树形节点的插入方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用循环统计桶结构上节点的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果该位置的下一个节点为空，则将要插入的元素放在该节点的后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 当桶结构上的节点数量超过链表转树的阈值时，进行转换</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果下一个节点不为空，hash 值相同并且是同一个键对象或者两个键</span></span><br><span class="line">                <span class="comment">// equals 为 true，表示当前的 HashMap 中存在要插入的键值对</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e 不为空表示 HashMap 中已经存在要插入的键值对</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent 表示仅在 oldValue 为空的时候才更新键值对的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 键值对的数量超过阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入元素主要逻辑包括以下几点：  </p>
<ol>
<li>当数组为空时，使用 resize() 方法扩容来初始化数组。  </li>
<li>查找需要插入的键值对是否已经存在，如果存在，则需要根据 onlyIfAbsent 来决定是否要覆盖值。  </li>
<li>如果不存在，并且不存在冲突，则直接放入元素；如果存在冲突则将键值对链接到链表上，同时当链表长度超过阈值时会转换成红黑树。  </li>
<li>判断键值对的数量，大于阈值会进行扩容。</li>
</ol>
<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 数组不为空并且该位置上有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// key 匹配</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取树节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                            (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果是树节点，则调用删除树节点的方法</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 数组元素置为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 链表删除节点，直接指向下一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧的容量大于等于最大容量时，修改阈值为 Integer 的最大值，</span></span><br><span class="line">        <span class="comment">// 同时不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧容量扩容为原来的 2 倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 阈值同样扩容为原来的 2 倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将旧的阈值指定为新的容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 调用无参构造时初始化的容量和阈值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按阈值计算公式计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 直接创建新容量的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 数组元素不为空，则进行元素 rehash</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 该位置元素没有下一个节点，则直接计算</span></span><br><span class="line">                <span class="comment">// 该元素在新数组中的位置</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是树，则需要对树进行拆分</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 下一个节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 如果 hash &amp; oldCap 为 0</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果尾节点为空，即链表为空，则</span></span><br><span class="line">                            <span class="comment">// 将节点赋给头节点和尾节点</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="comment">// 如果还有 hash &amp; oldCap 为 0 的</span></span><br><span class="line">                            <span class="comment">// 节点，则继续向后链入</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果 hash &amp; oldCap 不为 0，则</span></span><br><span class="line">                        <span class="comment">// 类似的将节点链入另一个链表 hiHead</span></span><br><span class="line">                        <span class="comment">// 和 hiTail 中</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将尾部置空</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 将头部指向新数组的该位置</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 将头部指向新数组的另一个位置</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容主要做了以下工作：  </p>
<ol>
<li>计算新数组的容量和阈值。  </li>
<li>根据新的容量直接创建一个新的数组。  </li>
<li>将键值对重新映射到新数组中。如果是树节点，则需要拆分红黑树；如果是普通节点，则直接 rehash 进行映射；如果是链表，则不需要重新进行多次的 rehash，而是将链表根据 hash &amp; oldCap 进行分组，并将分组后的两个链表分别链入新的数组中。</li>
</ol>
<p>这里需要重点分析的就是链表的分组。如果旧数组上存在链表，那么有可能是键的 hash 值相同导致计算后的数组下标相同，也有可能是 hash 值不同但是计算后的数组下标相同。一般的做法是遍历链表，然后一个个 rehash 计算它们在新数组的位置，在 JDK 1.7 中确实是这样做的。但是在 JDK 1.8 中则优化了这种做法，采用的就是根据 <code>hash &amp; oldCap == 0</code> 来对链表节点进行分组，下面举个例子来说明。  </p>
<p>假如初始容量为 16，数组上存在链表 5 -&gt; 21 -&gt; 37 -&gt; 53。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5       0000 0101</span><br><span class="line">21      0001 0101</span><br><span class="line">37      0010 0101</span><br><span class="line">53      0011 0101</span><br><span class="line">&amp;</span><br><span class="line">16-1    0000 1111</span><br></pre></td></tr></table></figure>

<p>可以看到，它们与容量减一进行与运算的结果都是 0101。当容量扩容为 32 时，此时原链表上的节点再进行与运算就会出现不同的索引值。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5       0000 0101</span><br><span class="line">21      0001 0101</span><br><span class="line">37      0010 0101</span><br><span class="line">53      0011 0101</span><br><span class="line">&amp;</span><br><span class="line">32-1    0001 1111</span><br></pre></td></tr></table></figure>

<p>但是其实并不需要重新计算每个节点的索引值，只需要判断因为扩容导致左侧多出的那一位的值。如果是 1，则需要将节点链接到 newTab[j + oldCap] 上；如果是 0，则原地不动。这也就是为什么使用 <code>hash &amp; oldCap == 0</code> 作为分组判断条件的原因。  </p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>如果仔细阅读源码，你会发现 HashMap 的桶数组 table 被修饰成了 <code>transient</code> 的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，被该关键字修饰的变量不会被默认的序列化机制序列化，但是我们肯定需要用到 HashMap 的序列化功能，那该怎么办呢？其实 HashMap 自己实现了自定义的序列化功能，即实现了 <code>readObject()</code> 和 <code>writeObject()</code> 这两个方法。为什么 HashMap 不使用默认的序列化机制，而是选择自定义实现呢？这其实主要有两方面的原因：  </p>
<p>其中一个原因是 table 在多数情况下是无法被存满的，序列化未使用的部分会造成空间的浪费。另一个原因是同一个键值对在不同的 JVM 下所处的桶位置可能不一样，这可能会造成不同的 JVM 反序列化时出错。因为如果没有重写键的 hashCode() 方法，则会使用 Object 的 hashCode() 方法，它是一个本地方法，不同的 JVM 下可能会有不同的实现，产生的哈希值也就可能不一样。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/28562088">知乎：关于hashMap的一些按位与计算的问题？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 集合框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 TLS</title>
    <url>/2023/03/30/%E6%B7%B1%E5%85%A5%20TLS/</url>
    <content><![CDATA[<p>一直以来对于 TLS 的运行机制一知半解，平常的工作和生活中也只是使用它，很少有机会深入了解它。最近 ChatGPT 大火，在体验了一段时间之后，反而意外地想静下心来学习和整理一番。</p>
<span id="more"></span>

<h1 id="HTTP-为什么不安全"><a href="#HTTP-为什么不安全" class="headerlink" title="HTTP 为什么不安全"></a>HTTP 为什么不安全</h1><p>由于 HTTP 采用明文传输，明文数据经过中间代理服务器、路由器、运营商等多个网络节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者可以<strong>窃听</strong>、<strong>篡改</strong>传输的内容，甚至<strong>冒充</strong>通信双方的身份且不被双方察觉，也就是所谓的中间人攻击（MITM）。</p>
<h1 id="使用对称加密"><a href="#使用对称加密" class="headerlink" title="使用对称加密"></a>使用对称加密</h1><p>既然传输内容是明文的，那我们很容易就能想到对传输内容进行加密。对称加密速度快，性能好，如果通信双方都知道对称加密的密钥，且没有任何第三方知道，那么通信当然是安全的。但是如何让通信的双方都知道该密钥呢？浏览器预存所有网站的密钥？这不现实。服务器通过网络传输密钥给浏览器？如果传输过程中被第三方劫持获取到了该密钥，那么之后双方所有的通信内容都能被解密。</p>
<h1 id="使用非对称加密"><a href="#使用非对称加密" class="headerlink" title="使用非对称加密"></a>使用非对称加密</h1><p>既然对称加密行不通，那么非对称加密呢？由于非对称加密的机制，我们可能会有以下思路：服务器明文传输公钥给浏览器，之后浏览器向服务器传输数据之前都会先用该公钥加密后再传输，只有服务器的私钥能解密该数据。但是反过来，服务器向浏览器传输数据，只能用私钥加密数据，浏览器可以用公钥解密，然而该公钥是服务器一开始通过明文传输给浏览器的，中间人一样可以获取到该公钥来解密服务器传输的数据。这个方案似乎只能保证浏览器向服务器传输数据的安全性（其实仍有问题）。</p>
<h1 id="改良非对称加密"><a href="#改良非对称加密" class="headerlink" title="改良非对称加密"></a>改良非对称加密</h1><p>基于以上方案，我们很快就能发现既然一对公私钥只能保证一侧的安全，那么我们使用两对公私钥，不就能保证双方通信的安全了吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器持有公钥 A 和私钥 A，浏览器持有公钥 B 和私钥 B</span><br><span class="line">双方通过明文传输各自的公钥</span><br><span class="line">之后浏览器向服务器传输数据都用公钥 A 加密，服务器使用私钥 A 解密</span><br><span class="line">同理服务器向浏览器传输数据都用公钥 B 加密，浏览器使用私钥 B 解密</span><br></pre></td></tr></table></figure>

<p>表面上看，这个方案似乎没有问题，但是 HTTPS 并没有采用这种方案，一个原因是因为非对称加密非常耗时，当然另一个原因是该方案有漏洞，这个一会儿再说，我们先来看看应该如何优化该方案。</p>
<h1 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密+对称加密"></a>非对称加密+对称加密</h1><p>既然非对称加密与对称加密相比性能较差，那么我们是否可以将两者结合起来呢？答案是可以！在密钥交换阶段，我们可以使用非对称加密保护通信时使用的对称加密密钥，在数据交换阶段使用对称加密保护传输的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器有一对公钥 A 和私钥 A</span><br><span class="line">服务器通过明文传输公钥 A 给浏览器</span><br><span class="line">浏览器随机生成一个用于对称加密的密钥 X，使用公钥 A 加密后传给服务器</span><br><span class="line">服务器通过私钥 A 解密得到对称加密的密钥 X</span><br><span class="line">这样双方都持有密钥 X，且第三方不知道，接下来所有的数据传输都可以使用该密钥加密和解密</span><br></pre></td></tr></table></figure>

<h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>我们刚才提到使用两对公私钥以及后续的优化方案都存在漏洞，这个漏洞就是存在中间人攻击。以优化的方案为例，我们来模拟中间人的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器有一对公钥 A 和私钥 A</span><br><span class="line">服务器通过明文传输公钥 A 给浏览器</span><br><span class="line">中间人劫持到了公钥 A，保存下来，并把数据包中的公钥 A 替换成自己伪造的公钥 B（它自然有对应的私钥 B）</span><br><span class="line">浏览器随机生成一个用于对称加密的密钥 X，使用公钥 B（浏览器不知道公钥被替换了）加密后传输给服务器</span><br><span class="line">中间人劫持后用私钥 B 解密得到密钥 X，再用公钥 A 加密后传给服务器</span><br><span class="line">服务器使用私钥 A 解密得到密钥 X</span><br></pre></td></tr></table></figure>

<p>这样在双方都没有发现的情况下，中间人已经获取到了双方用于通信加密的密钥 X。究其根本，是因为<strong>浏览器无法确认它接收到的公钥是不是服务器自己的</strong>。我们总不能再对公钥进行加密吧，那么又得进行密钥交换，重复之前的步骤并且永远没有尽头。</p>
<h1 id="如何保证公钥可信"><a href="#如何保证公钥可信" class="headerlink" title="如何保证公钥可信"></a>如何保证公钥可信</h1><p>很多时候证明的源头都是一条条不证自明的“公理”。现实生活中，员工入职时需要向企业提供学历证明，这个学历证明必须是由教育部颁发的学历证书。在这里，学历证书由教育部做担保，“公理”也就是“教育部可信”。</p>
<p>互联网世界也有一个类似的“公理”存在，那就是 CA 机构（Certificate Authority），CA 机构颁发的证书叫数字证书。网站在使用 HTTPS 之前，需要向 CA 机构申请一个数字证书，数字证书中包含证书持有者和颁发者的相关信息（组织、DNS 主机名、公钥等），服务器把证书传输给浏览器，浏览器从证书中获取网站的公钥。</p>
<p>由于证书也是通过网络传输的，那么如何确保证书的真实性，防止证书被篡改呢？答案是使用<strong>数字签名</strong>。CA 机构在颁发证书时，会使用某种散列函数（比如 MD5、SHA-1 等）计算公开的明文信息的信息摘要，然后使用 CA 的私钥对信息摘要进行加密，形成的密文即数字签名，最后将证书中的明文信息和数字签名一起组成数字证书。</p>
<blockquote>
<p>为什么要先生成摘要再加密，而不是直接加密呢？因为非对称加密对于加密的内容长度有限制（与公钥长度有关），同时非对称加密还比较耗时，采用直接加密会导致客户端验签时同样耗时，而采用摘要算法可以将明文内容压缩到很短的固定长度字符串，客户端验签时会快很多。当然还有一方面是出于安全考虑，这里比较复杂，可以参考：<a href="https://crypto.stackexchange.com/questions/12768/why-hash-the-message-before-signing-it-with-rsa/">Why hash the message before signing it with RSA?</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器拿到数字证书之后，得到证书明文的 T 和数字签名 S</span><br><span class="line">使用 CA 机构的公钥解密数字签名得到信息摘要 S&#x27;，使用证书中指明的摘要算法对明文 T 进行 hash 得到 T&#x27;</span><br><span class="line">接下来只要对比 S&#x27; 和 T&#x27; 是否一致即可，如果不一致则代表明文 T 或者数字签名 S 被篡改</span><br></pre></td></tr></table></figure>

<p>上面提到浏览器使用 CA 机构的公钥来解密数字签名，那么浏览器是怎么得到这个公钥的呢？换句话说，如何确保 CA 机构的公钥是可信的呢？我们回想一下数字证书是用来解决什么问题的？没错，为了证明某个公钥可信，即该公钥对应该网站，那么 CA 机构的公钥理所应当的也可以使用数字证书来证明。一般的，操作系统、浏览器都会预装一些他们信任的根证书，其中会有 CA 机构的根证书，这样客户端就可以拿到 CA 机构的公钥了。</p>
<p>我们提到的 CA 机构的根证书，是根证书机构（Root CA）颁发的公钥证书，它是互联网安全中信任链的起点，由于根证书没有上层机构为其签名，所以根证书都是自签证书，即使用者和颁发者都是它自己。实际上，证书之间的认证也不止一层，如果 A 信任 B，B 信任 C，那么这里的 B 就作为中间证书颁发机构。这一连串的数字证书，以根证书为起点，通过层层信任，使得数字证书的持有者可以获得转授的信任来证明其身份。</p>
<blockquote>
<p>增加中间证书有哪些好处？首先能够减少根证书机构的管理工作，提高证书审核和签发的效率。其次根证书一般内置，私钥一般离线存储，一旦私钥泄漏，吊销过程会比较困难，可能无法及时补救，而中间证书的私钥泄漏，则可以快速在线吊销并重新生成。</p>
</blockquote>
<p>现在我们已经能够保证证书内容不被篡改了，那么证书有没有可能被第三方掉包呢？因为实际上任何站点都可以向 CA 申请证书，中间人可以在客户端获取证书时劫持，返回自己向 CA 机构申请的有效的数字证书。针对这种情况，应对方法也很简单，只需要客户端在验签的同时，再验证一下证书上的域名与自己请求的域名是否一致即可。</p>
<h1 id="完整的握手过程"><a href="#完整的握手过程" class="headerlink" title="完整的握手过程"></a>完整的握手过程</h1><p>根据配置和协商的结果，握手过程会有许多变种，常见的有：只对服务端进行身份验证的握手；恢复之前会话采用的简短握手；对客户端和服务端都进行验证的握手等。下面是 <a href="https://www.rfc-editor.org/rfc/rfc5246">RFC 5246</a> 中 TLS（TLS 1.2）握手的全过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+                                        +--------+</span><br><span class="line">|        |    1. ClientHello                      |        |</span><br><span class="line">|        | -------------------------------------&gt; |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">|        |    2. ServerHello                      |        |</span><br><span class="line">|        |    3. Certificate (optional)           |        |</span><br><span class="line">|        |    4. ServerKeyExchange (optional)     |        |</span><br><span class="line">|        |    5. CertificateRequest (optional)    |        |</span><br><span class="line">|        |    6. ServerHelloDone                  |        |</span><br><span class="line">|        | &lt;------------------------------------- |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">| Client |    7. Certificate (optional)           | Server |</span><br><span class="line">|        |    8. ClientKeyExchange                |        |</span><br><span class="line">|        |    9. CertificateVerify (optional)     |        |</span><br><span class="line">|        |   10. [ChangeCipherSpec]               |        |</span><br><span class="line">|        |   11. Finished                         |        |</span><br><span class="line">|        | -------------------------------------&gt; |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">|        |   12. [ChangeCipherSpec]               |        |</span><br><span class="line">|        |   13. Finished                         |        |</span><br><span class="line">|        | &lt;------------------------------------- |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">+--------+                                        +--------+</span><br></pre></td></tr></table></figure>

<h2 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h2><p>首先客户端发送 ClientHello 消息，其中包含一个随机数（Client Random）、客户端支持的加密算法列表和压缩算法列表、最高支持的 TLS 协议版本、扩展字段等信息。扩展字段包含一些额外的辅助信息，比如最常见的 SNI。</p>
<p>客户端支持的加密算法更正式的叫法为密码套件（cipher suites），在 TLS 1.3 以前，一个密码套件包含非对称加密算法、对称加密算法以及信息摘要算法。非对称加密算法用来协商共享密钥，对称加密算法用来批量加密通信数据，摘要算法用来进行数据的完整性校验。</p>
<p>比如这样一个密码套件：TLS_RSA_WITH_AES_128_CBC_SHA，这个套件比较特殊的是，RSA 作为非对称加密算法，在密钥交换过程中使用，在通信的过程中需要签名的地方也会使用，同时也表示证书的公钥采用的也是该算法。AES_128_CBC 是对称加密算法，其密钥由 RSA 协商后计算产生。SHA 是信息摘要算法，表示后面证书里的签名用的就是该算法，同时后续通信需要数据校验时也会采用该算法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">你好，咱俩建立连接呗</span><br><span class="line">我这边最高支持 TLS 1.1</span><br><span class="line">支持的密码套件有 TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_256_CBC_SHA256 等等</span><br><span class="line">支持的压缩算法 DEFLATE</span><br><span class="line">随机数为 8c9006c661dbf0b3dc989c5e72124bc3ae2fa1d7c94a22f820f3c920264419d7</span><br></pre></td></tr></table></figure>

<h2 id="ServerHello"><a href="#ServerHello" class="headerlink" title="ServerHello"></a>ServerHello</h2><p>接下来服务端返回协商的结果，即发送 ServerHello 消息，其中包含一个随机数（Server Random）、要使用的加密算法和压缩算法、要使用的 TLS 协议版本等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">你好，没有问题啊</span><br><span class="line">我们使用 TLS 1.1 吧</span><br><span class="line">算法采用 TLS_RSA_WITH_AES_256_CBC_SHA256</span><br><span class="line">压缩算法不支持就不要了</span><br><span class="line">随机数为 73078baa0251a216a7e1489f685da66212ff2649734e3da7a8f8e0414d3fd722</span><br></pre></td></tr></table></figure>

<h2 id="Certificate-optional"><a href="#Certificate-optional" class="headerlink" title="Certificate (optional)"></a>Certificate (optional)</h2><p>该消息包含服务端的证书链，是可选的，服务端会根据加密算法的选择来决定是否发送，比如 DH_ANON 算法就不会发送该消息，当然这是不安全也是不推荐的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">这是我的证书，你验证一下吧</span><br></pre></td></tr></table></figure>

<h2 id="ServerKeyExchange-optional"><a href="#ServerKeyExchange-optional" class="headerlink" title="ServerKeyExchange (optional)"></a>ServerKeyExchange (optional)</h2><p>该消息也是可选的，服务端会根据加密算法的选择来决定，比如 RSA 算法就不需要发送该消息，客户端直接生成一个 Pre-master 就可以了，但是基于 DH 的算法就需要发送特殊的参数给客户端，以便它生成 Pre-master。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202304092054/2023/04/05/q4j.png" alt="ServerKeyExchange"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">这是生成 pre-master 所需要的一些参数，请查收</span><br></pre></td></tr></table></figure>
<h2 id="CertificateRequest-optional"><a href="#CertificateRequest-optional" class="headerlink" title="CertificateRequest (optional)"></a>CertificateRequest (optional)</h2><p>该消息也是可选的，在需要验证客户端身份时才会发送，以此来告诉客户端提供它的证书来证明身份。一般我们使用的都是单向身份认证，即只有服务端认证是不需要发送该消息的。需要双向认证的场景：比如访问银行网站进行交易时，此时证书由 U 盾提供。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">把你的证书发给我看看吧，我要确认一下你是不是 XXX</span><br></pre></td></tr></table></figure>

<h2 id="ServerHelloDone"><a href="#ServerHelloDone" class="headerlink" title="ServerHelloDone"></a>ServerHelloDone</h2><p>最后是 ServerHelloDone 消息，告诉客户端所有消息都已经发送完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">我要告诉你的就这些了，处理完给我发消息吧</span><br></pre></td></tr></table></figure>

<h2 id="Certificate-optional-1"><a href="#Certificate-optional-1" class="headerlink" title="Certificate (optional)"></a>Certificate (optional)</h2><p>如果客户端在前面收到了服务端的 CertificateRequest 消息，那么在这里客户端会发送自己的证书给服务端，即使没有证书，也会告诉服务端，由服务端来决定是否继续。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">这是我的证书，请查收</span><br></pre></td></tr></table></figure>

<h2 id="ClientKeyExchange"><a href="#ClientKeyExchange" class="headerlink" title="ClientKeyExchange"></a>ClientKeyExchange</h2><p>客户端在收到服务端的证书后，会进行证书校验。包括验证证书链的可信性，检查证书是否吊销（CRL 离线验证、OSCP 在线验证等），检查证书有效期以及证书域名与当前访问域名是否一致。接着，客户端会计算产生 Pre-master 随机数（或者产生 DH 算法的客户端参数），使用服务端的证书公钥加密后发送给服务端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202304092054/2023/04/05/4vV.png" alt="ClientKeyExchange"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">这是计算真正密钥要用到的 pre-master，我使用你证书里的公钥加密了</span><br></pre></td></tr></table></figure>

<h2 id="CertificateVerify-optional"><a href="#CertificateVerify-optional" class="headerlink" title="CertificateVerify (optional)"></a>CertificateVerify (optional)</h2><p>如果客户端给服务端发送了证书，那么就需要发送该消息来告诉服务端证书的私钥确实在该客户端手里。该消息是将迄今为止所有的握手数据（从 ClientHello 开始，不包括本条消息）经过指定的摘要算法压缩后再通过客户端私钥加密后得到的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">这是一段我用私钥加密后的数据，你可以用我证书里的公钥解密后查看</span><br><span class="line">如果解密后的数据与你使用已有握手数据计算摘要后的数据一致，则证明我没有骗你</span><br></pre></td></tr></table></figure>

<h2 id="Finished-Encrypted-Handshake-Message"><a href="#Finished-Encrypted-Handshake-Message" class="headerlink" title="Finished (Encrypted Handshake Message)"></a>Finished (Encrypted Handshake Message)</h2><p>接下来客户端和服务端就能够根据已有的数据计算对称加密需要的密钥了，这是 <a href="https://www.rfc-editor.org/rfc/rfc5246">RFC 5246</a> 给出的计算主密钥的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;,</span><br><span class="line">                          ClientHello.random + ServerHello.random)</span><br><span class="line">                          [0..47];</span><br></pre></td></tr></table></figure>

<p>然后双方将自己缓存的所有握手数据通过摘要算法计算后，再用刚刚算出来的主密钥加密后发送给对方。这样做有两个目的：一个是保证双方算出来的主密钥是一致的；另一个是确保双方通信过程中的每一步都没有其他人篡改，因为握手的前半部分都是明文的，存在被篡改的风险，只要双方根据各自缓存的握手数据算出来的校验数据一致，就说明中间没有被篡改过。验证数据的计算方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verify_data = PRF(master_secret, finished_label, Hash(handshake_messages))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client -&gt; server 这是我们之前握手数据的摘要，用主密钥加密了，你看看能不能解开，并比较一下摘要</span><br><span class="line">server -&gt; client 这是我们之前握手数据的摘要，用主密钥加密了，你看看能不能解开，也比较一下摘要</span><br></pre></td></tr></table></figure>

<p>如果双方发送完 Finished 消息而对方都没有报错，握手就完成了，后续所有数据的传输都会使用这个密钥进行加密。在上面的握手过程中，如果任何一方觉得有问题，都可能随时终止握手过程。</p>
<h1 id="解密-HTTPS-流量"><a href="#解密-HTTPS-流量" class="headerlink" title="解密 HTTPS 流量"></a>解密 HTTPS 流量</h1><p>我们知道，一些常见的 HTTP&#x2F;HTTPS 抓包工具（比如 <a href="https://www.telerik.com/fiddler">Fiddler</a>、<a href="https://www.charlesproxy.com/">Charles</a>、<a href="https://github.com/avwo/whistle/">whistle</a>），都是通过创建本地代理服务，再修改浏览器的代理设置来达到流量拦截的目的的，他们的工作原理与中间人攻击一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server &lt;---&gt; Local Proxy &lt;---&gt; Browser</span><br></pre></td></tr></table></figure>

<p>在服务端与中间人之间，中间人冒充客户端，由于任何客户端都可以与服务端建立连接，所以这部分一般没有问题。而对于客户端与中间人之间，中间人想要冒充服务端，就必须拿到对应域名的证书私钥，中间人可以通过这几种手段获取或替换私钥：入侵网站服务器，从 CA 处重签发该域名的证书，以及自己签发证书。</p>
<p>为了防范以上风险，我们要对服务器和网站做好安全防护，避免网站私钥被盗。同时保证域名解析安全，避免攻击者获取到域名管理的相关权限从而重签证书。对于攻击者自签发的证书，由于系统和浏览器内置有根证书校验，因此我们只需要注意不要随便信任第三方的证书，不向浏览器和系统中导入不明证书。</p>
<p>对于 Fiddler 这类工具来说，能够解密 HTTPS 流量的关键在于他们会往系统受信任的根证书列表中导入自己的证书，这样他们自签发的证书就能被浏览器所信任。在设置好相关配置之后，Fiddler 会在浏览器中设置对应的代理地址，接下来浏览器在浏览 HTTPS 的网站时，Fiddler 会根据网站自动生成站点的数字证书。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202303311750/2023/03/31/yvK.png" alt="Fiddler"></p>
<p>由于该证书是由 Fiddler 生成的，所以它肯定知道该证书的私钥，通过这种方式，Fiddler 完成了证书的掉包（证书域名与客户端请求的域名一致）。整个过程相当于 Fiddler 分别与客户端和服务端通过 TLS 握手建立了连接，具体类似下面的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端向服务端发送握手请求，Fiddler 拦截后伪装成客户端向服务端发送 TLS 握手请求</span><br><span class="line">Fiddler 收到服务端的响应后，使用根证书公钥验签并拿到证书公钥，然后用自己伪造的证书传递给客户端</span><br><span class="line">客户端进行同样的验签操作，然后生成第三个随机数 pre-master，使用 Fiddler 的证书公钥加密传输给服务端</span><br><span class="line">Fiddler 拦截客户端的请求，使用自己的私钥解密 pre-master，此时 Fiddler 已经可以通过三个随机数生成对称加密的密钥</span><br><span class="line">接下来客户端与服务端之间通过对称加密发送的消息都可以被 Fiddler 解密</span><br></pre></td></tr></table></figure>

<p>而像 Wireshark 这类工具的抓包原理则是直接读取并分析网卡的数据，要想让它解密 HTTPS 流量，有两种方法：一种是知道网站的证书私钥，在工具中配置该私钥来解密；另一种需要浏览器支持，一些浏览器可以将 TLS 会话中使用的对称加密密钥保存到外部文件中，然后在 Wireshark 的 TLS 配置面板中配置 <code>(Pre)-Master-Secret log filename</code> 选项即可。</p>
<h1 id="前向安全性（Forward-Secrecy）"><a href="#前向安全性（Forward-Secrecy）" class="headerlink" title="前向安全性（Forward Secrecy）"></a>前向安全性（Forward Secrecy）</h1><p>我们知道，TLS 握手阶段需要进行密钥交换、证书验证、身份验证等几个重要步骤。密钥交换是为了在一个不安全的数据通道中产生一个只有通信双方知道的共享密钥（pre-master），进而产生后续对称加密的密钥。客户端进行证书验证的目的是为了确保证书公钥是可信的。而进行身份验证的目的是为了确保握手消息没有被篡改。</p>
<p>在以前，RSA 密钥交换（TLS_RSA 系列的密码套件）是比较常见的密钥交换方式，浏览器使用证书提供的 RSA 公钥加密相关信息，如果服务端能够解密，意味着服务端拥有与公钥对应的私钥，同时服务端也能解密所需的共享密钥，即密钥交换与服务端身份验证合并在了一起。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202304092054/2023/04/04/pPr.png" alt="RSA 密钥交换"></p>
<p>由于 Client Random 和 Server Random 明文传输，中间人可以直接查看。客户端生成的 Pre-master 用服务端证书公钥加密后传输，中间人如果获取到了私钥，一样可以解密得到 Pre-master，通过这三个随机数，中间人就可以计算出双方最终通信使用的对称加密密钥。这也是为什么 Wireshark 可以通过配置私钥来解密 HTTPS 数据。</p>
<p>所以说 RSA 这种密钥交换方式不具备前向安全性，即攻击者可以把监听到的加密数据先存起来，一旦后续拿到了证书私钥，之前所有的数据都可以成功解密。常见的前向安全的密码套件有 ECDHE_RSA、ECDHE_ECDSA 等，其中 ECDHE 为密钥交换算法，RSA 或者 ECDSA 为数字签名算法。</p>
<blockquote>
<p>内置 ECDSA 公钥的证书一般称为 ECC 证书，内置 RSA 公钥的证书就是 RSA 证书。因为 256 位 ECC Key 在安全性上等同于 3072 位 RSA Key，所以 ECC 证书体积比 RSA 证书小，而且 ECC 运算速度更快，ECDHE 密钥交换 + ECDSA 数字签名是目前最好的密码套件。</p>
</blockquote>
<p>ECDHE 密钥交换与 RSA 密钥交换最大的区别是，ECDHE 在握手过程中需要发送 ServerKeyExchange 消息，而 RSA 不用。那么为什么 ECDHE 算法具有前向安全性呢，这就要讲到它的数学原理了。</p>
<h2 id="DH-算法"><a href="#DH-算法" class="headerlink" title="DH 算法"></a>DH 算法</h2><p>对于公式 $A &#x3D; G^a\pmod P$，G 为底数，P 为模数，a 为对数，A 为真数。当已知 a 时，可以计算出 A；但是已知 A 时，却几乎无法计算出 a。</p>
<p>与此同时，给出公式 $B &#x3D; G^b\pmod P$，根据幂模运算的一个基本属性，即 $(G^a)^b\pmod P &#x3D; (G^b)^a\pmod P$，有</p>
<p>$K &#x3D; A^b\pmod P &#x3D; (G^a)^b\pmod P &#x3D; (G^b)^a\pmod P &#x3D; B^a\pmod P$</p>
<p>在实际应用中，服务端与客户端协商出要使用的大素数 P 及其原根 G，它俩是公开的参数。然后服务端生成私钥 a，经过幂模运算得到公钥 A。客户端生成私钥 b，经过幂模运算得到公钥 B。服务端将自己计算得出的公钥 A 传递给客户端，为了防止篡改，加上签名参数。客户端将自己计算得出的公钥 B 使用服务端的证书公钥加密后传递给服务端。此时客户端拥有参数 A、b、G、P，服务端拥有参数 B、a、G、P，它俩都可以计算得出共享密钥 K。如果中间人拦截到了公开的参数和公钥 A 和加密后的公钥 B，甚至中间人已经拿到了服务端的证书私钥，也就是说中间人获取到了 A、B、G、P 这几个参数，但是因为没有私钥 a 和 b，一样计算不出最终的共享密钥 K，也就无法破解历史的数据。</p>
<h2 id="DHE-算法"><a href="#DHE-算法" class="headerlink" title="DHE 算法"></a>DHE 算法</h2><p>根据私钥生成的方式，DH 算法分为 static DH 算法和 DHE（Ephemeral）算法。static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥每次都是一样的，一般是服务器方固定，客户端的私钥则是随机生成的。那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商过程中，有些数据是公开的，黑客可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 static DH 算法不具备前向安全性。</p>
<h2 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h2><p>DHE 算法由于性能不佳，所以 ECDHE 算法在 DHE 算法的基础上引入了 ECC 椭圆曲线特性，可以使用更少的计算量算出公钥，以及最终的共享密钥。</p>
<p>椭圆曲线（Elliptic Curve）针对密码学进行了简化，公式为：$y^2 &#x3D; x^3 + ax + b$，例如对于椭圆曲线 <code>secp256k1</code>，<a href="https://www.secg.org/">SECG</a> 组织给出了推荐的参数：<code>a = 0, b = 7</code>，即该椭圆曲线的公式为：$y^2 &#x3D; x^3 + 7$。</p>
<p>在椭圆曲线加密（Elliptic Curve Cryptography, ECC）中，则使用了某种特殊形式的椭圆曲线，即定义在有限域上的椭圆曲线。针对具体的椭圆曲线，存在着一个确定的点 G（基点），乘以一个确定的整数 K（私钥），得到椭圆曲线的公钥 P，即 $P &#x3D; KG$。已知 K 和 G，算出公钥很容易，而已知 G 和 P，算出私钥 K 在目前则几乎不可能。</p>
<p>在实际应用中，服务端会在 ServerKeyExchange 消息中包含一个名为 <code>Named Curve</code> 的参数，它的值就是选定的椭圆曲线，指定了椭圆曲线实际上也就确定了基点的值（SECG 推荐的）。服务端随机生成私钥 Ks 并算出对应的公钥 Ps，客户端随机生成私钥 Kc 并算出公钥 Pc。由于椭圆曲线满足乘法交换律和结合律，所以 $KsPc &#x3D; KsKcG &#x3D; KcKsG &#x3D; KcPs$。也就是说，服务端和客户端只需要知道对方的椭圆曲线公钥，即可通过各自的私钥算出最终的共享密钥。</p>
<p>通过上面的推算过程也能够看出，在密钥交换阶段如果只使用 DH 系列的算法，中间人可以通过伪造双方的 DH 公钥参数来实施 MITM 攻击，因此使用 DH 算法进行密钥交换时，服务端发送的 DH 公钥参数需要加上数字签名，而客户端发送的 DH 公钥参数则可以使用服务端证书公钥加密后发送。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂 HTTPS 的加密原理</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000009002353">SSL&#x2F;TLS 及证书概述</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.rfc-editor.org/rfc/rfc4346">rfc4346</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN">椭圆曲线公式生成图形</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.rfc-editor.org/rfc/rfc4492">rfc4492</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 WebSocket 协议</title>
    <url>/2018/01/04/%E6%B7%B1%E5%85%A5%20WebSocket%20%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>在学习 WebSocket 之前，需要先了解几个术语：</p>
<p>(1) 全双工通信<br>也可以叫做双向同时通信，即通信的双方可以同时发送和接收消息。</p>
<p>(2) 半双工通信<br>即通信的双方都可以收发消息，但是同一时间只能有一方进行发送，另一方进行接收。</p>
<span id="more"></span>

<p>(3) 长连接<br>指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包（心跳包）以确认连接的有效性。</p>
<p>(4) 短连接<br>通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>WebSocket 是 IETF 提出的一个应用层协议，2008 年诞生，2011 年成为标准，HTML5 规范中给出了 WebSocket API。该协议基于 TCP 协议（为了兼容现有 HTTP 协议，使用 HTTP 发送建立连接的握手请求），它实现了客户端与服务器的全双工通信，允许服务器主动发送消息给客户端。</p>
<h1 id="历史沿革"><a href="#历史沿革" class="headerlink" title="历史沿革"></a>历史沿革</h1><p>我们知道，HTTP 协议是基于 TCP&#x2F;IP 的应用层协议，经历了 0.9、1.0、1.1 以及 2.0 版本（2015 年），其中 1.1 版本使用最广泛，这种分布式的、无状态的、基于 TCP 的请求响应式的协议为如今互联网的发展做出了巨大贡献。</p>
<p>在 web 1.0 时代，门户网站盛行，信息汇聚集中。后来 AJAX 技术流行，互联网开始进入 web 2.0 时代，信息开始流动，web 应用开始注重交互体验，现如今，互联网更是向着 web 3.0 迈进。但是反观 HTTP 协议从 1.0 到 1.1，除了 keep-alive 和其他一些不痛不痒的改进，变化并不大。</p>
<p>传统的 web 应用与服务器交互，需要提交一个表单，服务器接收表单数据，返回一个新的页面。一般前后页面的变化并不大，这一过程其实传输了大量的冗余数据，占用带宽。AJAX 的出现解决了这个问题，同时也满足了强调用户体验的 web2.0 的初期发展的要求。但是随着互联网的发展，一些需要实时通讯的 web 应用出现，AJAX 开始显现出它的不足。</p>
<p>我们首先从协议上看，由于 AJAX 其实还是基于 HTTP 协议的，因此它本质上并没有改变 HTTP 的请求响应模型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/2Q2.png" alt="http_model"></p>
<p>客户端发送 HTTP 请求，在 HTTP 工作之前，客户端首先通过三次握手与服务器建立 TCP 连接，连接建立后，客户端请求发出，服务器接收到请求后响应。在 HTTP 1.0 版本中，这意味着一次请求响应处理完成，需要通过四次握手关闭连接。但是有时候短期内客户端可能会大量请求服务器，这个时候如果每次请求都要建立连接，可想而知是多么消耗资源和时间，因此在 HTTP 1.1 版本中，可以通过添加头信息 Connection: keep-alive 来使得通信的双方保持住连接，以便下次通信时，可以不用建立连接，节省了时间和带宽（保持连接不是完美的，在 HTTP 1.1 中，默认情况下所有的连接都会被保持，即使通信的双方不再传输数据，除非显式指定 Connection: close，连接关闭。而操作系统能够支持的最大连接数有限，如果大量的连接被保持，则后续的连接可能无法建立）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/j0A.png" alt="wireshark"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/QOQ.png" alt="keep_alive"></p>
<p>其实可以看出，即便是 HTTP 1.1，也只是增加了连接的复用，HTTP 的请求响应模型并没有发生变化，<strong>服务器还是不能主动发送消息给客户端，客户端与服务器不能全双工通信</strong>。</p>
<p>另外，我们知道，HTTP 请求会在报文头部增加很多控制信息，很多时候，我们需要的数据其实很小，在使用频繁的请求时，大量无用的信息被传输，浪费了带宽。</p>
<h1 id="轮询（Polling）"><a href="#轮询（Polling）" class="headerlink" title="轮询（Polling）"></a>轮询（Polling）</h1><p>最早的处理实时 web 应用的方案，就是采用轮询（Polling，也可以称为短轮询）的方式，客户端每隔一段时间向服务器发送一次请求，以频繁的请求换来客户端与服务端数据的同步，然而并不是每次请求都能够遇到数据更新，更多的时候，请求收到的响应都是没有数据更新，这会带来无谓的网络传输，也给服务器增加了不必要的负担，是一种非常低效的实时方案。</p>
<h1 id="服务器推（Comet）"><a href="#服务器推（Comet）" class="headerlink" title="服务器推（Comet）"></a>服务器推（Comet）</h1><p>其实服务器推技术很早就已经存在了，最早是通过客户端套接口来实现服务器推，这种方式的缺点就是需要客户端安装软件，如 flash 等。随着浏览器技术的发展，在纯浏览器应用中也可以实现服务器推技术了。</p>
<p>一种实现方式就是长轮询（Long-Polling）。客户端发起请求，服务端接收请求后，发现数据并没有更新，此时并不会做出响应，而是 hold 住连接，直到数据更新时，再做出响应。客户端收到新的数据，更新后立即发送新的请求，重复以上过程。长轮询需要注意的一点就是，连接不能长久的 hold，需要设置一个超时时间。</p>
<p>另一种实现方式是基于 iframe 及 htmlfile 的流（streaming），这种方式还有一个高大上的名字：The forever iframe technique，其实就是在页面隐藏一个 iframe 标签，src 属性指向一个对长连接的请求，服务器接收到请求后作出响应并一直更新连接状态（reload）以保证连接有效，响应的内容并不只是数据，而是客户端函数的调用 + 数据，如：<code>&lt;script&gt;js_callbk(&#39;data&#39;)&lt;/script&gt;</code>。但是这种方式有一个弊端，就是浏览器的进度栏会一直显示加载未完成，为了解决这个问题，google 的技术人员使用了一个称为“htmlfile”的 ActiveX，并将该方法用到了 gmail + gtalk 中。</p>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>不管轮询还是 Comet，都不是真正意义上的实时，它们更多的是一种无奈的选择，但是不可否认它们在这个方向上所做的努力。如果能有一个可以双向实时通信，并且数据格式轻量的协议就好了。WebSocket 就是这样一个协议。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/qNA.png" alt="websocket_vs_http"></p>
<h2 id="WebSocket-协议的特点"><a href="#WebSocket-协议的特点" class="headerlink" title="WebSocket 协议的特点"></a>WebSocket 协议的特点</h2><ul>
<li>建立在 TCP 协议之上。因为 WebSocket 通信前需要通过 TCP 三次握手建立连接。</li>
<li>兼容现有 HTTP 协议。WebSocket 在握手阶段使用 HTTP 协议，默认端口也是 80 和 443。</li>
<li>数据格式较轻量。</li>
<li>可以发送文本和二进制数据。</li>
<li>无同源限制，客户端可以与任意服务器通信。</li>
<li>标识符是 ws，加密协议则为 wss。如 <code>ws://example.com:80/some/path</code> <code>wss://example.com:443/some/path</code>。</li>
</ul>
<h2 id="通信过程分析"><a href="#通信过程分析" class="headerlink" title="通信过程分析"></a>通信过程分析</h2><p>通过抓包来查看 WebSocket 的通信过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/vDa.png" alt="websocket"></p>
<p>(1) 首先客户端通过 TCP 三次握手建立连接（粉色部分）。</p>
<p>(2) 客户端 WebSocket 请求发出，WebSocket 的请求头部与普通的 HTTP 请求有些区别。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/DJ4.png" alt="websocket_header"></p>
<p>先看请求头信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 121.40.165.18:8088</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: http://www.blue-zero.com</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Sec-WebSocket-Key: zkt8dDQa61WCBACQ0KA+pQ==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Upgrade: websocket<br>表示这是一个特殊的 HTTP 请求，请求的目的是将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket 协议。</p>
</li>
<li><p>Connection: Upgrade<br>HTTP1.1 中规定 Upgrade 只能应用在「直接连接」中，所以带有 Upgrade 头的 HTTP 1.1 消息必须含有 Connection 头。因为 Connection 头的意义就是，任何接收到此消息的人（往往是代理服务器）都要在转发此消息之前处理掉 Connection 中指定的域（不转发 Upgrade 域）。</p>
</li>
<li><p>Sec-WebSocket-Key: zkt8dDQa61WCBACQ0KA+pQ&#x3D;&#x3D;<br>这是一段浏览器随机生成的 base64 加密的密钥，server 端收到后需要提取 Sec-WebSocket-Key 信息，然后加密。</p>
</li>
<li><p>Sec-WebSocket-Version: 13<br>客户端在握手的请求中携带的版本标识，表示这是一个升级版本，现在的浏览器都是使用的这个版本。</p>
</li>
</ul>
<p>再看看响应头信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: QbHcxHtM1yCmV3UzNEcnEbhx6Ew=</span><br></pre></td></tr></table></figure>

<ul>
<li>HTTP&#x2F;1.1 101 Switching Protocols<br>101 为服务器返回的状态码，所有非 101 的状态码都表示 handshake 并未完成。</li>
</ul>
<p>(3) 服务器返回状态码 101，表示连接建立成功。</p>
<p>(4) 服务器发送消息给客户端（红色部分），客户端收到消息后，发送 ACK 给服务端表示数据接收成功。</p>
<p>(5) 客户端发送消息给服务端（橘黄色部分），服务端接收到消息后，发送响应数据给客户端（绿色部分），客户端收到响应数据后，发送 ACK 给服务端表示数据接收成功。</p>
<p>(6) 客户端发送关闭连接消息，双方经过四次握手，断开连接。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/">Comet：基于 HTTP 长连接的“服务器推”技术</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></p>
<p><a href="https://www.w3.org/TR/2014/REC-html5-20141028/">W3C HTML5</a></p>
</blockquote>
<blockquote>
<p><a href="https://html.spec.whatwg.org/multipage/infrastructure.html">HTML Standard</a></p>
</blockquote>
<blockquote>
<p><a href="https://tools.ietf.org/html/rfc6455">The WebSocket Protocol</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>深入线程池</title>
    <url>/2017/11/13/%E6%B7%B1%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>在使用线程时，我们可以直接 new 一个线程，但是如果并发的线程很多，并且每个线程都是执行一个时间很短的任务就结束了，像这样频繁创建线程会大大降低系统的效率，创建线程和销毁线程都需要消耗系统资源，而线程池可以使线程在执行完一个任务后，并不是销毁，而是去执行其他任务，使线程得到复用。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JDK 的线程池使用了 Executor 框架，这个框架是在 JDK 1.5 引入的。Executor 是一个异步执行框架，支持多种不同类型的任务策略，提供了一种标准的方法将任务的提交过程和任务的执行过程解耦，基于生产者-消费者模型，提交任务的线程相当于生产者，执行任务的线程相当于消费者，使用 Runnable 表示任务，同时还提供生命周期管理、统计信息收集、性能监视等功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/MdP.png" alt="executor"></p>
<ul>
<li><p><strong>Executor</strong><br>一个接口，其定义了一个接收 Runnable 对象的方法 execute。</p>
</li>
<li><p><strong>ExecutorService</strong><br>一个比 Executor 使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回 Future 的方法。</p>
</li>
<li><p><strong>AbstractExecutorService</strong><br>ExecutorService 执行方法的默认实现。</p>
</li>
<li><p><strong>ScheduledExecutorService</strong><br>一个可定时调度任务的接口。</p>
</li>
<li><p><strong>ScheduledThreadPoolExecutor</strong><br>ScheduledExecutorService 的实现，一个可定时调度任务的线程池。</p>
</li>
<li><p><strong>ThreadPoolExecutor</strong><br>线程池，可以通过调用 Executors 中的静态工厂方法来创建线程池并返回一个 ExecutorService 对象。</p>
</li>
</ul>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p><strong>核心池的大小（corePoolSize）</strong><br>在创建了线程池后，默认情况下，线程池中并没有任何线程，当有任务提交时，就会创建一个线程去执行任务，即使核心池中存在其他空闲的能够执行新任务的线程，当线程池中的线程数目达到 corePoolSize 后，就会把之后提交的任务放到缓存队列当中。</p>
<p>如果在创建线程池之后调用了 prestartAllCoreThreads() 或者 prestartCoreThread() 方法，则会在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。</p>
<p><strong>线程池最大线程数量（maximumPoolSize）</strong><br>线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p>
<p><strong>线程没有任务执行时的存活时间（keepAliveTime）</strong><br>当工作线程数大于核心线程数时，线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p>
<p>ThreadPoolExecutor 中额定的工作线程数量由 corePoolSize 决定，当任务数量超过额定线程数量时，将任务缓存在 BlockingQueue 之中，当发现如果连 queue 中也放不下时，ThreadPoolExecutor 会请求再加几个线程（但是不能无上限地加，设置 maximumPoolSize 为上限）。当到达最大上限后，接下来可能会发生两种情况：一种是不再有新任务提交，则 keepAliveTime；另一种是仍然有新任务提交，则执行 RejectedExecutionHandler。</p>
<p><strong>存活时间的单位（unit）</strong><br>可选的单位有天、小时、分钟、秒、毫秒、微秒和纳秒。</p>
<p><strong>阻塞队列（workQueue）</strong><br>用来存储等待执行的任务，当运行的线程数少于 corePoolSize 时，在有新任务时直接创建新线程来执行任务而无需进入队列排队，当运行的线程数等于或多于 corePoolSize 时，在有新任务提交时就会进入队列排队。当队列满时，有新任务提交再创建新线程，直到到达线程池的最大线程数量 maximumPoolSize。一般队列有以下几种选择：</p>
<table>
<thead>
<tr>
<th>阻塞队列</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。这是一个经典的“有界缓冲区”，队列中有一个固定大小的数组用来存放由生产者插入的元素，并由消费者提取。一旦创建，容量不能改变。尝试将元素放入一个满队列将导致操作阻塞；尝试从一个空队列中取一个元素也会被阻塞</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>一个基于链表结构的有界阻塞队列，此队列按 FIFO（先进先出）排序元素，新加入的元素放入尾部，默认长度为 <code>Integer.MAX_VALUE</code>，吞吐量通常要高于 ArrayBlockingQueue，但是在大多数并发应用中性能较差</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>一个不存储元素的阻塞队列，没有任何内部容量。不能调用 peek 方法来查看队列中是否有元素，因为一个元素只有在你尝试取走时才会出现，不取走只想看一眼是不行的。只有另一个线程试图取出一个元素时才可以往队列中放入一个元素。因为不存储元素，所以也不能迭代。对于其他 Collection 方法，例如 contains，SynchronousQueue 充当空集合，该队列不允许空元素存在。它的吞吐量通常要高于 LinkedBlockingQueue</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>一个支持线程优先级排序的无界阻塞队列，默认按照字典顺序排序，也可以自定义实现 compareTo 方法来指定排序规则，不能保证同优先级元素的顺序</td>
</tr>
</tbody></table>
<p><strong>线程工厂（threadFactory）</strong><br>线程池中使用 ThreadFactory 来创建新的线程，默认使用 defaultThreadFactory 创建线程。</p>
<p><strong>任务被拒时的处理策略（handler）</strong><br>默认使用 ThreadPoolExecutor.AbortPolicy，任务被拒绝时将抛出 RejectExecutorException 异常。还有以下几种策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadPoolExecutor.AbortPolicy</td>
<td>丢弃任务并抛出 RejectedExecutionException 异常</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardPolicy</td>
<td>也是丢弃任务，但是不抛出异常</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardOldestPolicy</td>
<td>丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</td>
</tr>
<tr>
<td>ThreadPoolExecutor.CallerRunsPolicy</td>
<td>由调用线程处理该任务</td>
</tr>
</tbody></table>
<h1 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h1><p>线程池内部使用一个变量 <code>ctl</code> 来维护两个值：线程池的运行状态（runState）和线程数量（workerCount）。ctl 是一个 AtomicInteger 类型的变量，它的值当中，高 3 位用来保存 runState，低 29 位用于保存 workerCount，使用一个变量存储两个值可以避免在做相关决策的时候出现不一致的情况，不必为了维护两个状态的一致而使用锁。</p>
<h2 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h2><table>
<thead>
<tr>
<th>运行状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>创建线程池后的初始状态，可以接受新的任务，也能够处理阻塞队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>不再接受新提交的任务，但是还会继续处理阻塞队列中的任务（当然正在执行的任务也会继续）</td>
</tr>
<tr>
<td>STOP</td>
<td>不再接受新提交的任务，同时也不处理队列中的任务，并且会尝试中断正在执行的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>所有的任务都终止了，workCount 的数量为 0（线程池和等待队列都为空）</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>当线程池处于 TIDYING 状态，并且 terminated 钩子函数执行完毕后</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>运行状态转换</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING -&gt; SHUTDOWN</td>
<td>调用 shutdown 方法，则线程池处于 SHUTDOWN 状态</td>
</tr>
<tr>
<td>RUNNING&#x2F;SHUTDOWN -&gt; STOP</td>
<td>调用 shutdownNow 方法，则线程池处于 STOP 状态</td>
</tr>
<tr>
<td>SHUTDOWN -&gt; TIDYING</td>
<td>当线程池处于 SHUTDOWN 状态，并且线程池和等待队列都为空时，线程池状态为 TIDYING</td>
</tr>
<tr>
<td>STOP -&gt; TIDYING</td>
<td>当线程池处于 STOP 状态，并且线程池为空时（等待队列肯定为空），线程池状态为 TIDYING</td>
</tr>
<tr>
<td>TIDYING -&gt; TERMINATED</td>
<td>当线程池处于 TIDYING 状态，并且 terminate() 钩子方法完成后，线程池被设置为 TERMINATED 状态</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007022032/2020/07/02/1qq.png" alt="runState"></p>
<p>其实状态的变化基本上是通过 shutdown 和 shutdownNow 这两个方法来触发的，总的来说就是：这两个方法分别将运行状态设置为 SHUTDOWN 和 STOP，接下来或等待剩下的任务执行完成，或尝试中断正在执行的任务，最终它们都会调用 tryTerminate 方法，当线程池和等待队列都为空时，状态会变成 TIDYING，然后会调用 terminated 钩子函数（该方法是一个 protected 方法，由子类实现），最终将状态设置为 TERMINATED，并唤醒所有调用了 awaitTermination 方法，在 termination 条件上等待的线程。</p>
<h1 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果活动线程数小于核心线程大小，新建线程</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果活动线程数大于核心线程大小，将任务放入等待队列</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 执行到这里，说明队列已满，此时尝试新建线程，如果失败，则执行任务拒接策略</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute() 方法是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是 ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>submit() 方法是在 ExecutorService 中声明的方法，在 AbstractExecutorService 中实现，在 ThreadPoolExecutor 中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和 execute() 方法不同，它能够返回任务执行的结果，查看 submit() 方法的实现，会发现它实际上还是调用的 execute() 方法，只不过它利用了 Future 模式来获取任务执行结果。</p>
<h1 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在 java 中，++i 和 i++ 操作并不是线程安全的，在使用的时候，不可避免的会用到 synchroized 关键字，</span></span><br><span class="line"><span class="comment">    * 而 AtomicInteger 是一个提供原子操作的 Integer 类，通过线程安全的方式操作加减</span></span><br><span class="line"><span class="comment">    * ctlOf(RUNNING, 0) = -536870912 | 0 = -536870912</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Integer.SIZE = 32</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 536870911</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * -1: 10000001(原) -&gt; 11111111(补) -&gt; 左移一位 11111110(补) -&gt; 10000010(原) = -2</span></span><br><span class="line"><span class="comment">    * 左移 29 位，结果为-536870912</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 0: 00000000(原) -&gt; 00000000(补) -&gt; 左移一位 000000000(补) -&gt; 00000000(原) = 0</span></span><br><span class="line"><span class="comment">    * 左移 29 位，结果为 0</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 536870912</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 等待队列</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 线程池主要状态锁，对线程池的主要状态的改变都需要使用该锁</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 活动线程容器，只有在持有 mainLock 时才可以访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录曾经出现过的最大线程数量，只有在持有 mainLock 时才可以访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果为 false（默认），则核心线程即使空闲也会保持活动状态。</span></span><br><span class="line"><span class="comment">     * 如果为 true，则核心线程使用 keepAliveTime 超时等待工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 如果活动线程数大于等于核心线程或最大线程大小，则不创建线程，直接返回 false</span></span><br><span class="line"><span class="comment">                **/</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * workerCount 增加 1</span></span><br><span class="line"><span class="comment">                **/</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">// Re-read ctl</span></span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Worker 是 ThreadPoolExecutor 的一个内部类，类里持有一个 Runnable 和一个 Thread，</span></span><br><span class="line"><span class="comment">            * 当通过构造器传入一个任务时，类中的 Runnable 用来接收任务，</span></span><br><span class="line"><span class="comment">            * Thread 用来接收通过 ThreadFactory 将当前 worker 作为对象传入后创建的线程</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * Worker(Runnable firstTask) &#123;</span></span><br><span class="line"><span class="comment">            *   setState(-1); // inhibit interrupts until runWorker</span></span><br><span class="line"><span class="comment">            *   this.firstTask = firstTask;</span></span><br><span class="line"><span class="comment">            *   this.thread = getThreadFactory().newThread(this);</span></span><br><span class="line"><span class="comment">            * &#125;</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 此时这个 t 就是通过 ThreadFactory 创建的线程，线程执行的代码就是 worker 中 run 方法的代码</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 将 worker 放入活动线程容器中</span></span><br><span class="line"><span class="comment">                        **/</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            <span class="comment">//记录出现的最大线程数</span></span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 线程 start，会调用 worker 的 run 方法</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试使用 CAS-increment 来保证不使用悲观锁（使用乐观锁）的情况下增加 workerCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            runWorker(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 循环取任务</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 如果是第一次执行，会先执行创建线程时传入的任务，如果任务执行结束，</span></span><br><span class="line"><span class="comment">            * 会通过 getTask 从等待队列中取任务</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 任务执行前的一些处理，可以通过继承 ThreadPoolExecutor 后重写</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//实际执行的还是真正我们需要执行的任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 任务执行后的一些处理，如统计等，可以通过继承 ThreadPoolExecutor 重写</span></span><br><span class="line"><span class="comment">                        **/</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 线程退出工作处理</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从等待队列中取任务</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * Are workers subject to culling?</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * case 1 timed=false</span></span><br><span class="line"><span class="comment">            *       allowCoreThreadTimeOut=false wc&gt;corePoolSize=false</span></span><br><span class="line"><span class="comment">            *       线程即使空闲也会保持活动，并且活动线程数没有超过核心线程数</span></span><br><span class="line"><span class="comment">            * case 2 timed=true</span></span><br><span class="line"><span class="comment">            *       allowCoreThreadTimeOut=false wc&gt;corePoolSize=true</span></span><br><span class="line"><span class="comment">            *       虽然线程设置为即使空闲也会活动，但是活动线程数已经超过核心线程数</span></span><br><span class="line"><span class="comment">            * case 3 timed=true</span></span><br><span class="line"><span class="comment">            *       allowCoreThreadTimeOut=true wc&gt;corePoolSize=false</span></span><br><span class="line"><span class="comment">            *       线程设置为空闲一定时间后销毁</span></span><br><span class="line"><span class="comment">            * case 4 timed=true</span></span><br><span class="line"><span class="comment">            *       allowCoreThreadTimeout=true wc&gt;corePoolSize=true</span></span><br><span class="line"><span class="comment">            *       线程设置为空闲一定时间后销毁</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * poll 方法获取并删除队列头部元素，并且该方法会等待一段时间，如果超过时间则返回 null</span></span><br><span class="line"><span class="comment">                * take 方法获取并删除队列头部元素，该方法会阻塞，直到元素可以获取</span></span><br><span class="line"><span class="comment">                **/</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池中线程初始化"><a href="#线程池中线程初始化" class="headerlink" title="线程池中线程初始化"></a>线程池中线程初始化</h1><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务（execute 或 submit）之后才会创建线程。但是如果需要线程池创建之后立即创建线程，可以使用以下两种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化一个核心线程  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if a thread was started</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">prestartCoreThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化所有核心线程</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the number of threads started</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prestartAllCoreThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="literal">null</span>, <span class="literal">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getTaskCount</td>
<td>线程池需要执行的任务总数，由于任务和线程的状态在计算过程中可能会变化，因此这只是一个近似值</td>
</tr>
<tr>
<td>getCompletedTaskCount</td>
<td>线程池在运行过程中已完成的任务数量，小于或等于 taskCount，这是一个近似值</td>
</tr>
<tr>
<td>getLargestPoolSize</td>
<td>线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了</td>
</tr>
<tr>
<td>getPoolSize</td>
<td>线程池的线程数量</td>
</tr>
<tr>
<td>getActiveCount</td>
<td>获取活动（正在执行任务）的线程数，这是一个近似值</td>
</tr>
</tbody></table>
<h1 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h1><p>ThreadPoolExecutor 提供了两个方法用于线程池的关闭，分别是 shutdown 和 shutdownNow。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>shutdown</td>
<td>不会立即终止线程池，而是等待任务缓存队列中的任务都执行完后才终止，但不会接受新提交的任务</td>
</tr>
<tr>
<td>shutdownNow</td>
<td>立即终止线程池，并尝试中断正在执行的任务（通过 Thread.interrupt 方法实现，如果线程中没有使用 sleep、wait、Condition 相关的等一些可以响应中断的方法时，则无法中断线程），并且清空任务缓存队列，返回尚未执行的任务集合</td>
</tr>
</tbody></table>
<h1 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007022032/2020/07/02/Zo7.png" alt="整体流程"></p>
<p>首先创建线程池 ThreadPoolExecutor，设置初始化参数。新创建的线程池中并没有线程，需要通过 execute 方法或 submit 方法提交任务才会创建线程。</p>
<p>接着提交任务，任务提交后，线程池会执行以下操作。首先判断 <code>corePoolSize</code> 即核心线程池是否已满，没有满就新建线程，满了会再去判断 <code>workQueue</code> 即等待队列是否已满，没有满就放入等待队列，满了会再去判断线程池中线程数是否超过 <code>maximumPoolSize</code> 即最大线程数，没有就新建线程，如果超过了，执行拒绝策略。</p>
<p>这里所说的新建线程其实省略了很多必要的过程，首先执行的是 <code>addWorker()</code> 方法，该方法会创建一个 Worker 实例，Worker 是 ThreadPoolExecutor 的内部类，继承了 AQS，因此它是一个同步器，它的内部有一个 Thread 成员变量和一个 Runnable 成员变量。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202007022032/2020/07/02/NEY.png" alt="线程申请"></p>
<p>firstTask 是初始化的任务，如果它的值是非空的，那么线程会在启动初期立即执行这个任务；如果它的值为 null，那么就会创建一个线程去等待队列中获取任务执行。<code>getThreadFactory().newThread(this)</code> 方法将 Worker 的实例传入来创建一个新的线程，任务对象就是 worker 实例。创建完 Worker 实例后，将该实例放入活动线程容器 workers 中，然后调用 workder 的 thread 属性的 start 方法启动该线程，即调用 worker 的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run 方法中调用 runWorker 方法将 worker 实例传入，这里的重点是<strong>调用的是任务的 run 方法</strong>，第一次先执行一开始构造的第一个任务 firstTask，执行结束后，从等待队列中循环取新任务来执行。也就是说，新线程调用的 run 方法会通过循环取队列的方式来执行不同的任务，从而达到线程复用的目的。</p>
<h1 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h1><p>使用 Executors 可以使用 JDK 预置的一些线程池。</p>
<p><strong><code>newFixedThreadPool</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newFixedThreadPool 设置的 corePoolSize 和 maximumPoolSize 大小相同，阻塞队列使用的是 LinkedBlockingQueue，由于它没有给定一个初始化的队列容量，因此理论上该线程池永远不会拒绝任务，因此 maximumPoolSize 和 keepAliveTime 的设置都是无效的。</p>
<p><strong><code>newSingleThreadExecutor</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newSingleThreadExecutor 设置的 corePoolSize 和 maximumPoolSize 大小都为 1，阻塞队列使用的是 LinkedBlockingQueue。</p>
<p><strong><code>newCachedThreadPool</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的是 SynchronousQueue，由于这个队列没有存储空间，这就意味着只要有任务就必须找到一个线程来处理，如果当前没有空闲的线程，那么就会创建一个新的线程来运行，当线程空闲超过 60 秒，就销毁线程。因此它比较适合来处理执行时间比较短的任务。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程 ID=&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                + <span class="string">&quot; 线程名称=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach((e) -&gt; System.out.println(e));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    executor.execute(() -&gt; System.out.println(<span class="string">&quot;当前线程 ID=&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">            + <span class="string">&quot; 线程名称=&quot;</span> + Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>阿里巴巴的 Java 开发手册中提到过，使用 Executors 的静态方法来创建线程池可能会导致 OOM。newFixedThreadPool 底层使用的是 LinkedBlockingQueue，这是一个通过链表实现的有界阻塞队列，容量可以指定，如果不指定就会变成一个无边界的阻塞队列，最大的长度为 Integer.MAX_VALUE。由于 newFixedThreadPool 在创建 LinkedBlockingQueue 时没有指定容量，所以可以不断地向队列中添加任务，这就可能出现因为任务过多而导致内存溢出。</p>
<p>同理，newCachedThreadPool 和 newScheduledThreadPool 使用的虽然不是 LinkedBlockingQueue，但是因为最大线程数指定为 Integer.MAX_VALUE，还是可能会出现 OOM。所以一般不推荐使用 JDK 提供的 Executors 来创建线程池，正确的做法是直接调用 ThreadPoolExecutor 的构造方法来创建线程池，在创建时，指定阻塞队列的容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>这种情况下一旦提交的线程数超过当前可用线程数时，就会抛出 RejectedExecutionException，但是异常（Exception）总比发生错误（Error）要好。除了直接调用 ThreadPoolExecutor 的构造方法以外，还可以使用第三方的类库，比如 apache 或者 guava。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java 线程池实现原理及其在美团业务中的实践</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java 多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>用户密码的加密存储</title>
    <url>/2018/09/29/%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>早期的软件应用在数据库中存储用户密码时，使用的是明文存储，数据库数据泄漏就意味着用户密码的直接暴露。后来通过 MD5 等算法对密码明文进行加密后再存储到数据库中，因为 MD5 算法是不可逆的，即从数学逻辑上来讲无法通过一个加密后的密文反推出原始明文，所以这种方式还算是相对安全的。但是很多用户总是喜欢使用简单易记的密码，这在数据库被脱库，加密后的密文全部暴露的情况下，攻击者可以使用多种方式来破解密码。  </p>
<span id="more"></span>

<h1 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h1><ul>
<li>字典和暴力破解</li>
</ul>
<p>简单的暴力破解就是猜密码，对每一个可能的密码进行 Hash，然后与泄漏的密文进行比对，如果两者一样，则密码原文一致。好事者将常见的密码收集起来放到一个文件中，然后对文件中每一个词进行 Hash，再与密文比对，这种方式就是字典攻击。  </p>
<p>字典攻击和暴力破解针对的是常见简短密码，这种方式的成功率取决于字典的大小以及字典的选择是否合适，密码长度越长，字符组合的可能性就越多，需要的存储空间就越大，效率也就更低。虽然这种方式的破解比较原始，却也没有办法阻止，唯一可行的方法就是让他们的破解尽可能的低效，使破解的成本增加，迫使攻击者放弃破解。  </p>
<ul>
<li>查表破解</li>
</ul>
<p>对于特定的 Hash 算法，如果需要大量破解的话，查表是一种非常高效的方式。与字典类似，提供部分常见密码和计算好的 Hash 值，存放到设计合理的数据库表中，利用数据库查询的优势提高效率。  </p>
<ul>
<li>反向查表破解</li>
</ul>
<p>攻击者会根据泄漏的数据库数据制作一个用户名和对应的 Hash 表。然后将常见的字典密码进行 hash 之后，跟这个表的 hash 进行对比，就可以知道用哪些用户使用了这个密码。这种攻击方式很有效果，因为通常情况下很多用户都会有使用相同的密码。  </p>
<ul>
<li>彩虹表</li>
</ul>
<p>彩虹表的根本原理就是组合了暴力法和查表法，并在这两者之中取得一个折中，用我们可以承受的时间和存储空间进行破解。  </p>
<ul>
<li>碰撞破解</li>
</ul>
<p>与暴力破解不同的是，碰撞破解是寻找一个与原文不同的内容，经过 Hash 后与原文的 Hash 值相同。04 年的时候，王小云教授提出了 MD5 快速碰撞的方法，大大减少了碰撞尝试的次数。</p>
<h1 id="防护手段"><a href="#防护手段" class="headerlink" title="防护手段"></a>防护手段</h1><h2 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h2><p>单纯使用 hash 算法对密码进行加密，攻击者很容易根据常见密码制作字典进行暴力破解，一个好的方式就是加盐处理。简单来说就是使用 <code>hash(密码 + 盐)</code> 的方式进行加密，并且这个盐最好使用随机字符串生成，每个用户都有一个且都不一样。数据库可以简单设计成以下形式：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/09/29/8LV.png" alt="数据库设计"></p>
<p>同时，加盐需要注意的以下几点：  </p>
<ul>
<li>不要使用重复的盐</li>
</ul>
<p>不管是将盐硬编码在程序中，还是使用一个随机生成的盐，在系统中所有的密码都使用同一个盐是不可取的。一旦攻击者获取到该盐，就可以用来制作字典或者使用彩虹表进行暴力破解。  </p>
<ul>
<li>不要使用过短的盐</li>
</ul>
<p>如果盐的位数太短的话，攻击者也可以预先制作针对所有可能的盐的查询表。过短的盐会使攻击者制作盐查询表的成本降低。  </p>
<ul>
<li>不要使用用户名作为盐</li>
</ul>
<p>同样的理由，用户名虽然不可预测，但是并不是完全随机的。攻击者同样可以针对常见的用户名作为盐制作查询表和使用彩虹表暴力破解。  </p>
<ul>
<li>要使用安全可靠的伪随机数生成器</li>
</ul>
<p>伪随机数生成器（Cryptographically Secure Pseudo-Random Number Generator，CSPRNG）提供一个高标准的随机数，是完全无法预测的。比如 Java 中的 <code>java.security.SecureRandom</code>。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://www.project-rainbowcrack.com/">彩虹表 RainbowCrack</a></p>
</blockquote>
<blockquote>
<p><a href="https://my.oschina.net/GeorgeSu/blog/464966">从 hash 函数到王小云的 MD5 破解</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.freebuf.com/articles/web/28527.html">如何安全的存储用户的密码</a></p>
</blockquote>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>安全</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>申请泛域名证书</title>
    <url>/2019/01/22/%E7%94%B3%E8%AF%B7%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p><code>Let&#39;s Encrypt</code> 已经支持泛域名证书了，由于 <code>acme.sh</code> 实现了 acme 协议，可以从 <code>Let&#39;s Encrypt</code> 生成免费的证书，并且支持自动更新，所以这里使用它来快速实践一下。  </p>
<span id="more"></span>  

<h1 id="安装-acme-sh"><a href="#安装-acme-sh" class="headerlink" title="安装 acme.sh"></a>安装 acme.sh</h1><p>首先安装 <code>acme.sh</code>，可以使用官方提供的自动安装脚本，默认会把 <code>acme.sh</code> 安装到用户目录下，同时创建 cron 每日任务去检查是否有证书需要更新。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure>

<h1 id="获取域名-API"><a href="#获取域名-API" class="headerlink" title="获取域名 API"></a>获取域名 API</h1><p>目前泛域名证书仅支持 DNS 验证，<code>acme.sh</code> 通过 DNS 提供商的 API 自动完成域名验证、添加删除记录等操作，因此我们需要先设置 DNS API。我使用的是腾讯云提供的云解析，腾讯云使用的是 <a href="https://www.dnspod.cn/">DNSPOD</a> 的服务，这两家账号是通用的，登录后如果没有 API Token 则创建一个。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/01/22/jB4.png" alt="API Token"></p>
<h1 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h1><p>拿到 Token 后，将对应的 id 和 token 设置为环境变量。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> DP_Id=<span class="string">&quot;你的 Id&quot;</span></span><br><span class="line">$ <span class="built_in">export</span> DP_Key=<span class="string">&quot;你的 Token&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来使用命令申请证书。<code>dns</code> 参数的值与使用的 DNS 脚本有关，具体可以参见 <code>acme.sh</code> 的<a href="https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md">说明文档</a>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./acme.sh --issue --dns dns_dp -d nekolr.com -d *.nekolr.com --keylength ec-256</span><br></pre></td></tr></table></figure>

<blockquote>
<p>证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全，在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但是 ECC 的兼容性会差一些，不支持 Android 4.x 以下的版本，也不支持 Windows XP。  </p>
</blockquote>
<h1 id="添加证书"><a href="#添加证书" class="headerlink" title="添加证书"></a>添加证书</h1><p>生成证书以后，使用命令将证书拷贝一份留作备用（尽量避免手动拷贝，容易出错）。由于单纯使用 reload 参数，nginx 服务器只会重新加载配置文件，可能会导致新证书不生效，因此应该在证书安装完成后选择重启 nginx 服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./acme.sh --installcert -d nekolr.com -d *.nekolr.com \</span><br><span class="line">--fullchain-file /etc/letsencrypt/live/nekolr.com/fullchain.pem \</span><br><span class="line">--key-file /etc/letsencrypt/live/nekolr.com/privkey.pem \</span><br><span class="line">--ca-file /etc/letsencrypt/live/nekolr.com/chain.pem \</span><br><span class="line">--cert-file /etc/letsencrypt/live/nekolr.com/cert.pem \</span><br><span class="line">--reloadcmd <span class="string">&quot;nginx -s stop &amp;&amp; nginx&quot;</span> --ecc</span><br></pre></td></tr></table></figure>

<p>接下来修改 nginx 的配置文件，添加证书。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SSL 证书</span><br><span class="line">ssl_certificate    /etc/letsencrypt/live/nekolr.com/fullchain.pem;</span><br><span class="line"># SSL 私钥</span><br><span class="line">ssl_certificate_key    /etc/letsencrypt/live/nekolr.com/privkey.pem;</span><br><span class="line"># CA 根证书</span><br><span class="line">ssl_trusted_certificate    /etc/letsencrypt/live/nekolr.com/chain.pem;</span><br><span class="line"># 加密套件</span><br><span class="line">ssl_prefer_server_ciphers  on;</span><br><span class="line">ssl_ciphers    EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:!MD5;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>硬盘基础知识</title>
    <url>/2019/09/04/%E7%A1%AC%E7%9B%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>硬盘（HDD）主要由盘片、磁头、电机马达、接口等组成。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/04/VyP.jpg" alt="HDD"></p>
<p>**盘片（Platters）**表面涂有磁性材料，工作时在主轴马达的带动下进行高速旋转（比如每分钟 7200 转）。每个盘片都有上下两面，称为盘面，每个盘面都有一个对应的读写磁头负责读写该盘面上的数据。<strong>盘面数与磁头数相等</strong>。当关机时，磁头会停留在硬盘的停泊区，工作时才会移动到盘面上方，依靠磁盘高速旋转引起的空气动力效应悬浮在盘面上。在硬盘系统中，盘面按照从上到下的顺序从 0 开始编号，盘面号也叫磁头号，比如一个硬盘有两个盘片，则盘面号为 0 ~ 3。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/04/dww.png" alt="分解结构1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/04/AO1.jpg" alt="分解结构2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/05/12q.png" alt="分解结构3"></p>
<blockquote>
<p>其中 A 是磁道，B 是扇面，C 是扇区，D 是簇（扇区组）</p>
</blockquote>
<p>在盘片高速旋转时保持磁头不动，那么磁头就会在盘面上形成一个圆形的轨迹，这些同心的圆形轨迹就是<strong>磁道（Track）</strong>。每个盘面上都有多个磁道，这些磁道由外向内从 0 开始顺序编号，磁道之间并不是紧挨着的，因为磁化的单元挨得太近会相互影响。</p>
<p>所有盘面上半径相同的同心磁道垂直堆叠在一起构成的一个圆柱，称为<strong>柱面（Cylinder）</strong>。柱面是一个抽象出来的概念，它在物理上不是一体的，只是在空间上类似于一个圆柱的外壁。为了方便理解，可以认为柱面就是磁道。柱面上的磁头由上到下从 0 开始顺序编号，数据的读写也是按照柱面进行。在读写数据时，首先在同一柱面内从 0 号磁头开始操作，依次向下在同一柱面的不同盘面即磁头上进行操作，只有当同一柱面的所有磁头全部读写完毕后才将磁头切换到下一个柱面（同心圆往里的柱面）。这么做的原因是选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换，电子切换是相当快的，而机械切换磁头则要慢得多。概括来说，就是当一个磁道写满数据后，就在同一柱面的下一个盘面上写，一个柱面写满后，才会移动到下一个柱面，读数据也是按照同样的方式。</p>
<p>盘面上可以划分出很多磁道，但是我们并不需要每次都读写这么多数据，所以又将磁道划分为了若干更小的弧段，每段被称为一个<strong>扇区（Sector）</strong>。由于这些弧段转动的角速度一样，但是长度不同，所以线速度也不一样，外圈的线速度大于内圈，即相同的转速下，在同样的时间段内外圈划过的弧段长度要比内圈划过的弧段长度大。扇区从 1 开始编号，是硬盘进行读写操作的最小单位，一般硬盘的一个扇区大小为 512 字节，这也就意味着哪怕我们只存放 1 字节的数据也会占用硬盘的一个扇区（512 字节）。后来为了提升硬盘的效率和使用率又推出了 4K 大小的扇区标准。</p>
<p>扇区存储的第一个主要部分就是标识符，也就是扇区头标，它是一个扇区的三维地址，包括盘面号、柱面号和扇区号，通过这三个地址可以唯一确定一个扇区。扇区的第二个主要部分就是存储数据的数据段，可分为数据和保护数据的纠错码（ECC）。</p>
<h1 id="容量计算"><a href="#容量计算" class="headerlink" title="容量计算"></a>容量计算</h1><p><code>存储容量 = 磁头数（盘面数）* 磁道数（柱面数）* 每个磁道的扇区数 * 每个扇区的字节数</code></p>
<blockquote>
<p>以前的硬盘每个磁道的扇区数是一样的，外圈扇区的密度小，内圈扇区的密度大。现在的硬盘内外圈扇区的密度一致，这样磁道的长度越长，扇区就越多，存储的数据量就越大。</p>
</blockquote>
<h1 id="簇或块"><a href="#簇或块" class="headerlink" title="簇或块"></a>簇或块</h1><p>从硬盘的物理结构来看，数据存取信息的最小单位是扇区，一个扇区可能为 512 字节或者是 4K。由于扇区的容量小且数量众多，在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个整体，这个整体就是操作系统对硬盘进行存取的最小单位，在 Windows 下称为簇（Cluster），在 Linux 等系统中称为块（Block）。每个簇或块可以包含 2、4、8、16、32 等，2 的 n 次方个扇区。</p>
<p>我在我的这台老设备（Windows 系统）上通过管理员身份运行 <code>fsutil fsInfo ntfsInfo C:</code> 命令，会得到以下信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/09/05/Zv7.png" alt="磁盘信息"></p>
<p>这台设备使用的文件系统是 NTFS，默认的簇大小为 4096 字节。</p>
<h1 id="访盘过程"><a href="#访盘过程" class="headerlink" title="访盘过程"></a>访盘过程</h1><p>当需要从硬盘读取数据时，操作系统会将数据的逻辑地址发送给硬盘，硬盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读取的数据在哪个磁道，哪个扇区。</p>
<p>为了读取这个扇区的数据，需要将磁头移动到这个扇区的上方，为了实现这一点，首先必须找到对应的柱面，即磁头需要移动到对应的磁道上，这个过程叫做<strong>寻道</strong>，所耗费的时间叫做<strong>寻道时间</strong>。然后目标扇区旋转到磁头下，这个过程耗费的时间叫做<strong>旋转时间</strong>。接下来磁头读取该扇区的信息，然后就需要进行数据传输，即数据从硬盘传输到内存。</p>
<p>可以看到，进行一次读写硬盘所需要的时间可以概括为：寻道时间、旋转时间和传输时间。目前硬盘的平均寻道时间在 3ms 到 15ms 之间，普通硬盘的转速一般为 5400 rpm 或 7200 rpm。</p>
<h1 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h1><p>由于存储介质的特性，硬盘本身的存取速度就比主存慢很多，再加上磁头的机械运动，存取速度就更慢了。为了提高硬盘的效率，尽量减少磁盘 I&#x2F;O，硬盘往往不是严格的按需存取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序地向后读取一定长度的数据放入内存，这样做的理论依据是计算机科学中著名的空间局部性原理：</p>
<blockquote>
<p>当一个数据被用到时，其附近的数据通常也会马上被用到。</p>
</blockquote>
<p>程序在运行期间，一段时间内所需要的数据通常都比较集中，由于磁盘的顺序读取效率很高（不需要寻道时间，只需要很少的旋转时间），因此预读一般都可以提高磁盘 I&#x2F;O 的效率。磁盘预读的长度一般为页（Page）的整数倍。由于操作系统经常与内存和硬盘这两种设备进行通信，为了屏蔽底层物理存储结构的设计细节，需要抽象出一种逻辑上的存储单位。当与硬盘打交道时，操作系统使用簇或者块；当与内存打交道时，操作系统使用页。当程序要读取的数据不在内存中时，会触发一个缺页异常，此时操作系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置然后连续读取一页或者几页的数据放入内存，然后异常返回，程序继续执行。</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解内存地址</title>
    <url>/2018/11/08/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>简单整理内存地址的一些概念，方便后续深入了解，硬件平台是经典的 x86，其他平台可能存在出入。  </p>
<span id="more"></span>  

<h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>物理地址是加载到内存地址寄存器中的地址，是内存单元的真正地址，与和 CPU 相连接的地址总线相对应。在前端总线（连接 CPU 与北桥，很早之前就已经被淘汰了）上传输的内存地址都是物理地址，编号从 0 开始一直到可用的物理内存的最大值，这些值被北桥（现在也被淘汰了，北桥是以前的内存控制器，现在的内存控制器都集成到了 CPU 内部）映射到实际的内存条上。实际上我们可以将物理内存看作是一个从 0 字节一直到最大容量的逐个字节编号的大数组，虽然不准确但是容易理解。  </p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>与物理地址对应的真实内存不同，虚拟内存并不是真实存在的，现代操作系统都提供了一种内存管理的抽象，进程使用的虚拟内存的地址会由操作系统与相关硬件协作，转换成真正的物理内存地址。有了这种抽象，一个程序才可以使用比真实物理地址大得多的地址空间。  </p>
<h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>逻辑地址指的是机器语言执行中，用来指定一个操作数或者是一条指令的地址，比如说：<code>mov 0x80495b0, %eax</code> 这条指令，其中的 <code>0x80495b0</code> 就是一个逻辑地址。在段式内存管理中比较完整说法是，逻辑地址应该由一个段选择符加上一个段内偏移量，表示为段选择符:段内偏移量，比如上面的逻辑地址应该表示为 <code>代码段选择符:0x80495b0</code>。  </p>
<p>实模式下的逻辑地址与保护模式下的逻辑地址虽然都是使用**段（segment）:偏移量（offset）**表示，但是在保护模式下，段的概念发生了根本性的变化。在实模式下，段值还是可以看作最终地址的一部分，比如段值 xxxxh 表示以 xxxx0h 开始的一段内存；而在保护模式下，虽然段值仍然使用原来的 cs、ds 等寄存器存储，但此时它的值仅仅变成了一个索引，这个索引指向了一个数据结构的表项，表项中详细定义了段的起始地址、界限、属性等内容，这个数据结构就是 GDT（全局描述符表），也有可能是 LDT（局部描述符表）。  </p>
<h1 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h1><p>线性地址其实就是段基址加上段内偏移量。可能你会诧异，这不就是逻辑地址吗？我的理解是，其实逻辑地址真正的值是段内偏移量部分，段选择符:段内偏移量这种只是逻辑地址的表示形式。  </p>
<p>逻辑地址是段式内存管理中进行转换前的地址，而线性地址是页式内存管理中转换前的地址。CPU 将一个虚拟内存空间中的地址转换为物理地址，需要经过两步：首先给定的一个逻辑地址（其实是段内偏移量），CPU 利用其段式内存管理单元将逻辑地址转换成一个线性地址，接下来需要再利用其页式内存管理单元，将线性地址转换成最终的物理地址。这样转换确实很麻烦，完全可以直接将线性地址交给进程，intel 之所以这么做，完全是为了兼容以前的段式内存管理方式。  </p>
<p>需要说明的是，如果没有开启分页功能，那么线性地址其实就是最终的物理地址；如果开启了分页，则需要再将线性地址经过页式内存管理单元转换成最终的物理地址。  </p>
<h1 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h1><h2 id="逻辑地址转线性地址"><a href="#逻辑地址转线性地址" class="headerlink" title="逻辑地址转线性地址"></a>逻辑地址转线性地址</h2><p>严格意义上讲，实模式下不存在段式内存管理，段式内存管理出现在保护模式下。  </p>
<p>一个逻辑地址由两部分组成，段选择符:段内偏移量。段选择符由一个 16 位长的字段组成，其中 13 位是一个索引号，后面 3 位包含一些硬件细节，其中 TI（Table Index）是表指示器，RPL（Requested Privilege Level）是请求特权级。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/zJq.png" alt="段选择符">  </p>
<p>段选择符中的索引号指向的是段描述符表中的表项，这个段描述符表是一个简单的数组，数组元素长度为 8 个字节，每个元素描述一个段。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/rJ3.png" alt="段描述符">  </p>
<p>在这里我们可以只关心一个字段，那就是 Base 字段，它描述的是一个段的开始位置。Intel 设计的本意是，一些全局的段描述符，就放在 GDT 中，一些局部的，比如说每个进程自己的，就放在 LDT 中。这个可以通过段选择符中的 TI 字段表示。当 TI 为 0，表示用 GDT；当 TI 为 1，表示用 LDT。  </p>
<p>GDT 在内存中的地址和大小存放在 CPU 的 GDTR 控制寄存器中，而 LDT 则保存在 LDTR 寄存器中。下面给出一张逻辑地址转线性地址的过程图解（只有 GDT 的过程，LDT 类似）：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/11/09/xJr.png" alt="保护模式的分段">  </p>
<ol>
<li>首先需要给定一个完整的逻辑地址，包含段选择符和段内偏移地址。  </li>
<li>然后查看段选择符的 TI 字段的值，确定当前要转换的是 GDT 中的段还是 LDT 中的段。找到对应的寄存器，从寄存器中取出 GDT 或者 LDT 的内存地址和大小。 </li>
<li>根据段选择符的索引值查找 GDT 或者 LDT 表，找到对应的段描述符，这样就拿到基地址了。  </li>
<li>将 Base + offset，就得到了线性地址了。</li>
</ol>
<h2 id="Linux-的段式管理"><a href="#Linux-的段式管理" class="headerlink" title="Linux 的段式管理"></a>Linux 的段式管理</h2><p>Intel 要求进行两次转换，这样做虽然兼容，但是却很冗余。某些硬件平台并没有二次转换的概念，因此 Linux 需要提供一个高层的抽象来提供统一的界面。  </p>
<p>按照 Intel 的本意，全局的用 GDT，每个进程自己自己的用 LDT。但是 Linux 则对所有的进程都使用了相同的段来对指令和数据寻址，即用户代码段、用户数据段，内核中的是内核代码段、内核数据段。查看 Linux 内核关于 i386 架构的段定义（include&#x2F;asm-i386&#x2F;segment.h）：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ENTRY_DEFAULT_USER_CS           14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ENTRY_DEFAULT_USER_DS           15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ENTRY_KERNEL_BASE               12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ENTRY_KERNEL_CS                 (GDT_ENTRY_KERNEL_BASE + 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ENTRY_KERNEL_DS                 (GDT_ENTRY_KERNEL_BASE + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)</span></span><br></pre></td></tr></table></figure>

<p>将其中的值计算得出：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_CS 115       <span class="comment">// 00000000 1110  0  11</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_DS 123       <span class="comment">// 00000000 1111  0  11</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_CS 96      <span class="comment">// 00000000 1100  0  00</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_DS 104     <span class="comment">// 00000000 1101  0  00</span></span></span><br></pre></td></tr></table></figure>

<p>这样可以计算出索引值和 TI 字段的值：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__USER_CS               index = 14   TI = 0</span><br><span class="line">__USER_DS               index = 15   TI = 0</span><br><span class="line">__KERNEL_CS             index = 12   TI = 0</span><br><span class="line">__KERNEL_DS             index = 13   TI = 0</span><br></pre></td></tr></table></figure>

<p>TI 均为 0，表示都使用了 GDT，再查看初始化 GDT 的内容中对应的 12 到 15 项（arch&#x2F;i386&#x2F;head.S）：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.quad 0x00cf9a000000ffff        /* 0x60 kernel 4GB code at 0x00000000 */</span><br><span class="line">.quad 0x00cf92000000ffff        /* 0x68 kernel 4GB data at 0x00000000 */</span><br><span class="line">.quad 0x00cffa000000ffff        /* 0x73 user 4GB code at 0x00000000 */</span><br><span class="line">.quad 0x00cff2000000ffff        /* 0x7b user 4GB data at 0x00000000 */</span><br></pre></td></tr></table></figure>

<p>将它们的值展开，发现第 16 到 31 位全是 0，即这四个段的基地址都是 0。按照地址转换公式，0 + 段内偏移得到线性地址。因此可以得出一个重要的结论，<strong>在 Linux 下，逻辑地址与线性地址总是一致的（是一致，不是相同）。</strong>  </p>
<blockquote>
<p>在 x86 体系中，分段机制是必选的，而分页机制可由具体的操作系统选择，Linux 通过让段的基地址为 0 而巧妙的绕过了基地址，在 32 位平台上，线性地址的大小固定为 4GB，由于采用了保护机制，Linux 将这 4GB 分为了两部分，地址较高的 1GB（0xC0000000 到 0xFFFFFFFF）为共享的内核空间；而地址较低的 3GB（0x00000000 到 0xBFFFFFFF）为每个进程的用户空间。  </p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://bbs.chinaunix.net/thread-2083672-1-1.html">我理解的逻辑地址、线性地址、物理地址和虚拟地址(补充完整了)</a>  </p>
</blockquote>
<blockquote>
<p><a href="http://www.cnblogs.com/chenwb89/p/operating_system_002.html">操作系统篇-浅谈实模式与保护模式</a>  </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html">操作系统篇-分段机制与GDT|LDT</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解分布式系统与时钟</title>
    <url>/2020/08/04/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<p>分布式系统中，不同节点的物理时钟很难实现完全一致，即使我们给所有节点一个相同的起始时间，在经过一段时间后，节点之间的物理时钟也有很大可能会出现不一致。导致这种问题的根本原因是由于计算机的时钟是通过晶体振荡器实现的。晶体振荡器在通电后，内部的石英晶体会产生谐振，这种震荡的频率是稳定和精确的，比如为 10 MHz，处理器可以根据晶振的波形（震荡的次数）来计算时间。但是由于晶振的频率会受到温度变化的影响，因此机器工作时的温度变化会导致时钟过快或过慢，从而影响时钟的准确性。</p>
<span id="more"></span>

<p>选用高精度的晶振固然可以减缓这个问题，但是高精度的晶振同样成本也高。而采用 NTP 时钟同步虽然可以矫正时间，但是由于网络延迟、同步频率等因素的影响，各个节点的物理时钟还是很难保持精确一致。</p>
<p>当应用程序需要协作时，它们通过交换信息来协调它们的动作，而密切的协作通常取决于对程序动作发生时间的共识，达成共识的前提是我们需要知道一个事件发生的时间，也就是时间序列或者时间戳。在单体应用中，时间序列的获取是很容易的，即使计算机的时间与真实时间有出入，但是只要在一个计算机内，不同的进程获取的时间序列之间的顺序性是可以保证的（不考虑时钟回拨）；而在分布式应用中，不同机器的时钟很可能不同，并且我们也很难通过普通的手段实现多节点之间的时钟同步，这样也就无法确定系统中事件发生的顺序。</p>
<p>然而实际在很多应用中，机器不一定要求跟实际时间相一致，只需要所有的机器具有相同的时间就够了。或者更进一步来说，分布式应用中节点的交互只要在事件发生的顺序上达成共识即可，不需要对事件发生的时间达成共识。</p>
<h1 id="Lamport-逻辑时钟"><a href="#Lamport-逻辑时钟" class="headerlink" title="Lamport 逻辑时钟"></a>Lamport 逻辑时钟</h1><p>1978 年 Lamport 在《Time, Clocks and the Ordering of Events in a Distributed System》中提出了逻辑时钟的概念，通过判断事件的因果关系来决定事件的先后顺序。</p>
<h2 id="偏序（Partial-Ordering）"><a href="#偏序（Partial-Ordering）" class="headerlink" title="偏序（Partial Ordering）"></a>偏序（Partial Ordering）</h2><p>在论文中，作者将事件序列分为了两种：偏序事件序列和全序事件序列。所谓偏序指的是只为系统中的部分事件定义先后顺序，这里的部分事件指的是具有因果关系的事件，这种因果关系可以理解为在分布式系统中节点是否存在交互，同时根据这种因果关系可以将事件分为三类，一类发生在节点（或者进程）内部的事件，一类是发送消息的事件，一类是接收消息的事件。同时作者还定义了一种叫做 happened before 的偏序关系，这种关系具有以下几个规则：</p>
<ol>
<li>如果事件 a 和事件 b 在同一个进程中发生，并且 a 在 b 之前发生，那么记作 <code>a -&gt; b</code>。</li>
<li>如果事件 a 是发送消息，事件 b 是接收该消息，那么 a 在 b 之前发生（消息的传递需要时间），记作 <code>a -&gt; b</code>。</li>
<li>如果 <code>a -&gt; b</code>，并且 <code>b -&gt; c</code>，那么 <code>a -&gt; c</code>。另外如果两个事件 a 和 b 既不满足 <code>a -&gt; b</code>，也不满足 <code>b -&gt; a</code>，那么可以说两个事件是并发（concurrent）的。</li>
</ol>
<p>实际上，在分布式系统中，只有两个发生关联（进行过数据交换）的事件，我们才会去关心两者发生的先后顺序，而对于不存在交互的并发事件，我们可以不用考虑它们的时序问题。</p>
<h2 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h2><p>Lamport 逻辑时钟是一个单调增长的软件计数器，它的值与任何物理时钟无关。这个逻辑时钟的规则如下：</p>
<ol>
<li>每个节点在本地维护一个 logic clock 记作 LC<sub>i</sub>，每个事件对应一个 Lamport Timestamp，初始值为 0。</li>
<li>如果事件在节点内发生，则本地时间戳加 1，即 LC<sub>i</sub> &#x3D; LC<sub>i</sub> + 1。</li>
<li>如果事件是发送事件，那么本地时间戳加 1，并在消息中带上该时间戳。</li>
<li>如果事件是接收事件，那么在收到消息后 LC<sub>j</sub> &#x3D; max(LC<sub>j</sub>, 消息中的时间戳) + 1。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008061549/2020/08/05/qEO.png" alt="逻辑时钟，来源于 wikipedia"></p>
<p>通过这种算法，可以保证如果 a -&gt; b，那么 C(a) &lt; C(b)，但是无法通过比较两个逻辑时钟的大小来得到 a 和 b 的先后顺序，比如下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008061549/2020/08/05/4q6.png" alt="逆命题不成立"></p>
<p>逻辑时间为 56 的事件向另一个事件发送消息，从而得到另一个事件的逻辑时间为 62，尽管它的逻辑时间小于 61，但是它却是在逻辑时间为 61 的事件之后发生的。</p>
<h2 id="全序（Total-ordering）"><a href="#全序（Total-ordering）" class="headerlink" title="全序（Total ordering）"></a>全序（Total ordering）</h2><p>通过定义，我们知道如果 a -&gt; b，那么 C(a) &lt; C(b)，但是如果 C(a) &#x3D; C(b) 的时候，a 与 b 应该是什么先后顺序呢？由于它们肯定不是因果关系，所以它们之间的先后顺序其实并不会影响结果，我们只需要给出一种确定的方式来定义它们之间的先后顺序，就可以得到一个全序关系。一种可行的方式是给进程编号，并根据进程编号的大小来排序。在上图中我们假设进程 A、B、C 的编号分别为 1、2、3，那么虽然 C(B4) &#x3D; C(C3)，但是由于 B 的编号小于 C，所以它们的先后顺序是 B4 -&gt; C3。但是从上图还会发现，从时间轴来看 B5 应该早于 A3 发生，但是我们给出的全序关系中 A3 却是早于 B5 的，<strong>这是因为 Lamport 逻辑时钟只能保证因果关系的正确性，无法保证时序的正确性。同时全序关系也不是唯一的，与选定的方式有关。</strong></p>
<h1 id="向量时钟（Vector-Clock）"><a href="#向量时钟（Vector-Clock）" class="headerlink" title="向量时钟（Vector Clock）"></a>向量时钟（Vector Clock）</h1><p>Vector Clock 是在 Lamport 逻辑时钟的基础上演进的另一种逻辑时钟算法，它使用 Vector 结构不光记录本节点的 Lamport 时间戳，同时还会记录其他节点的 Lamport 时间戳。具体来说，每个节点都维护一个向量 VC，同时在这个向量中：VC<sub>i</sub>[i] 是到目前为止节点 i 上发生的事件的个数，而 VC<sub>i</sub>[k] 则为节点 i 知道节点 k 中发生的事件的个数。向量时钟通过以下算法进行更新：</p>
<ol>
<li>节点 i 本地发生的事件会将 VC<sub>i</sub> 加 1。</li>
<li>节点 i 给节点 j 发送消息时，会将整个 VC<sub>i</sub> 存在消息中。</li>
<li>节点 j 收到消息后，VC<sub>j</sub>[k] &#x3D; max(VC<sub>j</sub>[k], VC<sub>i</sub>[k])，同时 VC<sub>j</sub>[j] 加 1。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008061549/2020/08/06/xdq.png" alt="Vector Clock"></p>
<h2 id="为什么使用向量时钟"><a href="#为什么使用向量时钟" class="headerlink" title="为什么使用向量时钟"></a>为什么使用向量时钟</h2><p>对于一个数据库系统（或者存储系统）来说，需要一种机制来界定事务或者操作的先后顺序，如果是单机数据库，可以在事务提交时通过获取时间戳作为事务 ID，时间戳小的事务即为更早提交的事务。而到了分布式系统中，如果是单点写，则同样可以沿用这种方式；但是如果是一个支持多点写的系统，那么机器之间必然存在时钟误差，如果多个节点对同一条记录进行修改，那么就有可能出现在 wall time 上先提交的事务的 ID 反而更小，此时就可以通过向量时钟来处理这种冲突。</p>
<p>2007 年亚马逊的一篇论文：<a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf">Dynamo: Amazon’s Highly Available Key-value Store</a> 提到了亚马逊的 Dynamo 使用了 Vector Clock（Version Clock），但似乎在很早的时候就已经摒弃了这种做法。原因可能与向量时钟的缺陷有关，首先每次请求都要先向对方获取一次版本，这在性能上不好接受。向量时钟只能帮助发现冲突，但无法解决冲突。Cassandra 之前就发表过一篇文章：<a href="https://www.datastax.com/blog/2013/09/why-cassandra-doesnt-need-vector-clocks">Why Cassandra doesn’t need vector clocks</a> 说明了他们为何没有使用向量时钟。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">《Time, Clocks and the Ordering of Events in a Distributed System》</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/foxmailed/p/4985848.html">Vector Clock&#x2F;Version Clock</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.zhihu.com/question/19994133">分布式数据库中为什么要使用 Vector Clock？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>类文件结构</title>
    <url>/2018/04/18/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h1><p>由于计算机只能识别 0 和 1，所以我们写的程序需要经过编译器编译成二进制格式的本地机器码（Native Code）。本地机器码依赖于平台，不同平台编译成的机器码不同。Java 打破了这种模式，加入了 Java 虚拟机这个中间者。我们只要将写好的代码经过 Java 的编译器编译，就会生成能够被 Java 虚拟机理解的 class 文件，只要任意平台安装有 Java 虚拟机，就能够执行这个编译后的 class 文件。  </p>
<span id="more"></span>

<p>Java 虚拟机除了一个平台无关性，还有一个重要的特性就是语言无关性。不光是 Java，任意语言编写的程序，只要能够经过编译器编译成被 Java 虚拟机认可的 class 文件，就都可以在 Java 虚拟机上运行。时至今日，已经有大批能够在 JVM 上运行的语言和一些能够将某种语言程序翻译成 class 文件的解释器、编译器，如：Groovy、JRuby、Jython、Scala、Kotlin 等。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/19/2W2.png" alt="其他语言与虚拟机 "></p>
<h1 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h1><p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑排列在 Class 文件中，中间没有任何分隔符。当遇到需要占用 8 位字节以上的数据项时，使用 Big-Endian 方式分割成若干个 8 位字节存储。  </p>
<p>根据 Java 虚拟机规范，Class 文件格式采用一种类似于 C 语言的结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表。  </p>
<p>无符号数是基本的数据类型，以 <code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code> 分别表示 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成的字符串值。  </p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表习惯性的以“_info”结尾。<strong>整个 Class 文件本质上就是一张表</strong>，它由以下数据项构成。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count -1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h2 id="魔数与-Class-文件的版本"><a href="#魔数与-Class-文件的版本" class="headerlink" title="魔数与 Class 文件的版本"></a>魔数与 Class 文件的版本</h2><p>每个 Class 文件的头部都有 4 个字节称为魔数（Magic Number），值为 <code>0xCAFEBABE</code>，它的唯一作用是确定整个文件是否为一个能被虚拟机接受的 Class 文件。  </p>
<p>紧接着魔数的是 Class 文件的版本号，第 5 个字节是 <code>Minor Version</code>（次版本号），第 6 个字节是 <code>Major Version</code>（主版本号）。Java 的版本号是从 45 开始的，JDK 1.1 之后每个 JDK 大版本发布，主版本号加 1。高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件。如：JDK 1.1 能支持版本号为 45.0 ~ 45.65535 的 Class 文件，但不能运行版本号为 46.0 以上的 Class 文件，即使文件格式并未发生变化。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/19/Vnr.png" alt="class 文件 "></p>
<p>其中 CAFEBABE 是魔数，0000 是次版本号，0034 是主版本号（JDK 8）。  </p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要设置一个 <code>u2</code> 类型的数据用来表示常量池的计数值 <code>constant_pool_count</code>，这个值从 1 开始计算，设计者将第 0 项空出来是为了满足后边某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这个情况就可以把索引值用 0 表示。  </p>
<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。字面量类似于 Java 语言层面的常量概念，如声明为 final 的常量值等。符号引用则属于编译原理方面的概念，包含三类常量：  </p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）  </li>
<li>字段的名称和描述符（Descriptor）  </li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中的每一项常量都是一个表，在 JDK 7 之前共有 11 种结构不同的表，在 JDK 7 中为了更好的支持动态语言调用，又增加了 3 种。这 14 种表有一个共同的特点，表开始的第一位是一个 <code>u1</code> 类型的标志位，代表当前这个常量的类型。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/20/yMJ.png" alt="常量池 "></p>
<p>其中 <code>CONSTANT_Utf8_info</code> 类型的常量，它的 <code>length</code> 值说明了这个 UTF-8 编码的字符串长度是多少字节，<code>bytes</code> 的值为长度为 <code>length</code> 字节的 UTF-8 缩略编码表示的字符串。由于 Class 文件中方法、字段等都需要引用 <code>CONSTANT_Utf8_info</code> 型常量来描述名称，所以 <code>CONSTANT_Utf8_info</code>  型常量的最大长度也就是 Java 中方法、字段名的最大长度，即 <code>u2</code> 的 65535，也就是说最大 65535 字节，即 64KB。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/20/zPk.png" alt="Test.class"></p>
<p>如上 Test.class 文件，可以看到 <code>constant_pool_count</code> 的值为 <code>0x0020</code>，即 32，说明该类文件中一共有 31 个常量项。我们可以使用 JDK 提供的分析 Class 文件字节码的工具 <code>javap</code> 来查看类文件信息：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/20/xRg.png" alt="javap"></p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池之后的 2 个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，如一个 Class 是类还是接口；是否定义为 public 类型等等。  </p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为 public 类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否声明为 final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用 <code>invokespecial</code> 字节码指令的新语义。 <code>invokespecial</code> 指令的语义在 JDK 1.0.2 发生过改变，为了区别这条指令使用哪种语义，JDK 1.0.2 之后编译出来的类的这个标志都必须为真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为 abstract 类型，对于接口或者抽象类来说，这个标志值为真，其他为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识这个类并非由用户代码产生</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这是一个枚举</td>
</tr>
</tbody></table>
<p>如上 Test.class 文件，它是一个普通的类，使用 <code>public</code> 声明，使用 JDK 8 编译，因此 <code>access_flags</code> 的值应该为 <code>0x0021</code>。  </p>
<h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><p>类索引（this_class）和父类索引（super_class）都是一个 <code>u2</code> 类型的数据，接口索引集合（interfaces）是一个 <code>u2</code> 类型的数据的集合，Class 文件中这三项来确定这个类的继承关系。  </p>
<ul>
<li><p>类索引用于确定这个类的全限定名。  </p>
</li>
<li><p>父类索引用于确定这个类的父类的全限定名，由于 Java 不允许多继承，因此除了 <code>java.lang.Object</code> 外，所有的类都有父类，即所有的类的父类索引都不为 0。  </p>
</li>
<li><p>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按照 <code>implements</code>（如果类本身是接口，则为 <code>extends</code>）的顺序排列在接口索引集合中。</p>
</li>
</ul>
<p>类索引和父类索引用两个 <code>u2</code> 类型的索引值表示，它们各自指向一个 <code>CONSTANT_Class_info</code> 类型的类描述符常量，通过 <code>CONSTANT_Class_info</code> 类型的常量中的索引值可以在 <code>CONSTANT_Utf8_info</code> 类型的常量中找到全限定名字符串。  </p>
<p>索引查找过程过程如下：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/20/rRb.png" alt="索引查找过程 "></p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表（field_info）用于描述接口或类中声明的变量。字段（field）包括类变量以及实例变量（成员变量），但不包括方法内声明的局部变量。  </p>
<p>我们可以想想 Java 中一个字段可以包含的信息：字段的作用域（public、private、protected）、是成员变量还是类变量（static）、可变性（final）、并发可见性（volatile）、是否可序列化（transient）、字段数据类型（基本类型、对象、数组）、字段名称。上述信息，字段名和字段类型是不固定的，只能用常量池中的常量表示，其他修饰符都是布尔值，很适合用标志位表示。  </p>
<p>字段表结构：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>access_flags 项目：  </p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否是 public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否是 private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否是 protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否是 static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否是 final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否是 volatile</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>字段是否是 transient</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>字段是否由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否是 enum</td>
</tr>
</tbody></table>
<p><code>name_index</code> 和 <code>descriptor_index</code> 分别代表字段的简单名称（没有类型和参数修饰的方法或字段名称）和字段、方法的描述符，它们都是对常量池的引用。  </p>
<p>描述符标识字符及含义：  </p>
<table>
<thead>
<tr>
<th>标识字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本类型 byte</td>
</tr>
<tr>
<td>C</td>
<td>基本类型 char</td>
</tr>
<tr>
<td>D</td>
<td>基本类型 double</td>
</tr>
<tr>
<td>F</td>
<td>基本类型 float</td>
</tr>
<tr>
<td>I</td>
<td>基本类型 int</td>
</tr>
<tr>
<td>J</td>
<td>基本类型 long</td>
</tr>
<tr>
<td>S</td>
<td>基本类型 short</td>
</tr>
<tr>
<td>Z</td>
<td>基本类型 boolean</td>
</tr>
<tr>
<td>V</td>
<td>特殊类型 void</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，如 <code>Ljava/lang/Object</code></td>
</tr>
</tbody></table>
<p>对于数组类型，每一个纬度将使用一个前置的“[”字符描述，如一个定义为 <code>java.lang.String[][]</code> 类型的数组将被记录为：<code>[[Ljava/lang/String</code>，一个整型数组 <code>int[]</code> 将被记录为 <code>[I</code>。  </p>
<p>用描述符描述方法时，按照先参数列表后返回值的顺序。如：  </p>
<ul>
<li>方法 <code>void fn()</code> 的描述符为 <code>()V</code>  </li>
<li>方法 <code>java.lang.String toString()</code> 的描述符为 <code>()Ljava/lang/String</code>  </li>
<li>方法 <code>int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)</code> 的描述符为<code>([CII[CIII)I</code></li>
</ul>
<p>字段表集合中不会列出从超类或接口继承而来的字段，但有可能列出原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来说，如果两个字段的描述符不一致，那么字段重名是合法的。  </p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>方法表与字段表几乎一样。  </p>
<p>方法表结构：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>访问标志：  </p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>方法是否是 public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>方法是否是 private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>方法是否是 protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>方法是否是 static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>方法是否是 final</td>
</tr>
<tr>
<td>ACC_SYNCHRONIZED</td>
<td>0x0020</td>
<td>方法是否是 synchronized</td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td>0x0040</td>
<td>方法是否是由编译器产生的桥接方法</td>
</tr>
<tr>
<td>ACC_VARARGS</td>
<td>0x0080</td>
<td>方法是否接受不定参数</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td>0x0100</td>
<td>方法是否为 native</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>方法是否是 abstract</td>
</tr>
<tr>
<td>ACC_STRICTFP</td>
<td>0x0800</td>
<td>方法是否是 strictfp</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>方法是否由编译器自动产生</td>
</tr>
</tbody></table>
<p>如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。同时，方法表中也可能会出现由编译器自动添加的方法，典型的就是类构造器 <code>&lt;clinit&gt;</code> 方法和实例构造器 <code>&lt;init&gt;</code> 方法（当一个类中存在静态成员或静态代码块时才会生成类构造器 <code>&lt;clinit&gt;</code> 方法；<code>&lt;init&gt;</code> 方法是在一个类进行对象实例化时调用的。实例化一个类有四种途径：调用 new 操作符；调用 Class 或 <code>java.lang.reflect.Constructor</code> 对象的 newInstance() 方法；调用任何现有对象的 clone() 方法；通过 <code>java.io.ObjectInputStream</code> 类的 getObject() 方法反序列化）。  </p>
<p>在 Java 语言中重载一个方法，除了方法名相同外，还需要方法的特征签名（即各个参数在常量池中的字段符号引用的集合）一致，但是在字节码中，特征签名的范围更大一些，只要描述符不完全一致的两个方法也可以共存，即如果两个方法有相同的名称和特征签名，但是返回值不同，它们也可以合法共存于一个 Class 中。  </p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>在 Class 文件、字段表、方法表中都有属性表集合（attribute_info），用于描述某些场景的专有信息。  </p>
<p>与 Class 文件中其他数据项目要求严格的顺序、长度和内容不同，属性表集合不再要求严格的顺序，只要不与已经存在的属性名重复，任何实现的编译器都可以向属性表中写入自定义的属性信息，虚拟机运行时会忽略掉它不认识的属性。为了能正确解析 Class 文件，虚拟机规范预定义了一些属性。  </p>
<p>属性表结构：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
</tr>
</tbody></table>
<p>上述是一个符合虚拟机规范的属性表，对于每个属性，它的名称要从常量池中引用 <code>CONSTANT_Utf8_info</code> 类型的常量来表示，属性值的结构则完全自定义，只通过一个 <code>u4</code> 的长度属性说明属性值所占位数。  </p>
<p>一些常用的属性：  </p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>Java 代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final 关键字定义的常量值</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类、方法表、字段表</td>
<td>被声明为 <code>deprecated</code> 的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClasses</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code 属性</td>
<td>Java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code 属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code 属性</td>
<td>JDK 6 新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类、方法表、字段表</td>
<td>JDK 5 新增的属性，用于支持泛型情况下的方法签名，在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。由于 Java 的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>JDK 6 新增属性，用于存储额外的调试信息。譬如在进行 JSP 文件调试时，无法通过 Java 堆栈来定位到 JSP 文件的行号，JSR-45 规范为这些非 Java 语言编写，却需要编译成字节码并运行在 Java 虚拟机中的程序提供了一个进行调试的标准机制，使用该属性就可以存储这个标准所新加入的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类、方法表、字段表</td>
<td>表示方法或字段是由编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>JDK 5 新增属性，它使用特征签名代替描述符，为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类、方法表、字段表</td>
<td>JDK 5 新增属性，为动态注解提供支持。该属性指明哪些注解是运行时（实际上运行时就是进行反射调用）可见的</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>类、方法表、字段表</td>
<td>JDK 5 新增属性，与 <code>RuntimeVisibleAnnotations</code> 作用相反，用于指明哪些注解运行时不可见</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotations</td>
<td>方法表</td>
<td>JDK 5 新增属性，作用与 <code>RuntimeVisibleAnnotations</code> 作用相似，只不过作用对象为方法参数</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotations</td>
<td>方法表</td>
<td>JDK 5 新增属性，作用与 <code>RuntimeInvisibleAnnotations</code> 作用相似，只不过作用对象为方法参数</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>JDK 5 新增属性，用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>JDK 7 新增属性，用于存储 <code>invokedynamic</code> 指令引用的引导方法限定符</td>
</tr>
</tbody></table>
<h3 id="Code-属性"><a href="#Code-属性" class="headerlink" title="Code 属性"></a>Code 属性</h3><p>Java 代码经过编译后最终编程字节码指令存储在 Code 属性内，Code 属性在方法表的属性集合中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类就不存在 Code 属性。  </p>
<p>Code 属性表结构：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_table_length</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p><code>attribute_name_index</code> 是指向 <code>CONSTANT_Utf8_info</code> 型常量的索引，常量值为 <code>Code</code>  </p>
<p><code>attribute_length</code> 为属性值的长度  </p>
<p><code>max_stack</code> 为操作数栈的最大深度  </p>
<p><code>max_locals</code> 代表局部变量表所需的存储空间，这里的单位是 <code>Slot</code>，是虚拟机为局部变量分配内存使用的最小单位，对于 <code>byte</code>、<code>char</code>、<code>float</code>、<code>int</code>、<code>short</code>、<code>boolean</code> 和 <code>returnAddress</code> 等长度不超过 32 位的数据类型使用一个 <code>Slot</code>，<code>double</code> 和 <code>long</code> 使用两个 <code>Slot</code>。  </p>
<p><code>code_length</code> 是编译后字节码指令长度，<code>code</code> 则是存储的字节码指令。既然叫字节码指令，那么每个指令就是一个 <code>u1</code> 类型的单字节，一个 <code>u1</code> 类型的取值范围为 <code>0x00</code>~&#96;0xFF&#96;，对应十进制的 0 到 255，所以一共能够表示 256 条指令，Java 虚拟机已经定义了 200 多条编码值对应的指令。  </p>
<p><code>exception_table</code> 是显式异常处理表。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>start_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>end_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>handler_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>catch_type</td>
<td>1</td>
</tr>
</tbody></table>
<p>它的含义为：如果字节码在第 <code>start_pc</code> 行到第 <code>end_pc</code> 之间出现了类型为 <code>catch_type</code> 或者其子类的异常（<code>catch_type</code> 是一个指向 <code>CONSTANT_Uft8_info</code> 型常量的索引），则转到第 <code>handler_pc</code> 行继续处理。当 <code>catch_type</code> 值为 0 时，代表任意异常情况都需要转到 <code>handler_pc</code> 行进行处理。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自旋锁</title>
    <url>/2020/05/22/%E8%87%AA%E6%97%8B%E9%94%81/</url>
    <content><![CDATA[<p>我们可以把锁理解成门票，只有当线程拿到了门票才能进入临界区。我们可以用一个状态变量 state 表示锁，当 state 为 true 时就表示已经获取到了锁，为 false 时就表示锁已经被其他线程占用。那么当锁被占用时，应该怎么处理？基本上有两种思路，其中一种就是循环检测直到锁可用，也就是自旋锁；另一种就是让出 CPU 时间片，等待唤醒通知。这里主要讨论自旋的算法，为深入学习 AQS 做铺垫。</p>
<span id="more"></span>

<h1 id="TAS-Lock"><a href="#TAS-Lock" class="headerlink" title="TAS Lock"></a>TAS Lock</h1><p>自旋锁中最简单的一种实现就是 TAS Lock（Test And Set Lock）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TASLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.state.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 getAndSet 方法是通过 CAS 的方式自旋设置新值，当新值设置成功后才会返回，返回的值是之前的旧值。因此这里的 lock 方法只有在之前的值为 false 时才会返回，不然会一直自旋等待。也就是说当一个线程调用了 lock 方法后，其他线程再调用 lock 方法就会在此处自旋，直到该线程调用 unlock 方法后，其他线程才有可能退出自旋拿到锁。这种实现方式是在 CAS 操作上自旋，由于 AtomicBoolean 中维护的真实值是用 volatile 修饰的，为了可见性，该变量的修改和获取都需要通过总线与主存交互，CAS 操作一直在修改它的值，这会引发缓存一致性的流量风暴，从而占用总线资源。</p>
<h1 id="TTAS-Lock"><a href="#TTAS-Lock" class="headerlink" title="TTAS Lock"></a>TTAS Lock</h1><p>一种针对 TAS Lock 的改进就是 TTAS Lock（Test Test And Set Lock）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TTASLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 自旋在读操作，当 state 的值为 false 时才退出</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">this</span>.state.get()) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.state.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式最大的改进就是将自旋放在了获取 state 上，这样不会引发缓存一致性的流量风暴，但是每次获取 state 值的时候还是需要到主存中去读取。</p>
<h1 id="Anderson’s-Lock"><a href="#Anderson’s-Lock" class="headerlink" title="Anderson’s Lock"></a>Anderson’s Lock</h1><p>TAS 和 TTAS 都是基于一个状态变量来标识锁，所有的线程都需要轮询此变量的状态，这才会导致频繁占用总线流量。如果每个线程都有一个自己的状态，那么就可以大幅度的减少总线占用。Anderson’s lock 就是一个使用类似思想实现的锁，它基于数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ALock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flags[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// tail 本质上代表的是在数组上等待的最后一个线程</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; slot = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ALock</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = capacity;</span><br><span class="line">        <span class="built_in">this</span>.flags = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="built_in">this</span>.size];</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.flags[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程状态的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.tail.getAndIncrement() % <span class="built_in">this</span>.size;</span><br><span class="line">        <span class="built_in">this</span>.slot.set(index);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.flags[index]) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程状态的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.slot.get();</span><br><span class="line">        <span class="comment">// 复用</span></span><br><span class="line">        <span class="built_in">this</span>.flags[index] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 通知下一个线程</span></span><br><span class="line">        <span class="built_in">this</span>.flags[(index + <span class="number">1</span>) % <span class="built_in">this</span>.size] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock 方法会先计算出当前线程状态的位置并将它放到线程本地变量中，然后自旋判断状态，只有当前线程的状态为已经获取到锁（true）时才会退出。unlock 方法会通过线程本地变量获取当前线程状态的位置，然后修改状态为空闲（false），目的是为了其他的线程可以再次使用该位置。接着需要“唤醒”下一个等待的线程，即改变下一个线程的状态为已经获取到了锁。</p>
<p>可以看到，这种方式使用了一个线程共享的数组来存储每个线程的状态（是否获取到了锁），每个线程在自己的工作内存中都有一份该数组的拷贝。线程在获取锁时，只会在自己副本上的特定位置自旋。与 TTAS 相比，能够减少总线的占用，同时这种方式也形成了一个类似 FIFO 的队列，可以保证线程获取锁的公平性。当然缺点也很明显，就是数组长度固定，且空间效率不高，它为每个锁都分配了大小为 size 的数组，如果需要同步 N 个不同的对象就需要分配 N * size 的内存空间，即使线程一次仅访问一个锁。在无缓存的 NUMA 架构中，该算法的性能不佳，因为 lock 可能会在远程变量上自旋。</p>
<h1 id="CLH-Lock"><a href="#CLH-Lock" class="headerlink" title="CLH Lock"></a>CLH Lock</h1><p>CLH（Craig, Landin, and Hagersten）Lock 可以看作是 Anderson’s Lock 的改进和优化，从结构上看，它是一个虚拟的单向链表（之所以说是虚拟的，或者说是隐式的，是指节点本身并不持有下一个节点）。线程在获取锁时会在它的前驱节点上自旋，当前驱节点的锁释放，该线程就获取到了锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> &#123;</span><br><span class="line">    <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Node&gt; prev;</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Node&gt; node;</span><br><span class="line">    <span class="comment">// 队列的最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Node&gt; tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CLHLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.node = ThreadLocal.withInitial(Node::<span class="keyword">new</span>);</span><br><span class="line">        <span class="built_in">this</span>.prev = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.node.get();</span><br><span class="line">        node.locked = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 设置当前节点为队列的最后一个节点，同时获取前一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="built_in">this</span>.tail.getAndSet(node);</span><br><span class="line">        <span class="comment">// 将当前节点的前驱节点设置为在这之前队列的最后一个节点</span></span><br><span class="line">        <span class="built_in">this</span>.prev.set(prev);</span><br><span class="line">        <span class="comment">// 在前驱节点上自旋</span></span><br><span class="line">        <span class="keyword">while</span> (prev.locked) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.node.get();</span><br><span class="line">        node.locked = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.node.set(<span class="built_in">this</span>.prev.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202005222243/2020/05/22/3qP.png" alt="CLH"></p>
<p>与 Anderson’s Lock 相比，它最大的优点就是空间效率高，但是同样的，它还是具有与 Anderson’s Lock 相同的缺点，那就是在 NUMA 架构中性能不佳。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.csd.uoc.gr/~hy586/material/lectures/cs586-Section3.pdf">Section 3 Practice: Spin Locks and Contention</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机的类加载机制</title>
    <url>/2020/06/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。Java 类型的加载、连接和初始化都是在程序运行期间完成的，这种方式虽然会增加类加载时的性能开销，但是能够为 Java 应用提供更好的灵活性，Java 天生可以动态扩展的语言特性就是依靠运行期动态加载和动态连接这个特点实现的。例如，我们编写一个面向接口的应用，可以等到运行时再指定它的实现类；我们可以通过 Java 预定义的或者我们自定义的类加载器，从网络或者其他地方加载一个二进制的流作为应用程序代码的一部分。</p>
<span id="more"></span>

<h1 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h1><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备和解析三个部分又统称为连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202006091622/2020/06/08/jrY.png" alt="类加载过程"></p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（动态绑定或晚期绑定）。需要注意的是，这里说的是按部就班地开始而不是进行或者完成，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用激活另一个阶段。</p>
<p>什么情况下需要开始类加载过程的第一个阶段：加载？Java 虚拟机规范中并没有进行强制约束，因此这由虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机返回则严格规定了有且只有五种情况必须立即对类进行初始化（加载、验证、准备阶段自然已经完成）。</p>
<p>(1) 在遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这四条字节码指令时，如果类没有进行初始化，则需要先触发初始化操作。生成这四条指令的常见场景就是：使用 new 关键字实例化对象的时候、读取或者设置一个类的静态字段（被 final 修饰、已经在编译器把结果放进常量池的静态字段除外）的时候、以及调用一个类的静态方法的时候。</p>
<p>(2) 在使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，需要先进行初始化。</p>
<p>(3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，需要先触发其父类的初始化操作。</p>
<p>(4) 当虚拟机启动时，用户需要指定一个执行的主类，即包含 main 方法的那个类，虚拟机会先初始化该类。</p>
<p>(5) 当一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先进行初始化。</p>
<p>这五种会触发类初始化的场景中的行为称为对一个类的主动引用，其他所有的引用方式都不会触发类的初始化，称为被动引用。比如以下代码中，通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化，只有直接定义这个字段的类才会进行初始化。至于是否要触发子类的加载和验证，虚拟机规范中没有明确规定，这取决于虚拟机的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>类加载的全过程，也就是加载、验证、准备、解析和初始化这五个阶段。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，虚拟机需要完成三件事情。首先需要通过一个类的全限定名来获取定义此类的二进制字节流。接着将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。最后在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。对于 HotSpot 虚拟机来说，可以通过设置 <code>-XX:+TraceClassLoading</code> 参数在控制台观察类加载的日志。</p>
<p>虚拟机规范的这三个要求其实不是特别具体，因此虚拟机的实现灵活度很大。比如通过一个类的全限定名来获取定义此类的二进制字节流这一项，并没有规定二进制字节流非要从一个 Class 文件中获取，我们可以从 ZIP 包中读取，这也是我们常见的 JAR、EAR、WAR 格式的基础。也可以通过运行时计算生成，最常见的就是动态代理技术，在 java.lang.reflect.Proxy 中，使用 ProxyGenerator.generateProxyClass 方法来为特定接口生成形式为 “*$Proxy” 的代理类的二进制字节流。或者通过其他文件生成，典型的就是 JSP 应用，即通过 JSP 文件生成对应的 Servlet 类。</p>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段是开发人员可控性最强的，因为加载阶段可以使用系统提供的引导类加载器，也可以使用用户自定义的类加载器，开发人员可以通过自定义类加载器去控制字节流的获取方式（重写 loadClass 方法）。而对于数组而言，情况则有所不同，数组类本身不通过类加载器创建，它是由虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的。一个数组类的创建过程遵循以下规则：</p>
<p>(1) 如果数组的组件类型（数组去掉一个维度的类型）是引用类型，那就会采用正常的类加载过程去加载这个组件类型，同时该数组将在加载该组件类型的类加载器的类名称空间上被标识。</p>
<p>(2) 如果数组的组件类型不是引用类型，比如 int[] 数组，那么 Java 虚拟机将会把该数组标记为与引导类加载器相关联。</p>
<p>(3) 数组类的可见性与它的组件类型的可见性保持一致，如果组件类型不是引用类型，那么数组的可见性默认为 public。</p>
<p>加载阶段与连接阶段的部分阶段（比如部分字节码文件的格式验证）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但是这些夹在加载阶段之中进行的动作仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，目的是为了确保 Class 文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致会完成四个阶段的检验动作，包括文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<p>文件格式验证阶段可能会验证包括：是否以魔数 0xCAFEBABE 开头，主次版本号是否在当前虚拟机的处理范围内等等。元数据的验证主要是对字节码描述的信息进行语义分析，包括这个类是否有父类，是否继承了不允许继承的类，这个类是不是抽象类等等。字节码验证最为复杂，主要目的是通过数据流和控制流分析，确定程序语义是否合理合法的。符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的解析阶段发生。符号引用验证可以看作是对类自身以外的信息（常量池中的各种符号引用）进行匹配性校验，通常需要验证包括：符号引用中通过字符串描述的全限定名是否能找到对应的类，符号引用中类、字段和方法是否能被当前类访问（private、protected、public、default）等等。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。需要注意的是，这里所说的初始值通常情况下是数据类型的零值。假设定义一个类变量：<code>public static int value = 1</code>，那么变量 value 在准备阶段过后的初始值为 0 而不是 1，因为把 value 赋值为 1 的 putstatic 指令是程序被编译后，存放于类构造器 <code>&lt;clinit&gt;()</code> 方法之中的，所以把 value 赋值为 1 的动作将在初始化阶段才会进行。在特殊情况下，比如通过 final 修饰的类字段，在准备阶段就会被初始化为指定的值。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能够接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。符号引用在 Class 文件中以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。</p>
<p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同的虚拟机上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载过程的最后一步，在前面的类加载过程中，除了在加载阶段用户程序可以通过自定义类加载器参与之外，其余阶段完全由虚拟机主导和控制，到了初始化阶段才真正开始执行类中定义的 Java 程序代码。<strong>初始化阶段可以看作是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</strong></p>
<p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。<code>&lt;clinit&gt;()</code> 方法与类的构造函数（或者说是实例构造器 <code>&lt;init&gt;()</code> 方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。在虚拟机中，第一个被执行 <code>&lt;clinit&gt;()</code> 方法的类是 <code>java.lang.Object</code>。</p>
<p>如果一个类中没有静态代码块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。接口中不能使用静态代码块，但是接口仍然可以有静态变量（接口中的变量默认都是静态变量）初始化的操作，因此接口与类一样也可以产生 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法，只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确地加锁、同步，如果多线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都会阻塞等待。</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要它们的类加载器不同，那这两个类就不相等。这里的相等包括类的 Class 对象的 equals 方法、isAssignableFrom 方法、isInstance 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p>
<p>从虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器 Bootstrap ClassLoader，这个类加载器使用 C++ 实现，是虚拟机的一部分；另一种就是所有其他的类加载器，这些都是使用 Java 实现的，独立于虚拟机外部，并且都继承自抽象类 <code>java.lang.ClassLoader</code>。从开发人员的角度来讲，类加载器还可以划分得更细致些，包括启动类加载器、扩展类加载器和应用程序类加载器。</p>
<h2 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h2><p>负责将存放在 JAVA_HOME\lib 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机可以识别的（按照文件名识别，如 rt.jar，名称不符合的类库即使放在 lib 目录也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，只需要在 getClassLoader 方法中返回 null 即可。</p>
<h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h2><p>由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现，它负责加载 JAVA_HOME\lib\ext 目录中的，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<h2 id="应用类加载器（Application-ClassLoader）"><a href="#应用类加载器（Application-ClassLoader）" class="headerlink" title="应用类加载器（Application ClassLoader）"></a>应用类加载器（Application ClassLoader）</h2><p>由 <code>sun.misc.Launcher$AppClassLoader</code> 实现，由于这个类加载器是 ClassLoader 中的 getSystemClassLoader 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（比如 java 命令中的 classpath，或者 <code>java.class.path</code> 系统属性，或者 CLASSPATH 操作系统环境变量）指定的类库，开发者可以直接使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下就是用该类加载器。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202006091622/2020/06/09/z1g.png" alt="双亲委派模型"></p>
<p>如果一个类加载器收到了类加载的请求，它首先不会尝试自己加载该类，而是把这个请求委派给父加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递给最顶层的启动类加载器中，只有当父加载器无法完成加载请求时（在它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。</p>
<p>实现双亲委派的代码都集中在 java.lang.ClassLoader 中的 loadClass 方法中，该方法首先会检查类是否已经被加载过，如果没有则调用父加载器的 loadClass 方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父加载器加载失败抛出 ClassNotFoundException 异常，则会再调用自己的 findClass 方法进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用双亲委派的一个优点就是可以防止重复加载某个类。比如 java.lang.Object 类，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都会委派给最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。</p>
<h2 id="“破坏”双亲委派"><a href="#“破坏”双亲委派" class="headerlink" title="“破坏”双亲委派"></a>“破坏”双亲委派</h2><p>由于双亲委派模型是在 JDK 1.2 才引入的，而类加载器和抽象类 java.lang.ClassLoader 在 JDK 1.0 就已经存在了，面对已经存在的用户自定义类加载器的实现代码，Java 设计者在引入双亲委派时不得不做出一些妥协，为了向前兼容，JDK 1.2 在 ClassLoader 中添加了一个新的 protected 方法 findClass。通过之前的源码可以看到，双亲委派的具体逻辑就实现在 loadClass 方法中，因此在 JDK 1.2 之后已经不提倡用户再去覆盖 loadClass 方法了，而应当把自己的类加载逻辑写到 findClass 方法中，这样就可以保证双亲委派不会被破坏。</p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题，基础类一般都是作为被用户代码调用的 API，但是世事没有绝对，如果基础类又要调用回用户的代码，那该怎么办呢？一个典型的例子便是 JNDI 服务，它的代码由启动类加载器去加载，但是 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 CLASSPATH 下的 JNDI 接口提供者（SPI）的代码，但是启动类加载器不可能识别这些代码（不在搜索范围内）。为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader 方法进行设置，如果在创建线程时还未进行设置，那么它会从父线程中继承一个，如果在应用的全局范围内都没有设置过的话，那么这个类加载器（contextClassLoader）默认就是应用程序类加载器。有了这个线程上下文加载器，JNDI 服务就可以使用这个类加载器去加载需要的 SPI 代码，也就是通过父类加载器请求子类加载器去完成类加载的动作，这明显违背了双亲委派模型的一般性原则，但也无可奈何。Java 中涉及 SPI 的加载动作基本上都采用这种方法，比如 JNDI、JDBC 等。</p>
<p>双亲委派模型第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里的动态性是指代码热替换（HotSwap）、模块化等，说白了就是希望我们的应用能像计算机外设那样，即插即用。Sun 公司提出的 JSR-294、JSR-277 规范在与 JCP 组织的模块化规范之争中败给了 JSR-291（即 OSGi R4.2），因此在当时，OSGi 已经成为了业界“事实上”的 Java 模块化标准。然而 Sun 不甘失去对 Java 模块化的控制，一直在独立发展 Jigsaw 项目。后来的结果我们也都知道，Sun 在 2009 年被 Oracle 收购，Jigsaw 也就一起被 Oracle 接收并一直发展。使用 Jigsaw 项目作为核心的 JPMS（The Java Platform Module System）在 2014 年 12 月被 JCP 批准（JSR-376），并于 2017 年 9 月作为 JDK 9 的一部分发布。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《深入理解 Java 虚拟机:JVM 高级特性与最佳实践》</p>
</blockquote>
<blockquote>
<p><a href="http://openjdk.java.net/projects/jigsaw/">Project Jigsaw</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>行为树</title>
    <url>/2020/09/27/%E8%A1%8C%E4%B8%BA%E6%A0%91/</url>
    <content><![CDATA[<p>一个决策系统或者流程控制系统，在状态较少的情况下可以使用有限状态机。如果系统存在决策日趋复杂的可能性，那么简单的有限状态机并不是一个很好的选择，在使用它的过程中，你可能会感到越来越力不从心，这是有限状态机本身的局限性造成的。</p>
<span id="more"></span>

<p>在之前的有限状态机一文中，我们提到了它的缺陷。在使用有限状态机之前，我们需要列出所有可能的状态转换并设计出一张转换表，状态越多，这张表也就越复杂，出现遗漏的可能性也就越大，很多时候由于我们考虑不周，可能会导致现有的工作需要重新检查和修改，费时费力。下图是 Behavior Designer 官方文档中列出的一个意大利面条式的有限状态机：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/29/Jv6.png" alt="意大利面条有限状态机"></p>
<h1 id="什么是行为树？"><a href="#什么是行为树？" class="headerlink" title="什么是行为树？"></a>什么是行为树？</h1><p>行为树（Behavior Tree），简称 BT，一般用于游戏 AI，概括来说就是一棵用于控制 AI 行为的树结构。在我们要决策当前的 AI 需要执行哪个行为时，我们就会从它的行为树的根节点开始，自顶向下（或者自左向右）一层一层地对每个节点进行检查，也就是进行树的遍历。</p>
<p>行为树的节点类型有很多种，常见的包括：根节点、复合节点、行为节点和修饰节点，很多成熟的行为树框架中可能还会包含条件节点。需要强调的是，节点一般会有四种状态：Success、Failure、Running 和 Error，其中 Running 状态表示该节点的执行结果还不能立刻获知，比如在游戏中角色进行“向目标移动”的动作，很显然这并不是一个瞬时动作，所以在没有最终到达目的地之前都会一直返回 Running 状态。</p>
<h1 id="复合节点"><a href="#复合节点" class="headerlink" title="复合节点"></a>复合节点</h1><p>复合节点（Composite Node）也可以叫做控制节点，它有一个父节点和一个或者多个子节点，它的作用是控制子节点的执行方式，比如按照一定的顺序执行或者随机执行。根据执行方式的不同，常用的复合节点有三种：选择节点（Selector Node）、顺序节点（Sequence Node）和并行节点（Parallel Node）。当然，也有一些不常用的控制节点类型，比如随机选择节点、随机顺序节点、次数限制节点、权重选择节点等等。需要注意的是，复合节点需要向上级提供执行结果，它既可以控制行为节点，同时也能控制复合节点，这样就可以做到决策的复合。</p>
<h2 id="顺序节点"><a href="#顺序节点" class="headerlink" title="顺序节点"></a>顺序节点</h2><p>就像它的名字一样，顺序节点会按照一定的顺序（通常是从左到右或者从上到下）执行它的子节点。只有当一个子节点执行成功并向它返回 Success 之后，下一个子节点才会开始执行，当所有的子节点都执行成功，该顺序节点才算执行成功，同时它也会向自己的父节点返回 Success；如果一个子节点执行失败并返回 Failure，那么整个迭代就会停止，这也就意味着该顺序节点执行失败，此时它会向自己的父节点返回 Failure。</p>
<p>顺序节点通常用于执行一连串具有前后依赖关系的行为，其中一个行为失败必然导致后续的行为失去继续执行的意义，比如“进门”这个过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/28/Z7A.png" alt="顺序节点"></p>
<p>一个正确的“进门”过程应该是这样的：顺序节点 -&gt; walk to door(Success) -&gt; 顺序节点（Running）-&gt; open door(Success) -&gt; 顺序节点（Running）-&gt; walk through door(Success) -&gt; 顺序节点（Running）-&gt; close door(Success) -&gt; 顺序节点（Running）-&gt; 向父节点返回 Success。</p>
<p>如果角色因为一些原因未能成功走到门前，比如被其他物体挡住去路，那么后面的这些动作也就失去了执行的意义，这时走向门的这个动作失败并返回，顺序节点会向父节点报告失败，此时父节点就可以根据这个结果进行一些处理。</p>
<h2 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h2><p>如果把顺序节点理解为一个“与门”，那么选择节点就是一个“或门”。与顺序节点相同，选择节点也会按照一定的顺序执行子节点，但是与顺序节点不同，只要有一个子节点执行成功，那么选择节点就算执行成功并向父节点报告成功的消息。如果有一个子节点执行失败，那么选择节点会继续执行下一个子节点，只有当所有的子节点都执行失败之后，选择节点才算执行失败，此时它会向父节点报告失败的消息。</p>
<p>选择节点通常用于表示一个行为会有多种实现方式，比如攻击这个行为，可能会有劈、斩、砍三种不同的实现方式，选择节点可以选择这三种方式中的任意一种执行。更进一步的，我们可以定义一个优先级，优先级高的行为会先执行。回到“进门”的那个例子，我们增加一些复杂性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/28/7yv.png" alt="选择节点"></p>
<p>我们将角色开门这个动作进行了更加细化的安排，角色可以选择直接开门或者使用钥匙开门，当然如果角色脾气不太好，也有可能会选择直接把门打烂。</p>
<h2 id="并行节点"><a href="#并行节点" class="headerlink" title="并行节点"></a>并行节点</h2><p>并行节点意味着它会并发地执行所有的子节点，而在何种情况下向父节点报告执行结果则与并行节点所采用的具体策略有关。比如它可以是 Parallel Selector 类型的，那么只要有一个子节点执行成功就代表它执行成功；也有可能是 Parallel Sequence 类型的，那么只要有一个子节点执行失败就代表它执行失败。或者是 Parallel Hybird 类型的，那么只有在指定数量的子节点执行失败或者执行成功之后才会决定最终的执行结果。当然，还有很多其他的策略，这里就不一一列举了。</p>
<p>并行节点通常用于表示同一时刻一个事物会有多种行为同时执行，比如一个人物可以一边移动一边攻击。</p>
<h1 id="行为节点"><a href="#行为节点" class="headerlink" title="行为节点"></a>行为节点</h1><p>行为节点是叶子节点，它是具体动作的执行者，如果拿代码来做类比的话，那么复合节点和修饰节点就好比能够改变代码执行的流程控制语句：if、else、while 等等，而行为节点就是那些在控制语句范围内被调用的方法。</p>
<p>有些行为是可以在“瞬间”完成的，比如 2D 精灵的转身，而有些行为需要持续一段时间才能完成。因此，在这些持续行为节点中，我们需要先执行持续行为，然后挂起行为树，直到持续时间结束再恢复行为树的执行。为了实现这个目的，一般的做法是一颗行为树维护一个协程，在需要时通过协程等待持续行为的完成，从而避免阻塞当前线程。</p>
<h1 id="条件节点"><a href="#条件节点" class="headerlink" title="条件节点"></a>条件节点</h1><p>有些行为节点可能需要一个前提条件，只有在前提条件得到满足的情况下才能够执行，当然有的行为节点并没有前提条件。现在比较成熟的做法是将前提条件抽象分离出来作为一种新的节点类型——条件节点，将它作为叶子节点混入行为树中，提供条件的判断结果，并交给复合节点来决策。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/28/D4o.png" alt="条件节点"></p>
<h1 id="修饰节点"><a href="#修饰节点" class="headerlink" title="修饰节点"></a>修饰节点</h1><p>修饰节点可以有子节点，但是它只能拥有一个叶子节点。它的作用有很多，包括修改子节点的执行结果，终止子节点的执行以及重复执行子节点等等。一个比较常见的修饰节点就是逆变节点（Inverter），它可以将子节点的执行结果逆转，比如子节点返回了 Success，那么修饰节点就会向父节点返回 Failure。</p>
<p>还有很多其他类型的修饰节点，比如成功节点（Succeeder），它不管子节点的结果如何都会向父节点返回成功的结果，这在我们知道子节点一定会失败，而它的父节点又是顺序节点的情况下非常有用，这样我们就可以避免因为子节点失败而导致整个迭代停止。</p>
<h1 id="数据上下文"><a href="#数据上下文" class="headerlink" title="数据上下文"></a>数据上下文</h1><p>行为树的节点间是存在通信需求的，比如一个顺序节点，它包含两个子节点，一个是选择目标，另一个是攻击。这里就存在节点通信的需求，即攻击节点需要获取选择目标节点的结果，也就是“攻击目标”来发起攻击。那么这个“攻击目标”应该存储在哪里呢？一般情况下，我们都会选择存储在与这个行为树绑定的黑板上，也就是行为树对应的数据上下文当中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/29/W1r.png" alt="黑板模式"></p>
<h1 id="有限状态机与行为树"><a href="#有限状态机与行为树" class="headerlink" title="有限状态机与行为树"></a>有限状态机与行为树</h1><p>行为树从本质上讲，是将所有的行为分离出来作为行为节点，然后使用各种控制节点、条件节点和修饰节点将这些行为组合在一起，最终形成一套 AI 的行为决策系统。这么来说，行为树与有限状态机还是有很多相似之处的，或者我们可以理解为行为树对有限状态机做了一些改进和优化。</p>
<p>与有限状态机相比，行为树可以方便地把复杂的 AI 知识条目组织得非常直观，复合节点迭代子节点的方式就像是在处理一个预设的优先策略队列，这与我们正常的思考模式相符合：先最优再次优。由于行为树中的行为逻辑和状态数据相互分离，因此节点的可重用性很高，几乎所有的节点都可以复用，我们可以通过重组不同的节点来实现不同的行为树，同时这也使得行为树更容易实现可视化的 AI 设计工作。</p>
<p>但是行为树的缺陷也很明显，由于每次都需要从根节点开始层层遍历树，所以使用行为树可能会比有限状态机消耗更多的 CPU 资源，尤其是在行为树深度较深时会更加明显。</p>
<p>虽然行为树与有限状态机相比有诸多优势，但是这并不代表我们应该全面抛弃有限状态机。如果我们不需要一个特别复杂的 AI，我们可以考虑继续使用状态机。很多时候我们还可以将两者结合，由状态机负责 AI 的身体状态，而行为树负责 AI 的决策，但是这样的话，行为树在做决策之前还需要考虑状态机的状态，可能会使系统变得更加复杂。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://web.stanford.edu/class/cs123/lectures/CS123_lec08_HFSM_BT.pdf">Hierarchical Finite State Machine (HFSM) &amp; Behavior Tree (BT)</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/KillerAery/p/10007887.html">游戏 AI 之决策结构-行为树</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2018/04/04/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>观察者模式是一个重要的设计模式，很多框架都使用了该模式。  </p>
<span id="more"></span>

<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/nbW.png" alt="观察者模式"></p>
<ul>
<li><p>Subject（或者叫做 Observable）<br>被观察者，一般是一个抽象类，持有观察者的集合，除了自身的方法外，还有管理观察者和通知观察者的方法</p>
</li>
<li><p>Observer（观察者）<br>观察者接口</p>
</li>
</ul>
<p>下面使用代码来演示该模式。</p>
<h2 id="不使用-JDK-提供的实现"><a href="#不使用-JDK-提供的实现" class="headerlink" title="不使用 JDK 提供的实现"></a>不使用 JDK 提供的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nekolr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题（被观察者）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nekolr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 观察者集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个观察者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个观察者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态变更方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题的具体实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nekolr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的状态改变了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知观察者</span></span><br><span class="line">        <span class="built_in">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建被观察者</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;observer1 收到了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;observer2 收到了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        subject.addObserver(observer1);</span><br><span class="line">        subject.addObserver(observer2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变状态</span></span><br><span class="line">        subject.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-JDK-的实现"><a href="#使用-JDK-的实现" class="headerlink" title="使用 JDK 的实现"></a>使用 JDK 的实现</h2><p>其实，JDK 已经提供了被观察者（java.util.Observable）和观察者（java.util.Observer），下面根据 JDK 提供的类进行改造。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/63z.png" alt="JDK 提供的观察者模式"></p>
<p>需要注意的是，JDK 提供的被观察者只有一个改变状态的方法，我们可以定义一个 Subject 接口来声明一些自身的逻辑方法，具体的被观察者只需要实现该接口，并继承 <code>java.util.Observable</code> 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题（被观察者）接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nekolr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被观察者自身的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题的具体实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nekolr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.Observable <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自身的方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态改变</span></span><br><span class="line">        <span class="built_in">super</span>.setChanged();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知所有的观察者</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObservers(<span class="string">&quot;我可通知你们了哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建被观察者</span></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line"></span><br><span class="line">        java.util.<span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> (o, arg) -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;observer1 收到了 &quot;</span> + o.toString() + <span class="string">&quot; 发过来的 &quot;</span> + arg);</span><br><span class="line">        java.util.<span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> (o, arg) -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;observer2 收到了 &quot;</span> + o.toString() + <span class="string">&quot; 发过来的 &quot;</span> + arg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        subject.addObserver(observer1);</span><br><span class="line">        subject.addObserver(observer2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变状态</span></span><br><span class="line">        subject.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事件监听模式"><a href="#事件监听模式" class="headerlink" title="事件监听模式"></a>事件监听模式</h1><p>事件监听模式其实也是观察者模式的一种，但是实现要比一般的观察者模式复杂。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/3Yr.png" alt="JDK 提供的事件监听模式"></p>
<ul>
<li><p>EventSource<br>事件源。定义具体的事件，封装了（持有）监听者列表，能够添加和删除监听者，以及通知所有的监听者状态变更。  </p>
</li>
<li><p>EventObject<br>事件对象。封装了事件源以及事件相关的信息，在事件源与事件监听器之间传递信息。  </p>
</li>
<li><p>EventListener<br>事件监听器。注册在事件源上，进行事件处理。</p>
</li>
</ul>
<p>JDK 也提供了事件监听模式需要的类和接口。EventListener 接口和 EventObject 类，事件源需要我们自己编写。下面用代码模拟该设计模式。</p>
<h2 id="使用-JDK-的实现-1"><a href="#使用-JDK-的实现-1" class="headerlink" title="使用 JDK 的实现"></a>使用 JDK 的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;ChangeListener&gt; changeListeners = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加监听者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(ChangeListener listener)</span> &#123;</span><br><span class="line">        changeListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单击事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ChangeEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeEvent</span>(<span class="built_in">this</span>);</span><br><span class="line">        event.setStatus(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.notifyListeners(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双击事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDoubleClick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ChangeEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeEvent</span>(<span class="built_in">this</span>);</span><br><span class="line">        event.setStatus(<span class="string">&quot;double click&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.notifyListeners(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有的监听者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyListeners</span><span class="params">(ChangeEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;ChangeListener&gt; iterator = changeListeners.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">ChangeListener</span> <span class="variable">listener</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            listener.update(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EventObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChangeEvent</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChangeListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(ChangeEvent event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nekolr.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">EventSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventSource</span>();</span><br><span class="line"></span><br><span class="line">        source.addListener((event) -&gt; System.out.println(event.getStatus()));</span><br><span class="line"></span><br><span class="line">        source.onClick();</span><br><span class="line">        source.onDoubleClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>虽然事件监听模式也是观察者模式的一种，但是它俩还是有区别的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/04/14/oK7.png" alt="区别"></p>
<p>观察者模式只需要两个角色，而事件监听模式则需要三个角色，其实是将主题拆分成了事件源和事件对象。事件源需要经过包装，成为事件对象的属性后再传递给监听器。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="Spring-是如何使用的"><a href="#Spring-是如何使用的" class="headerlink" title="Spring 是如何使用的"></a>Spring 是如何使用的</h2><p>Spring 作为一个 Java 界流行的框架，同样使用了该模式。比如 Spring 的 <code>ApplicationListener</code> 和 <code>ApplicationEvent</code>。</p>
<blockquote>
<p>( 该文涉及的 Spring 的源代码对应的 Spring 版本为 4.3.13.RELEASE )</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationListener</code> 继承了 <code>java.util.EventListener</code>，也就是说这是一个监听者接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EventObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class to be extended by all application events. Abstract as it</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t make sense for generic events to be published directly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** use serialVersionUID from Spring 1.2 for interoperability */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** System time when the event happened */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new ApplicationEvent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> source the object on which the event initially occurred (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ApplicationEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(source);</span><br><span class="line">		<span class="built_in">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the system time in milliseconds when the event happened.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.timestamp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationEvent</code> 继承了 <code>EventObject</code>，因此它是一个事件对象。</p>
<p>很明显的，<code>ApplicationListener</code> 继承了 <code>EventListener</code>，而 <code>ApplicationEvent</code> 继承了 <code>EventObject</code>，因此我们还缺少一个 EventSource（事件源），通过跟踪代码发现这个事件源是 <code>ApplicationContext</code>，即容器上下文（或者理解为容器本身）。我判断事件源是它的原因是 <code>ApplicationContextEvent</code> 这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for events raised for an &#123;<span class="doctag">@code</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这里的参数为 ApplicationContext，也就是将 ApplicationContext 作为 source</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ApplicationContextEvent</span><span class="params">(ApplicationContext source)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(source);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Get the &#123;<span class="doctag">@code</span> ApplicationContext&#125; that the event was raised for.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> ApplicationContext <span class="title function_">getApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (ApplicationContext) getSource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 容器（IOC 容器）有一个重要的方法 <code>refresh</code> 在 <code>AbstractApplicationContext</code> 类中，该方法用于加载或刷新配置（XML、配置文件等）的 Bean。执行该方法，如果已经有容器存在，则会销毁容器和已经存在的实例并重新实例化，类似于重启。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>refresh</code> 方法里有一个方法 <code>finishRefresh</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里发布事件对象 ContextRefreshedEvent</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从大意上看，这里的代码：</p>
<p><code>publishEvent(new ContextRefreshedEvent(this))</code> 是将事件源 <code>ApplicationContext</code> 封装成事件对象 <code>ContextRefreshedEvent</code> 发布。与我们设想的通知监听者不太一样，继续看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Publishing event in &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>&lt;Object&gt;(<span class="built_in">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是重点</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>publishEvent</code> 方法中执行了这样一段代码：</p>
<p><code>getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType)</code>，这段代码大意是获取容器事件的广播器来广播事件，<code>multicastEvent</code> 方法在 <code>SimpleApplicationEventMulticaster</code> 类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    invokeListener(listener, event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很明显的发现，使用 <code>getApplicationListeners</code> 方法来获取所有的监听者，遍历执行 <code>invokeListener</code> 方法，重点是 <code>invokeListener</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="type">ErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> getErrorHandler();</span><br><span class="line">    <span class="keyword">if</span> (errorHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doInvokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            errorHandler.handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        doInvokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listener.onApplicationEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span> || msg.startsWith(event.getClass().getName())) &#123;</span><br><span class="line">            <span class="comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span></span><br><span class="line">            <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doInvokeListener</code> 方法调用了 listener 的 <code>onApplicationEvent</code> 方法，传入 event 事件对象来通知监听者。同样的，我们在 <code>AbstractApplicationContext</code> 类中找到了容器启动和关闭时执行的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    getLifecycleProcessor().start();</span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextStartedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    getLifecycleProcessor().stop();</span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextStoppedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里我有个疑惑，<code>ApplicationContext</code> 作为事件源，应该注册监听者啊，在哪呢？原来在 refresh 方法里，<code>registerListeners</code> 方法就是了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (earlyEventsToProcess != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">            getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h2><p>下面使用一个小栗子来说明如何使用 Spring 的事件处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextStartedEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartedListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextStartedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextStartedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------- Spring started ---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextStoppedEvent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStoppedListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextStoppedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextStoppedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------- Spring stopped ---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextRefreshedEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRefreshedListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------- Spring refreshed ---------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// applicationContext 在 src/main/resources 目录下</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStartedListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;MyStartedListener&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStoppedListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;MyStoppedListener&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myRefreshedListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;MyRefreshedListener&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------- Spring refreshed ---------------------</span><br><span class="line">------------------- Spring started ---------------------</span><br><span class="line">------------------- Spring stopped ---------------------</span><br></pre></td></tr></table></figure>

<p>通过 <code>ClassPathXmlApplicationContext</code> 来加载配置文件初始化容器上下文，在容器调用 start 方法时，事件 <code>ContextStartedEvent</code> 发布，容器调用 stop 方法时，事件 <code>ContextStoppedEvent</code> 发布。但是常用的业务场景是我们需要在容器加载完成后执行一些操作，这时候我们常使用 <code>ContextRefreshEvent</code> 事件对象。但是在使用它的时候需要注意，尤其是我们使用了 Spring 和 Spring MVC，因为父子容器的原因，系统中会存在两个容器，一个是 <code>Root Application Context</code>，另一个就是我们配置的 Spring MVC 的容器（作为 ROOT 的子容器）。这个时候 refresh 会被调用两次，同样监听器里的 <code>onApplicationEvent</code> 也会执行两次，避免这种情况就需要在自定义的监听器里修改代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextRefreshedEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRefreshedListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 没有父容器，则为 ROOT 容器</span></span><br><span class="line">        <span class="keyword">if</span> (event.getApplicationContext().getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------- Spring refreshed ---------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 中的事件对象：</p>
<table>
<thead>
<tr>
<th>事件对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ContextRefreshedEvent</td>
<td>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。</td>
</tr>
<tr>
<td>ContextStartedEvent</td>
<td>当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</td>
</tr>
<tr>
<td>ContextStoppedEvent</td>
<td>当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</td>
</tr>
<tr>
<td>ContextClosedEvent</td>
<td>当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域访问常用方法</title>
    <url>/2017/07/26/%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="跨域访问问题"><a href="#跨域访问问题" class="headerlink" title="跨域访问问题"></a>跨域访问问题</h1><p>由于浏览器同源策略的限制，一个域下的 JavaScript 无法访问另一个域，包括提交、获取等操作。这里的同源指的是协议、域名、端口都相同，其中即便是域名和域名对应的 IP 之间浏览器也不允许访问。对于端口和协议不同的跨域访问，只能在后端处理。</p>
<span id="more"></span>

<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>我们知道 JSON 是一种数据交换格式，而 JSONP（JSON with Padding）是一个<strong>非正式的跨域数据交互协议</strong>。受浏览器同源策略的影响，使用 AJAX 不能直接访问非同源的资源，但是 JavaScript 的 <code>&lt;script&gt;</code> 不受同源策略限制。于是我们可以使用 <code>&lt;script&gt;</code> 的 src 指向另一个域的地址并附带一个参数指定回调函数名，并提供这个回调函数来处理接收的数据，这个地址的服务器端后台处理这个请求并将数据返回，由于 JSON 的天然优势（纯文本、跨平台、JS 原生支持等），遂将数据用回调函数名包裹封装成 JSON 返回。浏览器请求这个 <code>&lt;script&gt;</code> 后会得到服务器端返回的数据，执行回调函数。这样说起来有点费劲，还是代码清楚。</p>
<p>使用 <code>Node.js</code> 模拟跨域环境，运行该脚本将启动一个 http 服务器，通过 <code>http://127.0.0.1:8888</code> 访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">request, response</span>) &#123;</span><br><span class="line">    <span class="comment">//封装数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取传递过来的回调函数名</span></span><br><span class="line">    <span class="keyword">const</span> callback = url.<span class="title function_">parse</span>(request.<span class="property">url</span>, <span class="literal">true</span>).<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8888</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------http server start on 8888 port--------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/06/12/0nk.png" alt="httpserver"></p>
<p>然后是前端的页面。这里要使用到 Node.js 的 <code>http-server</code>。使用 <code>npm install -g http-server</code>（加-g 参数全局安装）安装 <code>http-server</code>，然后在前端页面所在目录运行 <code>http-server</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/06/12/2YD.png" alt="http_server"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>firstpage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//回调函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:8888?callback=callback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/06/12/KR6.png" alt="result"></p>
<p>可以看到，<code>http://192.168.1.102:8080/firstpage.html</code> 中的脚本访问 <code>http://127.0.0.1:8888</code>，并成功获取到了数据。如果选择使用 jQuery 还可以免去定义 <code>&lt;script&gt;</code> 和回调函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>firstpage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8888&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">jsonp</span>: <span class="string">&#x27;callback&#x27;</span>,<span class="comment">//传递给后端的回调函数的参数名称</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">jsonpCallback</span>: <span class="string">&#x27;callback&#x27;</span>,<span class="comment">//回调函数的名称</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>**乍一看 AJAX 与 JSONP 很相似，但是它俩最本质的区别就是 AJAX 是通过 XMLHttpRequest 对象获取非本页数据（同源），而 JSONP 是通过 js 的 <code>&lt;script&gt;</code> 标签获取非本页数据（同源、不同源都可以）。**同时，JSONP 只能使用 GET 请求并且可能会有安全隐患。</p>
<h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>CORS 是 W3C 的标准，全称是”跨域资源共享”（cross-origin resource sharing）。它允许浏览器向跨源服务器发出 <code>XMLHttpRequest</code> 请求，从而克服了 ajax 只能同源使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持才可以生效，所以可能会存在兼容性的问题。服务器实现了 CORS 接口，选择兼容的浏览器就可以实现跨域通信，并且开发者完全可以用之前的方式使用 <code>XMLHttpRequest</code> 而感觉不到跨域限制的存在。</p>
<p>简单来说，CORS 通过在跨域地址的响应头中设置 Access-Control-Allow-Origin 的值为允许跨域访问的地址，一个域在发起跨域访问时，浏览器请求该地址并检测响应头中的 Access-Control-Allow-Origin 值，如果包含该域，则允许访问。发起请求的 JS 对象在某些 IE 中不是 <code>XMLHttpRequest</code> 而是 <code>XDomainRequest</code>，因此可以使用 jQuery 来做兼容处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">request, response</span>) &#123;</span><br><span class="line">    <span class="comment">//封装数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取传递过来的回调函数名</span></span><br><span class="line">    <span class="keyword">const</span> callback = url.<span class="title function_">parse</span>(request.<span class="property">url</span>, <span class="literal">true</span>).<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8888</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------http server start on 8888 port--------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CORS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8888&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/06/12/VQG.png" alt="CORS"></p>
<p>CORS 的优点是可以处理任意类型的请求，而 JSONP 只支持 GET 请求，同时它能够更好的处理错误，而 JSONP 对于请求出错不能很好的处理，并且 CORS 更为安全。</p>
<h1 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h1><p>听起来高大上，其实就是 JS 将跨域请求发送给同源的后端，由后端代为请求，然后将获取的数据封装返回。</p>
<h1 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h1><p>需要配合 <code>&lt;iframe&gt;</code> 使用，并且使用复杂，问题较多，暂不考虑。</p>
<h1 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h1><p>使用这种方式只适用两个主域名相同，子域名不同的域间通信，例如：<a href="http://www.test.com/">www.test.com</a> 和 sub.test.com 之间通信。为了模拟这种环境，除了跨域环境，还要进行域名映射，这里使用 nginx。</p>
<p><strong>a.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>a.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;test.com&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">src</span> = <span class="string">&#x27;http://sub.test.com/b.html&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(iframe);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> win = iframe.<span class="property">contentWindow</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(win.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>b.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>b.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;test.com&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">data</span> = <span class="string">&#x27;hello, cross domain&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先开启 <code>http-server</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/Qrn.png" alt="document.domain_http_server"></p>
<p>然后将 <code>www.test.com</code> 和 <code>sub.test.com</code> 都映射到 <code>http://192.168.0.141:8081</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#user nobody;</span><br><span class="line">worker_processes 1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name www.test.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://192.168.0.141:8081;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name sub.test.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://192.168.0.141:8081;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.test.com/">www.test.com</a> 这个域名在互联网上可能已经被注册，因此需要在 hosts 中指定我们要访问的并不是互联网上的这个地址，而是 <code>http-server</code> 部署的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># set nginx hosts</span><br><span class="line">192.168.0.141 www.test.com</span><br><span class="line">192.168.0.141 sub.test.com</span><br></pre></td></tr></table></figure>

<p>经过上面的配置，在客户端访问 <code>www.test.com</code> 和 <code>sub.test.com</code> 时，都会通过 nginx 的反向代理去请求真实的地址：<code>http://192.168.0.141:8081</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/je0.png" alt="nginx_proxy_broswer"></p>
<h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>window 对象有个 name 属性，该属性在一个窗口（window）的生命周期内载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>a.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">src</span> = <span class="string">&#x27;http://192.168.124.177:8081/b.html&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> data = iframe.<span class="property">contentWindow</span>.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 这里需要指定一个同源的路径</span></span></span><br><span class="line"><span class="language-javascript">		<span class="comment">// 目的是让 http://192.168.0.141:8081/a.html 能够访问到 iframe 中的数据</span></span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">src</span> = <span class="string">&#x27;http://192.168.0.141:8081&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>b.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">name</span>=<span class="string">&quot;this is data&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>http://192.168.0.141:8081/a.html</code> 访问 <code>http://192.168.124.177:8081/b.html</code> 中的提供的数据。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/qYm.png" alt="window_name"></p>
<p>window.name 的优点是兼容性好，几乎所有的浏览器都支持。抛开 HTML5 来说，它是 JSONP 很好的替代方案，比 JSONP 安全。</p>
<h1 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h1><p><code>window.postMessage(message,targetOrigin)</code> 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。监听 <code>message</code> 事件，事件能够获取三个重要的值。</p>
<ul>
<li>source：发送消息的 window 对象。</li>
<li>data：发送的消息数据。</li>
<li>origin：调用 <code>postMessage</code> 方法发送消息的 window 的源。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>a.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.124.177:8081/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> origin = <span class="string">&#x27;http://192.168.124.177:8081&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 通过 iframe 向 http://192.168.124.177:8081/b.html 发送消息</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">frames</span>[<span class="number">0</span>].<span class="title function_">postMessage</span>(<span class="string">&#x27;我是 a，我发消息给了 b&#x27;</span>, origin);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.html 接收到了消息：&#x27;</span> + e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>b.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (e.<span class="property">source</span> == <span class="variable language_">window</span>.<span class="property">parent</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.html 接收到了消息：&#x27;</span> + e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 再使用 iframe 向父窗口发送消息，e.origin 为调用 postMessage 的 window 的源</span></span></span><br><span class="line"><span class="language-javascript">            parent.<span class="title function_">postMessage</span>(<span class="string">&#x27;我是 b，我发消息给了 a&#x27;</span>, e.<span class="property">origin</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242036/2019/07/12/vke.png" alt="postMessage"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">HTTP 访问控制（CORS）</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000000709909">构建 public APIs 与 CORS</a></p>
</blockquote>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>路由的学习与探究</title>
    <url>/2017/06/10/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>路由（route）是什么？我们抛开生活中的路由不谈，在 web 开发中，路由的主要工作是根据 url 分配对应的处理程序。</p>
<span id="more"></span>

<p>假如有一个服务，域名为 <code>a.com</code>，它提供了一个可供访问的页面 <code>http://a.com/about</code>，当用户输入 <code>http://a.com/about</code> 访问时，Web 服务会根据用户输入的这个 URL 找到对应的处理程序，这个过程就是路由分发。
		</p>
<h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>在以前，我们一般是在后端做路由（想想熟悉的 Spring MVC 的控制器），分析处理 URL。但是随着前端的发展，单页面应用的流行，页面交互越来越复杂，一些路由的处理已经交给了前端。如今很多流行的 js 类库框架：AngularJS、Backbone、Vue、React 等等都支持前端路由，那么前端路由的原理是什么呢？		<br>		<br>在 HTML5 出现以前，通常使用 hash 来实现路由功能。那么 hash 是什么呢？比如 <code>www.nekolr.com/#git</code>，这个 <strong># 号及后面的字符</strong>被称为 hash。当 hash 值改变时，浏览器会产生历史记录，但不会向服务器发送请求，此时后退地址栏会发生变化但页面不会刷新。在了解了 hash 之后，还需要了解 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/hashchange" title="hashchange">hashchange</a> 事件，该事件在 hash 值改变时触发，这里有个小栗子：	</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hashchange<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#first&quot;</span>&gt;</span>first<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#second&quot;</span>&gt;</span>second<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是之前的:&quot;</span> + e.<span class="property">oldURL</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是新的:&quot;</span> + e.<span class="property">newURL</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="手写一个前端路由"><a href="#手写一个前端路由" class="headerlink" title="手写一个前端路由"></a>手写一个前端路由</h3><p>下面结合这两个知识点，我们来做一个简单的前端路由：	</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span>&#123;<span class="attribute">line-height</span>:<span class="number">2em</span>;&#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span>&#123;<span class="attribute">display</span>:inline-block;<span class="attribute">vertical-align</span>:top;<span class="attribute">padding</span>:<span class="number">0</span> .<span class="number">5em</span>;&#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-class">.active</span>&#123;<span class="attribute">background</span>:<span class="number">#369</span>;<span class="attribute">color</span>:<span class="number">#FFF</span>;&#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#!home&quot;</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span> 首页 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#!about&quot;</span>&gt;</span> 关于 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#!friend&quot;</span>&gt;</span> 友情链接 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">Router</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">key</span> = <span class="string">&quot;!&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">currentUrl</span> = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">routes</span> = &#123;&#125;;<span class="comment">//路由表</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      * 注册路由</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      * <span class="doctag">@param</span> <span class="variable">address</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      * <span class="doctag">@param</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Router</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reg</span> = <span class="keyword">function</span> (<span class="params">address, callback</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="variable language_">this</span>.<span class="property">key</span>+address] = callback;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 跳转到</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Router</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">go</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">currentUrl</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>) || <span class="string">&quot;!home&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">routes</span>[<span class="variable language_">this</span>.<span class="property">currentUrl</span>]();</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 初始化</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * <span class="doctag">@param</span> callback 一个回调函数，用来处理通用的操作</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Router</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            self.<span class="property">go</span>.<span class="title function_">bind</span>(self)()</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&quot;function&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                callback.<span class="title function_">bind</span>(self)(self.<span class="property">currentUrl</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 页面初始化加载首页</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="variable language_">this</span>.<span class="property">go</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**********************使 用************************/</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">init</span>(<span class="keyword">function</span> (<span class="params">currentUrl</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;nav a.active&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> i = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;nav a[href=&quot;#&#x27;</span>+currentUrl+<span class="string">&#x27;&quot;]&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(a) <span class="comment">// 如果存在这个 DOM</span></span></span><br><span class="line"><span class="language-javascript">            a.<span class="property">className</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(i)</span></span><br><span class="line"><span class="language-javascript">            i.<span class="property">className</span> = <span class="string">&#x27;active&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">reg</span>(<span class="string">&quot;home&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#content&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;这是首页&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 实际使用中，在这里调用 ajax 来实现无刷新更新页面内容</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     router.<span class="title function_">reg</span>(<span class="string">&quot;about&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#content&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;这是关于页&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">// 实际使用中，在这里调用 ajax 来实现无刷新更新页面内容</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     router.<span class="title function_">reg</span>(<span class="string">&quot;friend&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#content&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;这是友链页&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">// 实际使用中，在这里调用 ajax 来实现无刷新更新页面内容</span></span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本的思路就是：将关键字和对应的处理函数提前注册到路由表中，在页面 hash 改变，触发 hashchange 事件时调用对应的处理函数。		<br>		<br>前端路由一般在单页面应用（SPA）使用较多，优点主要是用户体验好，页面内容不需要每次都从服务器全部获取，能够快速展现给用户。缺点包括使用浏览器的前进、后退键会重新发送请求，没有合理地利用缓存，无法记住之前滚动的位置等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="https://www.zhihu.com/question/46767015">Web 开发中的”路由”是什么意思？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃表</title>
    <url>/2018/08/05/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<p>一个有大量元素的有序（从小到大）集合，使用怎样的数据结构存储，才能实现很高的插入和删除效率？</p>
<span id="more"></span>

<p>如果使用数组，插入元素首先需要查找插入的位置，因为是元素是有序的，可以使用二分查找，这个过程的时间复杂度为 O(logN)。找到插入的位置后，还需要通过移动元素腾出位置，至于是左移还是右移，可以根据插入的位置来优化，从而减少移动的次数，这个过程的时间复杂度可以简单看作 O(N)。删除的操作一样，也是需要先查找再移动元素。</p>
<p>如果使用链表，同样需要先找插入位置，链表无法使用二分查找，所以只能逐一比较，这个过程的时间复杂度为 O(N)，找到位置后，链表的插入就很简单了，修改一下指针的指向，这个过程的时间复杂度为 O(1)。删除的操作一样。</p>
<p>显然，使用这两种数据结构进行插入和删除的时间复杂度都在 O(N) 左右，这并不能满足我们的要求，因此需要再进行优化。我们知道链表的查询时间复杂度为 O(N)，插入和删除的时间复杂度为 O(1)，如果能够优化它的查询效率，整个过程的时间复杂度不就降低了吗？但是链表不能使用二分查找，因此我们需要寻找别的方法来减少查询需要比较的次数。</p>
<p>我们可以提取部分节点，组成一个新的有序链表。比如一个链表是 1 -&gt; 2 -&gt; 3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8，我们提取所有的奇数节点，组成下面的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/05/gQO.png" alt="提取元素"></p>
<p>此时如果想找值为 2 的节点，先从新链表的头开始，2 比 1 大，则比较新链表头的下一个节点，发现 3 比 2 大，则顺着头结点的下一层的指向，来到原链表去查找，头节点的下一个节点的值就是 2。如果想找值为 4 的节点，同样先从新链表的头节点开始比较，下一个节点比 4 小，则继续寻找下一个节点，发现 5 比 4 大，则顺着新链表节点值为 3 的节点的下一层指向，来到原链表继续寻找，发现该节点的下一个节点值为 5，说明链表中没有节点值为 4 的节点。</p>
<p>可以发现，这种优化虽然多使用了原来一半大小的空间，但是查询效率平均也提升了一倍，时间复杂度降低为 O(log N)。顺着这个思路，我们可以继续提取节点组成新的链表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/05/DjQ.png" alt="继续提取"></p>
<p>此时要查找值为 6 的节点，就可以顺着 1 -&gt; 5 -&gt; 5 -&gt; 5 -&gt; 6 这条路线快速找到。因此，当节点很多时，我们可以继续提取，保证每向上提取一层，节点数量减少一半。其实这就是跳跃表。</p>
<p>讲到这里，其实还有一个问题需要处理。当大量的新节点通过逐层比较，最终插入原链表后，上层的链表已经变得不够用了，此时需要将原链表中的新增加的部分节点提取到上层链表中进行补充。由于我们添加和删除节点跳跃表是无法预测的，为了使上层链表中节点大致均匀分布，跳跃表的设计者采用了类似抛硬币的方式，即随机决定新节点是否向上提拔，每次向上一层提拔的几率为 50%。</p>
<p>比如，新增了一个值为 9 的节点，第一次抛硬币，是正面，则向上提拔一层。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/05/q4b.png" alt="向上提拔"></p>
<p>继续抛硬币，还是正面，则继续向上提拔。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/05/v7n.png" alt="继续提拔"></p>
<p>跳跃表删除节点需要将每层的节点都删除掉。比如删除值为 5 的节点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/08/05/M84.png" alt="删除节点"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a href="http://blog.jobbole.com/111731/">漫画算法：什么是跳跃表？</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/George1994/p/7635731.html">跳跃表原理和实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
