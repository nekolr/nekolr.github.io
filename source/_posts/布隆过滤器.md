---
title: 布隆过滤器
date: 2019/8/30 10:13:0
tags: [算法]
mathjax: true
categories: [算法]
---

布隆过滤器（Bloom Filter）由布隆于 1970 年提出，它实际上由一个很长的二进制向量和一系列随机映射函数组成。布隆过滤器可以用于查询一个元素是否在一个集合中，它的优点是空间和时间效率都远超一般的算法，缺点是会有一定的误判和删除困难。

<!--more-->

当明白了 Bitmap 的原理后，布隆过滤器就很好理解了。布隆过滤器与 Bitmap 的不同之处在于：布隆过滤器使用了 k 个 Hash 函数，每个元素都需要通过 k 个 Hash 函数完成映射，这就降低了冲突的概率。

![布隆过滤器](https://img.nekolr.com/images/2019/08/30/6Pn.png)

# 布隆过滤器参数的确定
如果布隆过滤器的长度太小，所有的 bit 位很快就会被用完，此时任何查询都会返回“可能存在”；如果布隆过滤器的长度太大，那么误判的概率会很小，但是内存空间浪费严重。类似的，哈希函数的个数越多，则布隆过滤器的 bit 位被占用的速度越快；哈希函数的个数越少，则误判的概率又会上升。因此，布隆过滤器的长度和哈希函数的个数需要根据业务场景来权衡。

我们假设 k 为哈希函数的个数，m 为布隆过滤器的长度，n 为插入元素的个数（需要处理的数据个数），p 为误报率，则：

> 插入单个元素，某一 bit 位没有被置为 1 的概率为 1 - $\frac{1}{m}$

> k 次哈希运算后，某一 bit 位没有被置为 1 的概率为 $(1 - \frac{1}{m})^k$

> 插入 n 个元素后，某一 bit 位被置为 1 的概率为 1 - $(1 - \frac{1}{m})^{nk}$

> 在查询时，如果某个待查询的元素对应的 k 个 bit 位都被置为了 1，则算法会判定该元素在集合中。因此，误判的概率上限为 $(1 - (1 - \frac{1}{m})^{nk})^k$

# 参考
> [大数据量下的集合过滤 —— Bloom Filter](https://www.cnblogs.com/z941030/p/9218356.html)