---
title: 线程与进程
date: 2017/8/3 12:12:0
tags: [Java 多线程,Java,进程]
categories: [Java 多线程]
---
一直以来对于进程和线程的理解都很模糊，最近准备重新学习一下 Java 基础，一些重要的概念需要理解，以便后续的学习。		
<!--more-->		
		
以经典的进程、线程模型为例，用一句简单的话概括就是：进程是操作系统进行资源分配的基本单位，线程是程序运行和调度的基本单位。		
		
## 程序
程序只是指令、数据及其组织形式的描述，是一个静态的概念。		
		
## 进程
进程是程序的真正运行实例，是一个动态的概念。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。在面向进程设计的系统（早期的 UNIX、Linux 2.4 及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（现代操作系统、Linux2.6 及以后的版本）中，进程不再是基本的运行单位，而是线程的容器。		
		
程序运行就会产生进程。同一程序可产生多个进程以允许同时有多位用户运行同一程序，却不会互相冲突。		
- **独立性**
		
进程与进程之间相互独立，一个进程不能访问另一个进程的资源，但是由于进程都是抢占的系统资源，所以进程与进程也存在竞争关系。
- **并发性**
		
进程能够并发运行。从宏观上看，进程似乎是同时运行的，但是实际上，同一时刻，单个核心只能执行一个进程，只不过 CPU 处理速度很快，通过进程切换使人感觉多个进程在同时运行。  

## 父进程与子进程
进程中调用 fork 会创建出一个新的进程，这个新的进程就是子进程，调用 fork 的进程就是父进程。  

调用 fork 后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子，但在操作系统看来，二者更像是兄弟，因为它们只有代码段（代码空间）共享，数据空间是相互独立的，子进程数据空间的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两者的程序计数器 pc 值相同，子进程从 fork 返回处开始执行）。  

由于内核完整复制父进程的整个地址空间是比较耗时的，所以在 UNIX/Linux 中，采用写时复制（Copy-on-write）技术来处理 fork，即在调用 fork 后，内核并不马上复制整个进程的地址空间，而是让父子进程以只读的方式共享同一个地址空间，当父进程或者子进程试图对地址空间进行写入时，就会产生一个错误，这时内核才会复制地址空间。采用写时复制可以将地址空间的复制推迟到实际发生写入的时候。  

## 线程
在之前的操作系统中，拥有资源，能够独立运行的基本单位是进程，但是由于进程创建、撤消与切换存在较大的时空开销，同时由于 SMP 的出现，多个进程并行开销较大，因此急需一种轻型进程，也就是后续的线程。		
		
线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际执行单位。		
- **轻量实体**
		
线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，如程序计数器、一组寄存器和栈。
- **独立运行**
		
线程是能独立运行的基本单位，由于线程很“轻”，线程的切换非常迅速且开销小（在同一进程中的）。
- **并发执行**
		
线程可以并发执行。
- **共享资源**
		
在同一个进程下的各个线程共享进程资源，同时线程之间的通信要比进程通信更加容易。		
## 并发
当有多个线程在执行时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，某个时间段的某个线程代码运行时，其它线程处于挂起状态。		
		
## 并行
当系统有一个以上 CPU 时，一个 CPU 执行一个线程，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。		
## 程序运行
程序是一堆代码，放在磁盘中，在程序运行时，代码加载到内存，由 CPU 到内存取代码（指令）来执行，这样就启动了一个进程。  

一个程序的运行，如果程序中的代码没有创建多个线程，则为单线程程序，程序由这条单线程执行，而这个程序的运行就是一个进程，系统为该进程分配资源，因此进程是高于线程的存在，进程在程序加载到内存中时为这个进程的开始；如果程序中的代码创建了多个线程（由 Java 多线程可知，多线程是在 main 主线程中创建的），那么多个线程共享系统为进程分配的资源。		
		
Java 程序的运行，由 Java 命令启动 JVM，JVM 的启动就相当于创建出了一个进程，由该进程创建出一个主线程去调用 java 代码中的 main 方法（JVM 的启动，最少启动了两个线程：主线程和垃圾回收线程）。