---
title: Raft 共识算法
date: 2020/8/15 10:47:0
tags: [分布式]
categories: [分布式]
---

Paxos 算法偏向于理论，对于如何应用到工程实践上较少提及，同时 Paxos 算法较难理解且复杂性很高，目前能够真正在生产环境中独立使用的成品很少，已知的基础库，比如 Tencent 的 [phxpaxos](https://github.com/Tencent/phxpaxos) 早在 2016 年开源，并在很久之前就停止维护了。阿里的 X-Paxos 只有文章介绍，并不开源。

<!--more-->

Raft 在 2013 年提出，为了更容易理解和实施，Raft 将分布式问题分解和具化，由一个强有力（比 Paxos 的 leader 更强）的 leader 统一处理变更请求，使用 term 作为逻辑时钟来保证时序，一致性具化为保证节点间的操作日志副本（log replication）一致。

# Raft 算法的目标：日志复制同步
Raft 算法的目标是将日志完整地复制到集群所有的节点中，这些复制日志会被状态机（可以理解为一个函数）所使用，只要我们能够保证各个节点上的日志是相同的，那么各个节点上的状态机就能以相同的顺序执行相同的命令，得到一致的结果。

Raft 算法允许服务器崩溃，不过它更希望是 fail-stop 式的崩溃，也就是说，节点只是停止工作或者停止工作又恢复了，但是要求只要节点处于运行状态，那么它们的行为就必须是正确的，这就意味着节点不能有拜占庭式的故障。同时 Raft 算法还允许网络通信中断，消息延迟或者丢失，甚至消息无序，网络分化。

# 节点状态
任何时候，节点只会有以下三种状态或角色：

- 领导者（Leader）
Leader 负责处理客户端的请求，同时还负责处理日志的复制同步。任何时候只会有一个 Leader。
- 跟随者（Follower）
绝大多数节点在大部分时间下都是 Follower 状态，同时 Follower 不会主动发起任何 RPC 调用，它们只能被动地接收请求并响应。
- 候选者（Candidate）
处于领导者和跟随者之间的状态，只会在选举新 Leader 的过程中临时出现。

# 领导者任期（term）
在 Raft 中，时序被分割为领导者任期。每段领导者任期都有一个序号，这些序号随着任期数的增加会自动增长，不会重复使用。任期由选举开始（选举开始前，term 先自增），成功当选的领导者会服务至本任期结束。也有可能存在任期内没有领导者的情况，比如出现分票（Split Vote），即不存在获得大多数投票的领导者，当发生这种情况时，系统会马上进入下一个新的任期（term 增长）并尝试重新选举。在 Raft 中，所有的节点都会保持一个当前任期的值，同时该值还会被持久化到本地磁盘中，以保证节点崩溃后能够恢复。

# 心跳检测及超时处理
跟随者是被动的，为了让它们一直处于跟随者状态，需要集群中有一个领导者始终与它们保持通信，如果领导者没有主动发起日志复制的请求，那么领导者就必须定时向它们发送心跳检测消息，在 Raft 中，这些心跳检测消息只是一些不含有任何数据信息的 AppendEntries 远程调用。如果在一段时间内，跟随者没有收到任何的远程调用，那么它会认为集群中没有可达或者可用的领导者，因此它就会开始发起选举，看它是否有必要称为新的领导者。这段时间被称为选举超时（election timeout），通常这个时间为 100 ms 到 500 ms。

# 选举
当集群启动时，所有的节点都是跟随者，它们会等待选举超时结束后开始选举。节点在开始选举时，首先会增加当前的任期号，然后会将自己的状态转换为候选者状态，此时候选者会先给自己投票，然后再向其他所有的节点发送投票请求（Request Vote），如果该请求没有得到响应，它会持续发送重试的请求，知道获得响应为止。接下来可能会出现三种情况：

- 第一种，就是大多数情况，获选者获得了大多数选票，然后它会将自己的状态改为领导者并持续向集群的其他节点发送心跳检测。
- 第二种，可能同时还有其他候选者在运行，或许它们有可能获得大多数选票成为领导者，此时如果候选者收到来自领导者的 RPC 调用，那么它会立刻从候选者状态转换为跟随者状态。
- 第三种，可能没有任何节点获胜，如果存在多个节点同时成为候选者，它们会导致分票，没有节点能够获得大多数投票。为了检测这种情况，随着时间的推移，如果一个候选者既没能成为领导者，也没有获得到来自领导者的请求或心跳，那么它就会假定出现了分票，此时它会简单地增加任期号，重新进行选举。

## 选举的 safety 和 liveness
为了保证选举的 safety，每个节点只会给一个候选者投票，一旦它投出选票，那么它就会拒绝来自其他候选者的任何请求。为了实现这种机制，节点会将自己的投票信息持久化到磁盘。

在理论上，可能会出现反复分票的情况，多个获选者在同一任期内同时开始选举，在超时时间后，新一轮的选举再次出现分票，如此循环。为了保证选举的 liveness，每个节点会随机地计算下次超时时间间隔，这个时间间隔在 [T, 2T] 之间，其中 T 代表选举的超时时间。通过将超时时间分散，可以降低两个节点同时开始选举的几率，先开始的节点有充足的时间向其他节点发送投票请求，并在其他节点参与竞争之前就完成选举过程。

> 当选举超时时间（election timeout）远大于广播投票的时间（一个节点与其他所有节点通信所需的时间）时，Raft 的这个策略就会非常有效。