---
title: 消息队列中间件
date: 2019/11/12 15:17:0
tags: [消息队列]
categories: [消息队列]
---
从命名上看，消息队列可以简单理解为存放消息的队列（Queue），而队列是一种常见的数据结构，在 Java 中的 `java.util.Queue` 接口下就有大量的队列实现。在一些业务场景中，我们可以使用 JDK 以及第三方包提供的队列实现，但是有些场景我们就不得不引入独立的队列组件，这有点类似 `java.util.HashMap` 与 Redis 的关系，它们都是以 key/value 的形式将数据存储到内存，但是在很多场景中我们需要使用 Redis 来替换 HashMap。

<!--more-->

> 消息队列更为准确的描述是存放消息的容器，消息的生产者将消息放入容器，消费者可以从容器中取出消息进行消费。

# 为什么要使用消息队列
使用消息队列可以实现异步、解耦、削峰和流控，同时分布式系统中也可以使用消息队列来实现最终一致性。

## 异步
我们可以根据传递方式的不同将消息划分为同步消息和异步消息。同步消息中比较有代表性的就是 RPC 调用，而异步消息中比较有代表性的就是使用消息队列。异步消息一般不怎么关心消息执行的结果，如果希望了解异步消息的执行情况，通常有**轮询和通知**两种方式。轮询具体是指在消息执行完毕后向其他设备（比如一个阻塞队列等）刷新执行结果，由主调方轮询查看结果；而通知则可以通过注册回调的方式实现。

假如系统中有一个耗时操作，我们正常调用该操作时，需要等待该操作结束后才能得到返回结果并继续向下执行，如果此时我们在系统中引入消息队列，将耗时操作需要的参数发送给消息队列，由队列代为执行，则可以不用等待耗时操作结束就可以直接返回。

## 削峰/流控
使用消息队列实现的异步处理可以延伸出一个比较常用的功能，那就是削峰和流控。比如一个系统，在不使用消息队列的时候，用户的请求数据经过处理后直接写入到数据库中，在请求量突然增大的情况下，数据库的压力也会骤然增大，使得整个系统的响应速度变慢。在使用了消息队列之后，用户的请求数据会直接发送给消息队列后立即返回，消息队列的消费者进程会从消息队列中获取数据并写入到数据库中。由于消息队列的消息处理能力一般高于数据库，同时消息队列的伸缩性也优于数据库，因此整个系统的响应速度会得到大幅提升。

![削峰](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912031751/2019/12/03/5Qe.png)

## 解耦
有一个比较常见的业务场景，比如一个模块或系统，我们称为 A。A 需要将产生的数据传递给其他模块或系统，因此我们在 A 中直接调用其他模块或系统的方法来传递数据，而当其中的某个模块或系统不再需要该数据时，我们还需要再去修改 A 的逻辑，去掉向该模块或系统传递数据的方法。在这种场景下，如果业务频繁变更，我们需要不断修改 A 的逻辑，系统的可扩展性较差。

```java
public class SystemA {
    private SystemB systemB = new SystemB();
    private SystemC systemC = new SystemC();

    private void doSomething() {
        // execute A's logic
    }

    public void deliverData() {
        var data = this.doSomething();
        systemB.needToDo(data);
        systemC.needToDo(data);
    }
}
```

我们知道如果模块之间不存在直接调用，那么添加或修改模块就不会对其他模块产生较大的影响，这样系统的可扩展性无疑会更好。在这种思想的指导下一般我们会引入一个中间者，作为它们之间沟通和协调的枢纽。这个枢纽在这里就是消息队列，并且结合业务的特点，我们可以使用消息队列的发布/订阅模式，消息的发送者（生产者）发送消息，一个或多个消息接收者（消费者）订阅消息，这样消息发送者和消息接收者之间就避免了直接耦合，从而达到解耦的目的。

![解耦](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912091502/2019/12/09/kKd.png)

# 消息队列的本质
RPC 大多都是基于请求/响应模型的，这也包括响应式范式。一般需要点对点通信、强事务保证以及延迟敏感的服务大多使用 RPC 而不是消息队列。从某种意义上讲，消息队列可以看做是一种异步的 RPC，它把一次 RPC 拆分成了两次 RPC 加一次转储，如果需要消费者最终做消费确认则是三次 RPC。在消息队列中，消息发送者将消息投递到服务端（或者叫做 Broker），服务端需要考虑如何承载消息的堆积，然后在合适的时机再将消息转发给消息接收者。

# 常见的消息队列协议
在消息队列中，消息的发送者需要知道如何构造消息，消息的接收者需要知道如何解析消息，它们需要按照一种统一的格式描述消息，这种统一的格式被称为消息协议。常见的消息队列通信协议包括 STOMP、AMQP、MQTT、OpenWire（ActiveMQ）、HTTP、XMPP 等，也有很多消息中间件使用自定义的通信协议，比如 RocketMQ、Kafka 等。

## STOMP
STOMP 的全称为 The Simple (or Streaming) Text Oriented Messaging Protocol，意为**简单（或流式）面向文本的消息协议**。它是一种基于本文的协议，同时它也是一种基于帧的协议，帧的结构效仿了 HTTP 报文的格式，简单明了，比如：

```
COMMAND
header1:value1
header2:value2

Body^@
```

STOMP 提供了能够协作的报文格式，因此 STOMP 客户端可以与任何 STOMP 消息代理（Broker）进行通信。该协议的优点就是简单且易于实现，几乎所有的编程语言都有 STOMP 的客户端实现，缺点也很明显，它在消息大小和处理速度方面并无优势。比较典型的实现了该协议的消息队列就是 Apache ActiveMQ 和 Apache ActiveMQ Artemis。

很多时候，我们在使用 WebSocket 时通常会配合 STOMP 协议来实现实时通信的功能，也就是使用 STOMP over Websocket。这是因为 WebSocket 只定义了两种类型的消息：文本和二进制，但是它们的内容和格式并没有定义。因此我们需要在客户端与服务端之间定义一种更高级别的消息协议，将它使用在 WebSocket 之上去定义每次发送消息的类别、格式和内容等信息。而 STOMP 可用于任何可靠的双向流网络协议之上，比如 TCP 和 WebSocket，因此在 WebSocket 协议之上使用 STOMP 协议也就顺理成章了。

## AMQP
AMQP 协议的全称为 Advanced Message Queuing Protocol，意为**高级消息队列协议**。它是一种二进制的应用层协议，规范了消息传递方和消息接收方的行为，以使消息在不同的提供商之间实现互操作。与 JMS 在特定的 API 接口层面和实现行为上进行统一不同，AMQP 更关注于各种消息如何以字节流的形式传递，因此任何实现了该协议的应用程序之间都可以进行消息的接收和传递。

![AMQP](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912121531/2019/12/12/Ezg.png)

AMQP 协议比较全面且功能强大，但是实现比较复杂。典型的实现了该协议的消息队列就是 RabbitMQ。

## JMS
严格来说将 JMS 归为消息通信协议是不严谨的，但是我们又不得不提到 JMS。JMS 全称 Java Message Service，即 Java 消息服务。它是 Java 平台提供的面向消息中间件的 API，没有定义通信方式和报文格式等细节。这有点类似于 JDBC，由 JCP 组织发布 JDBC 规范，然后具体的数据库厂商来实现这套规范，比如 MySQL JDBC Driver。因此为了便于理解，我们可以将 JMS 看作 JDBC，将不同的消息队列看作是不同的数据库软件，如果某个消息中间件厂商实现了 JMS 规范，我们就可以直接使用 JMS API 来操作它。从这一点来讲，JMS 协议就不像 AMQP 和 MQTT 这种操作级的协议，直接定义了所有的交互细节，这样就可以只通过一个客户端来操作不同的实现了对应协议的消息中间件。

![JMS API](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/MyE.png)

JMS 中有两个重要的概念需要解释清楚，一个是 Provider，另一个是 Destination。其中 Provider 是消息的中转者，负责消息的存储和转发，在 ActiveMQ 中又叫做 Broker。比如一个 ActiveMQ 服务就是一个 Broker 或 Provider。而 Destination 则指明了消息发送的目的地以及客户端接收消息的来源，在 JMS 有两种目的地：队列（Queue）和主题（Topic）。

![JMS](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/ebr.png)

JMS 支持两种消息传送模型，一种是点对点（P2P）模型，一种是发布/订阅（Pub/Sub）模型。

点对点（PTP）消息模型也可称之为队列模式，特定的一条消息只能被一个消费者消费。生产者将消息发送到指定的 Queue 当中，Broker（中间件）针对消息是否需要持久化进行持久化存储后通知消费者进行处理，消费者处理完毕后发送一个回执（Acknowledge）给 Broker，Broker 认为该消息已被正常消费，于是从持久化存储中删除该条消息。回执的发送逻辑内嵌在 MQ 的 API 中，无需主动调用。消费者通常可以通过两种方式获取新消息：PUSH 和 PULL。PUSH 方式，由 MQ 收到消息后主动调用消费者的新消息通知接口，需要消耗 MQ 宝贵的线程资源，同时消费者只能被动等待消息通知；PULL 方式，由消费者轮询调用 MQ API 去获取新消息，对应于 ActiveMQ 中的 consumer.receive()，不消耗 MQ 线程，消费者更加主动，相对的消费者的处理逻辑会变得稍稍复杂。两种方式的根本区别在于线程消耗问题，由于 MQ 的线程资源相对客户端更加宝贵，PUSH 方式会占用 MQ 过多的线程从而难以适应高并发的消息场景。同时当某一消费者离线一段时间再次上线后，大量积压消息处理会消耗大量 MQ 线程从而拖累其它消费者的消息处理，所以 PULL 方式相对来说更好。Kafka 已经抛弃了 PUSH 模式，全面拥抱 PULL 模式。

![PTP](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/9JP.png)

发布/订阅模式（Pub/Sub）也可称之为主题模式，特定的一条消息可以被多个消费者所接收，只要消费者订阅了该主题。消息生产者（发布者）将消息发送到某个称为主题（Topic）的虚拟通道中，Topic 可以被多个消费者订阅，因此该模式类似于广播的方式。发布/订阅模式采用 PUSH 的方式传送消息，Subscriber 只需保持在线即可。Subscriber 分为临时性的和持久性的，当 Sub 离线时，MQ 会为持久性的 Sub 持久化消息，当 Sub 恢复时会重新收到消息。但是既然采用 Pub/Sub 模式就表明允许部分消费者接收不到消息，所以通常会采用临时性的 Subscriber 而不是持久性的。

![Pub/Sub](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912131556/2019/12/13/Ywy.png)

# 使用消息队列带来的问题
引入消息队列后，系统的可用性在某种程度上会下降，同时系统的复杂度也会提升。因为在引入消息队列之前，我们无需考虑消息队列挂掉的情况，但是在引入以后，我们就需要考虑这种情况，为此可能需要引入主从甚至是分布式消息队列，系统的复杂度无疑增加了很多，同时在引入了消息队列以后，我们还需要保证消息没有被重复消费和消息传递的顺序性，同时还要处理消息可能面临的丢失等问题，如果消费者没有正确消费消息，还有可能造成数据不一致的情况。

# 参考
> [消息队列设计精要](https://zhuanlan.zhihu.com/p/21649950)

> [新手也能看懂，消息队列其实很简单](https://zhuanlan.zhihu.com/p/52773169)

> [JMS 介绍：我对 JMS 的理解和认识](https://blog.csdn.net/KimmKing/article/details/6577021)