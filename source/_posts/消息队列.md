---
title: 消息队列中间件
date: 2019/11/12 15:17:0
tags: [消息队列]
categories: [消息队列]
---
从命名上看，消息队列可以简单理解为存放消息的队列（Queue），而队列是一种常见的数据结构，在 Java 中的 `java.util.Queue` 接口下就有大量的队列实现。在一些业务场景中，我们可以使用 JDK 以及第三方包提供的队列实现，但是有些场景我们就不得不引入独立的队列组件，这有点类似 `java.util.HashMap` 与 Redis 的关系，它们都是以 key/value 的形式将数据存储到内存，但是在很多场景中我们需要使用 Redis 来替换 HashMap。

<!--more-->

> 消息队列更为准确的描述是存放消息的容器，消息的生产者将消息放入容器，消费者可以从容器中取出消息进行消费。

# 为什么要使用消息队列
使用消息队列可以实现异步、解耦、削峰和流控，同时分布式系统中也可以使用消息队列来实现最终一致性。

## 异步
我们可以根据传递方式的不同将消息划分为同步消息和异步消息。同步消息中比较有代表性的就是 RPC 调用，而异步消息中比较有代表性的就是使用消息队列。异步消息一般不怎么关心消息执行的结果，如果希望了解异步消息的执行情况，通常有**轮询和通知**两种方式。轮询具体是指在消息执行完毕后向其他设备（比如一个阻塞队列等）刷新执行结果，由主调方轮询查看结果；而通知则可以通过注册回调的方式实现。

假如系统中有一个耗时操作，我们正常调用该操作时，需要等待该操作结束后才能得到返回结果并继续向下执行，如果此时我们在系统中引入消息队列，将耗时操作需要的参数发送给消息队列，由队列代为执行，则可以不用等待耗时操作结束就可以直接返回。

## 削峰/流控
使用消息队列实现的异步处理可以延伸出一个比较常用的功能，那就是削峰和流控。比如一个系统，在不使用消息队列的时候，用户的请求数据经过处理后直接写入到数据库中，在请求量突然增大的情况下，数据库的压力也会骤然增大，使得整个系统的响应速度变慢。在使用了消息队列之后，用户的请求数据会直接发送给消息队列后立即返回，消息队列的消费者进程会从消息队列中获取数据并写入到数据库中。由于消息队列的消息处理能力一般高于数据库，同时消息队列的伸缩性也优于数据库，因此整个系统的响应速度会得到大幅提升。

![削峰](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912031751/2019/12/03/5Qe.png)

## 解耦
有一个比较常见的业务场景，比如一个模块或系统，我们称为 A。A 需要将产生的数据传递给其他模块或系统，因此我们在 A 中直接调用其他模块或系统的方法来传递数据，而当其中的某个模块或系统不再需要该数据时，我们还需要再去修改 A 的逻辑，去掉向该模块或系统传递数据的方法。在这种场景下，如果业务频繁变更，我们需要不断修改 A 的逻辑，系统的可扩展性较差。

```java
public class SystemA {
    private SystemB systemB = new SystemB();
    private SystemC systemC = new SystemC();

    private void doSomething() {
        // execute A's logic
    }

    public void deliverData() {
        var data = this.doSomething();
        systemB.needToDo(data);
        systemC.needToDo(data);
    }
}
```

我们知道如果模块之间不存在直接调用，那么添加或修改模块就不会对其他模块产生较大的影响，这样系统的可扩展性无疑会更好。在这种思想的指导下一般我们会引入一个中间者，作为它们之间沟通和协调的枢纽。这个枢纽在这里就是消息队列，并且结合业务的特点，我们可以使用消息队列的发布/订阅模式，消息的发送者（生产者）发送消息，一个或多个消息接收者（消费者）订阅消息，这样消息发送者和消息接收者之间就避免了直接耦合，从而达到解耦的目的。

![解耦](https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201912091502/2019/12/09/kKd.png)

# 消息队列的本质
RPC 大多都是基于请求/响应模型的，这也包括响应式范式。一般需要点对点通信、强事务保证以及延迟敏感的服务大多使用 RPC 而不是消息队列。从某种意义上讲，消息队列可以看做是一种异步的 RPC，它把一次 RPC 拆分成了两次 RPC 加一次转储，如果需要消费者最终做消费确认则是三次 RPC。在消息队列中，消息发送者将消息投递到服务端（或者叫做 Broker），服务端需要考虑如何承载消息的堆积，然后在合适的时机再将消息转发给消息接收者。

# 常见的消息队列协议
常见的消息队列通信协议包括 STOMP、AMQP、MQTT、OpenWire（ActiveMQ）、HTTP、XMPP 等，也有很多消息中间件使用自定义的通信协议，比如 RocketMQ、Kafka 等。

## STOMP
STOMP 的全称为 The Simple (or Streaming) Text Oriented Messaging Protocol，翻译过来的意思就是**简单的面向文本或流的消息传递协议**。STOMP 提供了能够协作的报文格式，因此 STOMP 客户端可以与任何 STOMP 消息代理（Broker）进行通信，从而为多语言和多平台提供简单且普遍的消息协作。

STOMP 是一种基于帧的协议，帧的结构效仿了 HTTP 报文的格式，简单明了，比如：

```
COMMAND
header1:value1
header2:value2

Body^@
```

很多时候，我们在使用 WebSocket 时通常会配合 STOMP 协议来实现实时通信的功能，也就是使用 STOMP over Websocket。这是因为 WebSocket 只定义了两种类型的消息：文本和二进制，但是它们的内容和格式并没有定义。因此我们需要在客户端与服务端之间定义一种更高级别的消息协议，将它使用在 WebSocket 之上去定义每次发送消息的类别、格式和内容等信息。而 STOMP 可用于任何可靠的双向流网络协议之上，比如 TCP 和 WebSocket，因此在 WebSocket 协议之上使用 STOMP 协议也就顺理成章了。

# 使用消息队列带来的问题
引入消息队列后，系统的可用性在某种程度上会下降，同时系统的复杂度也会提升。因为在引入消息队列之前，我们无需考虑消息队列挂掉的情况，但是在引入以后，我们就需要考虑这种情况，为此可能需要引入主从甚至是分布式消息队列，系统的复杂度无疑增加了很多，同时在引入了消息队列以后，我们还需要保证消息没有被重复消费和消息传递的顺序性，同时还要处理消息可能面临的丢失等问题，如果消费者没有正确消费消息，还有可能造成数据不一致的情况。

# 参考
> [消息队列设计精要](https://zhuanlan.zhihu.com/p/21649950)

> [新手也能看懂，消息队列其实很简单](https://zhuanlan.zhihu.com/p/52773169)