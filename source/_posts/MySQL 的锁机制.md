---
title: MySQL 的锁机制
date: 2020/7/16 10:34:0
tags: [数据库]
categories: [数据库]
---

并发事务访问相同记录的情况大致可以分为三种：读读、读写和写写。读读的情况并不会产生并发问题，真正会产生问题的是并发的读写或者写写。并发的写写可能会产生脏写和丢失更新的问题，由于这类问题比较严重，数据库会通过加锁的方式阻塞并发的修改，因此在任何隔离级别下数据库都不会出现脏写和丢失更新的情况，但是在应用层面，还是有可能出现逻辑意义上的丢失更新。

<!--more-->

并发的读写可能会产生脏读、不可重复读以及幻读的问题。处理这类问题有两种可选的方案，一种是对写操作加锁，读操作则利用 MVCC 机制。在 READ COMMITTED 隔离级别中，一个事务中每次执行普通的 SELECT 操作都会生成一个 ReadView，这样就保证了每次的读操作都只能读到已经提交的事务的更改。而在 REPEATABLE READ 隔离级别中，一个事务中只有第一次执行普通的 SELECT 操作才会生成一个 ReadView，之后的读操作都会复用该 ReadView，因此也就避免了不可重复读和幻读的问题。

另一种就是对读操作和写操作都加锁，如果一些业务场景中不允许读取记录的旧版本，而是每次都需要读取记录的最新版本，那么就需要在读的时候加锁，同时写操作也需要加锁，这也就意味着读写操作也像写写操作那样排队执行。很明显，因为使用 MVCC 可以使读写操作并发执行，因此性能更好。在一般情况下，我们都采用默认的方式，也就是读操作利用 MVCC，写操作加锁。当一些业务需要的时候，再手动给读操作加锁。

# MySQL 中的数据操作
在 MySQL 中，读操作分为两种。一种是快照读（Snapshot Read），也叫做一致性读（Consistent Read）或者一致性无锁读。快照读通过 MySQL 的 MVCC 机制实现，不需要加锁，读取的是当前记录的快照。所有普通的 SELECT（plain SELECT）语句在读提交和可重复读隔离级别下都是快照读。

另一种就是锁定读（Locking Read），也叫做当前读（Current Read）。当前读可以看作是一种特殊的读操作，它读取的是最新的记录，包括隐含当前读逻辑的插入、更新和删除，以及一些手工添加锁的读都是当前读。使用 `SELECT ... LOCK IN SHARE MODE` 语句会为读取到的数据加入 S 锁，这样别的事务可以继续获取这些记录的 S 锁，但是不能获取这些记录的 X 锁。使用 `SELECT ... FOR UPDATE` 语句会为读取到的数据加入 X 锁，这样别的事务就无法再获取这些记录的 S 锁和 X 锁。

在 MySQL 中，写操作无非就是 DELETE、UPDATE 和 INSERT 这三种。对一条记录进行 DELETE 操作的过程实际上是先在 B+树中定位到这条记录的位置，然后获取该记录的 X 锁，最后再执行设置删除标记位的操作。因此我们可以把删除操作看作是一个获取 X 锁的锁定读。

对一条记录进行 UPDATE 操作时可以分为三种情况。第一种就是没有修改该记录的键值，并且更新后的列占用的存储空间没有发生变化，那么只需要在 B+树中定位该记录，然后获取该记录的 X 锁，最后完成修改操作即可。因此这个过程可以看作是一个获取 X 锁的锁定读。第二种就是没有修改该记录的键值，但是更新后至少有一个列占用的存储空间发生了变化，那么就需要在 B+树中定位该记录，然后获取该记录的 X 锁，接下来将该记录删除掉，最后再插入一条新的记录。这个定位记录的过程可以看作是一个获取 X 锁的锁定读，而接下来新插入的记录由 INSERT 操作提供的隐式锁来保护。第三种就是修改了该记录的键值，此时相当于在原记录上做了 DELETE 操作后又进行了一次 INSERT 操作。

对于 INSERT 操作来说，新插入一条记录的操作会通过隐式锁来保护这条插入的记录在本事务提交之前不会被其他事务访问。

# MySQL 中的锁分类
从锁的属性来分，锁分为两种：共享锁（S 锁）和独占锁（X 锁）。一个事务获取到了一些记录的 S 锁，其他事务还可以继续获取这些记录的 S 锁，但是不可以获取这些记录的 X 锁。而当一个事务获取到了一些记录的 X 锁，那么其他事务就不能再获取这些记录的 S 锁和 X 锁。也就是 S 锁和 X 锁互斥，同时 X 锁与 X 锁也互斥，只有 S 锁与 S 锁能够共存。

从锁的粒度来分，锁可以分为行锁和表锁。如果给一个表加了 S 锁，那么其他事务可以继续获取该表或者该表中某些记录的 S 锁，但是不能获取该表或者该表中某些记录的 X 锁。而如果给一个表加了 X 锁，那么其他事务既不能给该表或者该表中的某些记录加 S 锁，也不能给该表或者该表中的某些记录加 X 锁。

有的时候我们需要在给表上锁之前检查表中有没有行锁，此时不可能依次遍历每一条记录，因此 InnoDB 提供了一种称为意向锁的表锁。意向锁可以分为意向共享锁（Intention Shared Lock）和意向独占锁（Intention Exclusive Lock）。意向共享锁也叫 IS 锁，当事务准备给某条记录加 S 锁时，需要先给表加一个 IS 锁。而意向独占锁也叫 IX 锁，当事务准备给某条记录加 X 锁时，需要先给表加一个 IX 锁。有了这两种锁，我们在给某条记录加 S 锁时，先要给整个表加一个 IS 锁，之后如果需要给表加 S 锁，那么就需要检查该表有没有 IX 锁，如果没有则可以给表加 S 锁，否则需要等 IX 锁释放。同样，如果我们要给某条记录加 X 锁时，需要先给整个表加一个 IX 锁，之后如果需要给表加 X 锁，需要先看该表有没有 IS 锁和 IX 锁，如果没有则可以直接给表加 X 锁，否则需要等待锁释放。

虽然 IS 和 IX 是表锁，但是它们仅仅是为了在给表加锁时可以快速判断表中的记录是否上锁，因此 IS 与 IX 是可以共存的。

# InnoDB 中的表锁
InnoDB 中的表锁除了之前所说的 S 锁和 X 锁，IS 锁和 IX 锁，还有 AUTO-INC 锁，该锁只有在某个列添加了 AUTO_INCREMENT 属性，之后插入记录时才会使用。

在对某个表执行增删改查操作时，InnoDB 存储引擎是不会为该表添加 S 锁或者 X 锁的。另外对于一些 DDL 操作，比如 ALTER TABLE、DROP TABLE 等操作，其实是在 MySQL 的 Server 层使用了一种称为元数据锁（Metadata Locks）的东西来实现的。只有在一些特殊场景下使用，比如崩溃恢复。当然我们也可以手工获取，比如先设置 `autocommit=0, innodb_table_locks=1`，然后通过 `LOCK TABLES t READ` 和 `LOCK TABLES t WRITE` 来分别获取表 t 的 S 锁和 X 锁。

# InnoDB 中的行锁
InnoDB 中的行锁有很多种，包括普通的记录锁（官方名称为 `LOCK_REC_NOT_GAP`）、GAP 锁（又叫间隙锁，官方名称为 `LOCK_GAP`）、Next-Key Locks（官方名称为 `LOCK_ORDINARY`）、插入意向锁（官方称为 `LOCK_INSERT_INTENTION`）。

普通的记录锁有 S 锁和 X 锁之分，它们之间的关系与之前讲的一样，S 锁之间可以共存，S 锁与 X 锁之间、X 锁与 X 锁之间不能共存。

## GAP 锁
我们说 MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，具体来说是通过 MVCC 机制解决了快照读时可能产生的幻读问题，通过 Next-Key Locks 解决了使用当前读时可能产生的幻读问题。

由于在事务在第一次执行读取操作时，那些幻影记录并不存在，因此我们无法给这些记录加上普通的记录锁，这时就可以使用 GAP 锁。为了说明方便，这里先创建一个表：

```sql
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country VARCHAR(100),
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;

INSERT INTO hero VALUES
    (1, 'l刘备', '蜀'),
    (3, 'z诸葛亮', '蜀'),
    (8, 'c曹操', '魏'),
    (15, 'x荀彧', '魏'),
    (20, 's孙权', '吴');
```

如果我们给 number 为 8 的那条记录加一个 GAP 锁，那么就不允许别的事务在 number 值为 8 的记录前的**间隙**插入新的记录，也就是 `(3,8)` 这个区间内是不允许立即插入新纪录的。比如一个 number 为 4 记录就无法插入到该间隙中。

可以看到，给一条记录添加一个 GAP 锁，只是不允许其他事务在这条记录前的间隙插入新记录，那么如果往是最后一条记录之后的间隙插入新记录又该怎么办呢？答案就是给表中最后一条记录，也就是 number 值为 20 的记录所在页面的 Supremum 记录加上一个 GAP 锁。由于 Supremum 记录总是比该数据页中最大的行记录还大，因此可以阻止其他事务向 `(20, +∞)` 这个区间插入新记录。

## Next-Key Locks
