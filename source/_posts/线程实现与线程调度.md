---
title: 线程实现与线程调度
date: 2018/6/2 19:30:0
tags: [Java,Java 多线程]
categories: [Java 多线程]
---

主要讲解线程的实现、Java 是如何实现线程的、Java 线程的调度。  

<!--more-->  

# 线程的实现

实现线程主要有三种方式：使用内核线程的实现、使用用户线程的实现和使用用户线程 + 轻量级进程混合实现。  

## 使用内核线程实现

内核线程（Kernel-Level Thread, KLT）就是直接由操作系统内核支持的线程，这种线程由内核完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。  

程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process, LWP），这种轻量级进程与内核线程之间是 1:1 的关系。  

![内核线程 ](https://img.nekolr.com/images/2018/06/02/kxy.png)  

- 优点
由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在调用时阻塞了，也不会影响整个进程继续工作。  

- 缺点
由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行内核的调用，而内核调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）间来回切换。并且由于每个轻量级进程都需要一个内核线程支持，所以一个系统支持的轻量级进程的数量是有限的。  

## 使用用户线程实现

广义上讲，一个线程只要不是内核线程就可以认为是用户线程（User Thread, UT），因此广义上轻量级进程也属于用户线程。狭义上的用户线程指的是完全建立在用户空间的线程，系统内核无法感知到用户线程的存在。用户线程的操作，如创建、同步、销毁和调度完全在用户态中完成，不需要内核帮助。  

![用户线程 ](https://img.nekolr.com/images/2018/06/02/8rQ.png)  

- 优点
由于不需要在用户态和内核态间来回切换，因此操作非常快速且消耗低，并且支持的线程数量也相对较大。  

- 缺点
由于没有内核的帮助，线程所有的操作都需要用户程序自己处理，并且由于操作系统只把资源分配给进程，诸如“阻塞如何处理”、“多处理器系统中如何将线程任务映射到各个处理器”，等这类问题处理比较困难。这些问题导致了现在单纯使用用户线程的程序越来越少了。  

## 使用用户线程和轻量级进程混合实现

在这种实现中，用户线程还是完全建立在用户空间，因此线程的创建、析构、切换等操作依然快速且消耗低，并且支持的线程数量较大。操作系统提供轻量级进程作为用户线程和内核线程的桥梁，这样可以使用内核提供的线程调度以及处理器映射，用户线程的调度也交由轻量级进程处理，这大大降低了进程阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N:M 的关系。许多 `UNIX` 系统，如 `Solaris`、`HP-UX` 等都提供了 N:M 的线程模型。  

![混合 ](https://img.nekolr.com/images/2018/06/02/NXw.png)  

## Java 线程的实现

Java 的线程在 `JDK 1.2` 之前是基于称为“绿色线程”（Green Thread）的用户线程实现的，在 `JDK 1.2` 线程模型替换成了基于操作系统原生线程模型来实现。因此，在目前的 JDK 版本中，不同的操作系统下，可能实现的方式不同。对于 `Sun JDK` 来说，在 `Windows` 和 `Linux` 系统中都是使用一对一的线程模型实现的，即一条 Java 线程映射到一个轻量级进程中。在 `Solaris` 平台中，由于操作系统支持一对一以及多对多的线程模型，所以在 `Solaris` 版的 JDK 提供了两个平台专有的虚拟机参数：`-XX:+UseLWPSynchronization` 和 `-XX:+UseBoundThreads` 来切换使用的线程模型。  

# 线程调度

线程调度是系统为线程分配处理器使用权的过程，主要的调度方式有两种，协同式线程调度和抢占式线程调度。  

## 协同式线程调度

使用协同式线程调度的多线程系统，线程的执行时间由线程本身控制。线程将自己的工作做完后，要主动通知系统切换到另一个线程。  

- 优点
实现简单，由于需要线程做完工作后主动通知系统进行线程切换，所以没有线程同步问题。  

- 缺点
线程执行时间不可控，如果一个线程编写有问题，一直不告知操作系统进行线程切换，那么程序将会阻塞，严重的可能会造成系统崩溃。  

## 抢占式线程调度

使用抢占式线程调度的多线程系统，每个线程由操作系统分配执行时间，线程切换不由线程来决定（Java 中，可以通过 `Thread.yield()` 让出执行时间，当然不一定管用）。  

- 优点
线程执行时间是确定的、可控的，因此不会有一个线程导致整个程序阻塞的问题。  

- 缺点
需要考虑线程同步问题。  

## Java 的线程调度

Java 的线程调度使用的是抢占式。  

虽然 Java 的线程调度是由操作系统自动完成的，但是我们还是可以“建议”操作系统给某些线程多一点执行时间，另外一些线程少一点执行时间，这个操作可以通过设置线程的优先级来完成。Java 提供了 10 个级别的线程优先级，在两个线程同时处于 `Ready` 状态时，优先级越高的越容易先被执行。不过，由于 Java 的线程是映射到原生线程上来实现的，所以最终的线程调度还是取决于操作系统，并且操作系统的线程优先级的数量可能和 Java 的不能一一对应（如 `Solaris` 中有 2^32 种优先级，而 `Windows` 中只有 7 种）。  

# 参考

> 《深入理解 Java 虚拟机:JVM 高级特性与最佳实践》