---
title: 数据结构中的树
date: 2019/2/19 10:50:0
tags: [数据结构]
mathjax: true
categories: [数据结构]
---
数据结构中的树有很多种，常见的树包括二叉树、自平衡二叉查找树和 B 树。

<!--more-->

![树](https://img.nekolr.com/images/2019/09/03/3pB.png)

# 树的相关术语
- 节点的度：一个节点包含的子树的个数。
- 叶子节点或终端节点：度为 0 的节点。
- 树的度：树内度最大的节点的度。
- 高度：对于任意节点 n，n 的高度为从 n 到一个叶子节点的最长路径长，所有的叶子节点高度都为 0。
- 深度：对于任意节点 n，n 的深度为从根节点到 n 的唯一路径长，根的深度为 0。
- 节点的层次：从根节点开始，根为第一层，根的子节点为第二层，以此类推。

![树的例子](https://img.nekolr.com/images/2019/09/03/o34.png)

# 二叉查找树
二叉查找树又叫二叉搜索树、有序二叉树或者排序二叉树，它是指一棵空树或者具有下列性质：
1. 若任意节点的左子树不为空，则左子树上所有节点的值均小于它根节点的值。
2. 若任意节点的右子树不为空，则右子树上所有节点的值均大于它根节点的值。
3. 任意节点的左、右子树也分别为二叉查找树。
4. 没有键值相等的节点。

![二叉查找树](https://img.nekolr.com/images/2019/09/03/BMN.png)

二叉查找树利用二分查找的思想，其查找、插入和删除的平均时间复杂度为 O(logN)，其中 N 为节点个数。**其实这里的时间复杂度就是树的高度**，理想状态下的时间复杂度为 O(logN)，最坏的情况下，二叉查找树会退化成线性表，此时的时间复杂度为 O(N)。很多改进版的二叉查找树可以使树高维持在 O(logN)，从而使最坏情况下的时间复杂度仍为 O(logN)，比如 AVL 树、红黑树等。

# AVL 树
AVL 树是最早被发明的自平衡二叉查找树，AVL 树的任意一个节点对应的两棵子树的最大高度差（或者叫做平衡因子，Balance Factor）为 1，因此它也被称为高度平衡树。AVL 树的查找、插入和删除在平均和最坏情况下的时间复杂度都为 O(logN)。插入和删除元素可能会使平衡因子大于 1，此时需要对树进行一次或者多次旋转，从而实现树的重新平衡。

插入和删除元素可能会引起树的失衡，可将情况分为四种。我们约定其中 Root 表示失衡树的根节点，Pivot 为旋转后重新平衡的树的根节点。

## LL 型
![LL](https://img.nekolr.com/images/2019/09/03/dy1.png)

LL 型，也就是左左型，失衡的原因可能是在 Pivot 的左子树上插入节点。调整过程为一次右旋，即以 Pivot 为轴心，Root 节点右旋成为 Pivot 的右子树，Root 的左子树由 Pivot 的右子树代替。

![LL右旋](https://img.nekolr.com/images/2019/09/03/AqD.png)

## RR 型
![RR](https://img.nekolr.com/images/2019/09/03/1OD.png)

RR 型，也就是右右型，失衡的原因可能是在 Pivot 的右子树上插入节点。调整过程为一次左旋，即以 Pivot 为轴心，Root 节点左旋称为 Pivot 的左子树，Root 的右子树由 Pivot 的左子树代替。

![RR左旋](https://img.nekolr.com/images/2019/09/03/Zvb.png)

## LR 型
![LR](https://img.nekolr.com/images/2019/09/03/NWJ.png)

LR 型，也就是左右型，失衡的原因可能是在 Pivot 的右子树上插入节点。调整过程为一次左旋加一次右旋，即以 Pivot 为轴心，Root 节点左旋成为 Pivot 的左子树，Root 的右子树由 Pivot 的左子树代替，这样就将 LR 型转换成了 LL 型，然后再按照 LL 型的方法右旋即可。

![第一次旋转](https://img.nekolr.com/images/2019/09/03/77L.png)

![第二次旋转](https://img.nekolr.com/images/2019/09/03/bbw.png)

## RL 型
![RL](https://img.nekolr.com/images/2019/09/03/BBg.png)

RL 型，也就是右左型，失衡的原因可能是在 Pivot 的左子树上插入节点。调整过程为一次右旋加一次左旋，即以 Pivot 为轴心，Root 节点右旋成为 Pivot 的右子树，Root 的左子树由 Pivot 的右子树代替，这样就将 RL 型转成了 RR 型，然后再按照 RR 型的方法左旋即可。

![第一次旋转](https://img.nekolr.com/images/2019/09/03/lgk.png)

![第二次旋转](https://img.nekolr.com/images/2019/09/03/jeY.png)

## AVL 树的局限性
由于维护这种高度平衡需要付出很大的代价，因此 AVL 的实际应用不多，更多的是采用追求局部而不是非常严格的整体平衡的红黑树。如果应用场景中插入和删除不频繁而查找频繁，那么 AVL 树还是优于红黑树的。

# 红黑树
红黑树是一种自平衡二叉查找树，与普通的二叉查找树不同的是，它的每个节点都带有颜色属性，颜色有红色或黑色两种。红黑树除了具有二叉查找树的性质外，还具有以下性质：
1. 节点是黑色或者红色。
2. 根是黑色的。
3. 所有的叶子节点（实际上就是 NULL 指针）都是黑色的。
4. 如果一个节点是红色的，那么它的两个子节点都是黑色的（也就是说，不能有两个相邻的红色节点）。
5. 从任意一个节点到其每个叶子节点的所有简单路径中都包含相同数目的黑色节点。

![红黑树](https://img.nekolr.com/images/2019/09/04/zMg.png)

红黑树的数据项只能存储在内部节点（internal node）中，叶子节点在其父节点中仅仅作为一个 NULL 指针表示，将它也看作一个节点有助于描述红黑树的插入和删除算法。以上性质决定了从根节点到叶子节点的最长路径的长度不会超过任何其他路径长度的两倍。比如有一棵红黑树，它的根节点到叶子节点的路径中黑色节点数为 3，从根节点到叶子节点的最短路径长为 2（黑 - 黑 - 黑），那么最长路径也只可能为 4（黑 - 红 - 黑 - 红 -黑）。

一个拥有 N 个内部节点的红黑树的树高 $h <= 2log(N + 1)$。

## 红黑树与 AVL 树比较
红黑树并不追求高度平衡，即不像 AVL 树那样要求 $BF <= 1$，它只要求部分达到平衡，通过这种非严格的平衡来换取插入和删除节点时旋转次数的降低。在插入节点导致树失衡时，AVL 树和红黑树都可以通过最多两次旋转来实现树的重新平衡，旋转的时间复杂度为 O(1)。在删除节点导致树失衡时，AVL 树需要维护从被删除节点到根节点这条路径上所有节点的平衡，旋转的时间复杂度为 O(logN)，而红黑树最多只需要 3 次旋转就可以实现树的重新平衡。

红黑树的查询性能稍逊于 AVL 树。在具有相同节点的情况下，红黑树的高度最多会比 AVL 树多 1。
