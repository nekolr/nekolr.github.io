---
title: 数据结构中的树
date: 2019/2/19 10:50:0
tags: [数据结构]
categories: [数据结构]
---
数据结构中的树有很多种，常见的树包括二叉树、自平衡二叉查找树和 B 树。

<!--more-->

![树](https://img.nekolr.com/images/2019/09/03/3pB.png)

# 树的相关术语
- 节点的度：一个节点包含的子树的个数。
- 叶子节点或终端节点：度为 0 的节点。
- 树的度：树内度最大的节点的度。
- 高度：对于任意节点 n，n 的高度为从 n 到一个叶子节点的最长路径长，所有的叶子节点高度都为 0。
- 深度：对于任意节点 n，n 的深度为从根节点到 n 的唯一路径长，根的深度为 0。
- 节点的层次：从根节点开始，根为第一层，根的子节点为第二层，以此类推。

![树的例子](https://img.nekolr.com/images/2019/09/03/o34.png)

# 二叉查找树
二叉查找树又叫二叉搜索树、有序二叉树或者排序二叉树，它是指一棵空树或者具有下列性质：
1. 若任意节点的左子树不为空，则左子树上所有节点的值均小于它根节点的值。
2. 若任意节点的右子树不为空，则右子树上所有节点的值均大于它根节点的值。
3. 任意节点的左、右子树也分别为二叉查找树。
4. 没有键值相等的节点。

![二叉查找树](https://img.nekolr.com/images/2019/09/03/BMN.png)

二叉查找树利用二分查找的思想，其查找、插入和删除的平均时间复杂度为 O(logN)，其中 N 为节点个数。**其实这里的时间复杂度就是树的高度**，理想状态下的时间复杂度为 O(logN)，最坏的情况下，二叉查找树会退化成线性表，此时的时间复杂度为 O(N)。很多改进版的二叉查找树可以使树高维持在 O(logN)，从而使最坏情况下的时间复杂度仍为 O(logN)，比如 AVL 树、红黑树等。

# AVL 树
AVL 树是最早被发明的自平衡二叉查找树，AVL 树的任意一个节点对应的两棵子树的最大高度差（或者叫做平衡因子）为 1，因此它也被称为高度平衡树。AVL 树的查找、插入和删除在平均和最坏情况下的时间复杂度都为 O(logN)。插入和删除元素可能会使平衡因子大于 1，此时需要对树进行一次或者多次旋转，从而实现树的重新平衡。

插入和删除元素时，可能会引起树的失衡，可将情况分为四种。我们约定其中 Root 表示失衡树的根节点，Pivot 为旋转后重新平衡的树的根节点。

## LL 型
![LL](https://img.nekolr.com/images/2019/09/03/dy1.png)

LL 型，也就是左左型，失衡的原因是在 Pivot 的左子树上插入节点。调整过程为一次右旋，即以 Pivot 为轴心，Root 节点右旋成为 Pivot 的右子树，Root 的左子树由 Pivot 的右子树代替。

![LL右旋](https://img.nekolr.com/images/2019/09/03/AqD.png)

## RR 型
![RR](https://img.nekolr.com/images/2019/09/03/1OD.png)

RR 型，也就是右右型，失衡的原因是在 Pivot 的右子树上插入节点。调整过程为一次左旋，即以 Pivot 为轴心，Root 节点左旋称为 Pivot 的左子树，Root 的右子树由 Pivot 的左子树代替。

![RR左旋](https://img.nekolr.com/images/2019/09/03/Zvb.png)

## LR 型
![LR](https://img.nekolr.com/images/2019/09/03/NWJ.png)

LR 型，也就是左右型，失衡的原因是在 Pivot 的右子树上插入节点。调整过程为一次左旋加一次右旋，即以 Pivot 为轴心，Root 节点左旋成为 Pivot 的左子树，Root 的右子树由 Pivot 的左子树代替，这样就将 LR 型转换成了 LL 型，然后再按照 LL 型的方法右旋即可。

![第一次旋转](https://img.nekolr.com/images/2019/09/03/77L.png)

![第二次旋转](https://img.nekolr.com/images/2019/09/03/bbw.png)

## RL 型
![RL](https://img.nekolr.com/images/2019/09/03/BBg.png)

RL 型，也就是右左型，失衡的原因是在 Pivot 的左子树上插入节点。调整过程为一次右旋加一次左旋，即以 Pivot 为轴心，Root 节点右旋成为 Pivot 的右子树，Root 的左子树由 Pivot 的右子树代替，这样就将 RL 型转成了 RR 型，然后再按照 RR 型的方法左旋即可。

![第一次旋转](https://img.nekolr.com/images/2019/09/03/lgk.png)

![第二次旋转](https://img.nekolr.com/images/2019/09/03/jeY.png)
