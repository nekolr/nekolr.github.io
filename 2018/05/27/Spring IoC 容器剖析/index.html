<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat72.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat48.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.nekolr.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.15.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":null,"show_result":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="使用 spring 5.1.19.RELEASE 分析  整个 IoC 容器都是围绕着 BeanFactory 和 ApplicationContext 来设计的。BeanFactory 提供了容器的基本功能。ApplicationContext 继承自 BeanFactory，不光实现了容器的基本功能，还实现了一些更高级的容器特性。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring IoC 容器剖析">
<meta property="og:url" content="https://blog.nekolr.com/2018/05/27/Spring%20IoC%20%E5%AE%B9%E5%99%A8%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="nekolr&#39;s blog">
<meta property="og:description" content="使用 spring 5.1.19.RELEASE 分析  整个 IoC 容器都是围绕着 BeanFactory 和 ApplicationContext 来设计的。BeanFactory 提供了容器的基本功能。ApplicationContext 继承自 BeanFactory，不光实现了容器的基本功能，还实现了一些更高级的容器特性。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/3q7.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/o6x.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/WnD.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/YAN.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/28/LXL.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/12/5NM.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/16/kbQ.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/16/Evd.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/21/P3q.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/21/9vo.png">
<meta property="article:published_time" content="2018-05-27T19:08:00.000Z">
<meta property="article:modified_time" content="2023-03-31T09:54:37.172Z">
<meta property="article:author" content="nekolr">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/3q7.png">


<link rel="canonical" href="https://blog.nekolr.com/2018/05/27/Spring%20IoC%20%E5%AE%B9%E5%99%A8%E5%89%96%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://blog.nekolr.com/2018/05/27/Spring%20IoC%20%E5%AE%B9%E5%99%A8%E5%89%96%E6%9E%90/","path":"2018/05/27/Spring IoC 容器剖析/","title":"Spring IoC 容器剖析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring IoC 容器剖析 | nekolr's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="nekolr's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">nekolr's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱吃咖喱棒的打字员DA☆ZE~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#BeanFactory-%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">BeanFactory 容器设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ApplicationContext-%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">ApplicationContext 容器设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">容器初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%90%AB-BeanDefinition-%E7%9A%84%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D"><span class="nav-number">3.1.</span> <span class="nav-text">包含 BeanDefinition 的资源定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanDefinition-%E7%9A%84%E8%BD%BD%E5%85%A5%E5%92%8C%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">BeanDefinition 的载入和解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanDefinition-%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">3.3.</span> <span class="nav-text">BeanDefinition 的注册</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">循环依赖的问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IoC-%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">5.</span> <span class="nav-text">IoC 容器的依赖注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.</span> <span class="nav-text">Spring Bean 生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">nekolr</p>
  <div class="site-description" itemprop="description">爱吃咖喱棒的打字员DA☆ZE~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/nekolr" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nekolr" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:excalibll@163.com" title="E-Mail → mailto:excalibll@163.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.nekolr.com/2018/05/27/Spring%20IoC%20%E5%AE%B9%E5%99%A8%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nekolr">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nekolr's blog">
      <meta itemprop="description" content="爱吃咖喱棒的打字员DA☆ZE~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring IoC 容器剖析 | nekolr's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring IoC 容器剖析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-05-27 19:08:00" itemprop="dateCreated datePublished" datetime="2018-05-27T19:08:00+00:00">2018-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>使用 spring 5.1.19.RELEASE 分析</p>
</blockquote>
<p>整个 IoC 容器都是围绕着 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 来设计的。<code>BeanFactory</code> 提供了容器的基本功能。<code>ApplicationContext</code> 继承自 <code>BeanFactory</code>，不光实现了容器的基本功能，还实现了一些更高级的容器特性。  </p>
<span id="more"></span>		

<h1 id="BeanFactory-容器设计"><a href="#BeanFactory-容器设计" class="headerlink" title="BeanFactory 容器设计"></a>BeanFactory 容器设计</h1><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/3q7.png" alt="ConfigurableBeanFactory"></p>
<p>这是一条主要的 <code>BeanFactory</code> 设计路线。</p>
<ul>
<li><code>BeanFactory</code> 提供了如 <code>getBean</code> 这样的基本方法用来获取容器中的 bean。</li>
<li><code>HierarchicalBeanFactory</code> 提供了 <code>getParentBeanFactory</code> 方法，使得容器获得了父子容器管理的功能。</li>
<li><code>SingletonBeanRegistry</code> 提供了管理单例 bean 的功能。</li>
<li><code>ConfigurableBeanFactory</code> 提供了一些容器的配置功能，比如设置容器的父容器的 <code>setParentBeanFactory</code> 方法。</li>
</ul>
<p>在这条路线上，有一个实现了基本容器功能的类 <code>DefaultListableBeanFactory</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/o6x.png" alt="DefaultListableBeanFactory"></p>
<p><code>DefaultListableBeanFactory</code> 已经实现了容器的基本功能，也就是说我们可以直接使用它了。该类还有一个子类 <code>XmlBeanFactory</code>，不过已经不推荐使用了。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;serial&quot;, &quot;all&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultListableBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">this</span>(resource, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">      <span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看 <code>XmlBeanFactory</code> 的代码，我们可以模仿它来使用 <code>DefaultListableBeanFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义资源文件</span></span><br><span class="line">    <span class="type">ClassPathResource</span> <span class="variable">classPathResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建 DefaultListableBeanFactory 实例</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">defaultListableBeanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 创建 XmlBeanDefinitionReader</span></span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(defaultListableBeanFactory);</span><br><span class="line">    <span class="comment">// 使用 XmlBeanDefinitionReader 来解析资源文件中的 bean 定义</span></span><br><span class="line">    reader.loadBeanDefinitions(classPathResource);</span><br><span class="line">    <span class="comment">// 获取容器中的 bean</span></span><br><span class="line">    <span class="type">ElectricCar</span> <span class="variable">electricCar</span> <span class="operator">=</span> (ElectricCar) defaultListableBeanFactory.getBean(<span class="string">&quot;electricCar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ApplicationContext-容器设计"><a href="#ApplicationContext-容器设计" class="headerlink" title="ApplicationContext 容器设计"></a>ApplicationContext 容器设计</h1><p>IoC 容器的第二条设计路线以 <code>ApplicationContext</code> 接口为主，在继承了 <code>BeanFactory</code> 的同时，还继承了 <code>MessageSource</code>、<code>ApplicationEventPublisher</code>、<code>ResourceLoader</code> 等接口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/WnD.png" alt="ApplicationContext"></p>
<p> <code>ApplicationContext</code> 作为 <code>BeanFactory</code> 的实现，和 <code>XmlBeanFactory</code> 一样，也是在 <code>DefaultListableBeanFactory</code> 这个基本的容器实现上做扩展（一般是通过持有一个 <code>DefaultListableBeanFactory</code> 对象来实现）。我们常用的应用上下文基本上都是 <code>ConfigurableApplicationContext</code> 或者 <code>WebApplicationContext</code> 的实现。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/27/YAN.png" alt="ConfigurableWebApplicationContext"></p>
<table>
<thead>
<tr>
<th>实现了 ConfigurableApplicationContext 接口的类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统加载 xml 配置文件来初始化容器</td>
</tr>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过 classpath 加载 xml 配置文件来初始化容器</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>通过加载纯注解的配置类来初始化容器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>实现了 WebApplicationContext 接口的类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AnnotationConfigWebApplicationContext</td>
<td>通过加载纯注解的配置类来初始化具有 Web 功能的容器</td>
</tr>
<tr>
<td>XmlWebApplicationContext</td>
<td>在 Web 应用中，我们一般会在 web.xml 中设置一个监听器：ContextLoaderListener，默认情况下，它会在 Servlet 容器启动时创建并初始化一个 XmlWebApplicationContext</td>
</tr>
</tbody></table>
<h1 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h1><p>IoC 容器的初始化是通过 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法来完成的，这个过程主要包括 BeanDefinition 的 Resource 定位、载入和注册三个基本操作，Spring 将这三个过程分开，使用了不同的模块来完成（比如使用 ResourceLoader、BeanDefinitionReader 等）。通过这种方式，可以让用户根据需要更加灵活地对这三个过程进行修改或者扩展。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@201911242020/2018/05/28/LXL.png" alt="AbstractApplicationContext"></p>
<h2 id="包含-BeanDefinition-的资源定位"><a href="#包含-BeanDefinition-的资源定位" class="headerlink" title="包含 BeanDefinition 的资源定位"></a>包含 BeanDefinition 的资源定位</h2><p>我们知道，BeanDefinition 接口是 Bean 定义的抽象，用来描述 Bean 的一些信息，比如是单例 Bean 还是原型 Bean，对应的类的全限定名称，是否需要延迟初始化，依赖关系等等。Bean 定义的存在形式有很多种，常见的可能会在文件系统中或者在类路径中，因此，Spring 抽象出了 Resource 接口，在文件系统中的 Bean 定义资源就可以通过 FileSystemResource 来抽象，而在类路径的 Bean 定义资源则可以通过 ClassPathResource 来抽象，然后它们都可以通过对应的 ResourceLoader 来获取。</p>
<p>在以编程的方式使用 DefaultListableBeanFactory 时，我们需要定义一个 Resource 来定位容器所使用的 Bean 定义资源，这里的 Resource 并不能直接交给 DefaultListableBeanFactory 使用，因为 DefaultListableBeanFactory 只是一个单纯的 IoC 容器，我们需要为它配置一个特定的 BeanDefinitionReader，用来读取 Bean 定义资源，并将 Bean 定义转换成容器能够处理的形式。而我们使用的很多 ApplicationContext 实现中已经提供了一系列能够加载不同 Resource 的读取器实现，我们以 FileSystemXmlApplicationContext 为例，从头到尾梳理一下容器的初始化过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/12/5NM.png" alt="FileSystemXmlApplicationContext"></p>
<p>通过上图可以看出，FileSystemXmlApplicationContext 通过继承 AbstractApplicationContext，具备了 ResourceLoader 读取 Resource 的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个构造函数可以传入父容器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个构造函数可以传入 BeanDefinition 所在的文件路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;configLocation&#125;, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileSystemXmlApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">        String[] configLocations, <span class="type">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span><br><span class="line">        <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="built_in">super</span>(parent);</span><br><span class="line">      <span class="comment">// 设置 BeanDefinition 所在文件路径</span></span><br><span class="line">      setConfigLocations(configLocations);</span><br><span class="line">      <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">// 这个 refresh 启动了容器的初始化过程，当然也包括 BeanDefinition 的载入过程</span></span><br><span class="line">        refresh();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Resource <span class="title function_">getResourceByPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        path = path.substring(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最后这个构造器中调用了父类的构造器，我们沿着类图一直向上，能够追溯到 AbstractApplicationContext 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">DefaultResourceLoader</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">ConfigurableApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>();</span><br><span class="line">      setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> ResourcePatternResolver <span class="title function_">getResourcePatternResolver</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 AbstractApplicationContext 中初始化了一个 PathMatchingResourcePatternResolver 类，它实现了 ResourcePatternResolver 接口。我们知道，Resource 是资源的抽象，通过它可以访问各种包含 Bean 定义的资源，但是该接口有一个问题：它不支持以通配符的方式读取资源。如果我们要访问同一个路径下所有符合条件的资源，只能将读取的资源路径全部写出来才可以，ResourcePatternResolver 的出现就是为了解决这个问题的，它能够按照相应的模式匹配策略将资源路径转换成对应的资源，默认情况下使用的 PathMatchingResourcePatternResolver 是按照 Ant 风格的匹配策略来处理资源路径的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigLocations</span><span class="params">(<span class="meta">@Nullable</span> String... locations)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (locations != <span class="literal">null</span>) &#123;</span><br><span class="line">    Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.configLocations = <span class="keyword">new</span> <span class="title class_">String</span>[locations.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">      <span class="comment">// resolvePath 方法主要用来处理资源路径中的占位符</span></span><br><span class="line">      <span class="built_in">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.configLocations = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">resolvePath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理路径中的占位符</span></span><br><span class="line">    <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着回到 setConfigLocations 方法。在该方法中，resolvePath 方法能够将资源路径字符串中的占位符转换成对应的值。比如资源路径为：<code>classpath:applicationContext-$&#123;profile&#125;.xml</code>，那么该方法会从环境变量（包括系统变量、用户自定义的变量等）中寻找对应的值进行替换。</p>
<p>对于容器的启动来说，refresh 方法是一个很重要的方法，它详细地描述了整个 ApplicationContext 的初始化过程，比如 BeanFactory 的刷新，MessageSource 和 PostProcessor 的注册等等，这个执行过程为 Bean 的生命周期管理创造了条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">        *   准备要刷新的上下文。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">        *   告诉子类刷新内部的 BeanFactory。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">        *   对 BeanFactory 做相关配置，如设置 BeanPostProcessor、BeanClassLoader 等。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">            *   允许在上下文子类中对 BeanFactory 进行后处理。</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;&#125;</span></span><br><span class="line"><span class="comment">            *   该方法是一个空方法，由 AbstractApplicationContext 的子类去实现。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">            *   执行在上下文注册为 bean 的 BeanFactoryPostProcessor。</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   Spring 提供的扩展点，我们可以实现 BeanFactoryPostProcessor 接口，并注册为 Spring 的 bean。</span></span><br><span class="line"><span class="comment">            *   在本方法中表现为通过将读取到的 beanDefinitionNames 逐个解析，判断是否为 BeanFactoryPostProcessor </span></span><br><span class="line"><span class="comment">            *   的实现类来确定执行哪些 BeanFactoryPostProcessor。</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   这样我们就可以在 bean 实例化之前，读取 BeanFactory 中的 bean 配置，并根据需要进行修改，</span></span><br><span class="line"><span class="comment">            *   比如修改 bean 的 scope 等等，甚至可以预先将 bean 初始化（不推荐）。</span></span><br><span class="line"><span class="comment">            */</span>  </span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">/** </span></span><br><span class="line"><span class="comment">            *   Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">            *   注册拦截 bean 创建的处理器</span></span><br><span class="line"><span class="comment">            *   </span></span><br><span class="line"><span class="comment">            *   Spring 提供的扩展点，我们可以实现 BeanPostProcessor 接口，并注册为 Spring 的 bean。</span></span><br><span class="line"><span class="comment">            *   Spring 发现这些实现类的方式和发现 BeanFactoryPostProcessor 的方式一致。</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *   实现 BeanPostProcessor 接口需要重写 postProcessBeforeInitialization() 和 </span></span><br><span class="line"><span class="comment">            *   postProcessAfterInitialization() 方法，这两个方法会在每个非手工注册的 bean 初始化之前和初始化之后执行。</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Initialize message source for this context.</span></span><br><span class="line"><span class="comment">            *   初始化消息国际化。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">            *   初始化事件广播。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">            *   这是一个模版方法，允许子类在进行 bean 初始化之前进行一些定制操作。默认空实现。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">            *   注册事件监听者（实现了 ApplicationListener 接口）。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">            *   完成 BeanFactory 的最终配置，并实例化所有剩下的非懒加载的单例 bean。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">            *   完成刷新，调用 LifecycleProcessor 的 onRefresh() 方法，发布 ContextRefreshedEvent 事件</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *   Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line"><span class="comment">            *   销毁已经创建的单例 bean</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们需要重点关注 obtainFreshBeanFactory 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 刷新 BeanFactory</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 获取 BeanFactory</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   org.springframework.context.support.AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        <span class="comment">// 销毁已经实例化的 Bean</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">        <span class="comment">// 关闭 BeanFactory</span></span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 默认创建一个 DefaultListableBeanFactory，如果有父容器会作为参数传入</span></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 此处加载 bean 定义信息</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 在刷新 BeanFactory 时，会检测 BeanFactory 是否已经创建，已经创建会执行销毁方法，然后重新创建。在 BeanFactory 创建完成后，会开始加载并解析 bean 的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.context.support.AbstractXmlApplicationContext</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">    <span class="comment">// 创建 XmlBeanDefinitionReader 来读取和解析 BeanDefinition</span></span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    <span class="comment">// 配置读取器的上下文环境</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">// 允许子类自定义读取器的初始化方法</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 真正的加载 BeanDefinition</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">    <span class="comment">// 使用 ClassPathXmlApplicationContext 容器时会调用此处</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 FileSystemXmlApplicationContext 容器时调用此处</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着追溯 loadBeanDefinitions 方法，会发现由 AbstractBeanDefinitionReader 调用了该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.springframework.beans.factory.support.AbstractBeanDefinitionReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="comment">// 获取 ResourceLoader</span></span><br><span class="line">    <span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个 ResourceLoader 同样实现了 ResourcePatternResolver</span></span><br><span class="line">    <span class="comment">// 很多容器都实现了该接口，方便通过模式匹配加载多个资源</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取匹配到的资源</span></span><br><span class="line">        Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> loadBeanDefinitions(resources);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="literal">null</span>) &#123;</span><br><span class="line">          Collections.addAll(actualResources, resources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 只能通过访问绝对路径的方式加载单个资源</span></span><br><span class="line">      <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">      <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(location);</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> loadBeanDefinitions(resource);</span><br><span class="line">      <span class="keyword">if</span> (actualResources != <span class="literal">null</span>) &#123;</span><br><span class="line">        actualResources.add(resource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      count += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，如果 ResourceLoader 同样实现了 ResourcePatternResolver 接口，那么就通过模式匹配的方式加载资源；否则就单纯的使用绝对路径来加载单个资源。至此，所有的资源都已经完成了定位，接下来开始调用 loadBeanDefinitions 方法进行 BeanDefinition 的载入和解析。</p>
<h2 id="BeanDefinition-的载入和解析"><a href="#BeanDefinition-的载入和解析" class="headerlink" title="BeanDefinition 的载入和解析"></a>BeanDefinition 的载入和解析</h2><p>在这一过程中，首先需要读取所有定位好的资源，接着要按照一定的规则将读取到的内容转换成 IoC 容器内部的数据结构，这个数据结构对应的就是 BeanDefinition 接口。</p>
<p>我们接着分析上面的代码，在 loadBeanDefinitions 方法中，循环调用了一个同名的 loadBeanDefinitions 方法，该方法只有一个 Resource 参数，由 AbstractBeanDefinitionReader 的子类来实现，在我们的这个例子当中，显然这里调用的是 XmlBeanDefinitionReader 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里拿到资源对应的流，封装成 InputSource</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">          inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正的加载流程</span></span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">          <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取文档的内容</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 注册 Bean 定义</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正执行载入 Bean 定义的是 doLoadBeanDefinitions 方法。在该方法中，doLoadDocument 方法只负责读取 xml 文档内容，生成一个 Document 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Document <span class="title function_">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="built_in">this</span>.errorHandler,</span><br><span class="line">        getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getValidationModeForResource</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 XML 文档的校验方式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">validationModeToUse</span> <span class="operator">=</span> getValidationMode();</span><br><span class="line">    <span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line">      <span class="keyword">return</span> validationModeToUse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 试图查找 XML 文档的校验方式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">detectedMode</span> <span class="operator">=</span> detectValidationMode(resource);</span><br><span class="line">    <span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line">      <span class="keyword">return</span> detectedMode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Hmm, we didn&#x27;t get a clear indication... Let&#x27;s assume XSD,</span></span><br><span class="line">    <span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line">    <span class="comment">// detection stopped (before finding the document&#x27;s root tag).</span></span><br><span class="line">    <span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">detectValidationMode</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resource.isOpen()) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStream inputStream;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream = resource.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据文件头部是否包含 DOCTYPE 等关键字来判断采用哪种校验方式</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;Unable to determine validation mode for [&quot;</span> +</span><br><span class="line">          resource + <span class="string">&quot;]: an error occurred whilst reading from the InputStream.&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doLoadDocument 方法中，我们可以关注一下 getValidationModeForResource 这个方法，该方法主要用来获取应该采用何种方式校验 XML 文件。如果 XML 文件头部包含 <code>DOCTYPE</code> 等关键字，那么会通过 DTD 约束来校验文件；否则会通过 XSD 约束来校验文件。使用了 DTD 约束的 XML 配置文件类似下面这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">beans</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//SPRING//DTD BEAN 2.0//EN&quot;</span> <span class="string">&quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与此同时，还有一个方法值得关注，那就是 getEntityResolver，该方法用来获取 EntityResolver。我们知道，配置文件在头部会定义约束文件，而约束文件一般都带有 URL 地址，这意味着我们需要网络来获取约束文件，但现实环境往往比较复杂，项目有时会面临离线的状态。为了解决这个问题，约束文件一般会跟随框架一起打包，那么这些约束文件被放在哪里了呢？在 Spring 中，它们的位置被记录在了 <code>META-INF/spring.schemas</code> 文件中。比如我们打开 spring-beans.jar 下的该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.0.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-3.0.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line"># 以下省略</span><br></pre></td></tr></table></figure>

<p>可以看到，各个版本以及没有版本号的约束文件，都指向了同一路径下的一个约束文件。在 EntityResolver 接口中，只有一个 resolveEntity 方法，这个方法的作用就是根据提供的约束文件 URL，寻找对应的离线约束文件。</p>
<p>我们接着回到 doLoadBeanDefinitions 方法。此时我们已经将所有的配置转换成了一个 <code>org.w3c.dom.Document</code> 结构，接下来只需要将它转换成对应的 BeanDefinitions 就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="comment">// 创建 BeanDefinitionDocumentReader</span></span><br><span class="line">    <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 将解析文档的工作委派给它</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XmlReaderContext <span class="title function_">createReaderContext</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlReaderContext</span>(resource, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.eventListener,</span><br><span class="line">        <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 registerBeanDefinitions 方法中，又创建了一个 BeanDefinitionDocumentReader，然后将文档解析的工作委派给了它，同时还给它额外传入了一个 ReaderContext 参数，这个参数我们可以理解为一个文档读取的上下文环境。在这个上下文环境当中，有一个重要的属性：NamespaceHandlerResolver，乍一看这个名字起的有点奇怪，Handler 后面为什么还加了个 Resolver？我们带着这个问题，查看 getNamespaceHandlerResolver 方法，发现在这里最终是创建了一个默认的实现：DefaultNamespaceHandlerResolver，它的作用是从 <code>META-INF/spring.handlers</code> 文件中加载不同命名空间所对应的 NamespaceHandler。比如 spring-context.jar 下该文件的内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure>

<p>在这里我们随便打开一个 NamespaceHandler，比如 ContextNamespaceHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;property-placeholder&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertyPlaceholderBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;property-override&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertyOverrideBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;annotation-config&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationConfigBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;component-scan&quot;</span>, <span class="keyword">new</span> <span class="title class_">ComponentScanBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;load-time-weaver&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoadTimeWeaverBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;mbean-export&quot;</span>, <span class="keyword">new</span> <span class="title class_">MBeanExportBeanDefinitionParser</span>());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;mbean-server&quot;</span>, <span class="keyword">new</span> <span class="title class_">MBeanServerBeanDefinitionParser</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里初始化的是 context 命名空间中所有可用的元素（标签）和它们对应的解析器，这个解析器被 Spring 抽象为 BeanDefinitionParser 接口。我们常见的一些命名空间配置，比如 <code>&lt;context:component-scan base-package=&quot;xxx&quot; /&gt;</code> 等，就由这些解析器来处理。</p>
<p>我们回到之前的代码。由于文档解析的工作交给了 BeanDefinitionDocumentReader，同时在这里使用的是它的一个默认实现：DefaultBeanDefinitionDocumentReader，因此我们继续深入到它的方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">    doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">    <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">// 判断是否是默认的命名空间：http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">// 获取 beans 的 profile 属性</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">        String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">            profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">        <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">        <span class="comment">// 从 ReadContext 的环境变量中获取当前被激活的 profile</span></span><br><span class="line">        <span class="comment">// 如果当前正在解析的配置文件不是被激活的 profile，那么直接跳过文档解析的过程</span></span><br><span class="line">        <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置处理，默认是一个空实现，可以由子类来重写</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析 BeanDefinitions</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 后置处理，默认是一个空实现，可以由子类来重写</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，首先执行了一些前置工作，比如检查默认激活的 profile 与当前解析的文档是否一致，如果不一致则直接跳过解析过程。然后还有两个可以由子类扩展的前置和后置处理的方法，以及真正执行解析工作的 parseBeanDefinitions 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否是默认的命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">          <span class="comment">// 如果是默认的命名空间，则使用默认的元素处理方法</span></span><br><span class="line">          <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">            parseDefaultElement(ele, delegate);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            delegate.parseCustomElement(ele);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是默认的命名空间则执行自定义元素处理方法</span></span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是 import 标签，则执行 import 的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 alias 标签，则处理 alias 的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 bean 标签，则执行解析 BeanDefinition 的逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 beans 标签，则通过递归的方式回到上面的方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parseCustomElement(ele, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取命名空间约束文件 URI</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取对应的命名空间处理器</span></span><br><span class="line">    <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将解析的工作交给命名空间处理器</span></span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parseBeanDefinitions 方法的逻辑很清晰：根据不同的命名空间，调用不同的处理逻辑。在默认命名空间中有四类标签：<code>import</code>、<code>alias</code>、<code>bean</code> 和 <code>beans</code>，其中 <code>bean</code> 标签对应的处理逻辑能够将 bean 定义转换成 BeanDefinition。对于其他命名空间的标签，我们在前面提到过，使用 NamespaceHandlerResolver 可以获取对应的命名空间处理器，然后将解析工作交给对应的 NamespaceHandler 来处理。这里我们只重点关注 <code>bean</code> 标签的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="comment">// 解析标签，并将转换后的 BeanDefinition 放入 BeanDefinitionHolder 中</span></span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">            bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，parseBeanDefinitionElement 方法将解析 <code>bean</code> 标签并生成对应的 BeanDefinition（创建的是一个 GenericBeanDefinition），最后将它放入一个 BeanDefinitionHolder 中。接下来的需要做的就是将 BeanDefinition 注册到容器中。</p>
<h2 id="BeanDefinition-的注册"><a href="#BeanDefinition-的注册" class="headerlink" title="BeanDefinition 的注册"></a>BeanDefinition 的注册</h2><p>向 IoC 容器注册 BeanDefinition 是通过调用 BeanDefinitionRegistry 接口的实现来完成的。简单来说就是在 IoC 容器内部有一个名为 beanDefinitionMap 的 ConcurrentHashMap，注册的过程就是将 BeanDefinition 放入这个 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.BeanDefinitionReaderUtils</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">// 注册别名</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">        registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环依赖的问题"><a href="#循环依赖的问题" class="headerlink" title="循环依赖的问题"></a>循环依赖的问题</h1><p>这部分内容之所以放在容器的依赖注入之前，是因为将这类问题单独拎出来，再结合 Spring 对于循环依赖问题的处理完整分析一遍，对于接下来解析 Spring 依赖注入部分的代码很有帮助。</p>
<p>所谓循环依赖，说白了就是一个或多个对象实例之间存在直接或者间接的依赖关系，这个依赖关系最终形成了一个环形的结构。一般循环依赖可以简化为三种情况，即自己依赖自己，两两之间的直接依赖和多个对象之间的间接依赖。前两种情况的直接循环依赖比较好识别，第三种间接循环依赖的情况有时候因为业务代码调用层级很深，不容易识别出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/16/kbQ.png" alt="循环依赖"></p>
<p>在 Spring 中，出现循环依赖的场景主要有以下几种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/16/Evd.png" alt="Spring 中循环依赖的主要场景"></p>
<p>在这些可能出现循环依赖的场景中，有些 Spring 是能够处理的，有些则不能。Spring 跟我们一样，我们在平常编码时无法解决的循环依赖问题，它同样也无法解决，比如多例的 setter 注入和构造器注入。我们举个例子，用大白话来分析一下。假设有两个类 A 和 B，它们之间互相依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line">  <span class="comment">// 省略构造器和 setter 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> A a;</span><br><span class="line">  <span class="comment">// 省略构造器和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要实现多例，也就是每次都要创建一个新的对象。在使用 setter 方法注入时，我们首先需要实例化 A，由于 A 依赖于 B，所以我们又实例化了一个 B，然后使用 setter 方法将 B 的实例注入到 A 的实例中。接着我们又发现 B 依赖于 A，同时由于我们要实现多例，那么此时还需要再重新实例化一个 A，然后将这个 A 的新实例通过 setter 注入给 B 的实例。这还没完，A 的新实例也需要注入呀，因此我们又实例化了一个 B 的新实例，如此往复。这显然是没有尽头的，也是无法处理的。</p>
<p>而在构造器注入的场景下，无法解决循环依赖的问题是因为创建对象需要调用构造器，而构造器需要传入依赖的对象，由于此时被依赖的对象还没有创建，因此同样使用构造器创建，不过该构造器也需要传入依赖的对象，这就陷入了死胡同。</p>
<p>DependsOn 循环依赖则比较特殊，它是 Spring 框架特有的。对于一个 Bean，Spring 大体上向用户提供了两种方式来配置它的依赖。一种是使用 <code>depends-on</code> 属性或者 <code>@DependsOn</code> 注解，另一种是使用 <code>ref</code> 属性等类似的方式。其中，通过 <code>ref</code> 属性来配置依赖的对象中需要持有被依赖的对象，而 DependsOn 则不需要。所以我们可以理解为这种依赖只是一种初始化顺序上的依赖，那么因此我们就很容易理解：具有初始化顺序依赖的两个对象之间不应该存在逻辑上（初始化上）的依赖。</p>
<p>到了单例环境中，循环依赖的问题其实是很容易处理的，利用我们经常使用的 setter 方法执行注入即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">a.setB(b);</span><br><span class="line">b.setA(a);</span><br></pre></td></tr></table></figure>

<p>如果让我们按照这个思路，实现一个简易的，能够处理循环依赖的 IoC 容器，我们应该怎么做呢？回看上面的代码，你会发现其实这是一种延迟初始化的思想。也就说，我们在初始化 Bean 的时候，首先通过无参构造创建了一个“空”对象，接着我们要将这个对象的引用存储起来，方便我们后续还能找到这个未初始化完成的对象，执行 setter 注入。这里有一个很重要的信息，那就是存储对象的引用，因此我们需要一个缓存容器。到了这里，我们离 Spring 的实现又近了一步。没错，Spring 的设计思路跟我们一样，不过不同的是，它一次性使用了三个这样的缓存容器，也就是我们俗称的三级缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   单例对象的缓存容器，对应的结构是：bean 名称 -&gt; bean 实例，这个 bean 是完全初始化的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   早期暴露出来的单例对象的缓存容器，对应的结构是：bean 名称 -&gt; bean 实例，这个 bean 是不完全初始化的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   单例工厂的缓存容器，对应的结构是：bean 名称 -&gt; ObjectFactory 实例，它是可以生成 Bean 的工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>一级缓存为 singletonObjects，存储的是已经完全初始化的 bean 实例。二级缓存为 earlySingletonObjects，存储的是已经实例化，但是还没有初始化的 bean 实例。三级缓存为 singletonFactories，存储的是能够生成 bean 实例的工厂对象。Spring 为什么要使用三级缓存来处理循环依赖的问题呢？换句话说，只使用一级缓存，或者只使用二级缓存可以吗？答案是不行。</p>
<p>我们先看只使用一级缓存为什么不行。同样还是拿着 A 和 B 这两个类来举例。用户获取 A 的实例，此时缓存容器中没有，因此 A 要先实例化，实例化之后放入缓存容器中，接着我们需要填充 A 的属性，也就是 B 的实例。此时我们需要先从缓存容器中尝试获取 B 的实例，如果没有我们需要先实例化 B。等等！我们先别急着向下分析，在 A 实例化并放入缓存容器之后，如果此时有个用户尝试获取 A 的实例怎么办？或者尝试获取 B 的实例，同样经过了上述步骤，在填充属性时，从缓存容器中拿到了 A 的实例。在这些场景中，A 的实例都没有完全初始化，但是用户已经获取到并开始准备使用它了。这显然是有问题的，而产生问题的关键是我们无法得知某一时刻缓存容器中的实例是否完全初始化了。比较简单直接的解决方法就是使用两个缓存容器，一个存放实例化但没初始化的 bean，另一个存放实例化并且完全初始化的 bean，各司其职。那为什么我们在一开始又说：在 Spring 中，只使用二级缓存是不行的呢？</p>
<p>我们不要忘了，Spring Framework 作为一个成熟的商业产品，IoC 只是它的一个基本功能。除了 IoC，它还有一个很重要也是很基础的功能：AOP。如果一个 bean 经过了 AOP 的织入（Weaving），那么我们拿到的这个 bean 实际上是一个代理 bean。在我们像上面那样去使用二级缓存时，二级缓存中存放只是原始的 bean 实例，这样其他依赖该 bean 的实例在填充属性时获取到的也只是原始的 bean 实例，并不是我们真正想要获取的代理 bean 实例。那么你可能又会问了，如果我们不像上面那样将实例化后的 bean 对象放入二级缓存，而是将代理对象（代理对象包裹着未初始化的原始实例）放入二级缓存中不就行了吗。理论上来说，这是完全没有问题的，那么 Spring 又为什么非要使用三级缓存呢？<strong>其实，Spring 的根本目的是为了保证在没有循环依赖的情况下，在引入了 AOP 之后，Bean 的生命周期设计不会得到破坏，即代理对象应该在 bean 初始化完成之后才生成，而不应该在 bean 实例化之后就生成。</strong></p>
<p>我们还是用上面存在循环依赖的 A 和 B 来举例，我们假设只使用二级缓存，并且二级缓存存放的是代理对象，那么整个流程大概就像下图这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/21/P3q.png" alt="使用二级缓存时的流程"></p>
<p>显然不管有没有循环依赖，在使用二级缓存时，代理对象总是在 bean 完全初始化之前生成。为了解决这个问题，Spring 又设计了一个 ObjectFactory 接口，这个接口是一个函数式接口，只有一个 getObject 方法用来获取实例对象。接下来我们只要在 bean 实例化之后，将它传入一个 ObjectFactory 的实现中，在这个实现中完成 AOP 的织入，最后将这个 ObjectFactory 放入缓存中即可。这样只有在其他依赖此 bean 的实例执行属性填充时，才会从三级缓存中拿到对应的 ObjectFactory，然后通过 getObject 方法创建对应的代理对象。但是，如果每个依赖此 bean 的实例都需要通过 getObject 方法来持有一个代理对象，那么显然它们持有的并不是同一个代理对象。因此我们需要再添加一个缓存容器，然后将 ObjectFactory 存放在三级缓存中，在其他实例获取三级缓存时，将直接调用获取到的 ObjectFactory 的 getObject 方法，并将结果存入二级缓存，同时删除对应的三级缓存，这样下次就可以直接从二级缓存获取代理对象了。</p>
<p>这就是 Spring 三级缓存的由来。在使用了三级缓存之后，如果不存在循环依赖，那么代理对象的创建会在 bean 完全初始化之后才会进行；如果存在循环依赖，整个流程大概就变成下图这样了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104211444/2021/04/21/9vo.png" alt="使用三级缓存时的流程"></p>
<blockquote>
<p>在 Spring 中，AOP 的功能通过 Bean 后置处理器来完成的，更确切的说，是由 <code>@EnableAspectJAutoProxy</code> 注解导入的 <code>AnnotationAwareAspectJAutoProxyCreator</code> 来完成的。在它的 postProcessAfterInitialization 方法中，同样实现了根据已有 bean 实例创建代理对象的逻辑，这也是为什么说如果不存在循环依赖，那么代理对象的创建会在 bean 完全初始化之后才会进行的原因。</p>
</blockquote>
<h1 id="IoC-容器的依赖注入"><a href="#IoC-容器的依赖注入" class="headerlink" title="IoC 容器的依赖注入"></a>IoC 容器的依赖注入</h1><p>IoC 容器的依赖注入过程是在用户第一次向容器索要 Bean 时触发的，当然也有例外，那些设置 Bean 的 lazy-init 属性为 false（默认就是 false）的 BeanDefinition 会在容器初始化时就完成预实例化。这个预实例化实际上也是一个完成依赖注入的过程，只不过它是在容器初始化的过程中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.context.support.AbstractApplicationContext</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">    String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">    <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 转换 bean 的名称</span></span><br><span class="line">    <span class="comment">// 如果是别名，转换成标准名。如果首字符是 &amp;，则会去掉所有的 &amp;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">    <span class="comment">// 尝试从缓存中获取单例 bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 判断当前实例是否正在创建中</span></span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">          <span class="comment">// 省略此处代码。这里会输出 trace 级别的日志信息，主要提醒用户该实例还没有完全初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是 FactoryBean，则会根据用户传入的 name 来决定是返回 FactoryBean 实例</span></span><br><span class="line">      <span class="comment">// 还是通过 FactoryBean 的 getObject 方法返回实例。如果不是 FactoryBean 则会原样返回</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果该原型实例正在创建中，则直接抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取父容器</span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="comment">// 如果有父容器，并且当前容器中也没有 BeanDefinition，那么就去父容器查找</span></span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">              nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个标记的作用是控制是否刷新 mergedBeanDefinitions 缓存</span></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">        <span class="comment">// 标记当前 bean 为正在创建的过程中，同时清空 mergedBeanDefinitions 缓存，以防 BeanDefinition 的</span></span><br><span class="line">        <span class="comment">// 元数据发生变化后还读到旧的缓存数据</span></span><br><span class="line">        markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 合并 BeanDefinition</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">        <span class="comment">// 确保依赖的 bean 被初始化</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">            <span class="comment">// 根据暂存的依赖关系检测是否存在循环依赖</span></span><br><span class="line">            <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将依赖关系暂存</span></span><br><span class="line">            registerDependentBean(dep, beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取依赖 bean</span></span><br><span class="line">              getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建单例 bean</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">              <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">              <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建原型 bean</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">          <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在创建之前先做个标记，表示该 bean 正在创建中</span></span><br><span class="line">            <span class="comment">// 标记存储在一个名为 prototypesCurrentlyInCreation 的 ThreadLocal 中</span></span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            <span class="comment">// 创建 bean</span></span><br><span class="line">            prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除标记</span></span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">          bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 此处省略其他 scope 的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查类型，如果类型不一致会尝试进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">              ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 Bean 的方法最终调用的是 doGetBean 方法。在该方法中，首先尝试从三个级别的缓存中获取单例 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 先尝试从一级缓存获取</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="comment">// 再尝试从二级缓存获取</span></span><br><span class="line">      singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="comment">// 如果允许提前暴露单例 bean</span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">          <span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">          singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 尝试从三级缓存中获取</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">              ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">              <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                <span class="comment">// 获取到之后放入二级缓存同时删除三级缓存</span></span><br><span class="line">                <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果缓存为空，那么会有三种可能：实例在父容器中，从未创建和初始化过该 bean，这是一个原型 bean。所以接下来会在父容器存在，并且当前容器中没有对应的 BeanDefinition 时，尝试从父容器获取 bean 的实例。如果父容器不存在，或者当前容器中存在对应的 BeanDefinition 时，继续向下执行获取 bean 的过程。</p>
<p>在这个过程中，如果 BeanDefinition 存在继承关系，那么还需要使用 getMergedLocalBeanDefinition 方法合并它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> <span class="built_in">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> mbd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">return</span> getMergedBeanDefinition(beanName, bd, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> RootBeanDefinition <span class="title function_">getMergedBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">    String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 先尝试从缓存中获取</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd == <span class="literal">null</span>) &#123;</span><br><span class="line">        mbd = <span class="built_in">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的 BeanDefinition 没有父级的 BeanDefinition</span></span><br><span class="line">        <span class="keyword">if</span> (bd.getParentName() == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果它是 RootBeanDefinition 类型的，则再克隆一个出来</span></span><br><span class="line">          <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">            mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果它不是 RootBeanDefinition 类型的，那么就使用 BeanDefinition 构造一个</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            mbd = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(bd);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 能走到这里代表当前 BeanDefinition 是一个 Child，因此需要合并父 BeanDefinition</span></span><br><span class="line">          BeanDefinition pbd;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前 bean 名称与父 bean 名称不同</span></span><br><span class="line">            <span class="comment">// 那么使用父 bean 的名称递归调用 getMergedBeanDefinition 方法</span></span><br><span class="line">            <span class="comment">// 这样可以确保具有继承关系的 BeanDefinition 都被合并</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">parentBeanName</span> <span class="operator">=</span> transformedBeanName(bd.getParentName());</span><br><span class="line">            <span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">              pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果名称相同，则直接通过父容器调用 getMergedBeanDefinition 方法</span></span><br><span class="line">              <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">              <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">                pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(parentBeanName,</span><br><span class="line">                    <span class="string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(bd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 先使用父级 BeanDefinition 构建一个 RootBeanDefinition</span></span><br><span class="line">          mbd = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(pbd);</span><br><span class="line">          <span class="comment">// 然后将父子 BeanDefinition 合并</span></span><br><span class="line">          mbd.overrideFrom(bd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">          mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (containingBd != <span class="literal">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">          mbd.setScope(containingBd.getScope());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (containingBd == <span class="literal">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">          <span class="built_in">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mbd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着还要处理 BeanDefinition 的 dependsOn 属性，这个依赖可以理解为只有 dependsOn 属性中指定的 bean 先完成初始化之后，该 bean 才能进行初始化。这就意味着，该 bean 并不需要持有依赖对象，如果持有的话直接使用 ref 即可。在这些前期工作完成以后，接下来会通过 <code>getSingleton(beanName, singletonFactory)</code> 方法来获取 bean 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 先尝试从一级缓存获取</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在销毁该容器的单例 bean 时，不允许创建单例 Bean</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">              <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">              <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在创建单例 bean 之前做一些检查和标记，比如设置 singletonsCurrentlyInCreation</span></span><br><span class="line">        beforeSingletonCreation(beanName);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">          <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 通过 ObjectFactory 获取单例 bean，注意这个 bean 是一个完成初始化（依赖注入）的 bean</span></span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          newSingleton = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">          <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">          <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">          singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">          <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">              ex.addRelatedCause(suppressedException);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">            <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 在创建单例 bean 之后做一些检查和标记</span></span><br><span class="line">          afterSingletonCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是新建的 bean，将它放入一级缓存，同时删除对应的二级和三级缓存</span></span><br><span class="line">        <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">          addSingleton(beanName, singletonObject);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，我们可以看到主要的一行代码就是调用 ObjectFactory 的 getObject 方法，这个方法实际上调用的是 createBean 方法来创建并初始化一个 bean 的实例。由于这个实例是一个完成依赖注入之后的实例，因此最后还会将它放入一级缓存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line">    <span class="comment">// 确保需要创建 bean 实例的类可以被实例化</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">          beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 在 bean 实例化之前完成一些用户自定义的操作</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">          <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建 bean</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createBean 方法中，首先会检查需要创建 bean 实例的类是否可以被实例化。如果容器配置了 BeanPostProcessor，那么在实例化 bean 之前还会调用 Bean 后置处理器的 postProcessBeforeInstantiation 方法完成一些用户自定义的操作。该方法返回的 bean 对象可以是代替目标 bean 的代理对象，这样目标 bean 就不会执行默认的实例化操作，唯一会执行的进一步处理就是调用 Bean 后置处理器的 postProcessAfterInitialization 方法来完成 bean 的初始化操作，然后直接返回初始化完成的 bean。在方法的最后，doCreateBean 才是真正创建并初始化 bean 实例的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// 这个 BeanWrapper 用来包装实例化的 bean</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建 bean 实例</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处将允许 MergedBeanDefinitionPostProcessor 对 BeanDefinition 进行处理</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">              <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果容器允许单例 bean 出现循环依赖，同时此单例 bean 还在创建中，那么提早将这个单例 bean 放入缓存（三级缓存）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">        isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">            <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将单例 bean 放入三级缓存 singletonFactories 中</span></span><br><span class="line">      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// bean 的依赖注入</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="comment">// 执行一些初始化操作</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">// 尝试从一级缓存和二级缓存中获取实例</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">          exposedObject = earlySingletonReference;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">          String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">          Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">          <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">              actualDependentBeans.add(dependentBean);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doCreateBean 方法中，通过 createBeanInstance 方法来创建 bean 的实例。如果 Spring 容器允许单例 bean 出现循环依赖，那么这个未初始化的 bean 实例会被放入三级缓存中。接下来通过 populateBean 方法对 bean 实例执行属性值的依赖注入，然后使用 initializeBean 方法执行一些初始化的操作。最后通过 registerDisposableBeanIfNecessary 方法注册一些销毁 bean 的回调方法，比如一些 DestructionAwareBeanPostProcessor 接口，DisposableBean 接口，以及自定义的 <code>destroy-method</code> 方法。将未初始化的 bean 实例放入三级缓存这部分代码最简单，我们先来看它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 一级缓存中没有</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 放入三级缓存</span></span><br><span class="line">        <span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">        <span class="comment">// 删除二级缓存中对应的数据</span></span><br><span class="line">        <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          <span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="comment">// 调用 getEarlyBeanReference 方法</span></span><br><span class="line">          exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我想说的是 getEarlyBeanReference 方法，这个方法在容器没有配置 BeanPostProcessor 时只会返回之前未完成初始化的 bean 实例，而如果容器设置了这类 Bean 后置处理器，这里就会调用它们的 getEarlyBeanReference 方法来获得用户特殊处理过的 bean 实例。这个扩展点很多时候是被用来返回经过 AOP 处理的代理 bean 对象。</p>
<p>我们回到刚才的 doCreateBean 方法，继续查看 createBeanInstance 部分的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point. </span></span><br><span class="line">    <span class="comment">// 确保需要创建 bean 实例的类可以被实例化</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">          <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在 Supplier 回调，则使用给定的回调方法进行实例化</span></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里使用 FactoryBean 的工厂方法对 bean 进行实例化，需要注意的是该工厂方法可以是一个静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 Spring 需要根据参数确认到底使用哪个构造函数，该过程比较耗时，所以采用了缓存机制</span></span><br><span class="line">    <span class="comment">// 将解析过的数据放在 BeanDefinition 中，下次创建相同 bean 时能够提高效率</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">        <span class="comment">// resolvedConstructorOrFactoryMethod 用于缓存已解析的构造函数或工厂方法</span></span><br><span class="line">        <span class="comment">// 如果它不为空，说明缓存中已经有解析好的构造函数或工厂方法</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">          resolved = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// constructorArgumentsResolved 用于标记构造函数的参数是否已经解析完毕</span></span><br><span class="line">          autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数或工厂方法已经解析过（知道该用哪个）</span></span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="comment">// 如果参数也已经解析过了，那么可以直接使用构造函数进行实例化</span></span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用默认的无参构造函数进行实例化</span></span><br><span class="line">        <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里尝试从 SmartInstantiationAwareBeanPostProcessor 中获取候选构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用首选构造函数进行实例化。比如 Kotlin 中的主要构造器（Primary Constructor）</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无需特殊的处理，直接使用默认的无参构造函数进行实例化</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createBeanInstance 方法中，大体上有四种实例化 bean 的方式。obtainFromSupplier 方法会从 BeanDefinition 中获取一个名为 instanceSupplier 的 Supplier，然后通过这个 Supplier 获取 bean 的实例。instantiateUsingFactoryMethod 使用 FactoryBean 的工厂方法来创建 bean 的实例，需要注意的是该工厂方法可以是一个静态方法。autowireConstructor 方法则是通过构造方法完成 bean 的实例化，不过由于构造函数和构造参数的不确定性，这个方法在没有提供候选的构造函数时需要花大量的精力来确定构造函数和构造参数（可以通过 BeanPostProcessor 提供候选构造器）。最后的 instantiateBean 方法则是使用默认构造函数进行实例化。</p>
<p>我们回到上面的 doCreateBean 方法，继续查看 populateBean 部分的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">    <span class="comment">// 空对象无法注入</span></span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里会调用 InstantiationAwareBeanPostProcessor 的 postProcessAfterInstantiation 方法</span></span><br><span class="line">    <span class="comment">// 执行 bean 实例化后的操作</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 BeanDefinition 获取 property 值</span></span><br><span class="line">    <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 这里是对 autowire 的处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line">    <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">      <span class="comment">// 根据名称执行自动注入</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">        autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据类型执行自动注入</span></span><br><span class="line">      <span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line">      pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">        pvs = mbd.getPropertyValues();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里会调用 InstantiationAwareBeanPostProcessor 的 postProcessProperties 方法</span></span><br><span class="line">      <span class="comment">// 在 bean 注入属性值之前，对属性值进行处理</span></span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">          <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">          <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">          <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">              filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">            &#125;</span><br><span class="line">            pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          pvs = pvsToUse;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      &#125;</span><br><span class="line">      checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对属性执行注入</span></span><br><span class="line">    <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">      applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，如果容器配置了 Bean 后置处理器，那么就会执行它们的 postProcessAfterInstantiation 方法来完成用户自定义的一些 bean 实例化后的操作。如果 BeanDefinition 配置了自动注入的模式，那么还会选择对应的模式对该 bean 的属性值执行注入。接下来还会执行 Bean 后置处理器的 postProcessProperties 方法，在 bean 注入属性值之前，对属性值进行一些自定义的处理。最终会调用 applyPropertyValues 方法，对 bean 的属性值执行注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">      ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">mpvs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">      mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">      <span class="comment">// 已经过转换，则直接设置属性值</span></span><br><span class="line">      <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">        <span class="comment">// Shortcut: use the pre-converted values as-is.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          bw.setPropertyValues(mpvs);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">              mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="literal">null</span>) &#123;</span><br><span class="line">      converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BeanDefinitionValueResolver</span> <span class="variable">valueResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionValueResolver</span>(<span class="built_in">this</span>, beanName, mbd, converter);</span><br><span class="line">    <span class="comment">// 创建一个属性值的深拷贝列表，最终会使用该列表对 bean 执行属性值注入</span></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(original.size());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">resolveNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">      <span class="comment">// 属性值已经过转换，则直接添加到列表中</span></span><br><span class="line">      <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">        deepCopy.add(pv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行转换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> pv.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">originalValue</span> <span class="operator">=</span> pv.getValue();</span><br><span class="line">        <span class="comment">// 如果有必要，使用 BeanDefinitionValueResolver 转换属性值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resolvedValue</span> <span class="operator">=</span> valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">convertedValue</span> <span class="operator">=</span> resolvedValue;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">convertible</span> <span class="operator">=</span> bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">            !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">        <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">          convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将转换后的值放入 PropertyValue 进行缓存</span></span><br><span class="line">        <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">          <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">            <span class="comment">// 将转换后的属性值缓存起来</span></span><br><span class="line">            pv.setConvertedValue(convertedValue);</span><br><span class="line">          &#125;</span><br><span class="line">          deepCopy.add(pv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">            !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">            !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">          pv.setConvertedValue(convertedValue);</span><br><span class="line">          deepCopy.add(pv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          resolveNecessary = <span class="literal">true</span>;</span><br><span class="line">          deepCopy.add(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(pv, convertedValue));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="literal">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">      mpvs.setConverted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置处理后的属性值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      bw.setPropertyValues(<span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(deepCopy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，主要工作是对属性值进行处理，这项工作由 BeanDefinitionValueResolver 的 resolveValueIfNecessary 方法完成。为此还创建了一个属性值的深拷贝列表，所有已经处理过的属性值都会被放入该列表中。当所有的属性值都处理完毕之后，使用 BeanWrapper 的 setPropertyValues 方法，将这个深拷贝列表传入，执行属性值注入的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.BeanDefinitionValueResolver</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveValueIfNecessary</span><span class="params">(Object argName, <span class="meta">@Nullable</span> Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 属性值可以能是另一个 bean 的引用</span></span><br><span class="line">    <span class="comment">// 这个 RuntimeBeanReference 是在载入 BeanDefinition 时根据配置生成的</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;</span><br><span class="line">      <span class="type">RuntimeBeanReference</span> <span class="variable">ref</span> <span class="operator">=</span> (RuntimeBeanReference) value;</span><br><span class="line">      <span class="keyword">return</span> resolveReference(argName, ref);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> evaluate(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object bean;</span><br><span class="line">      <span class="type">String</span> <span class="variable">refName</span> <span class="operator">=</span> ref.getBeanName();</span><br><span class="line">      refName = String.valueOf(doEvaluate(refName));</span><br><span class="line">      <span class="keyword">if</span> (ref.isToParent()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.getParentBeanFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">              <span class="built_in">this</span>.beanDefinition.getResourceDescription(), <span class="built_in">this</span>.beanName,</span><br><span class="line">              <span class="string">&quot;Can&#x27;t resolve reference to bean &#x27;&quot;</span> + refName +</span><br><span class="line">                  <span class="string">&quot;&#x27; in parent factory: no parent factory available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从父容器获取 bean</span></span><br><span class="line">        bean = <span class="built_in">this</span>.beanFactory.getParentBeanFactory().getBean(refName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从当前容器获取 bean</span></span><br><span class="line">        bean = <span class="built_in">this</span>.beanFactory.getBean(refName);</span><br><span class="line">        <span class="built_in">this</span>.beanFactory.registerDependentBean(refName, <span class="built_in">this</span>.beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">        bean = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到上面的 doCreateBean 方法，继续查看 initializeBean 部分的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">          (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">          beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，invokeAwareMethods 方法用来向 Aware 类型的接口注入它们需要的参数，比如 beanName、beanFactory 等。如果容器配置了 Bean 后置处理器，那么还会调用它们的 postProcessBeforeInitialization 方法，在 bean 完全初始化之前执行一些用户自定义的操作。如果当前 bean 是一个 <code>InitializingBean</code>，那么还会调用它的 afterPropertiesSet 方法完成一些自定义的配置验证和最终初始化工作。接下来会调用 bean 的 <code>init-method</code> 方法。当然，最终还会调用 Bean 后置处理器的 postProcessAfterInitialization 方法来，在 bean 完全初始化之后完成一些用户自定义的操作。</p>
<p>经过上面的分析，我们已经了解了 doCreateBean 方法的细节，接下来我们回到 doGetBean 方法，来看看 Spring 是如何处理最终返回给用户的 bean 实例的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  org.springframework.beans.factory.support.AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">    Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查用户传入的 name 值，如果首字符是 &amp;，而从容器中获取到的却不是 FactoryBean，则直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果用户想要获取 FactoryBean 本身，或者从容器获取到的不是 FactoryBean，直接返回该 bean</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 能走到这里说明用户想要获取的不是 FactoryBean，而是通过 FactoryBean 得到的 bean 实例</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 先尝试从缓存中获取</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="literal">null</span>) &#123;</span><br><span class="line">      object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">      FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">      <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">      <span class="comment">// 通过 FactoryBean 获取 bean 实例</span></span><br><span class="line">      object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="type">boolean</span> shouldPostProcess)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">        <span class="comment">// 先尝试从缓存获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 调用 FactoryBean 的 getObject 方法获取 bean 实例</span></span><br><span class="line">          object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">          <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">          <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">alreadyThere</span> <span class="operator">=</span> <span class="built_in">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (alreadyThere != <span class="literal">null</span>) &#123;</span><br><span class="line">            object = alreadyThere;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">              &#125;</span><br><span class="line">              beforeSingletonCreation(beanName);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 后置处理</span></span><br><span class="line">                object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                    <span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">              <span class="built_in">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">      <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说来，如果用户想要获取的 bean 是一个 FactoryBean，那么根据用户传入的 bean 名称（首字符是否为 <code>&amp;</code>），选择返回 FactoryBean 对象还是返回通过调用它的 getObject 方法返回的对象。而如果用户想要获取的 bean 就是一个普通的 bean，那么直接返回。</p>
<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><p>在 Spring Bean 的生命周期中，框架为我们提供了一系列扩展方法方便我们调用，可以将这些方法大体分为：bean 级别和容器级别。</p>
<p>bean 级别的方法包括 bean 本身的方法，比如通过配置文件定义的 <code>init-method</code> 方法和 <code>destroy-method</code> 方法，以及 bean 实现的 <code>InitializingBean</code>、<code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>DisposableBean</code> 等接口的方法。</p>
<p>容器级别的包括 bean 后置处理器 <code>BeanPostProcessor</code> 和 <code>InstantiationAwareBeanPostProcessor</code> 接口的方法，以及 bean 工厂后置处理器 <code>BeanFactoryPostProcessor</code> 接口的方法等。</p>
<p>如下表格列出的是 Spring Bean 的一般生命周期以及生命周期中的扩展方法，按照从上到下的顺序依次进行。需要注意两个单词：<code>Instantiation</code> 和 <code>Initialization</code>，它们分别对应了 Bean 的两个生命周期阶段：实例化阶段和初始化阶段。</p>
<table>
<thead>
<tr>
<th>方法或过程</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BeanFactoryPostProcessor.postProcessorBeanFactory</td>
<td>可以对 bean 的定义（配置元数据）进行处理</td>
</tr>
<tr>
<td>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</td>
<td>在 bean 实例化之前执行一些操作</td>
</tr>
<tr>
<td>构造器方法</td>
<td>调用 bean 的构造器进行实例化</td>
</tr>
<tr>
<td>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</td>
<td>在 bean 实例化之后执行一些操作</td>
</tr>
<tr>
<td>InstantiationAwareBeanPostProcessor.postProcessPropertyValues</td>
<td>完成其他定制依赖注入和依赖检查等</td>
</tr>
<tr>
<td>属性值注入</td>
<td></td>
</tr>
<tr>
<td>BeanNameAware.setBeanName</td>
<td>设置 beanName</td>
</tr>
<tr>
<td>BeanFactoryAware.setBeanFactory</td>
<td>设置 BeanFactory</td>
</tr>
<tr>
<td>ApplicationContextAware.setApplicationContext</td>
<td>设置 ApplicationContext</td>
</tr>
<tr>
<td>BeanPostProcessor.postProcessBeforeInitialization</td>
<td>在 bean 初始化之前执行一些操作</td>
</tr>
<tr>
<td>InitializingBean.afterPropertiesSet</td>
<td>执行一些初始化操作</td>
</tr>
<tr>
<td>init-method 属性指定的方法</td>
<td>执行一些初始化操作</td>
</tr>
<tr>
<td>BeanPostProcessor.postProcessAfterInitialization</td>
<td>在 bean 初始化之后执行一些操作</td>
</tr>
<tr>
<td>DisposableBean.destroy</td>
<td>在 Bean 销毁之前，执行一些销毁操作</td>
</tr>
<tr>
<td>destroy-method 属性指定的方法</td>
<td>在 Bean 销毁之前，执行一些销毁操作</td>
</tr>
</tbody></table>
<p>除了上述方法，还有一些方法也可以影响 Bean 生命周期中执行的操作。比如 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解，它们是 JSR 250 规范中定义的注解，Spring 也支持这些注解。被 <code>@PostConstruct</code> 注解标注的方法会在当前 Bean 完成依赖注入之后调用；被 <code>@PreDestroy</code> 注解标注的方法会在当前 Bean 销毁之前调用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《Spring 技术内幕：深入解析 Spring 架构与计原理 (第 2 版)》</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/05/07/%E5%AD%A6%E4%B9%A0%20Dubbo%20%E4%B9%8B%E5%89%8D%EF%BC%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/" rel="prev" title="学习 Dubbo 之前：应用架构演变">
                  <i class="fa fa-chevron-left"></i> 学习 Dubbo 之前：应用架构演变
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/05/29/%E4%B8%BA%E4%BD%95%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E8%A6%81%E7%94%A8%20final%20%E4%BF%AE%E9%A5%B0/" rel="next" title="为何匿名内部类的参数引用要用 final 修饰">
                  为何匿名内部类的参数引用要用 final 修饰 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nekolr</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","mhchem":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
