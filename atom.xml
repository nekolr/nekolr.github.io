<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekolr&#39;s blog</title>
  
  <subtitle>爱吃咖喱棒的打字员DA☆ZE~</subtitle>
  <link href="https://blog.nekolr.com/atom.xml" rel="self"/>
  
  <link href="https://blog.nekolr.com/"/>
  <updated>2023-04-20T09:51:11.114Z</updated>
  <id>https://blog.nekolr.com/</id>
  
  <author>
    <name>nekolr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入 TLS</title>
    <link href="https://blog.nekolr.com/2023/03/30/%E6%B7%B1%E5%85%A5%20TLS/"/>
    <id>https://blog.nekolr.com/2023/03/30/%E6%B7%B1%E5%85%A5%20TLS/</id>
    <published>2023-03-30T11:35:00.000Z</published>
    <updated>2023-04-20T09:51:11.114Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对于 TLS 的运行机制一知半解，平常的工作和生活中也只是使用它，很少有机会深入了解它。最近 ChatGPT 大火，在体验了一段时间之后，反而意外地想静下心来学习和整理一番。</p><span id="more"></span><h1 id="HTTP-为什么不安全"><a href="#HTTP-为什么不安全" class="headerlink" title="HTTP 为什么不安全"></a>HTTP 为什么不安全</h1><p>由于 HTTP 采用明文传输，明文数据经过中间代理服务器、路由器、运营商等多个网络节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者可以<strong>窃听</strong>、<strong>篡改</strong>传输的内容，甚至<strong>冒充</strong>通信双方的身份且不被双方察觉，也就是所谓的中间人攻击（MITM）。</p><h1 id="使用对称加密"><a href="#使用对称加密" class="headerlink" title="使用对称加密"></a>使用对称加密</h1><p>既然传输内容是明文的，那我们很容易就能想到对传输内容进行加密。对称加密速度快，性能好，如果通信双方都知道对称加密的密钥，且没有任何第三方知道，那么通信当然是安全的。但是如何让通信的双方都知道该密钥呢？浏览器预存所有网站的密钥？这不现实。服务器通过网络传输密钥给浏览器？如果传输过程中被第三方劫持获取到了该密钥，那么之后双方所有的通信内容都能被解密。</p><h1 id="使用非对称加密"><a href="#使用非对称加密" class="headerlink" title="使用非对称加密"></a>使用非对称加密</h1><p>既然对称加密行不通，那么非对称加密呢？由于非对称加密的机制，我们可能会有以下思路：服务器明文传输公钥给浏览器，之后浏览器向服务器传输数据之前都会先用该公钥加密后再传输，只有服务器的私钥能解密该数据。但是反过来，服务器向浏览器传输数据，只能用私钥加密数据，浏览器可以用公钥解密，然而该公钥是服务器一开始通过明文传输给浏览器的，中间人一样可以获取到该公钥来解密服务器传输的数据。这个方案似乎只能保证浏览器向服务器传输数据的安全性（其实仍有问题）。</p><h1 id="改良非对称加密"><a href="#改良非对称加密" class="headerlink" title="改良非对称加密"></a>改良非对称加密</h1><p>基于以上方案，我们很快就能发现既然一对公私钥只能保证一侧的安全，那么我们使用两对公私钥，不就能保证双方通信的安全了吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器持有公钥 A 和私钥 A，浏览器持有公钥 B 和私钥 B</span><br><span class="line">双方通过明文传输各自的公钥</span><br><span class="line">之后浏览器向服务器传输数据都用公钥 A 加密，服务器使用私钥 A 解密</span><br><span class="line">同理服务器向浏览器传输数据都用公钥 B 加密，浏览器使用私钥 B 解密</span><br></pre></td></tr></table></figure><p>表面上看，这个方案似乎没有问题，但是 HTTPS 并没有采用这种方案，一个原因是因为非对称加密非常耗时，当然另一个原因是该方案有漏洞，这个一会儿再说，我们先来看看应该如何优化该方案。</p><h1 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密+对称加密"></a>非对称加密+对称加密</h1><p>既然非对称加密与对称加密相比性能较差，那么我们是否可以将两者结合起来呢？答案是可以！在密钥交换阶段，我们可以使用非对称加密保护通信时使用的对称加密密钥，在数据交换阶段使用对称加密保护传输的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器有一对公钥 A 和私钥 A</span><br><span class="line">服务器通过明文传输公钥 A 给浏览器</span><br><span class="line">浏览器随机生成一个用于对称加密的密钥 X，使用公钥 A 加密后传给服务器</span><br><span class="line">服务器通过私钥 A 解密得到对称加密的密钥 X</span><br><span class="line">这样双方都持有密钥 X，且第三方不知道，接下来所有的数据传输都可以使用该密钥加密和解密</span><br></pre></td></tr></table></figure><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>我们刚才提到使用两对公私钥以及后续的优化方案都存在漏洞，这个漏洞就是存在中间人攻击。以优化的方案为例，我们来模拟中间人的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器有一对公钥 A 和私钥 A</span><br><span class="line">服务器通过明文传输公钥 A 给浏览器</span><br><span class="line">中间人劫持到了公钥 A，保存下来，并把数据包中的公钥 A 替换成自己伪造的公钥 B（它自然有对应的私钥 B）</span><br><span class="line">浏览器随机生成一个用于对称加密的密钥 X，使用公钥 B（浏览器不知道公钥被替换了）加密后传输给服务器</span><br><span class="line">中间人劫持后用私钥 B 解密得到密钥 X，再用公钥 A 加密后传给服务器</span><br><span class="line">服务器使用私钥 A 解密得到密钥 X</span><br></pre></td></tr></table></figure><p>这样在双方都没有发现的情况下，中间人已经获取到了双方用于通信加密的密钥 X。究其根本，是因为<strong>浏览器无法确认它接收到的公钥是不是服务器自己的</strong>。我们总不能再对公钥进行加密吧，那么又得进行密钥交换，重复之前的步骤并且永远没有尽头。</p><h1 id="如何保证公钥可信"><a href="#如何保证公钥可信" class="headerlink" title="如何保证公钥可信"></a>如何保证公钥可信</h1><p>很多时候证明的源头都是一条条不证自明的“公理”。现实生活中，员工入职时需要向企业提供学历证明，这个学历证明必须是由教育部颁发的学历证书。在这里，学历证书由教育部做担保，“公理”也就是“教育部可信”。</p><p>互联网世界也有一个类似的“公理”存在，那就是 CA 机构（Certificate Authority），CA 机构颁发的证书叫数字证书。网站在使用 HTTPS 之前，需要向 CA 机构申请一个数字证书，数字证书中包含证书持有者和颁发者的相关信息（组织、DNS 主机名、公钥等），服务器把证书传输给浏览器，浏览器从证书中获取网站的公钥。</p><p>由于证书也是通过网络传输的，那么如何确保证书的真实性，防止证书被篡改呢？答案是使用<strong>数字签名</strong>。CA 机构在颁发证书时，会使用某种散列函数（比如 MD5、SHA-1 等）计算公开的明文信息的信息摘要，然后使用 CA 的私钥对信息摘要进行加密，形成的密文即数字签名，最后将证书中的明文信息和数字签名一起组成数字证书。</p><blockquote><p>为什么要先生成摘要再加密，而不是直接加密呢？因为非对称加密对于加密的内容长度有限制（与公钥长度有关），同时非对称加密还比较耗时，采用直接加密会导致客户端验签时同样耗时，而采用摘要算法可以将明文内容压缩到很短的固定长度字符串，客户端验签时会快很多。当然还有一方面是出于安全考虑，这里比较复杂，可以参考：<a href="https://crypto.stackexchange.com/questions/12768/why-hash-the-message-before-signing-it-with-rsa/">Why hash the message before signing it with RSA?</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器拿到数字证书之后，得到证书明文的 T 和数字签名 S</span><br><span class="line">使用 CA 机构的公钥解密数字签名得到信息摘要 S&#x27;，使用证书中指明的摘要算法对明文 T 进行 hash 得到 T&#x27;</span><br><span class="line">接下来只要对比 S&#x27; 和 T&#x27; 是否一致即可，如果不一致则代表明文 T 或者数字签名 S 被篡改</span><br></pre></td></tr></table></figure><p>上面提到浏览器使用 CA 机构的公钥来解密数字签名，那么浏览器是怎么得到这个公钥的呢？换句话说，如何确保 CA 机构的公钥是可信的呢？我们回想一下数字证书是用来解决什么问题的？没错，为了证明某个公钥可信，即该公钥对应该网站，那么 CA 机构的公钥理所应当的也可以使用数字证书来证明。一般的，操作系统、浏览器都会预装一些他们信任的根证书，其中会有 CA 机构的根证书，这样客户端就可以拿到 CA 机构的公钥了。</p><p>我们提到的 CA 机构的根证书，是根证书机构（Root CA）颁发的公钥证书，它是互联网安全中信任链的起点，由于根证书没有上层机构为其签名，所以根证书都是自签证书，即使用者和颁发者都是它自己。实际上，证书之间的认证也不止一层，如果 A 信任 B，B 信任 C，那么这里的 B 就作为中间证书颁发机构。这一连串的数字证书，以根证书为起点，通过层层信任，使得数字证书的持有者可以获得转授的信任来证明其身份。</p><blockquote><p>增加中间证书有哪些好处？首先能够减少根证书机构的管理工作，提高证书审核和签发的效率。其次根证书一般内置，私钥一般离线存储，一旦私钥泄漏，吊销过程会比较困难，可能无法及时补救，而中间证书的私钥泄漏，则可以快速在线吊销并重新生成。</p></blockquote><p>现在我们已经能够保证证书内容不被篡改了，那么证书有没有可能被第三方掉包呢？因为实际上任何站点都可以向 CA 申请证书，中间人可以在客户端获取证书时劫持，返回自己向 CA 机构申请的有效的数字证书。针对这种情况，应对方法也很简单，只需要客户端在验签的同时，再验证一下证书上的域名与自己请求的域名是否一致即可。</p><h1 id="完整的握手过程"><a href="#完整的握手过程" class="headerlink" title="完整的握手过程"></a>完整的握手过程</h1><p>根据配置和协商的结果，握手过程会有许多变种，常见的有：只对服务端进行身份验证的握手；恢复之前会话采用的简短握手；对客户端和服务端都进行验证的握手等。下面是 <a href="https://www.rfc-editor.org/rfc/rfc5246">RFC 5246</a> 中 TLS（TLS 1.2）握手的全过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--------+                                        +--------+</span><br><span class="line">|        |    1. ClientHello                      |        |</span><br><span class="line">|        | -------------------------------------&gt; |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">|        |    2. ServerHello                      |        |</span><br><span class="line">|        |    3. Certificate (optional)           |        |</span><br><span class="line">|        |    4. ServerKeyExchange (optional)     |        |</span><br><span class="line">|        |    5. CertificateRequest (optional)    |        |</span><br><span class="line">|        |    6. ServerHelloDone                  |        |</span><br><span class="line">|        | &lt;------------------------------------- |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">| Client |    7. Certificate (optional)           | Server |</span><br><span class="line">|        |    8. ClientKeyExchange                |        |</span><br><span class="line">|        |    9. CertificateVerify (optional)     |        |</span><br><span class="line">|        |   10. [ChangeCipherSpec]               |        |</span><br><span class="line">|        |   11. Finished                         |        |</span><br><span class="line">|        | -------------------------------------&gt; |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">|        |   12. [ChangeCipherSpec]               |        |</span><br><span class="line">|        |   13. Finished                         |        |</span><br><span class="line">|        | &lt;------------------------------------- |        |</span><br><span class="line">|        |                                        |        |</span><br><span class="line">+--------+                                        +--------+</span><br></pre></td></tr></table></figure><h2 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h2><p>首先客户端发送 ClientHello 消息，其中包含一个随机数（Client Random）、客户端支持的加密算法列表和压缩算法列表、最高支持的 TLS 协议版本、扩展字段等信息。扩展字段包含一些额外的辅助信息，比如最常见的 SNI。</p><p>客户端支持的加密算法更正式的叫法为密码套件（cipher suites），在 TLS 1.3 以前，一个密码套件包含非对称加密算法、对称加密算法以及信息摘要算法。非对称加密算法用来协商共享密钥，对称加密算法用来批量加密通信数据，摘要算法用来进行数据的完整性校验。</p><p>比如这样一个密码套件：TLS_RSA_WITH_AES_128_CBC_SHA，这个套件比较特殊的是，RSA 作为非对称加密算法，在密钥交换过程中使用，在通信的过程中需要签名的地方也会使用，同时也表示证书的公钥采用的也是该算法。AES_128_CBC 是对称加密算法，其密钥由 RSA 协商后计算产生。SHA 是信息摘要算法，表示后面证书里的签名用的就是该算法，同时后续通信需要数据校验时也会采用该算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">你好，咱俩建立连接呗</span><br><span class="line">我这边最高支持 TLS 1.1</span><br><span class="line">支持的密码套件有 TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_256_CBC_SHA256 等等</span><br><span class="line">支持的压缩算法 DEFLATE</span><br><span class="line">随机数为 8c9006c661dbf0b3dc989c5e72124bc3ae2fa1d7c94a22f820f3c920264419d7</span><br></pre></td></tr></table></figure><h2 id="ServerHello"><a href="#ServerHello" class="headerlink" title="ServerHello"></a>ServerHello</h2><p>接下来服务端返回协商的结果，即发送 ServerHello 消息，其中包含一个随机数（Server Random）、要使用的加密算法和压缩算法、要使用的 TLS 协议版本等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">你好，没有问题啊</span><br><span class="line">我们使用 TLS 1.1 吧</span><br><span class="line">算法采用 TLS_RSA_WITH_AES_256_CBC_SHA256</span><br><span class="line">压缩算法不支持就不要了</span><br><span class="line">随机数为 73078baa0251a216a7e1489f685da66212ff2649734e3da7a8f8e0414d3fd722</span><br></pre></td></tr></table></figure><h2 id="Certificate-optional"><a href="#Certificate-optional" class="headerlink" title="Certificate (optional)"></a>Certificate (optional)</h2><p>该消息包含服务端的证书链，是可选的，服务端会根据加密算法的选择来决定是否发送，比如 DH_ANON 算法就不会发送该消息，当然这是不安全也是不推荐的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">这是我的证书，你验证一下吧</span><br></pre></td></tr></table></figure><h2 id="ServerKeyExchange-optional"><a href="#ServerKeyExchange-optional" class="headerlink" title="ServerKeyExchange (optional)"></a>ServerKeyExchange (optional)</h2><p>该消息也是可选的，服务端会根据加密算法的选择来决定，比如 RSA 算法就不需要发送该消息，客户端直接生成一个 Pre-master 就可以了，但是基于 DH 的算法就需要发送特殊的参数给客户端，以便它生成 Pre-master。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202304092054/2023/04/05/q4j.png" alt="ServerKeyExchange"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">这是生成 pre-master 所需要的一些参数，请查收</span><br></pre></td></tr></table></figure><h2 id="CertificateRequest-optional"><a href="#CertificateRequest-optional" class="headerlink" title="CertificateRequest (optional)"></a>CertificateRequest (optional)</h2><p>该消息也是可选的，在需要验证客户端身份时才会发送，以此来告诉客户端提供它的证书来证明身份。一般我们使用的都是单向身份认证，即只有服务端认证是不需要发送该消息的。需要双向认证的场景：比如访问银行网站进行交易时，此时证书由 U 盾提供。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">把你的证书发给我看看吧，我要确认一下你是不是 XXX</span><br></pre></td></tr></table></figure><h2 id="ServerHelloDone"><a href="#ServerHelloDone" class="headerlink" title="ServerHelloDone"></a>ServerHelloDone</h2><p>最后是 ServerHelloDone 消息，告诉客户端所有消息都已经发送完毕。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server -&gt; client</span><br><span class="line"></span><br><span class="line">我要告诉你的就这些了，处理完给我发消息吧</span><br></pre></td></tr></table></figure><h2 id="Certificate-optional-1"><a href="#Certificate-optional-1" class="headerlink" title="Certificate (optional)"></a>Certificate (optional)</h2><p>如果客户端在前面收到了服务端的 CertificateRequest 消息，那么在这里客户端会发送自己的证书给服务端，即使没有证书，也会告诉服务端，由服务端来决定是否继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">这是我的证书，请查收</span><br></pre></td></tr></table></figure><h2 id="ClientKeyExchange"><a href="#ClientKeyExchange" class="headerlink" title="ClientKeyExchange"></a>ClientKeyExchange</h2><p>客户端在收到服务端的证书后，会进行证书校验。包括验证证书链的可信性，检查证书是否吊销（CRL 离线验证、OSCP 在线验证等），检查证书有效期以及证书域名与当前访问域名是否一致。接着，客户端会计算产生 Pre-master 随机数（或者产生 DH 算法的客户端参数），使用服务端的证书公钥加密后发送给服务端。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202304092054/2023/04/05/4vV.png" alt="ClientKeyExchange"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">这是计算真正密钥要用到的 pre-master，我使用你证书里的公钥加密了</span><br></pre></td></tr></table></figure><h2 id="CertificateVerify-optional"><a href="#CertificateVerify-optional" class="headerlink" title="CertificateVerify (optional)"></a>CertificateVerify (optional)</h2><p>如果客户端给服务端发送了证书，那么就需要发送该消息来告诉服务端证书的私钥确实在该客户端手里。该消息是将迄今为止所有的握手数据（从 ClientHello 开始，不包括本条消息）经过指定的摘要算法压缩后再通过客户端私钥加密后得到的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client -&gt; server</span><br><span class="line"></span><br><span class="line">这是一段我用私钥加密后的数据，你可以用我证书里的公钥解密后查看</span><br><span class="line">如果解密后的数据与你使用已有握手数据计算摘要后的数据一致，则证明我没有骗你</span><br></pre></td></tr></table></figure><h2 id="Finished-Encrypted-Handshake-Message"><a href="#Finished-Encrypted-Handshake-Message" class="headerlink" title="Finished (Encrypted Handshake Message)"></a>Finished (Encrypted Handshake Message)</h2><p>接下来客户端和服务端就能够根据已有的数据计算对称加密需要的密钥了，这是 <a href="https://www.rfc-editor.org/rfc/rfc5246">RFC 5246</a> 给出的计算主密钥的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, &quot;master secret&quot;,</span><br><span class="line">                          ClientHello.random + ServerHello.random)</span><br><span class="line">                          [0..47];</span><br></pre></td></tr></table></figure><p>然后双方将自己缓存的所有握手数据通过摘要算法计算后，再用刚刚算出来的主密钥加密后发送给对方。这样做有两个目的：一个是保证双方算出来的主密钥是一致的；另一个是确保双方通信过程中的每一步都没有其他人篡改，因为握手的前半部分都是明文的，存在被篡改的风险，只要双方根据各自缓存的握手数据算出来的校验数据一致，就说明中间没有被篡改过。验证数据的计算方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify_data = PRF(master_secret, finished_label, Hash(handshake_messages))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client -&gt; server 这是我们之前握手数据的摘要，用主密钥加密了，你看看能不能解开，并比较一下摘要</span><br><span class="line">server -&gt; client 这是我们之前握手数据的摘要，用主密钥加密了，你看看能不能解开，也比较一下摘要</span><br></pre></td></tr></table></figure><p>如果双方发送完 Finished 消息而对方都没有报错，握手就完成了，后续所有数据的传输都会使用这个密钥进行加密。在上面的握手过程中，如果任何一方觉得有问题，都可能随时终止握手过程。</p><h1 id="解密-HTTPS-流量"><a href="#解密-HTTPS-流量" class="headerlink" title="解密 HTTPS 流量"></a>解密 HTTPS 流量</h1><p>我们知道，一些常见的 HTTP&#x2F;HTTPS 抓包工具（比如 <a href="https://www.telerik.com/fiddler">Fiddler</a>、<a href="https://www.charlesproxy.com/">Charles</a>、<a href="https://github.com/avwo/whistle/">whistle</a>），都是通过创建本地代理服务，再修改浏览器的代理设置来达到流量拦截的目的的，他们的工作原理与中间人攻击一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server &lt;---&gt; Local Proxy &lt;---&gt; Browser</span><br></pre></td></tr></table></figure><p>在服务端与中间人之间，中间人冒充客户端，由于任何客户端都可以与服务端建立连接，所以这部分一般没有问题。而对于客户端与中间人之间，中间人想要冒充服务端，就必须拿到对应域名的证书私钥，中间人可以通过这几种手段获取或替换私钥：入侵网站服务器，从 CA 处重签发该域名的证书，以及自己签发证书。</p><p>为了防范以上风险，我们要对服务器和网站做好安全防护，避免网站私钥被盗。同时保证域名解析安全，避免攻击者获取到域名管理的相关权限从而重签证书。对于攻击者自签发的证书，由于系统和浏览器内置有根证书校验，因此我们只需要注意不要随便信任第三方的证书，不向浏览器和系统中导入不明证书。</p><p>对于 Fiddler 这类工具来说，能够解密 HTTPS 流量的关键在于他们会往系统受信任的根证书列表中导入自己的证书，这样他们自签发的证书就能被浏览器所信任。在设置好相关配置之后，Fiddler 会在浏览器中设置对应的代理地址，接下来浏览器在浏览 HTTPS 的网站时，Fiddler 会根据网站自动生成站点的数字证书。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202303311750/2023/03/31/yvK.png" alt="Fiddler"></p><p>由于该证书是由 Fiddler 生成的，所以它肯定知道该证书的私钥，通过这种方式，Fiddler 完成了证书的掉包（证书域名与客户端请求的域名一致）。整个过程相当于 Fiddler 分别与客户端和服务端通过 TLS 握手建立了连接，具体类似下面的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端向服务端发送握手请求，Fiddler 拦截后伪装成客户端向服务端发送 TLS 握手请求</span><br><span class="line">Fiddler 收到服务端的响应后，使用根证书公钥验签并拿到证书公钥，然后用自己伪造的证书传递给客户端</span><br><span class="line">客户端进行同样的验签操作，然后生成第三个随机数 pre-master，使用 Fiddler 的证书公钥加密传输给服务端</span><br><span class="line">Fiddler 拦截客户端的请求，使用自己的私钥解密 pre-master，此时 Fiddler 已经可以通过三个随机数生成对称加密的密钥</span><br><span class="line">接下来客户端与服务端之间通过对称加密发送的消息都可以被 Fiddler 解密</span><br></pre></td></tr></table></figure><p>而像 Wireshark 这类工具的抓包原理则是直接读取并分析网卡的数据，要想让它解密 HTTPS 流量，有两种方法：一种是知道网站的证书私钥，在工具中配置该私钥来解密；另一种需要浏览器支持，一些浏览器可以将 TLS 会话中使用的对称加密密钥保存到外部文件中，然后在 Wireshark 的 TLS 配置面板中配置 <code>(Pre)-Master-Secret log filename</code> 选项即可。</p><h1 id="前向安全性（Forward-Secrecy）"><a href="#前向安全性（Forward-Secrecy）" class="headerlink" title="前向安全性（Forward Secrecy）"></a>前向安全性（Forward Secrecy）</h1><p>我们知道，TLS 握手阶段需要进行密钥交换、证书验证、身份验证等几个重要步骤。密钥交换是为了在一个不安全的数据通道中产生一个只有通信双方知道的共享密钥（pre-master），进而产生后续对称加密的密钥。客户端进行证书验证的目的是为了确保证书公钥是可信的。而进行身份验证的目的是为了确保握手消息没有被篡改。</p><p>在以前，RSA 密钥交换（TLS_RSA 系列的密码套件）是比较常见的密钥交换方式，浏览器使用证书提供的 RSA 公钥加密相关信息，如果服务端能够解密，意味着服务端拥有与公钥对应的私钥，同时服务端也能解密所需的共享密钥，即密钥交换与服务端身份验证合并在了一起。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202304092054/2023/04/04/pPr.png" alt="RSA 密钥交换"></p><p>由于 Client Random 和 Server Random 明文传输，中间人可以直接查看。客户端生成的 Pre-master 用服务端证书公钥加密后传输，中间人如果获取到了私钥，一样可以解密得到 Pre-master，通过这三个随机数，中间人就可以计算出双方最终通信使用的对称加密密钥。这也是为什么 Wireshark 可以通过配置私钥来解密 HTTPS 数据。</p><p>所以说 RSA 这种密钥交换方式不具备前向安全性，即攻击者可以把监听到的加密数据先存起来，一旦后续拿到了证书私钥，之前所有的数据都可以成功解密。常见的前向安全的密码套件有 ECDHE_RSA、ECDHE_ECDSA 等，其中 ECDHE 为密钥交换算法，RSA 或者 ECDSA 为数字签名算法。</p><blockquote><p>内置 ECDSA 公钥的证书一般称为 ECC 证书，内置 RSA 公钥的证书就是 RSA 证书。因为 256 位 ECC Key 在安全性上等同于 3072 位 RSA Key，所以 ECC 证书体积比 RSA 证书小，而且 ECC 运算速度更快，ECDHE 密钥交换 + ECDSA 数字签名是目前最好的密码套件。</p></blockquote><p>ECDHE 密钥交换与 RSA 密钥交换最大的区别是，ECDHE 在握手过程中需要发送 ServerKeyExchange 消息，而 RSA 不用。那么为什么 ECDHE 算法具有前向安全性呢，这就要讲到它的数学原理了。</p><h2 id="DH-算法"><a href="#DH-算法" class="headerlink" title="DH 算法"></a>DH 算法</h2><p>对于公式 $A &#x3D; G^a\pmod P$，G 为底数，P 为模数，a 为对数，A 为真数。当已知 a 时，可以计算出 A；但是已知 A 时，却几乎无法计算出 a。</p><p>与此同时，给出公式 $B &#x3D; G^b\pmod P$，根据幂模运算的一个基本属性，即 $(G^a)^b\pmod P &#x3D; (G^b)^a\pmod P$，有</p><p>$K &#x3D; A^b\pmod P &#x3D; (G^a)^b\pmod P &#x3D; (G^b)^a\pmod P &#x3D; B^a\pmod P$</p><p>在实际应用中，服务端与客户端协商出要使用的大素数 P 及其原根 G，它俩是公开的参数。然后服务端生成私钥 a，经过幂模运算得到公钥 A。客户端生成私钥 b，经过幂模运算得到公钥 B。服务端将自己计算得出的公钥 A 传递给客户端，为了防止篡改，加上签名参数。客户端将自己计算得出的公钥 B 使用服务端的证书公钥加密后传递给服务端。此时客户端拥有参数 A、b、G、P，服务端拥有参数 B、a、G、P，它俩都可以计算得出共享密钥 K。如果中间人拦截到了公开的参数和公钥 A 和加密后的公钥 B，甚至中间人已经拿到了服务端的证书私钥，也就是说中间人获取到了 A、B、G、P 这几个参数，但是因为没有私钥 a 和 b，一样计算不出最终的共享密钥 K，也就无法破解历史的数据。</p><h2 id="DHE-算法"><a href="#DHE-算法" class="headerlink" title="DHE 算法"></a>DHE 算法</h2><p>根据私钥生成的方式，DH 算法分为 static DH 算法和 DHE（Ephemeral）算法。static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥每次都是一样的，一般是服务器方固定，客户端的私钥则是随机生成的。那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商过程中，有些数据是公开的，黑客可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 static DH 算法不具备前向安全性。</p><h2 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h2><p>DHE 算法由于性能不佳，所以 ECDHE 算法在 DHE 算法的基础上引入了 ECC 椭圆曲线特性，可以使用更少的计算量算出公钥，以及最终的共享密钥。</p><p>椭圆曲线（Elliptic Curve）针对密码学进行了简化，公式为：$y^2 &#x3D; x^3 + ax + b$，例如对于椭圆曲线 <code>secp256k1</code>，<a href="https://www.secg.org/">SECG</a> 组织给出了推荐的参数：<code>a = 0, b = 7</code>，即该椭圆曲线的公式为：$y^2 &#x3D; x^3 + 7$。</p><p>在椭圆曲线加密（Elliptic Curve Cryptography, ECC）中，则使用了某种特殊形式的椭圆曲线，即定义在有限域上的椭圆曲线。针对具体的椭圆曲线，存在着一个确定的点 G（基点），乘以一个确定的整数 K（私钥），得到椭圆曲线的公钥 P，即 $P &#x3D; KG$。已知 K 和 G，算出公钥很容易，而已知 G 和 P，算出私钥 K 在目前则几乎不可能。</p><p>在实际应用中，服务端会在 ServerKeyExchange 消息中包含一个名为 <code>Named Curve</code> 的参数，它的值就是选定的椭圆曲线，指定了椭圆曲线实际上也就确定了基点的值（SECG 推荐的）。服务端随机生成私钥 Ks 并算出对应的公钥 Ps，客户端随机生成私钥 Kc 并算出公钥 Pc。由于椭圆曲线满足乘法交换律和结合律，所以 $KsPc &#x3D; KsKcG &#x3D; KcKsG &#x3D; KcPs$。也就是说，服务端和客户端只需要知道对方的椭圆曲线公钥，即可通过各自的私钥算出最终的共享密钥。</p><p>通过上面的推算过程也能够看出，在密钥交换阶段如果只使用 DH 系列的算法，中间人可以通过伪造双方的 DH 公钥参数来实施 MITM 攻击，因此使用 DH 算法进行密钥交换时，服务端发送的 DH 公钥参数需要加上数字签名，而客户端发送的 DH 公钥参数则可以使用服务端证书公钥加密后发送。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂 HTTPS 的加密原理</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000009002353">SSL&#x2F;TLS 及证书概述</a></p></blockquote><blockquote><p><a href="https://www.rfc-editor.org/rfc/rfc4346">rfc4346</a></p></blockquote><blockquote><p><a href="https://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a></p></blockquote><blockquote><p><a href="https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN">椭圆曲线公式生成图形</a></p></blockquote><blockquote><p><a href="https://www.rfc-editor.org/rfc/rfc4492">rfc4492</a> </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直以来对于 TLS 的运行机制一知半解，平常的工作和生活中也只是使用它，很少有机会深入了解它。最近 ChatGPT 大火，在体验了一段时间之后，反而意外地想静下心来学习和整理一番。&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="https://blog.nekolr.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="HTTPS" scheme="https://blog.nekolr.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 分区</title>
    <link href="https://blog.nekolr.com/2022/04/26/Kafka%20%E5%88%86%E5%8C%BA/"/>
    <id>https://blog.nekolr.com/2022/04/26/Kafka%20%E5%88%86%E5%8C%BA/</id>
    <published>2022-04-26T15:06:00.000Z</published>
    <updated>2023-04-20T09:51:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>主要讨论 Kafka 分区与生产者和消费者之间的分配关系。</p><span id="more"></span><h1 id="分区与生产者"><a href="#分区与生产者" class="headerlink" title="分区与生产者"></a>分区与生产者</h1><p>生产者在往主题发送消息时，首先需要确定这条消息最终要发送到哪个分区上，为此 Kafka 提供了多种选择分区的策略。在 Kafka 2.4 以前，默认的策略是：如果指定了分区，则消息投递到指定分区。如果未指定分区，但是指定了 key，那么通过 <code>hash(key)</code> 来计算分区。如果分区和 key 都没有指定，则轮询选择分区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref: org/apache/kafka/clients/producer/KafkaProducer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="type">byte</span>[] serializedKey, <span class="type">byte</span>[] serializedValue, Cluster cluster)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">partition</span> <span class="operator">=</span> record.partition();</span><br><span class="line">    <span class="comment">// 如果指定了分区，则直接使用该分区；否则通过分区策略去选择</span></span><br><span class="line">    <span class="keyword">return</span> partition != <span class="literal">null</span> ?</span><br><span class="line">            partition :</span><br><span class="line">            partitioner.partition(</span><br><span class="line">                    record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref: org/apache/kafka/clients/producer/internals/DefaultPartitioner.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过元数据获取 topic 下的所有分区</span></span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPartitions</span> <span class="operator">=</span> partitions.size();</span><br><span class="line">    <span class="comment">// 如果 key 为空</span></span><br><span class="line">    <span class="keyword">if</span> (keyBytes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取主题中递增的一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextValue</span> <span class="operator">=</span> nextValue(topic);</span><br><span class="line">        <span class="comment">// 获取所有的可用分区（可用分区是指该分区存在首领副本）</span></span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将递增的值进行取模运算，即轮询算法</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">part</span> <span class="operator">=</span> Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">            <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法可以理解为在消息记录中没有指定 key 的情况下，通过生成一个数来代替 key hash</span></span><br><span class="line"><span class="comment">// 即为主题生成一个随机数，之后就在这个随机数的基础上递增</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">nextValue</span><span class="params">(String topic)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存获取主题的起始随机数</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> topicCounterMap.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == counter) &#123;</span><br><span class="line">        <span class="comment">// 创建随机数</span></span><br><span class="line">        counter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ThreadLocalRandom.current().nextInt());</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">currentCounter</span> <span class="operator">=</span> topicCounterMap.putIfAbsent(topic, counter);</span><br><span class="line">        <span class="keyword">if</span> (currentCounter != <span class="literal">null</span>) &#123;</span><br><span class="line">            counter = currentCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kafka 2.4 中，默认的分区器中实现了粘性分区（Sticky Partition），这个就不展开了，具体可以看<a href="https://www.cnblogs.com/huxi2b/p/12540092.html">这篇译文</a>。</p><h1 id="分区与消费者"><a href="#分区与消费者" class="headerlink" title="分区与消费者"></a>分区与消费者</h1><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202204271740/2022/04/26/lD9.png" alt="分区与消费者" style="width: 80%" /><p>在 Kafka 中，一个主题（topic）下可以有一个或多个分区（partition），消费者以分组的形式订阅主题，分组内可以有一个或多个消费者。同一时刻，一条消息只能被同一组内的某个消费者消费。这就意味着，在一个主题下，如果分区数大于消费者的个数，那么必定有消费者同时消费 2 个或以上的分区；如果分区数等于消费者的个数，那么正好一个消费者对应一个分区；如果分区数小于消费者的个数，那么必定有消费者处于空闲状态。</p><p>当消费者组成员变更时，包括成员加入或离开（比如 shutdown 或 crash），消费者组订阅的主题数变更时（主要发生在基于正则表达式订阅主题，当有新匹配的主题创建时）以及消费者组订阅的主题分区数变更时，Kafka 都将进行一次分区分配的过程，这个过程也叫做再平衡（rebalance）。再平衡过程中，如何分配分区则需要根据消费者的分区分配策略来实现，它可以通过 <code>partition.assignment.strategy</code> 属性来配置，Kafka 默认提供了三种策略：range、roundrobin 和 sticky。</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range 策略基于每个主题，按照序号排列可用分区，以字典顺序排列消费者，将分区数除以消费者数，得到每个消费者的分区数。如果没有平均划分，那么最初的几个消费者将有一个额外的分区。</p><p>假设有两个消费者 c0 和 c1，两个主题 t0 和 t1，每个主题有三个分区，即 t0p0，t0p1，t0p2，t1p0，t1p1，t1p2。那么使用 range 分配策略得到的结果就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c0 [t0p0，t0p1，t1p0，t1p1]</span><br><span class="line">c1 [t0p2，t1p2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; <span class="title function_">assign</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span><br><span class="line"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> &#123;</span><br><span class="line">    <span class="comment">// 主题与消费者集合的映射</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; consumersPerTopic = consumersPerTopic(subscriptions);</span><br><span class="line">    <span class="comment">// key 为消费者 ID，value 为分配给该消费者的 TopicPartition</span></span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; topicEntry : consumersPerTopic.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> topicEntry.getKey();</span><br><span class="line">        List&lt;String&gt; consumersForTopic = topicEntry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该 topic 的 partition 个数</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">numPartitionsForTopic</span> <span class="operator">=</span> partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 对消费者按照字典顺序排序</span></span><br><span class="line">        Collections.sort(consumersForTopic);</span><br><span class="line">        <span class="comment">// 计算每个消费者分到的分区数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numPartitionsPerConsumer</span> <span class="operator">=</span> numPartitionsForTopic / consumersForTopic.size();</span><br><span class="line">        <span class="comment">// 取余，计算剩余分区数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">consumersWithExtraPartition</span> <span class="operator">=</span> numPartitionsForTopic % consumersForTopic.size();</span><br><span class="line"></span><br><span class="line">        List&lt;TopicPartition&gt; partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = consumersForTopic.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 剩余分区分配给前面的几个消费者</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition);</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> numPartitionsPerConsumer + (i + <span class="number">1</span> &gt; consumersWithExtraPartition ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            assignment.get(consumersForTopic.get(i)).addAll(partitions.subList(start, start + length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="round-robin"><a href="#round-robin" class="headerlink" title="round robin"></a>round robin</h2><p>轮询策略基于所有可用消费者和所有可用分区，与 range 策略最大的不同是它不再局限于某个主题。如果所有的消费者的订阅都是相同的，那么就可以均衡分配。</p><p>假设有两个消费者 c0 和 c1，两个主题 t0 和 t1，每个主题有三个分区，即 t0p0，t0p1，t0p2，t1p0，t1p1，t1p2。那么最终的分配结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c0 [t0p0，t0p2，t1p1]</span><br><span class="line">c1 [t0p1，t1p0，p1p2]</span><br></pre></td></tr></table></figure><p>事实上，同组也可以订阅不同的主题。如果组中的每个消费者订阅的主题都不相同，分配的过程仍然使用轮询的方式，若消费者没有订阅主题，那么就要跳过该实例，这有可能会导致分配不平衡。也就是说，消费者组是一个逻辑概念，同组意味着同一时刻分区只能被一个消费者实例消费，换句话说，同组意味着一个分区只能分配给组中的一个消费者。</p><p>假设有三个消费者 c0、c1、c2 和三个主题 t0、t1、t2，三个主题分别具有 1、2、3 个分区，因此分区为：t0p0、t1p0、t1p1、t2p0、t2p1、t2p2。如果 c0 订阅 t0，c1 订阅 t0、t1，c2 订阅 t0、t1、t2，那么最终分配的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c0 [t0p0]</span><br><span class="line">c1 [t1p0]</span><br><span class="line">c2 [t1p1，t2p0，t2p1，t2p2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; <span class="title function_">assign</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span><br><span class="line"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> &#123;</span><br><span class="line">    <span class="comment">// subscriptions 是组成员与它订阅的主题的映射</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">        assignment.put(memberId, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    CircularIterator&lt;String&gt; assigner = <span class="keyword">new</span> <span class="title class_">CircularIterator</span>&lt;&gt;(Utils.sorted(subscriptions.keySet()));</span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> partition.topic();</span><br><span class="line">        <span class="comment">// 如果该消费者没有订阅该 topic，则跳过</span></span><br><span class="line">        <span class="keyword">while</span> (!subscriptions.get(assigner.peek()).topics().contains(topic))</span><br><span class="line">            assigner.next();</span><br><span class="line">        <span class="comment">// 找到订阅该 TopicPartition 的消费者</span></span><br><span class="line">        assignment.get(assigner.next()).add(partition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;TopicPartition&gt; <span class="title function_">allPartitionsSorted</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,</span></span><br><span class="line"><span class="params">                                                Map&lt;String, Subscription&gt; subscriptions)</span> &#123;</span><br><span class="line">    SortedSet&lt;String&gt; topics = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 所有 topic 排序</span></span><br><span class="line">    <span class="keyword">for</span> (Subscription subscription : subscriptions.values())</span><br><span class="line">        topics.addAll(subscription.topics());</span><br><span class="line"></span><br><span class="line">    List&lt;TopicPartition&gt; allPartitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String topic : topics) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">numPartitionsForTopic</span> <span class="operator">=</span> partitionsPerTopic.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (numPartitionsForTopic != <span class="literal">null</span>)</span><br><span class="line">            allPartitions.addAll(AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allPartitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>前两种分配策略，如果遇到 rebalance 的情况，分区的调整可能会比较大，而粘性分区策略则可以保证在尽量均衡的前提下减少分配结果的变动。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要讨论 Kafka 分区与生产者和消费者之间的分配关系。&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://blog.nekolr.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="https://blog.nekolr.com/tags/Kafka/"/>
    
    <category term="消息队列" scheme="https://blog.nekolr.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CPU Cache 与缓存一致性</title>
    <link href="https://blog.nekolr.com/2022/02/07/CPU%20Cache%20%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://blog.nekolr.com/2022/02/07/CPU%20Cache%20%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-02-07T10:33:00.000Z</published>
    <updated>2023-04-20T09:51:11.102Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机中，存储体系是一个典型的金字塔结构，按照速度排列从上到下依次是：CPU 寄存器、CPU Cache（L1&#x2F;L2&#x2F;L3）、内存、SSD 固态硬盘以及 HDD 传统机械硬盘。越上层的存储设备速度越快，当然价格也更贵，容量也越小。</p><span id="more"></span><p>从广义上讲，上一级的存储器都是下一级存储器的缓存。当然这里我们只关注 CPU Cache。现代 CPU 缓存通常都有三个等级，分为 L1、L2 和 L3，其中 L1 和 L2 在每个 CPU 核心中都有，而 L3 则是所有核心共享的。在 L1 高速缓存中，指令和数据是分开存储的；而在 L2 和 L3 中则不区分，称为统一缓存（unified cache）。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/07/wEP.png" alt="CPU Cache"></p><p>在 Linux 系统中，我们可以通过以下命令来查看 L1&#x2F;L2&#x2F;L3 的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L1 数据缓存</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/size</span><br><span class="line">32K</span><br><span class="line"></span><br><span class="line"><span class="comment"># L1 指令缓存</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index1/size</span><br><span class="line">32K</span><br><span class="line"></span><br><span class="line"><span class="comment"># L2</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index2/size</span><br><span class="line">256K</span><br><span class="line"></span><br><span class="line"><span class="comment"># L3</span></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index3/size</span><br><span class="line">3072K</span><br></pre></td></tr></table></figure><h1 id="CPU-Cache-映射策略"><a href="#CPU-Cache-映射策略" class="headerlink" title="CPU Cache 映射策略"></a>CPU Cache 映射策略</h1><p>CPU Cache 从内存读取到的数据是一块一块存储的，这一块可以理解为 CPU Cache 的最小缓存单位，它有一个专门的名字：Cache Line，一般它的大小为 64 Byte。在 Linux 中可以通过以下命令来查看它的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</span><br><span class="line">64</span><br></pre></td></tr></table></figure><p>由于 CPU Cache 与内存容量上的差异，必然需要某种映射规则，来确定 Cache Line 与内存地址的关系，这种关系就是我们所说的映射策略，一般常见的策略有：直接映射、全相联和组相联。</p><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p>直接映射是一种多对一的映射，这种方式下，主存中的每个内存块只能有一个 Cache Line 与之对应，因此它也叫做“单路组相联”。具体来说就是使用内存块地址对 Cache Line 的个数取模。比如内存共被划分了 32 个内存块，而 CPU Cache 共有 8 个 Cache Line，假如 CPU 想要访问第 15 号内存块，如果该内存块的数据已经缓存在了 Cache Line 中，那么一定是映射在了 7 号 Cache Line 中。一般来说，缓存的索引号可以通过以下公式计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I = (Am / B) mod N</span><br></pre></td></tr></table></figure><p>其中 I 为缓存索引，Am 为内存地址，B 为 Cache Line 的大小，N 为 Cache Line 的个数。Am 除以 B 是内存块的个数。</p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/mgx.png" alt="直接映射" style="width: 60%" /><p>直接映射的优点就是结构简单，易于实现，但是存在显著的冲突问题。由于多个不同的内存块会共享同一个缓存块，一旦缓存失效则必须将缓存块当前的数据清除，这在频繁更换缓存内容时会造成大量的延迟，并且也无法有效利用程序运行期间所具有的时间局部性特征（近期访问的地址在不久的将来很有可能被再次访问）。</p><h2 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h2><p>组相联是把缓存划分为多个组，每个组有若干个 Cache Line。用一句话来概括就是：组间直接映射，组内全相联。以下是一个 2 路组相联的例子：</p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/nOA.png" alt="2 路组相联" style="width: 60%" /><p>上图将缓存分成了 s 组，每组 2 个 Cache Line，即 2 路（2 ways），主存中的每个数据块只能位于分组中的某一个，但是可以在指定分组中的任意一个 Cache Line 中。一般来说，组相联的缓存索引可以通过以下公式计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I = (Am / Nw / Na) mod N</span><br></pre></td></tr></table></figure><p>其中，I 为缓存索引，Am 为内存地址，Nw 为缓存块内字数（也可以认为是 Cache Line 的大小），Na 为相联路数，N 为分组个数。</p><h2 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h2><p>全相联是指主存中的数据块可能出现在任意一个 Cache Line 中，这种方式使得替换具有最大的灵活性（可以使用 LFU 或者 LRU 等算法），同时也意味着有最低的 miss 率。但是由于没有索引可以使用，检查一个 cache 是否命中需要在整个 cache 范围内搜索，这带来了查找电路的大量延时。因此只有在缓存极小的情况才有可能使用这种方式。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实上面的三种映射方式，其实都可以看作是组相联，直接映射是单路组相联，而全映射则只有一个分组。因此，一个主存地址映射到高速缓存大体上有三个步骤：组选择（查找 Cache Set），行匹配（查找 Cache Line）和字抽取（查找 Cache Line 中一个字的起始字节）。</p><p>比如一个 32 位系统的内存地址映射到 4 MB 高速缓存中。首先是组选择，对于直接映射来说，分组数等于 Cache Line 的个数：65536，也就意味着需要中间 16 bit 来表示 Cache Line 的编号。接下来是行匹配，对于直接映射来说，一个分组只有一个 Cache Line，不用选择。最后是字抽取，由于一般 Cache Line 的大小是 64 Byte，同时现代处理器中，存储单元一般是以字节为单位的，也是最小的寻址单元，这也就意味着一个 Cache Line 可以存储 64 个存储单元，因此内存地址的低位 6 个 bit 用于表示在 Cache Line 中的偏移量（数据从第几个字节开始）。剩余的高位 10 bit 作为内存地址的一部分，同样也会映射到 Cache Line 中，作为标记位。</p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/677.png" alt="组映射" style="width: 90%" /><p>上图是组映射的一般表示，对于一个 E 路组相联来说，缓存被划分为了 2^s 组，即通过内存地址的中间 s 位即可找到目标 Cache Line 的对应分组。找到分组后，遍历分组中所有的 Cache Line，检查 Cache Line 中的有效位，以及对比 Cache Line 中的标记位与内存地址的高位 t bit 是否一致。当 tag 和 valid 校验成功，我们称为缓存命中，此时只需要根据内存地址的低位 b bit 计算出 Cache Line 中数据的起始字节，向后读取一个字放入 CPU 寄存器即可。</p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202202081621/2022/02/08/31e.png" alt="内存地址的一般表示" style="width: 90%" /><blockquote><p>计算机各个硬件之间进行信息传递是通过贯穿整个系统的一组电子管道，称做总线，它携带信息字节并负责在各个部件间传递。硬件之间进行信息交流需要有一个统一的标准，也就是二进制信息传递规则，为了高效考虑，通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，在各个系统中的情况都不尽相同。操作系统中的 32 位（4 个字节）或 64 （8 个字节）位就叫总线的字长单位。</p></blockquote><h1 id="写回和写直达"><a href="#写回和写直达" class="headerlink" title="写回和写直达"></a>写回和写直达</h1><p>既然有缓存，那必然会出现缓存与主存数据不一致的情况，此时就需要将最新的数据更新到对应的内存当中。通常有两种更新方式：写直达（Write Through）和写回（Write Back）。写直达要求 CPU 在写数据的时候，同时更新缓存和内存，这样缓存和内存的数据就会始终保持一致，但是对性能影响较大。而写回则要求 CPU 在写数据的时候，仅修改缓存，只有当缓存需要被替换时才会去更新内存，这样就大大减少了写内存的操作，提高了性能。关于写回，我们详细展开描述。</p><p>如果发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个标记代表 CPU Cache 里的这个 Cache Block 的数据和内存是不一致的，此时不需要把数据写到内存里。</p><p>如果发生写操作时，数据对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的，如果是脏的话，就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Block 里，同时也把它标记为脏的；如果 Cache Block 里面的数据没有被标记为脏，则直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的即可。</p><h1 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h1><p>在多核 CPU 中，由于每个核心都有自己的 L1 和 L2 缓存，因此必然存在核心之间的缓存一致性问题，MESI 协议就是为解决这个问题而存在的。在 MESI 协议中，Cache Line 有 4 种不同的状态：</p><p>已修改（Modified），表示缓存行是脏的，与主存的值不一致，如果别的 CPU 核心要读取主存中的这块数据，该缓存行必须写回主存，然后缓存行的状态变为共享。</p><p>独占的（Exclusive），表示缓存行只在当前缓存中，与已修改不同的是，该缓存行是干净的，即没有发生修改。CPU 可以直接对其进行修改，然后状态变为已修改。</p><p>共享的（Shared），表示缓存行也存在于其他缓存中且都是干净的。处于该状态的缓存行不能直接被修改，需要该 CPU 核心向其他核心广播一个消息，要求其他拥有相同数据的核心把各自对应的缓存行标记为无效。</p><p>无效的（Invalid），表示缓存行是无效的，不可以再读取该状态的缓存行数据。另外，一般的 Cache 会优先填充 Invalid 状态的缓存行。</p><p>缓存行的状态转换可以通过一个有限状态机来描述，触发状态转换的场景有两种：缓存所在处理器的读写，其他处理器的读写。有时一个处理器对于缓存的请求可能需要通过总线来发送，而总线请求会被总线窥探器监听。以下是<strong>某个 CPU 操作时，当前缓存行的状态转换表：</strong></p><table><thead><tr><th>初始状态</th><th>操作</th><th>响应</th></tr></thead><tbody><tr><td>Invalid</td><td>读</td><td>此时向总线发送读缓存的请求，其他处理器监听到该请求后，会检查自己是否有有效的数据副本。如果有，则通过总线发送该数据副本，此时该缓存行状态变为 Shared；如果没有，则会请求主存获取数据，缓存行状态变为 Exclusive</td></tr><tr><td>Invalid</td><td>写</td><td>此时向总线发送写缓存的请求，其他处理器监听到该请求后，会检查自己是否有有效的数据副本。如果有，则其中一个通过总线发送该数据副本，同时这些拥有有效副本的缓存都将设置为 Invalid；如果没有，则会请求主存获取数据。为什么要获取最新的值？答案是因为此前没有该缓存，获取是为了独占缓存。之后该处理器会向缓存块中写入修改后的值</td></tr><tr><td>Exclusive</td><td>读</td><td>只有当前处理器拥有该缓存，因此不会发送总线请求，状态保持不变</td></tr><tr><td>Exclusive</td><td>写</td><td>只有当前处理器拥有该缓存，因此不会发送总线请求，此时直接写入修改后的值，缓存行状态变为 Modified</td></tr><tr><td>Shared</td><td>读</td><td>没有总线请求产生，状态保持不变</td></tr><tr><td>Shared</td><td>写</td><td>其他处理器拥有该缓存，因此需要发送总线请求，其他处理器监听到该请求后，会将自己的有效副本标记为 Invalid，然后当前缓存行的状态变为 Modified</td></tr><tr><td>Modified</td><td>读</td><td>此时没有总线请求产生，直接读取缓存，状态保持不变</td></tr><tr><td>Modified</td><td>写</td><td>同样没有总线请求产生，同时状态保持不变，直接修改缓存为新值即可</td></tr></tbody></table><p>写操作仅在缓存行是已修改或者独占状态时可以自由执行，如果在共享状态，其他处理器的缓存都需要先设置为无效，这种广播操作称为 RFO（Request For Ownership）。对于已修改状态的缓存行，要监听各处理器对其的读请求，发送其数据到总线的同时还要写回主存。对于共享状态的缓存行，要监听使其无效或请求拥有的广播，当匹配时把该缓存行置为无效。</p><h1 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h1><p>当某个处理器尝试修改其他处理器的 Cache Line 中的数据时，MESI 的广播操作带来的延迟对于处理器来说是难以忍受的。为了解决这个问题，在 CPU 和 Cache 中间又引入了 Store Buffer。这是一个容量比高速缓存还小的私有部件，当处理器需要修改数据时，会先将数据写入写缓冲器中，然后继续处理其他事情，当收到其他处理器的响应时，才将数据从写缓冲器转移到 Cache Line 中。</p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202203041757/2022/03/04/ova.png" alt="Store Buffer" style="width: 70%" /><h1 id="Store-Forwarding"><a href="#Store-Forwarding" class="headerlink" title="Store Forwarding"></a>Store Forwarding</h1><p>在同一个处理器中，写缓冲器的引入必然会带来一个问题，即异步操作引发的数据滞后性。自处理器的写操作将最新的数据放入写缓冲器时起，高速缓存中的数据就已经过时，此后所有的加载操作看到的都是旧的数据，直到写缓冲器将数据同步到高速缓存。</p><p>为了解决这个问题，硬件工程师实现了 Store Forwarding 技术，这个技术可以使 CPU 直接从 Store Buffer 加载数据，即支持将 CPU 放入 Store Buffer 的数据传递给后续的加载操作而不经过高速缓存。</p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202203041757/2022/03/04/Bwe.png" alt="Store Forwarding" style="width: 70%" /><p>需要注意的是，虽然处理器可以直接读取其 Store Buffer 中自己以前的写操作，但是在将这些操作从写缓冲区刷新到高速缓存之前，其他处理器是无法看到这些写操作的。这就意味着，Store Forwarding 技术只能解决单个处理器中的缓存滞后问题，无法解决多核处理器的此类问题。</p><h1 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h1><p>由于 Store Buffer 的容量很小，因此它很容易就会被填满，此时处理器必须等待它发出的使缓存无效的广播请求得到响应，才可以将 Store Buffer 中的数据转移到高速缓存，从而释放空间。</p><p>为了解决这个同步操作带来的延迟问题，硬件工程师又为每个处理器添加了一个无效队列。处理器在监听到使缓存无效的消息后，直接将消息放入无效队列中排队，然后立即发送回复消息，这就大大降低了响应的延迟。</p><blockquote><p>有些处理器并没有实现 Invalid Queue。</p></blockquote><h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>内存屏障（memory barrier）又叫内存栅栏（memory fence），其目的是用来阻止 CPU 对指令的重排序（有些编译器也会对指令进行重排序）。根据 CPU 对于变量的操作读（load）和写（store），两两组合可以有四种内存屏障：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>LoadLoad 屏障</td><td>保证屏障前的 load 操作一定在屏障后的 load 操作之前完成</td></tr><tr><td>StoreStore 屏障</td><td>保证屏障前的 store 操作一定在屏障后的 store 操作之前完成</td></tr><tr><td>LoadStore 屏障</td><td>保证屏障前的 load 操作一定在屏障后的 store 操作之前完成</td></tr><tr><td>StoreLoad 屏障</td><td>保证屏障前的 store 操作一定在屏障后的 load 操作之前完成</td></tr></tbody></table><p>内存屏障除了有阻止指令重排序的作用，还与 MESI 协议有关。我们知道 MESI 为了优化性能，引入了 Store Buffer 和 Invalid Queue，因此写类型的内存屏障还能触发内存的强制更新，让 Store Buffer 中的数据立刻写回到高速缓存中。读类型的内存屏障会让 Invalid Queue 中的缓存行在后面的 load 操作之前全部标记为失效。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/">关于CPU Cache – 程序猿需要知道的那些事</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/296949412/answer/760347883">既然 CPU 有缓存一致性协议（MESI），为什么 JMM 还需要 volatile 关键字？</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机中，存储体系是一个典型的金字塔结构，按照速度排列从上到下依次是：CPU 寄存器、CPU Cache（L1&amp;#x2F;L2&amp;#x2F;L3）、内存、SSD 固态硬盘以及 HDD 传统机械硬盘。越上层的存储设备速度越快，当然价格也更贵，容量也越小。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://blog.nekolr.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://blog.nekolr.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java Agent</title>
    <link href="https://blog.nekolr.com/2021/08/15/Java%20Agent/"/>
    <id>https://blog.nekolr.com/2021/08/15/Java%20Agent/</id>
    <published>2021-08-15T16:32:00.000Z</published>
    <updated>2023-04-20T09:51:11.102Z</updated>
    
    <content type="html"><![CDATA[<p>说到 Java Agent，有必要提一提 AOP，也就是面向切面编程思想。AOP 作为 OOP（面向对象编程思想）的一个补充，在技术实现上是没有规定和约束的。在 Java 中，最常见的实现方式就是 Filter 的责任链模式和 Spring AOP 的代理模式。</p> <span id="more"></span><p>当然，AOP 也不一定非得像 Spring AOP 那样，在运行时通过动态生成代理对象来织入增强。一个 Java 类的生命周期，从编码开始，还需要经历编译、加载、连接、初始化、使用和卸载这些阶段。而在使用之前，每个阶段我们都可以对类进行增强。</p><h1 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h1><p>在编码阶段，我们可以通过静态代理的方式对目标对象进行增强，但是缺点也很明显，就是不够灵活，属于一锤子买卖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectImpl</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;operation...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectProxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Subject target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubjectProxy</span><span class="params">(Subject target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        target.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h1><p>在编译阶段，我们可以通过使用特殊的编译器，在将源文件编译成字节码的时候进行增强，编译后的字节码本身就包含了增强的内容，这就是编译期织入 CTW（Compile-Time Weaving）。典型的工具库就是：AspectJ。</p><p>AspectJ 提供了两种切面的编写方式，其中一种是使用 AspectJ 特有的语法；另一种是使用注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect SubjectAspect &#123;</span><br><span class="line">    <span class="comment">// 切点 pointcut</span></span><br><span class="line">    pointcut <span class="title function_">doBefore</span><span class="params">()</span>:execution(<span class="keyword">void</span> SubjectImpl.operation(..));</span><br><span class="line">    pointcut <span class="title function_">doAfter</span><span class="params">()</span>:execution(<span class="keyword">void</span> SubjectImpl.operation(..));</span><br><span class="line">    pointcut <span class="title function_">doAround</span><span class="params">()</span>:execution(<span class="keyword">void</span> SubjectImpl.operation(..));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 advice</span></span><br><span class="line">    before(): doBefore() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after(): doAfter() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// around 和 before、after 不要同时出现，编译会报错</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>: doAround() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before...&quot;</span>);</span><br><span class="line">        proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* org.example.SubjectImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然使用 AspectJ 的特有语法来描述切面会更加灵活，但是由于它不兼容 java 语法，在 IDE 中需要安装插件来支持它的语法，再加上需要额外的学习成本，因此这种方式实际上使用的并不多，通常还是采用兼容 java 语法的注解来定义切面。</p><p>在定义好了切面以后，还需要使用 AspectJ 特定的编译器来编译代码。在 AspectJ 1.9.7 版本中，可以直接通过下载的 jar 包进行安装，安装后的程序包含 <code>ajc</code> 命令。当然也可以通过安装 IDE 插件或者使用构建工具（比如 Maven）的插件来编译。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complianceLevel</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">complianceLevel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">showWeaveInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWeaveInfo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Xlint</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">Xlint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面就是通过 <code>ajc</code> 编译器编译后的代码，可以看到增强的部分直接被织入到了目标方法前后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectImpl</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubjectImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SubjectAspect.aspectOf().doBefore();</span><br><span class="line">            System.out.println(<span class="string">&quot;operation...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">            SubjectAspect.aspectOf().doAfter();</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubjectAspect.aspectOf().doAfter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>aspectjrt.jar 包的主要作用是提供运行时环境，包括一些注解、静态方法等，在使用 AspectJ 时一般都需要引入。aspectjtools.jar 主要提供的是赫赫有名的 <code>ajc</code> 编译器，通常这个包会被封装到 IDE 插件或者自动化构建工具的插件中。aspectjweaver.jar 主要提供了一个 java agent 用于在类加载期间织入切面（LTW）。</p></blockquote><h1 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h1><p>由于类的加载本质上就是类加载器将从文件、网络或者其他渠道获取的字节流解析成 Class 对象的过程，因此我们只需要通过某种方式修改字节流，就可以实现类的增强。也就是说，在类加载阶段，我们只需要自定义一个类加载器，在类加载器读取字节流之前，利用一些字节码增强工具（比如：ASM、Javassist 等）对类进行增强，最后将增强后的字节流解析为 Class 对象即可。</p><p>下面使用 Javassist 简单演示一下在类加载阶段实现类增强的步骤。首先写一个类，添加一个方法 <code>test</code>，方便我们后续对该方法进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeThing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个方法，该方法接收字节流，内部通过 Javassist 的 API 对字节流进行修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhanceMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] printCost(<span class="type">byte</span>[] classBytes) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> ClassPool.getDefault().makeClass(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(classBytes));</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getMethod(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">        ctMethod.addLocalVariable(<span class="string">&quot;cost&quot;</span>, CtClass.longType);</span><br><span class="line">        ctMethod.insertBefore(<span class="string">&quot;cost = System.currentTimeMillis();&quot;</span>);</span><br><span class="line">        ctMethod.insertAfter(<span class="string">&quot;cost = System.currentTimeMillis() - cost; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;System.out.println(\&quot;total cost: \&quot; + cost);&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来自定义一个类加载器，在读到原始类文件的流之后，调用该方法替换流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileUrl</span> <span class="operator">=</span> filePath;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="keyword">new</span> <span class="title class_">URI</span>(fileUrl + name + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line">            bytes = EnhanceMethod.printCost(bytes);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是使用自定义的类加载器加载原始类文件，然后调用对象的 <code>test</code> 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;file:/d:/code/myAgent/&quot;</span>;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(filePath);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> myClassLoader.loadClass(<span class="string">&quot;SomeThing&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Instrument"><a href="#Instrument" class="headerlink" title="Instrument"></a>Instrument</h1><p>Instrument 是 JDK 5 提供的一个新特性，用一句话来总结它的主要作用就是：实现了 JVM 级别的 AOP。通过这个特性，开发者可以构建一个独立于应用程序的代理程序，用来监测和协助运行在 JVM 上的应用。</p><h2 id="JVMTI"><a href="#JVMTI" class="headerlink" title="JVMTI"></a>JVMTI</h2><p>Instrument 的底层实现依赖于 JVMTI（JVM Tool Interface），它是 JVM 暴露出来为了方便用户扩展的接口集合。JVMTI 是基于事件驱动的，具体来说就是，JVM 在执行过程中触发了某些事件就会调用对应事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。</p><h2 id="JVMTIAgent"><a href="#JVMTIAgent" class="headerlink" title="JVMTIAgent"></a>JVMTIAgent</h2><p>JVMTIAgent 其实就是一个动态链接库。它利用 JVMTI 暴露出来的接口实现了一些特殊的功能，一般情况下，它会实现如下的一个或者多个接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Agent_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">char</span> *options, <span class="type">void</span> *reserved)</span>;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Agent_OnAttach</span><span class="params">(JavaVM* vm, <span class="type">char</span>* options, <span class="type">void</span>* reserved)</span>;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Agent_OnUnload</span><span class="params">(JavaVM *vm)</span>;</span><br></pre></td></tr></table></figure><p>VM 是通过启动函数来启动 agent 的。如果 agent 是在 VM 启动时加载的，也就是说 agent 是在 java 命令中通过 <code>-agentlib</code> 指定的，那么 VM 就会在启动过程中去执行这个 agent 里的 Agent_OnLoad 函数来启动该 agent。如果 agent 不是在 VM 启动时加载的，而是在 VM 处于运行过程中时，先 attach 到目标进程上，然后向目标进程发送 load 命令来加载的，此时 VM 会在加载过程中会调用这个 agent 里的 Agent_OnAttach 函数来启动该 agent。而 Agent_OnUnload 函数会在 agent 卸载时被调用，一般很少实现它。</p><blockquote><p>这里提到的 agent 程序和 java agent 不是同一概念。我们在使用 IDE 进行开发时，如果仔细观察，在控制台中会发现类似的命令：<code>java.exe -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:62290,suspend=y,server=n</code>，这个动态链接库 jdwp 同样也是一个 JVMTIAgent，它实现了程序调试相关的功能。</p></blockquote><h2 id="java-agent"><a href="#java-agent" class="headerlink" title="java agent"></a>java agent</h2><p>java agent 的功能则是由一个叫做 instrument 的 JVMTIAgent 实现的，它由 JDK 内置提供，在 Linux 下对应的动态库是 <code>libinstrument.so</code>，在 Windows 下是 <code>instrument.dll</code>。由于它实现了 Agent_OnLoad 和 Agent_OnAttach 函数，因此可以在 JVM 启动时加载，也可以在运行时动态加载。其中，启动时加载还可以通过类似 <code>-javaagent:agent.jar</code> 的方式来间接加载 instrument agent。</p><p>对于开发人员来说，如果希望 agent 在目标 JVM 启动时加载，只需要编写一个类，然后实现以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs)</span>;</span><br></pre></td></tr></table></figure><p>如果希望目标 JVM 在运行时加载 agent，则需要实现以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs)</span>;</span><br></pre></td></tr></table></figure><p>上述方法中，JVM 会先寻找对应的第一个方法，如果没有找到则会去寻找对应的第二个方法。其中 agentArgs 是 premain 函数或 agentmain 函数得到的程序参数，由 <code>-javaagent</code> 指定。inst 是一个 <code>Instrumentation</code> 实例，由 JVM 传入，我们可以通过该参数进行类增强等操作。</p><p>接下来需要将这个 agent 打包成一个 jar 文件，同时 jar 文件中还要包含一个 <code>MANIFEST.MF</code> 描述文件，文件中需要指定 Premain-Class 或 Agent-Class 属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: org.example.AgentApplication</span><br><span class="line">Agent-Class: org.example.AgentApplication</span><br></pre></td></tr></table></figure><h2 id="从源代码解析启动时加载"><a href="#从源代码解析启动时加载" class="headerlink" title="从源代码解析启动时加载"></a>从源代码解析启动时加载</h2><p>在创建 JVM 时，JVM 会进行启动参数的解析，我们这里重点关注 <code>-agentlib</code>、<code>-agentpath</code> 和 <code>-javaagent</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-agentlib:&quot;</span>, &amp;tail) ||</span><br><span class="line">      (is_absolute_path = <span class="built_in">match_option</span>(option, <span class="string">&quot;-agentpath:&quot;</span>, &amp;tail))) &#123;</span><br><span class="line">  <span class="keyword">if</span>(tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pos = <span class="built_in">strchr</span>(tail, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    <span class="type">size_t</span> len = (pos == <span class="literal">NULL</span>) ? <span class="built_in">strlen</span>(tail) : pos - tail;</span><br><span class="line">    <span class="type">char</span>* name = <span class="built_in">strncpy</span>(<span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="type">char</span>, len + <span class="number">1</span>, mtInternal), tail, len);</span><br><span class="line">    name[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *options = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      options = <span class="built_in">strcpy</span>(<span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="type">char</span>, <span class="built_in">strlen</span>(pos + <span class="number">1</span>) + <span class="number">1</span>, mtInternal), pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">valid_hprof_or_jdwp_agent</span>(name, is_absolute_path)) &#123;</span><br><span class="line">      <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">        <span class="string">&quot;Profiling and debugging agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br><span class="line">    <span class="built_in">add_init_agent</span>(name, options, is_absolute_path);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// -javaagent</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">match_option</span>(option, <span class="string">&quot;-javaagent:&quot;</span>, &amp;tail)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !INCLUDE_JVMTI</span></span><br><span class="line">  <span class="built_in">jio_fprintf</span>(defaultStream::<span class="built_in">error_stream</span>(),</span><br><span class="line">    <span class="string">&quot;Instrumentation agents are not supported in this VM\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> JNI_ERR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span>(tail != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *options = <span class="built_in">strcpy</span>(<span class="built_in">NEW_C_HEAP_ARRAY</span>(<span class="type">char</span>, <span class="built_in">strlen</span>(tail) + <span class="number">1</span>, mtInternal), tail);</span><br><span class="line">    <span class="built_in">add_init_agent</span>(<span class="string">&quot;instrument&quot;</span>, options, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !INCLUDE_JVMTI</span></span></span><br><span class="line"><span class="comment">// -Xnoclassgc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ref: hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;arguments.cpp</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -agentlib and -agentpath arguments</span></span><br><span class="line"><span class="type">static</span> AgentLibraryList _agentList;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">add_init_agent</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">char</span>* options, <span class="type">bool</span> absolute_path)</span></span></span><br><span class="line"><span class="function">  </span>&#123; _agentList.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">AgentLibrary</span>(name, options, absolute_path, <span class="literal">NULL</span>)); &#125;</span><br></pre></td></tr></table></figure><blockquote><p>ref: hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;arguments.hpp</p></blockquote><p>这里我们只需要关注 <code>add_init_agent</code> 方法，该方法将解析好的参数放入了一个 <code>AgentLibraryList</code> 类型的链表中，以备后续使用。</p><p>接下来我们回到创建 JVM 的方法，在这个方法中，我省略了部分代码，重点关注解析参数后的加载过程即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">Threads::create_vm</span><span class="params">(JavaVMInitArgs* args, <span class="type">bool</span>* canTryAgain)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 解析参数</span></span><br><span class="line">  jint parse_result = Arguments::<span class="built_in">parse</span>(args);</span><br><span class="line">  <span class="keyword">if</span> (parse_result != JNI_OK) <span class="keyword">return</span> parse_result;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Launch -agentlib/-agentpath and converted -Xrun agents</span></span><br><span class="line">  <span class="keyword">if</span> (Arguments::<span class="built_in">init_agents_at_startup</span>()) &#123;</span><br><span class="line">    <span class="built_in">create_vm_init_agents</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threads::create_vm_init_agents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">JavaVM_</span> main_vm;</span><br><span class="line">  AgentLibrary* agent;</span><br><span class="line">  JvmtiExport::<span class="built_in">enter_onload_phase</span>();</span><br><span class="line">  <span class="comment">// agents 方法从 _agentList 链表中取出一个元素</span></span><br><span class="line">  <span class="keyword">for</span> (agent = Arguments::<span class="built_in">agents</span>(); agent != <span class="literal">NULL</span>; agent = agent-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">    OnLoadEntry_t  on_load_entry = <span class="built_in">lookup_agent_on_load</span>(agent);</span><br><span class="line">    <span class="keyword">if</span> (on_load_entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// 调用 Agent_OnLoad 方法</span></span><br><span class="line">      jint err = (*on_load_entry)(&amp;main_vm, agent-&gt;<span class="built_in">options</span>(), <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (err != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;agent library failed to init&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">vm_exit_during_initialization</span>(<span class="string">&quot;Could not find Agent_OnLoad function in the agent library&quot;</span>, agent-&gt;<span class="built_in">name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  JvmtiExport::<span class="built_in">enter_primordial_phase</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the Agent_OnLoad entry point</span></span><br><span class="line"><span class="function"><span class="type">static</span> OnLoadEntry_t <span class="title">lookup_agent_on_load</span><span class="params">(AgentLibrary* agent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Agent_OnLoad</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lookup_on_load</span>(agent, on_load_symbols, <span class="built_in">sizeof</span>(on_load_symbols) / <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ref: hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;thread.cpp</p></blockquote><p>可以看到，在加载过程中，又调用了 <code>lookup_agent_on_load</code> 方法，该方法的主要作用是加载 agent 对应的动态链接文件。我们回忆刚才分析的代码，也就是说，当指定了 <code>-javaagent</code> 参数时，这里会加载 <code>instrument</code> 这个动态链接文件，最终还会调用它的 Agent_OnLoad 方法，因此，我们接下来要分析 Agent_OnLoad 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Agent_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">char</span> *tail, <span class="type">void</span> * reserved)</span> </span>&#123;</span><br><span class="line">    initerror = <span class="built_in">createNewJPLISAgent</span>(vm, &amp;agent);</span><br><span class="line">    <span class="keyword">if</span> ( initerror == JPLIS_INIT_ERROR_NONE ) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Parse &lt;jarfile&gt;[=options] into jarfile and options</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseArgumentTail</span>(tail, &amp;jarfile, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;-javaagent: memory allocation failure.\n&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        attributes = <span class="built_in">readAttributes</span>(jarfile);</span><br><span class="line">        premainClass = <span class="built_in">getAttribute</span>(attributes, <span class="string">&quot;Premain-Class&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Convert JAR attributes into agent capabilities</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">convertCapabilityAtrributes</span>(attributes, agent);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Track (record) the agent class name and options data</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        initerror = <span class="built_in">recordCommandLineData</span>(agent, premainClass, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ref: jdk&#x2F;src&#x2F;share&#x2F;instrument&#x2F;InvocationAdapter.c</p></blockquote><p>以上是精简后的代码，大概的流程就是：先创建一个 JPLISAgent，然后将 ManiFest 文件中设定的一些参数解析出来， 比如 Premain-Class 等。在创建了 JPLISAgent 之后，还会调用 initializeJPLISAgent 方法对这个 Agent 进行初始化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JPLISInitializationError</span></span><br><span class="line"><span class="function"><span class="title">initializeJPLISAgent</span><span class="params">(   JPLISAgent *    agent,</span></span></span><br><span class="line"><span class="params"><span class="function">                        JavaVM *        vm,</span></span></span><br><span class="line"><span class="params"><span class="function">                        jvmtiEnv *      jvmtienv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* now turn on the VMInit event */</span></span><br><span class="line">    <span class="keyword">if</span> ( jvmtierror == JVMTI_ERROR_NONE ) &#123;</span><br><span class="line">        jvmtiEventCallbacks callbacks;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;callbacks, <span class="number">0</span>, <span class="built_in">sizeof</span>(callbacks));</span><br><span class="line">        callbacks.VMInit = &amp;eventHandlerVMInit;</span><br><span class="line"></span><br><span class="line">        jvmtierror = (*jvmtienv)-&gt;<span class="built_in">SetEventCallbacks</span>( jvmtienv,</span><br><span class="line">                                                     &amp;callbacks,</span><br><span class="line">                                                     <span class="built_in">sizeof</span>(callbacks));</span><br><span class="line">        <span class="built_in">check_phase_ret_blob</span>(jvmtierror, JPLIS_INIT_ERROR_FAILURE);</span><br><span class="line">        <span class="built_in">jplis_assert</span>(jvmtierror == JVMTI_ERROR_NONE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，我们只关注 <code>callbacks.VMInit = &amp;eventHandlerVMInit;</code> 这行代码，这里设置了一个 VMInit 事件的回调函数，表示<strong>在 JVM 初始化的时候</strong>会回调 eventHandlerVMInit 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">eventHandlerVMInit</span><span class="params">( jvmtiEnv *      jvmtienv,</span></span></span><br><span class="line"><span class="params"><span class="function">                    JNIEnv *        jnienv,</span></span></span><br><span class="line"><span class="params"><span class="function">                    jthread         thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* process the premain calls on the all the JPL agents */</span></span><br><span class="line">    <span class="keyword">if</span> ( environment != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jthrowable outstandingException = <span class="built_in">preserveThrowable</span>(jnienv);</span><br><span class="line">        success = <span class="built_in">processJavaStart</span>( environment-&gt;mAgent,</span><br><span class="line">                                    jnienv);</span><br><span class="line">        <span class="built_in">restoreThrowable</span>(jnienv, outstandingException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jboolean</span></span><br><span class="line"><span class="function"><span class="title">processJavaStart</span><span class="params">(   JPLISAgent *    agent,</span></span></span><br><span class="line"><span class="params"><span class="function">                    JNIEnv *        jnienv)</span> </span>&#123;</span><br><span class="line">    jboolean    result;</span><br><span class="line">    result = <span class="built_in">initializeFallbackError</span>(jnienv);</span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 sun.instrument.InstrumentationImpl 实例</span></span><br><span class="line">        result = <span class="built_in">createInstrumentationImpl</span>(jnienv, agent);</span><br><span class="line">        <span class="built_in">jplis_assert</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭 VMInit handler 同时设置 ClassFileLoadHook 事件的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = <span class="built_in">setLivePhaseEventHandlers</span>(agent);</span><br><span class="line">        <span class="built_in">jplis_assert</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载 java agent 同时调用它的 premain 方法</span></span><br><span class="line">    <span class="keyword">if</span> ( result ) &#123;</span><br><span class="line">        result = <span class="built_in">startJavaAgent</span>(agent, jnienv,</span><br><span class="line">                                agent-&gt;mAgentClassName, agent-&gt;mOptionsString,</span><br><span class="line">                                agent-&gt;mPremainCaller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个 VMInit 事件发生时，虚拟机的主要操作是实例化了一个 <code>sun.instrument.InstrumentationImpl</code>，然后设置了 ClassFileLoadHook 事件的回调函数，最后加载 java agent 同时调用它的 premain 方法。其中，InstrumentationImpl 是 <code>java.lang.instrument.Instrumentation</code> 接口的实现类。此时我们很容易就会想到 premain 方法中的 inst 参数，没错，在调用 premain 方法时，由虚拟机传入的 inst 参数就是它。</p><h2 id="从源代码解析运行时加载"><a href="#从源代码解析运行时加载" class="headerlink" title="从源代码解析运行时加载"></a>从源代码解析运行时加载</h2><p>与启动时加载 Agent 相比，运行时加载 Agent 显得更有吸引力，因为运行时加载 Agent 给我们提供了很强的动态性，我们可以在需要的时候加载 Agent 来进行一些工作。<code>tools.jar</code> 中提供了一个 <code>com.sun.tools.attach.VirtualMachine</code> 类，通过它可以实现虚拟机在运行时动态加载 agent。以下代码来自美团技术博客。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attachAgentToTargetJVM</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;VirtualMachineDescriptor&gt; virtualMachineDescriptors = VirtualMachine.list();</span><br><span class="line">    <span class="type">VirtualMachineDescriptor</span> <span class="variable">targetVM</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (VirtualMachineDescriptor descriptor : virtualMachineDescriptors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (descriptor.id().equals(configure.getPid())) &#123;</span><br><span class="line">            targetVM = descriptor;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetVM == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;could not find the target jvm by process id:&quot;</span> </span><br><span class="line">        + configure.getPid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        virtualMachine = VirtualMachine.attach(targetVM);</span><br><span class="line">        virtualMachine.loadAgent(<span class="string">&quot;&#123;agent&#125;&quot;</span>, <span class="string">&quot;&#123;params&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (virtualMachine != <span class="literal">null</span>) &#123;</span><br><span class="line">            virtualMachine.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们回到创建虚拟机的过程，在上面我们分析过了这个过程的部分操作，其中我们忽略了一个操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">Threads::create_vm</span><span class="params">(JavaVMInitArgs* args, <span class="type">bool</span>* canTryAgain)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  os::<span class="built_in">signal_init</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::signal_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ReduceSignalUsage) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> thread_name[] = <span class="string">&quot;Signal Dispatcher&quot;</span>;</span><br><span class="line">    Handle string = java_lang_String::<span class="built_in">create_from_str</span>(thread_name, CHECK);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123; <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">      JavaThread* signal_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;signal_thread_entry);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle ^BREAK</span></span><br><span class="line">    os::<span class="built_in">signal</span>(SIGBREAK, os::<span class="built_in">user_handler</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法创建了一个名为：Signal Dispatcher 的线程，这个线程的入口方法为：signal_thread_entry。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">signal_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    &#123;</span><br><span class="line">      sig = os::<span class="built_in">signal_wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sig == os::<span class="built_in">sigexitnum_pd</span>()) &#123;</span><br><span class="line">       <span class="comment">// Terminate the signal thread</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (sig) &#123;</span><br><span class="line">      <span class="keyword">case</span> SIGBREAK: &#123;</span><br><span class="line">        <span class="keyword">if</span> (!DisableAttachMechanism &amp;&amp; AttachListener::<span class="built_in">is_init_trigger</span>()) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，如果 Signal Dispatcher 线程接收到 <code>SIGBREAK</code> 信号时，就执行接下来的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AttachListener::is_init_trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">init_at_startup</span>() || <span class="built_in">is_initialized</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> fn[PATH_MAX+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(fn, <span class="string">&quot;.attach_pid%d&quot;</span>, os::<span class="built_in">current_process_id</span>());</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat64</span> st;</span><br><span class="line">  <span class="built_in">RESTARTABLE</span>(::<span class="built_in">stat64</span>(fn, &amp;st), ret);</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(fn, <span class="built_in">sizeof</span>(fn), <span class="string">&quot;%s/.attach_pid%d&quot;</span>,</span><br><span class="line">             os::<span class="built_in">get_temp_directory</span>(), os::<span class="built_in">current_process_id</span>());</span><br><span class="line">    <span class="built_in">RESTARTABLE</span>(::<span class="built_in">stat64</span>(fn, &amp;st), ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// simple check to avoid starting the attach mechanism when</span></span><br><span class="line">    <span class="comment">// a bogus user creates the file</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_uid == <span class="built_in">geteuid</span>()) &#123;</span><br><span class="line">      <span class="built_in">init</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ref: hotspot\src\os\linux\vm\attachListener_linux.cpp</p></blockquote><p>上面这部分代码是 linux 平台下的实现，可以看到，在该方法中会先检查 JVM 是否已经启动了 Attach Listener，如果没有，会在 <code>/tmp</code> 目录下创建一个叫做 <code>.attach_pid&#123;pid&#125;</code> 的文件，然后执行 AttachListener 的 init 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AttachListener::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> thread_name[] = <span class="string">&quot;Attach Listener&quot;</span>;</span><br><span class="line">  Handle string = java_lang_String::<span class="built_in">create_from_str</span>(thread_name, CHECK);</span><br><span class="line"></span><br><span class="line">  &#123; <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    JavaThread* listener_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;attach_listener_thread_entry);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 Signal Dispatcher 线程类似，这里也创建了一个线程：Attach Listener。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">attach_listener_thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    AttachOperation* op = AttachListener::<span class="built_in">dequeue</span>();</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;<span class="built_in">name</span>(), AttachOperation::<span class="built_in">detachall_operation_name</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">      AttachListener::<span class="built_in">detachall</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// find the function to dispatch too</span></span><br><span class="line">      AttachOperationFunctionInfo* info = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; funcs[i].name != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* name = funcs[i].name;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">strlen</span>(name) &lt;= AttachOperation::name_length_max, <span class="string">&quot;operation &lt;= name_length_max&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op-&gt;<span class="built_in">name</span>(), name) == <span class="number">0</span>) &#123;</span><br><span class="line">          info = &amp;(funcs[i]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// dispatch to the function that implements this operation</span></span><br><span class="line">        res = (info-&gt;func)(op, &amp;st);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st.<span class="built_in">print</span>(<span class="string">&quot;Operation %s not recognized!&quot;</span>, op-&gt;<span class="built_in">name</span>());</span><br><span class="line">        res = JNI_ERR;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个入口函数中，首先通过 dequeue 方法拉取操作，这个拉取的方法在不同的平台有不同的实现，在 linux 下，Attach Listener 线程会监听某个端口，通过 accept 方法来接收一个连接，然后从连接中读取请求并封装成一个 AttachOperation 类型的对象，然后到对应的操作列表中去匹配，最后执行相应的函数。以下是这个操作列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> AttachOperationFunctionInfo funcs[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;agentProperties&quot;</span>,  get_agent_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;datadump&quot;</span>,         data_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;dumpheap&quot;</span>,         dump_heap &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;load&quot;</span>,             JvmtiExport::load_agent_library &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;properties&quot;</span>,       get_system_properties &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;threaddump&quot;</span>,       thread_dump &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;inspectheap&quot;</span>,      heap_inspection &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;setflag&quot;</span>,          set_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;printflag&quot;</span>,        print_flag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;jcmd&quot;</span>,             jcmd &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span>,               <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过上面的分析，我们应该能够隐约知道 VirtualMachine 的 attach 方法的大概逻辑，下面通过源代码来验证一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> VirtualMachine <span class="title function_">attach</span><span class="params">(String var0)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;id cannot be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">var1</span> <span class="operator">=</span> AttachProvider.providers();</span><br><span class="line">        <span class="keyword">if</span> (var1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(<span class="string">&quot;no providers installed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">AttachNotSupportedException</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> var1.iterator();</span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                <span class="type">AttachProvider</span> <span class="variable">var4</span> <span class="operator">=</span> (AttachProvider)var3.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> var4.attachVirtualMachine(var0);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (AttachNotSupportedException var6) &#123;</span><br><span class="line">                    var2 = var6;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> VirtualMachine <span class="title function_">attachVirtualMachine</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkAttachPermission();</span><br><span class="line">    <span class="built_in">this</span>.testAttachable(var1);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinuxVirtualMachine</span>(<span class="built_in">this</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">LinuxVirtualMachine(AttachProvider var1, String var2) <span class="keyword">throws</span> AttachNotSupportedException, IOException &#123;</span><br><span class="line">    <span class="built_in">super</span>(var1, var2);</span><br><span class="line">    <span class="type">int</span> var3;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var3 = Integer.parseInt(var2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException var25) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(<span class="string">&quot;Invalid process identifier&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.path = <span class="built_in">this</span>.findSocketFile(var3);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.path == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.createAttachFile(var3);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> var5;</span><br><span class="line">            <span class="keyword">if</span> (isLinuxThreads) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var5 = getLinuxThreadsManager(var3);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var24) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(var24.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> var5 &gt;= <span class="number">1</span>;</span><br><span class="line">                sendQuitToChildrenOf(var5);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendQuitTo(var3);</span><br><span class="line">            &#125;</span><br><span class="line">            var5 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">200L</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">var8</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="built_in">this</span>.attachTimeout() / var6);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(var6);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException var23) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.path = <span class="built_in">this</span>.findSocketFile(var3);</span><br><span class="line">                ++var5;</span><br><span class="line">            &#125; <span class="keyword">while</span>(var5 &lt;= var8 &amp;&amp; <span class="built_in">this</span>.path == <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.path == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AttachNotSupportedException</span>(<span class="string">&quot;Unable to open socket file: target process not responding or HotSpot VM not loaded&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            var4.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkPermissions(<span class="built_in">this</span>.path);</span><br><span class="line">    <span class="type">int</span> <span class="variable">var27</span> <span class="operator">=</span> socket();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connect(var27, <span class="built_in">this</span>.path);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        close(var27);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">findSocketFile</span><span class="params">(<span class="type">int</span> var1)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>, <span class="string">&quot;.java_pid&quot;</span> + var1);</span><br><span class="line">    <span class="keyword">return</span> !var2.exists() ? <span class="literal">null</span> : var2.getPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attachVirtualMachine 方法在不同的平台有不同的实现，上面的代码是 linux 平台下的实现。大体逻辑是，首先检查 <code>/tmp</code> 目录下是否存在 <code>java_pid&#123;pid&#125;</code> 文件。如果已经存在了，则说明 Attach 机制已经准备就绪，可以接受客户端的命令了，这个时候客户端就可以通过 connect 方法连接到目标 JVM 进行命令的发送。如果 <code>java_pid&#123;pid&#125;</code> 文件还不存在，则通过 sendQuitTo 方法向目标 JVM 发送一个 <code>SIGBREAK</code> 信号，让它初始化 Attach Listener 线程并准备接受客户端连接。可以看到，发送了信号之后客户端会循环等待 <code>java_pid&#123;pid&#125;</code> 这个文件，之后再通过 connect 连接到目标 JVM 上。</p><h2 id="instrument-实例"><a href="#instrument-实例" class="headerlink" title="instrument 实例"></a>instrument 实例</h2><p>在上面我们分析了 agent 技术的实现，在实际使用中，我们只需要编写 premain 或者 agentmain 方法，然后在其中通过 Instrument API 来完成类的动态修改即可。Instrument 接口的 addTransformer 方法可以添加一个类转换器（也就是 ClassFileTransformer 接口），该接口只有一个方法：transform，当类被加载时，虚拟机就会调用它进行类的转换。</p><p>下面我们通过 Byte Buddy 这个开源库来写一个简单的实例，这个 java agent 能够实现打印指定包中所有方法的执行耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAgent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is a java agent&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;arguments: &quot;</span> + agentArgs);</span><br><span class="line"></span><br><span class="line">        AgentBuilder.<span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> (builder, typeDescription, classLoader, javaModule) -&gt; builder</span><br><span class="line">                <span class="comment">// 拦截所有方法</span></span><br><span class="line">                .method(ElementMatchers.any())</span><br><span class="line">                <span class="comment">// 指定拦截器</span></span><br><span class="line">                .intercept(MethodDelegation.to(ExecuteTimeInterceptor.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AgentBuilder</span></span><br><span class="line">                .Default()</span><br><span class="line">                <span class="comment">// 根据包名前缀拦截类</span></span><br><span class="line">                .type(ElementMatchers.nameStartsWith(<span class="string">&quot;org.example.agent.demo&quot;</span>))</span><br><span class="line">                .transform(transformer)</span><br><span class="line">                .installOn(inst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecuteTimeInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@RuntimeType</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">intercept</span><span class="params">(<span class="meta">@Origin</span> Method method, <span class="meta">@SuperCall</span> Callable&lt;?&gt; callable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行原始方法</span></span><br><span class="line">            <span class="keyword">return</span> callable.call();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(method.getName() + <span class="string">&quot;:&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与加载时不同，运行时需要通过 redefineClasses 方法进行类的重定义，同时使用该方法不能添加、删除或者重命名字段和方法，也不能修改方法的签名或者类的继承关系。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html">Java 动态调试技术原理及实践</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;说到 Java Agent，有必要提一提 AOP，也就是面向切面编程思想。AOP 作为 OOP（面向对象编程思想）的一个补充，在技术实现上是没有规定和约束的。在 Java 中，最常见的实现方式就是 Filter 的责任链模式和 Spring AOP 的代理模式。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://blog.nekolr.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://blog.nekolr.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git 内部原理</title>
    <link href="https://blog.nekolr.com/2021/06/10/Git%20%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.nekolr.com/2021/06/10/Git%20%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-10T11:47:00.000Z</published>
    <updated>2023-04-20T09:51:11.102Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文主要用于记录博主在学习 Git 官方教程时的整个过程和一些心得体会，具体学习的章节是《Git 内部原理》。</p><span id="more"></span><h1 id="底层命令与上层命令"><a href="#底层命令与上层命令" class="headerlink" title="底层命令与上层命令"></a>底层命令与上层命令</h1><p>我们平常使用的 git 命令一般都是对用户友好的上层（porcelain）命令，然而，由于 Git 最初只是一套面向版本控制系统的工具集，所以它还包含了一部分用于完成底层工作的子命令，这部分命令一般称为底层（plumbing）命令。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>当在一个新目录或已有目录执行 <code>git init</code> 时，Git 会创建一个 <code>.git</code> 目录。 这个目录包含了几乎所有 Git 存储和操作的东西。如果想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。新初始化的 <code>.git</code> 目录的典型结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure><p>description 文件仅供 GitWeb 程序使用，我们无需关心。config 文件包含项目特有的配置选项。info 目录包含一个全局性的排除（global exclude）文件，用于放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns）。hooks 目录包含客户端或服务端的钩子脚本（hook scripts）。</p><p>剩下的四个条目很重要：HEAD 文件、（尚未创建的）index 文件，和 objects 目录、refs 目录。它们都是 Git 的核心组成部分。objects 目录存储所有的数据内容；refs 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针；HEAD 文件指向目前被检出的分支；index 文件保存暂存区信息。</p><h1 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h1><p>Git 的核心部分是一个简单的键值对数据库。我们可以向 Git 仓库中插入任意类型的内容（文本或文件），它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。底层命令 <code>git hash-object</code> 可以实现该效果：将任意数据保存到 <code>objects</code> 目录，并返回指向该数据对象的唯一的键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git init test</span><br><span class="line">Initialized empty Git repository in /tmp/test/.git/</span><br><span class="line">$ cd test</span><br><span class="line">$ find .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br></pre></td></tr></table></figure><p>可以看到，Git 对 objects 目录进行了初始化，并创建了 pack 和 info 子目录，但均为空。接着，我们用 <code>git hash-object</code> 创建一个新的数据对象并将它手动存入 Git 数据库中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;test content&#x27; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>其中，<code>-w</code> 选项指示该命令不光要返回键，还要将该对象写入数据库中。<code>--stdin</code> 选项则指示该命令从标准输入读取内容，如果不指定此选项，则须在命令尾部给出需要存储的文件的路径。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;test content&#x27; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>该命令输出的是一个长度为 40 个字符的哈希值，该校验和通过将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算得到。现在我们可以查看 Git 是如何存储数据的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>再次查看 objects 目录，可以在其中找到一个与新内容对应的文件。这就是 Git 存储内容的方式：一个文件对应一条内容，以该内容加上特定头部信息一起做 SHA-1 校验和来为文件命名。校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><p>一旦将内容存储在了对象数据库中，那么就可以通过 <code>cat-file</code> 命令从 Git 仓库取回数据（如果直接使用 cat 命令查看写入的内容，会发现全是乱码，这是因为写入的东西是经过压缩的）。指定 <code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure><p>接下来我们尝试对一个文件进行简单的版本控制。首先，创建一个新文件并将其内容存入数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;version 1&#x27; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure><p>接着，向文件里写入新内容，并再次将其存入数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;version 2&#x27; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br></pre></td></tr></table></figure><p>对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><p>接下来我们可以删除该文件，同时只需要通过 <code>cat-file</code> 传入不同的键，就可以取回该文件的第一个版本和第二个版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">version 1</span><br><span class="line">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">version 2</span><br></pre></td></tr></table></figure><p>然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存。上述类型的对象我们称之为数据对象（blob object）。利用 <code>git cat-file -t</code> 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><h2 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h2><p>Git 以一种类似于 UNIX 文件系统的方式存储内容，所有内容均以树对象和数据对象的形式存储。其中树对象对应 UNIX 中的目录，数据对象则大致对应 inodes 或文件内容。一个树对象包含一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或子树对象的 SHA-1 指针，以及相应的模式、类型和文件名信息。例如，某个项目当前对应的最新树对象可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure><blockquote><p><code>master^&#123;tree&#125;</code> 语法表示 master 分支上最新的提交所指向的树对象。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107182129/2021/07/18/Y2E.png" alt="树对象"></p><p>通常，Git 根据某一时刻暂存区（index 文件）所表示的状态创建并记录一个对应的树对象，如此重复便可以依次记录（某个时间段内）一系列的树对象。因此，为了创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。可以通过底层命令 <code>git update-index</code> 为一个单独文件（之前 test.txt 文件的首个版本）创建一个暂存区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure><p>使用该命令，可以将 test.txt 的首个版本人为地加入到一个新的暂存区，<code>--add</code> 选项表示此前该文件并不在暂存区中（我们甚至都没有创建过一个暂存区）。<code>--cacheinfo</code> 选项表示该文件位于 Git 数据库中，而不是当前目录下。同时还需要指定文件模式、SHA-1（Git 数据库对象的键）和文件名。</p><blockquote><p>Git 中的文件模式参考了 UNIX 的文件模式，但远没有那么灵活。数据对象只有三种文件模式：普通文件 100644、可执行文件 100755、符号链接 120000。还有一些其他的文件模式用于目录项和子模块。</p></blockquote><p>接下来可以通过 <code>git write-tree</code> 命令将暂存区的内容写入到一个树对象。这里不用指定 <code>-w</code> 选项，如果某个树对象此前并不存在的话，调用此命令会根据当前暂存区的状态自动创建一个新的树对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"></span><br><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</span><br><span class="line"></span><br><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p>接下来我们创建一个新的数对象，它包含 test.txt 文件的第二个版本，以及一个新的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;new file&#x27; &gt; new.txt</span><br><span class="line"></span><br><span class="line">$ git update-index --add --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line"></span><br><span class="line">$ git update-index --add new.txt</span><br></pre></td></tr></table></figure><p>暂存区现在包含了 test.txt 文件的新版本和一个新文件：new.txt。记录下这个目录树（将当前暂存区的状态记录为一个树对象）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>我们发现新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值就是之前该文件的第二个版本。我们还可以将第一个树对象加入到第二个树对象中，使其成为新树对象的一个子目录。使用 <code>git read-tree</code> 命令可以将一个树对象读入暂存区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"></span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579    bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a    test.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107252029/2021/07/25/MMg.png" alt="树对象"></p><h2 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h2><p>现在我们已经有了三个树对象，它们代表我们想要跟踪的不同项目的快照。然而我们要想重用这些快照，还是需要提供它们的 SHA-1 值，并且我们也不知道是谁保存了这些快照，在什么时候保存的，以及为什么保存这些快照。而以上这些信息，都可以通过提交对象（commit object）来保存。</p><p>可以通过 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。我们先从之前创建的第一个树对象开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;first commit&#x27; | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">444dd711ed72fa1fbc5f3004d0d2ba43adf126fb</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 444dd711ed72fa1fbc5f3004d0d2ba43adf126fb</span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author nekolr &lt;excalibll@163.com&gt; 1627202862 +0800</span><br><span class="line">committer nekolr &lt;excalibll@163.com&gt; 1627202862 +0800</span><br><span class="line"></span><br><span class="line">first commit</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>由于创建时间和作者数据不同，现在及之后的散列值都有可能不同。</p></blockquote><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照。然后是可能存在的父提交，之后是作者和提交者信息（外加时间戳），接着留空一行，最后是提交注释。</p><p>接着，我们将创建另外两个提交对象，它们分别引用各自的上一个提交作为其父提交对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;second commit&#x27; | git commit-tree 0155eb -p 444dd71</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line"></span><br><span class="line">$ echo &#x27;third commit&#x27;  | git commit-tree 3c4e9c -p 5dd3923</span><br><span class="line">1dd880144c02a460642d6d00c204a86289c23fe7</span><br></pre></td></tr></table></figure><p>现在，如果对最后一个提交的 SHA-1 值运行 git log 命令，你会发现已经有一个货真价实的、可由 git log 查看的 Git 提交历史了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat 1dd880</span><br><span class="line">commit 1dd880144c02a460642d6d00c204a86289c23fe7</span><br><span class="line">Author: nekolr &lt;excalibll@163.com&gt;</span><br><span class="line">Date:   Sun Jul 25 16:50:24 2021 +0800</span><br><span class="line"></span><br><span class="line">    third commit</span><br><span class="line"></span><br><span class="line"> bak/test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit 5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line">Author: nekolr &lt;excalibll@163.com&gt;</span><br><span class="line">Date:   Sun Jul 25 16:50:00 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line"> new.txt  | 1 +</span><br><span class="line"> test.txt | 2 +-</span><br><span class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 444dd711ed72fa1fbc5f3004d0d2ba43adf126fb</span><br><span class="line">Author: nekolr &lt;excalibll@163.com&gt;</span><br><span class="line">Date:   Sun Jul 25 16:47:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们没有借助任何上层命令，仅凭几个底层操作便完成了 Git 提交历史的创建。这就是我们在执行 <code>git add</code> 和 <code>git commit</code> 命令时，Git 所做的工作：将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。如果跟踪所有的内部指针，可以得到类似下面的对象关系图：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107252029/2021/07/25/vvp.png" alt="对象关系（原图中的 SHA-1 值与本地并不一致）"></p><h1 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h1><p>如果想查看一个提交（比如 <code>1dd880</code>）之前的历史，可以运行 <code>git log 1dd880</code> 命令，但是这样我们需要记住 <code>1dd880</code> 是我们查看历史的起点提交。如果我们能有一个文件来保存这个 SHA-1 值，同时该文件又有一个简单的名字，使用这个名字指针替代原始的 SHA-1 值会使查看日志变得更加简单。</p><p>在 Git 中，这个简单的名字被称为引用（references，简写为 refs），可以在 <code>.git/refs</code> 目录下找到它们。在当前的项目中，这个目录下并没有任何文件，但它包含了一个简单的目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br></pre></td></tr></table></figure><p>如果要创建一个新的引用来帮助记录最新提交所在的位置，从原理上讲，只需要执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo 1dd880144c02a460642d6d00c204a86289c23fe7 &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure><p>接下来就可以使用这个刚创建的新引用来替代 SHA-1 值查看 log 记录了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline master</span><br><span class="line">1dd880144c02a460642d6d00c204a86289c23fe7 (HEAD -&gt; master) third commit</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b second commit</span><br><span class="line">444dd711ed72fa1fbc5f3004d0d2ba43adf126fb first commit</span><br></pre></td></tr></table></figure><p>不过 Git 并不提倡直接编辑引用文件，如果想更新某个引用，Git 提供了一个更加安全的命令 <code>update-ref</code> 来完成这项工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/master 1dd880144c02a460642d6d00c204a86289c23fe7</span><br></pre></td></tr></table></figure><p>这基本上就是 Git 分支的本质：<strong>一个指向某一系列提交之首的指针或引用</strong>。当运行类似于 <code>git branch &lt;branch_name&gt;</code> 这样的命令时，Git 实际上执行的是 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值。如果想在第二个提交上创建一个新分支，可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/test 5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line"></span><br><span class="line">$ git log --pretty=oneline test</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b (test) second commit</span><br><span class="line">444dd711ed72fa1fbc5f3004d0d2ba43adf126fb first commit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202107312345/2021/07/31/RxK.png" alt="引用（原图中的 SHA-1 值与本地并不一致）"></p><h2 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h2><p>那么 Git 在执行 <code>git branch &lt;branch_name&gt;</code> 时，又是如何得知当前分支最新提交的 SHA-1 值的呢？答案是 HEAD 文件。HEAD 文件通常是一个符号引用（symbolic reference），它是一个指向其他引用的指针，指向当前所在的分支。在你检出一个标签、提交或远程分支时，HEAD 文件可能会包含一个 git 对象的 SHA-1 值，这是因为此时仓库处于<strong>分离 HEAD</strong>状态。</p><p>直接查看 HEAD 文件内容，通常是：<code>ref: refs/heads/master</code>，如果执行 <code>git checkout test</code>，Git 会更新这个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br><span class="line"></span><br><span class="line">$ git checkout test</span><br><span class="line">$ cat .git/HEAD</span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure><p>当我们执行 <code>git commit</code> 时，该命令会创建一个提交对象，并用 HEAD 文件中的那个引用所指向的 SHA-1 值设置其父提交字段。我们可以手动编辑该文件，当然 Git 同样提供了一个更安全的命令 <code>git symbolic-ref</code> 来完成这件事。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看 HEAD 引用的值</span><br><span class="line">$ git symbolic-ref HEAD</span><br><span class="line"></span><br><span class="line"># 设置 HEAD 引用的值</span><br><span class="line">$ git symbolic-ref HEAD refs/heads/test</span><br></pre></td></tr></table></figure><h2 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h2><p>Git 中除了数据对象、树对象和提交对象，实际上还有一种对象：标签对象（tag object），它非常类似于提交对象，包含一个标签创建者信息，一个日期，一段注释，以及一个指针。标签对象与提交对象的主要区别在于，标签对象的指针指向的通常是一个提交对象，而不是一个树对象。它就像一个永不移动的分支引用，永远指向同一个提交对象，只不过是给这个提交对象指定了一个更加友好的名字罢了。</p><p>Git 中存在两种类型的标签：附注标签和轻量标签。轻量标签可以直接通过指定一个固定的引用，也就是提交对象来创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/tags/v1.0</span><br><span class="line">5dd39238bee9e686bd8436140c5e07776c5bc73b</span><br></pre></td></tr></table></figure><p>而若要创建一个附注标签，Git 会创建一个标签对象，然后记录一个引用来指向该标签对象。也就是说：标签引用中存储的并不是某个提交对象，而是一个指向该标签对象的引用。我们可以通过创建一个附注标签来验证这一过程（使用 <code>-a</code> 选项）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 1dd880144c02a460642d6d00c204a86289c23fe7 -m &#x27;test tag&#x27;</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/tags/v1.1</span><br><span class="line">3a62c1d03f5e77c307ed4a9176e3dce46369f01e</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 3a62c1d03f5e77c307ed4a9176e3dce46369f01e</span><br><span class="line">object 1dd880144c02a460642d6d00c204a86289c23fe7</span><br><span class="line">type commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger nekolr &lt;excalibll@163.com&gt; 1627745037 +0800</span><br><span class="line"></span><br><span class="line">test tag</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要注意的是，标签对象并非必须指向某个提交对象，我们可以对任意类型的 Git 对象打标签。例如，在 Git 源码中，项目维护者将他们的 GPG 公钥添加为一个数据对象，然后对这个对象打了一个标签。可以克隆一个 Git 版本库，然后通过执行下面的命令在这个版本库中查看上述公钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file blob junio-gpg-pub</span><br></pre></td></tr></table></figure><h2 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h2><p>如果我们添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs&#x2F;remotes 目录下。例如，你可以添加一个叫做 origin 的远程版本库，然后把 master 分支推送上去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:nekolr/simplegit-progit.git</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>此时查看 <code>refs/remotes/origin/master</code> 文件，可以发现 origin 远程版本库的 master 分支所对应的 SHA-1 值，就是最近一次与服务器通信时本地 master 分支所对应的 SHA-1 值。</p><p>远程引用和分支（位于 refs&#x2F;heads 目录下的引用）之间最主要的区别在于：远程引用是只读的。虽然可以 <code>git checkout</code> 某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。因此，你永远不能通过 commit 命令来更新远程引用。Git 将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇博文主要用于记录博主在学习 Git 官方教程时的整个过程和一些心得体会，具体学习的章节是《Git 内部原理》。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://blog.nekolr.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.nekolr.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>CAS 初探</title>
    <link href="https://blog.nekolr.com/2021/03/29/CAS%20%E5%88%9D%E6%8E%A2/"/>
    <id>https://blog.nekolr.com/2021/03/29/CAS%20%E5%88%9D%E6%8E%A2/</id>
    <published>2021-03-29T16:34:00.000Z</published>
    <updated>2023-04-20T09:51:11.102Z</updated>
    
    <content type="html"><![CDATA[<p>CAS（中央身份认证服务，Central Authentication Service）是由耶鲁大学发起的一个企业级开源项目，目的是帮助 Web 应用系统构建一种可靠的单点登录解决方案。</p><span id="more"></span><h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><p>CAS 主要包含两大组件：CAS Server 和 CAS Client，它们之间可以通过各种协议进行通信。在使用 CAS 之前，除了 CAS Server 和 CAS Client，还需要了解 TGT、TGC 以及 ST。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104011547/2021/03/31/qNO.png" alt="CAS 的架构"></p><h2 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h2><p>CAS Server 的主要职责就是通过签发和验证 Ticket 来认证用户并授予其对 CAS Client 的访问权限。当用户成功登录后，CAS Server 会给用户签发一个 Ticket，同时还会创建一个 SSO 会话（该 Ticket 在这里被称为 TGT，TGT 会以 Cookie 的形式保存在浏览器中）。当用户访问某个服务时，CAS Server 会根据用户提供的 TGT 来签发一个 Ticket 作为令牌（该 Ticket 在这里被称为 ST），并通过浏览器重定向的形式返回。此时，该服务会拿着重定向 URL 中携带的 Ticket，向 CAS Server 验证有效性，以判断是否放行。</p><p>CAS Server 是通过 Spring Framework 搭建的一个 Java Servlet 应用，在较新的版本中，则使用了 Spring Boot 框架，因此可以直接使用内置容器。CAS Server 一般都是独立部署的。可以通过<a href="https://github.com/apereo/cas-overlay-template">该项目</a>快速部署一个 CAS Server。</p><h2 id="CAS-Client"><a href="#CAS-Client" class="headerlink" title="CAS Client"></a>CAS Client</h2><p>CAS Client 的主要职责就是保护 CAS 应用（可以理解为各种应用和服务，只不过它们都通过各种方式包装成了 CAS Client），并通过各种协议与 CAS Server 通信，以验证用户是否具有访问权限。</p><p>CAS Client 支持的软件平台和产品有很多，比如 Java、.NET、PHP 等等，不过与 Java 平台相比，其他平台的活跃性一般。</p><h2 id="TGT"><a href="#TGT" class="headerlink" title="TGT"></a>TGT</h2><p>TGT 全称为 Ticket-Granting Ticket，当用户登录成功后，用户的基本信息，登录有效期等信息都存储在这里。我们可以先简单地把用户登录后 CAS Server 为用户创建的 SSO 会话理解为我们之前使用的 HttpSession。在以前，我们的 Session 中会保存用户的一些信息，比如用户名。TGT 就是这些信息的一个封装。</p><h2 id="TGC"><a href="#TGC" class="headerlink" title="TGC"></a>TGC</h2><p>TGC 全称为 Ticket-Granting Cookie，TGT 会以 Cookie 的形式保存在浏览器中，用来维持与用户的会话。</p><h2 id="ST"><a href="#ST" class="headerlink" title="ST"></a>ST</h2><p>ST 全称为 Service Ticket，它是 CAS Sever 通过 TGT 给用户发放的一张 Ticket，用户在访问其他服务时，如果发现没有 Cookie 或者 ST ，那么就会 302 到 CAS Server 去获取 ST，然后再携带着 ST 回来，接着 CAS Client 会通过 ST 去 CAS Server 上获取用户的登录状态。</p><h1 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h1><p>下面通过官方给出的流程图来看下 CAS 单点登录的一般流程是怎样的。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104011547/2021/03/31/4w6.png" alt="CAS 登录授权的一般过程"></p><p>首先用户通过浏览器访问受保护的 APP1，APP1 发现用户没有登录，所以返回 302，让用户到 CAS Server 的地址去登录，同时地址中还会包含一个 service 参数，对应的是 APP1 的地址。</p><p>接着浏览器会自动重定向到 CAS Server 的地址，由于用户没有与 CAS Server 建立 SSO 会话，所以用户需要登录。当用户登录成功后，CAS Server 会要求浏览器设置 TGC 并返回 302，让用户访问之前 service 参数指定的地址，同时地址中还会包含一个 ticket 参数，对应的就是 ST。</p><p>接着浏览器自动重定向到 APP1 的地址，并带有 ticket 参数。APP1 检测到 ticket 参数，会带着该参数去 CAS Server 验证 ticket 的有效性，验证成功后，APP1 会要求浏览器设置 session cookie 并返回 302，让用户重定向到 APP1 的地址（该地址不带 ticket 参数，目的是让浏览器地址栏隐藏 ST）。此时浏览器自动重定向，并带着 session cookie 访问 APP1，APP1 只需要验证 session cookie 即可确认是否放行。如果用户再次访问 APP1，只要 APP1 的 session cookie 还在，用户就可以一直访问 APP1。</p><p>当用户通过浏览器访问 APP2 时，同样 APP2 会返回 302，让用户到 CAS Server 去登录，地址中还会包含一个 service 参数，对应的是 APP2 的地址。由于用户的浏览器中带有 CAS Server 的 cookie（TGC），所以 CAS Server 会验证 TGT 的有效性，验证成功后会返回 302，让用户访问之前 service 参数指定的地址，同时地址中会包含一个 ticket 参数，对应的是 ST。接下来重复上述步骤，用户不需要再次登录就可以访问 APP2。</p><h1 id="CAS-Server-部署"><a href="#CAS-Server-部署" class="headerlink" title="CAS Server 部署"></a>CAS Server 部署</h1><p>CAS Server 一般不需要从头编写并部署，使用官方提供的一个起始项目 <a href="https://github.com/apereo/cas-overlay-template">cas-overlay-template</a>，通过少量的代码修改就可以快速部署。</p><blockquote><p>在写这篇文章时，CAS 的最新稳定版为 v6.3.3，它要求 JDK 的版本为 JDK 11，由于 Oracle JDK 协议的修改，我们最好安装一个 OpenJDK 11。</p></blockquote><p>首先将项目克隆下来，需要注意的是，该项目通过 Gradle 来构建，由于众所周知的原因，首先修改 <code>build.gradle</code> 配置文件中的 maven 地址为阿里云的镜像仓库地址 <code>maven &#123; url &quot;http://maven.aliyun.com/nexus/content/groups/public/&quot; &#125;</code>。</p><p>接着我们需要通过 <code>./gradlew.bat clean build</code> 命令来清理并构建项目，第一次构建的时候比较慢。在构建完成后，会在项目中生成一个 build 目录，其中 libs 目录下的 cas.war 就是整个 CAS Server 的部署文件。接着我们使用 <code>./gradlew.bat explodeWar</code> 命令可以将该 war 文件解压，解压后的文件位于 build 目录下的 cas-resources 目录，此时我们需要在 src&#x2F;main 目录下新建一个 resources 目录，并将 cas-resources 目录下的文件复制到该目录下。</p><p>CAS Server 从版本 4 开始，要求使用 HTTPS 进行通信，所以我们得提前准备 HTTPS 证书。如果是公司里的项目，可能需要购买 HTTPS 证书，自己玩的话可以申请一个免费的 HTTPS 证书，或者使用 <a href="https://github.com/FiloSottile/mkcert">mkcert</a> 来生成一个本地的 HTTPS 证书。</p><blockquote><p>在本地开发中，我们经常需要模拟 HTTPS 环境，比如 PWA 应用就要求必须使用 https 访问。在传统的解决方案中，我们需要使用自签证书，然后在 http server 中使用自签证书。由于自签证书浏览器不信任，所以我们需要将自签证书使用的 CA 证书添加到系统或浏览器的可信 CA 证书中来规避这个问题。以前完成这些操作需要执行一系列繁琐的 openssl 命令，现在可以直接使用 mkcert 这个工具来简化这一过程，生成本地的 https 证书，并且信任自签 CA。</p></blockquote><p>这里为了方便，我们就使用 mkcert 来生成一个本地的 HTTPS 证书。首先执行 <code>mkcert -install</code> 命令将 CA 证书添加到本地可信 CA 中，以后由该 CA 签发的证书在本地都是可信的。</p><p>接着使用 <code>mkcert -pkcs12 -p12-file filepath\localhost.p12 localhost 127.0.0.1</code> 命令生成一个 PKCS#12 文件格式的 HTTPS 证书（一般 PKCS#12 证书都需要一个加密口令，这里生成的默认口令是 changeit）。</p><p>最后我们需要通过 keytool 工具将该证书转换成 Java 特有的证书格式（KeyStore），以便 Tomcat 等容器识别。使用 <code>keytool -importkeystore -srckeystore &#39;filepath\localhost.p12&#39; -destkeystore &#39;filepath\localhost.keystore&#39;</code> 进行转换，转换过程中需要输入密码（changeit）。</p><p>我们将 keytool 转换后的证书文件放到 <code>src/main/resources</code> 目录下，然后修改 application.properties 文件内容：<code>server.ssl.key-store=classpath:localhost.keystore</code> 即可。</p><p>接下来我们可以使用 <code>./gradlew.bat run</code> 命令运行项目，也可以通过 <code>./gradlew.bat clean build</code> 命令构建新的 war 包后使用 <code>java -jar cas.war</code> 命令直接运行 war 包，然后通过地址：<code>https://localhost:8443/cas/login</code> 访问。</p><p>在不修改配置文件的情况下，默认的登录用户名和密码分别为：casuser 和 Mellon，这是通过 application.properties 文件配置的：<code>cas.authn.accept.users=casuser::Mellon</code>。一般后续会修改为通过数据库查询的方式验证，此时会注释掉该部分代码，并添加类似下面的代码：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># CAS Authentication Credentials</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">cas.authn.accept.enabled</span>=<span class="literal">false</span></span><br><span class="line"><span class="comment">#cas.authn.accept.users=casuser::Mellon</span></span><br><span class="line"><span class="comment">#cas.authn.accept.name=Static Credentials</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Common properties</span></span><br><span class="line"><span class="comment"># more info: https://apereo.github.io/cas/6.3.x/configuration/Configuration-Properties-Common.html#database-settings</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">user</span>=root</span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">password</span>=root</span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">driver-class</span>=com.mysql.jdbc.Driver</span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">url</span>=jdbc:mysql://localhost:<span class="number">3306</span>/cas?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-<span class="number">8</span>&amp;useSSL=<span class="literal">false</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">dialect</span>=org.hibernate.dialect.MySQL57Dialect</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Password Encoding</span></span><br><span class="line"><span class="comment"># more info: https://apereo.github.io/cas/6.3.x/configuration/Configuration-Properties-Common.html#password-encoding</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @See PasswordEncoderProperties</span></span><br><span class="line"><span class="comment"># 使用 Bcrypt 算法，Spring Security&#x27;s BCryptPasswordEncoder</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">password-encoder.type</span>=BCRYPT</span><br><span class="line"><span class="comment"># The encoding algorithm to use such as &#x27;UTF-8&#x27;. Relevant when the type used is &#x27;DEFAULT&#x27;</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].password-encoder.character-encoding=UTF-8</span></span><br><span class="line"><span class="comment"># The encoding algorithm to use such as &#x27;MD5&#x27;. Relevant when the type used is &#x27;DEFAULT&#x27; or &#x27;GLIBC_CRYPT&#x27;.</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].password-encoder.encoding-algorithm=MD5</span></span><br><span class="line"><span class="comment"># Secret to use with STANDARD, PBKDF2, BCRYPT, GLIBC_CRYPT password encoders. Secret usually is an optional setting.</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].password-encoder.secret=</span></span><br><span class="line"><span class="comment"># 表示 hash 杂凑次数，可选值为 4 到 31，数值越高越安全，默认 10 次</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">password-encoder.strength</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># Query Database Authentication</span></span><br><span class="line"><span class="comment"># more info: https://apereo.github.io/cas/6.3.x/configuration/Configuration-Properties.html#query-database-authentication</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @See BaseJdbcAuthenticationProperties</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].credential-criteria=</span></span><br><span class="line"><span class="comment"># Name of the authentication handler</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].name=</span></span><br><span class="line"><span class="comment"># Order of the authentication handler in the chain</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].order=</span></span><br><span class="line"><span class="comment"># 用户登录时的查询语句</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">sql</span>=SELECT * FROM user WHERE username=?</span><br><span class="line"><span class="comment"># 匹配的密码属性列</span></span><br><span class="line">cas.authn.jdbc.query<span class="section">[0]</span>.<span class="attr">field-password</span>=password</span><br><span class="line"><span class="comment"># 指定过期字段，tinyint(1) 类型，字段值为 1 表示过期，过期账号需要修改密码；值为 0 表示没有过期</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].field-expired=expired</span></span><br><span class="line"><span class="comment"># 指定禁用字段，tinyint(1) 类型，字段值为 1 表示禁用；值为 0 表示没有正常</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].field-disabled=disabled</span></span><br><span class="line"><span class="comment"># List of column names to fetch as user attributes</span></span><br><span class="line"><span class="comment">#cas.authn.jdbc.query[0].principal-attribute-list=uid,cn:commonName,age,id_card_num:idcardnum</span></span><br></pre></td></tr></table></figure><p>由于开启 Database Authentication 需要依赖 <code>cas-server-support-jdbc</code> 库，因此修改 build.gradle 文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Add modules in format compatible with overlay casModules property</span></span><br><span class="line">    <span class="keyword">if</span> (project.hasProperty(<span class="string">&quot;casModules&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">def</span> dependencies = project.getProperty(<span class="string">&quot;casModules&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        dependencies.each &#123;</span><br><span class="line">            <span class="keyword">def</span> projectsToAdd = rootProject.subprojects.findAll &#123;project -&gt;</span><br><span class="line">                project.name == <span class="string">&quot;cas-server-core-$&#123;it&#125;&quot;</span> || project.name == <span class="string">&quot;cas-server-support-$&#123;it&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            projectsToAdd.each &#123;implementation it&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS dependencies/modules may be listed here statically...</span></span><br><span class="line">    implementation <span class="string">&quot;org.apereo.cas:cas-server-webapp-init:$&#123;casServerVersion&#125;&quot;</span></span><br><span class="line">    <span class="comment">// 由于该库依赖的 MySQL 驱动版本过高，所以需要排除掉后自行设置</span></span><br><span class="line">    implementation (<span class="string">&quot;org.apereo.cas:cas-server-support-jdbc:$&#123;casServerVersion&#125;&quot;</span>) &#123;</span><br><span class="line">        exclude <span class="attr">group:</span> <span class="string">&quot;mysql&quot;</span>, <span class="attr">module:</span> <span class="string">&quot;mysql-connector-java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    implementation <span class="string">&quot;mysql:mysql-connector-java:5.1.49&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;CAS（中央身份认证服务，Central Authentication Service）是由耶鲁大学发起的一个企业级开源项目，目的是帮助 Web 应用系统构建一种可靠的单点登录解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="安全" scheme="https://blog.nekolr.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="CAS" scheme="https://blog.nekolr.com/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议的发展概述</title>
    <link href="https://blog.nekolr.com/2021/02/24/HTTP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%91%E5%B1%95%E6%A6%82%E8%BF%B0/"/>
    <id>https://blog.nekolr.com/2021/02/24/HTTP%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%91%E5%B1%95%E6%A6%82%E8%BF%B0/</id>
    <published>2021-02-24T10:24:00.000Z</published>
    <updated>2023-04-20T09:51:11.102Z</updated>
    
    <content type="html"><![CDATA[<p>1969 年诞生于美国的因特网（Internet），现如今已经发展为覆盖五大洲 150 多个国家和地区的开放型全球计算机网络系统，我们普通用户只需要一根网线，一个调制解调器与因特网服务提供商相连，便可以进入其中。当然，因特网并不是全球唯一的互联网络，比如在欧洲就存在欧盟网（Euronet），在美国也还有国际学术网（BITNET）等。一般来说，我们会将因特网看作是互联网（internet），但是严格来说互联网泛指由多个计算机网络互相连接而组成的一个大型网络，因此因特网只是互联网的一种。</p><span id="more"></span><p>万维网（World Wide Web）作为因特网最主要的组成部分，由无数个网络站点和网页组成，而负责传输这些超文本信息的就是 HTTP 协议（HyperText Transfer Protocol）。HTTP 协议建立在 TCP&#x2F;IP 协议簇之上，从早期的单行协议，到如今的 QUIC，总体上看还是保持着一些基本的特征。</p><p>首先 HTTP 是简单的，虽然 HTTP&#x2F;2 协议将 HTTP 消息封装到了帧（frames）中，但是 HTTP 从大体上看还是简单易读的。HTTP 是可扩展的，在 HTTP&#x2F;1.0 协议中添加的 HTTP headers 让协议的扩展变得非常容易，只需要服务端与客户端就新 header 的语义达成一致，新功能就可以很轻松的添加进来。HTTP 是无状态的，这意味着请求之间是没有关系的，这就带来一个问题，即用户无法在一个网站中进行连续的交互，所幸我们可以通过 HTTP 的头部扩展，也就是 HTTP Cookies 来解决这个问题。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103022303/2021/03/02/r7m.png" alt="HTTP 的发展"></p><h1 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h1><p>最初的 HTTP 协议并没有版本号，后来它的版本号被定为 0.9 是为了区分在它之后的版本，即 HTTP&#x2F;1.0。HTTP&#x2F;0.9 极其简单，请求由单行指令构成，只能使用 GET 方法，后面跟着目标资源的路径，比如：<code>GET /index.html</code>，响应则只包含文档本身。由于没有头部信息，所以无法传输其他类型的文件。在此协议中，连接会在单个请求和响应完成之后关闭。关于 HTTP&#x2F;0.9 的详细信息，可以查看<a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html">这份文档</a>。</p><h1 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h1><p>在 20 世纪 90 年代初的互联网热潮中，不断增长的 Web 需求很快就暴露了 HTTP&#x2F;0.9 的种种缺陷，于是浏览器和服务器纷纷扩展内容使其用途更广。在 1991 年到 1995 年，这些新的扩展并没有被引入到标准中以促进协议的完善，而是仅仅作为一些尝试，在这之中，也出现了一些最佳实践和常见模式。直到 1996 年 5 月，网络工作组（Network Working Group）才发布了 <a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a>，也就是 HTTP&#x2F;1.0 协议的规范。它记录了许多已经被广泛使用的 HTTP&#x2F;1.0 的“常见用法”，由于这只是一个偏向信息性质的 RFC，因此不能算作是一个正式的规范或 Internet 标准。</p><p>在 HTTP&#x2F;1.0 中，请求和响应的消息格式得到了规范。一个完整的请求消息包含请求行（Request Line）、请求头、空行（CRLF）和请求实体（Entity Body）四个部分，请求行新增了 HTTP 版本号，同时请求方法也扩展出了 HEAD 和 POST。一个完整的响应消息则包含状态行（Status Line）、响应头、空行和响应实体（Entity Body）四个部分。HTTP Header 的引入让协议变得非常灵活，得益于 Content-Type 头的出现，新的 HTTP 协议具备了能够传输除纯文本 HTTP 文件以外其他类型文件的能力。新增的响应状态码会在响应开始时发送，使浏览器能够了解请求执行的情况，并作出相应的调整行为。</p><p>需要注意的是，在 HTTP&#x2F;1.0 中，连接默认是不持久的，这就意味着每次请求都需要开启一个新的连接，而开启连接是一个很耗时的操作，同时连接过多也会造成大量的资源消耗，因此一般浏览器都会有针对每个服务端的最大连接数限制。下表是各个浏览器的单个 host 的最大连接数限制，数据来源于 <a href="https://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/">Roundup on Parallel Connections</a> 这篇文章。</p><table><thead><tr><th>Browser</th><th>HTTP&#x2F;1.1</th><th>HTTP&#x2F;1.0</th></tr></thead><tbody><tr><td>IE 6,7</td><td>2</td><td>4</td></tr><tr><td>IE 8</td><td>6</td><td>6</td></tr><tr><td>Firefox 2</td><td>2</td><td>8</td></tr><tr><td>Firefox 3</td><td>6</td><td>6</td></tr><tr><td>Safari 3,4</td><td>4</td><td>4</td></tr><tr><td>Chrome 1,2</td><td>6</td><td>?</td></tr><tr><td>Chrome 3</td><td>4</td><td>4</td></tr></tbody></table><blockquote><p>虽然 HTTP&#x2F;1.0 中没有关于 keepalive 操作的正式规范，但是有一些客户端和服务端已经实现了该功能。在这些实现中，请求或响应的头部中可以使用 <code>Connection: keep-alive</code>，表示连接不会在请求和响应结束后立即断开，而是保持连接。一般情况下，此时还会带有一个类似 <code>Keep-Alive: timeout=5, max=100</code> 的头部信息，用来描述连接保持的时间和最多支持的请求数。</p></blockquote><h1 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h1><p>HTTP&#x2F;1.0 的多种不同的实现方式在实际运用中显得有些混乱，所以在 1997 年初，HTTP 的第一个标准化版本 <a href="https://tools.ietf.org/html/rfc2068">RFC 2068</a>，也就是针对 HTTP&#x2F;1.0 规范的修订版 HTTP&#x2F;1.1 标准正式发布。1999 年 6 月，HTTP&#x2F;1.1 的第一个修订版 <a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 发布。2014 年 6 月，IETF 废弃了 RFC 2616 并将它拆分到了六个单独的协议中，同时重点对原来语义模糊的部分进行了解释。</p><p>HTTP&#x2F;1.1 消除了大量具有歧义的内容，并引入了多项改进，比如默认使用连接复用，支持管线化技术（Pipelining），支持响应分块传输，增加了额外的缓存控制机制，内容协商机制等等。</p><h2 id="连接复用"><a href="#连接复用" class="headerlink" title="连接复用"></a>连接复用</h2><p>HTTP&#x2F;1.1 默认使用持久化连接机制，因此多个请求和响应可以共用一个 TCP 连接，这样可以明显减少请求延迟，因为在发送第一个请求之后，客户端不再需要重新与服务端进行 TCP 的三次握手来建立连接。</p><p>连接复用的好处有很多，但是随之而来的一个问题就是：客户端在请求得到响应后，又该如何得知服务端响应的数据已经全部传输完毕了呢？在没有使用连接复用的时候，服务端在发送完所有的响应内容之后就会关闭连接，客户端读取数据时就会返回 EOF（-1），这样就能够得知数据已经全部接收完毕了；而使用了连接复用后，当客户端发送第一个请求时就与服务端建立了连接，这个连接会在一段时间内保持，此时客户端无法得知响应的数据是否已经全部传输完毕，比如客户端可能会在接收到部分数据后，短时间内一直没有再次收到响应的数据，但是我们无法确定是不是由于网络延迟等原因导致响应没有及时到达。</p><p>为了解决这个问题，可以使用 <code>Content-Length</code> 头，用来指明 Entity Body 的大小。这个标志在 GET 请求中不能使用，在 POST 请求中需要使用，同时也经常出现在响应头中。比如，当响应头中带有 <code>Content-Length: 700</code>，则表示该响应体的内容共有 700 字节，浏览器在接收到 700 个字节的响应体数据之后就知道响应已经完成了。</p><h2 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h2><p>有时响应体的大小并不容易确定，比如由动态语言生成的响应体，此时就需要用到 <code>Transfer-Encoding: chunked</code> 消息头，它表示响应体的内容会采用分块传输。如果一个 HTTP 消息的头信息包含该字段和值，那么之后的消息体则会由数量未定的块组成，每一个非空的块都以该块所包含的数据长度（十六进制的字节数）开始，跟随一个 CRLF，之后是数据本身，最后以 CRLF 结尾。最后一个块则不包含任何数据，由块大小为 0，一些可选的填充空白格以及 CRLF 结尾，代表分块内容结束。如果还有额外的数据，可以在结束之后，使用 Trailer 进行拖挂传输额外的数据。</p><h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p>默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到响应之后才会被发出，由于受到网络延迟和带宽的限制，在下一个请求被发送之前，可能需要等待很长一段时间。管线化（Pipelining）的出现使得客户端在同一条连接上可以发送多个连续的请求，而不用等待响应返回，但是服务端需要按照客户端发送请求的顺序来返回响应。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103022303/2021/03/02/LKm.png" alt="管线化"></p><p>管线化实际上是将多个 HTTP 请求同时输出到一个连接中（更确切的说是输出到一个 TCP 连接中，或者说是放到一个 TCP 分组中），然后等待响应。这在浏览器需要大批量提交请求时可以大幅度缩短页面的加载时间，特别是在传输延迟较高的情况下（比如使用卫星网络）会更加明显。</p><p>使用管线化的请求方法需要是幂等的，非幂等的方法，例如 POST 将不会被管线化。连续的 GET 和 HEAD 请求总是可以管线化的，其他的幂等方法，如 PUT 和 DELETE 是否可以被管线化取决于一连串请求是否依赖于其他请求的响应。在初次创建连接时，不应启动管线化机制，因为对方（服务器或代理服务器）不一定支持该机制。支持管线化的服务端并不一定需要提供管线化的回复，只要求在收到管线化请求时不会失败即可。</p><p>管线化看起来很美好，然而很多现代的浏览器都没有进行支持或者默认关闭了该功能（在目前 HTTP&#x2F;2 的大背景下，浏览器大都选择了支持多路复用）。导致这一现象的原因主要有：很多 HTTP 代理服务器可能不支持或者不通过管线化传输请求。正确的实现管线化是复杂的，传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，管线化带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局，因此 HTTP 管线化在大多数情况下带来的改善并不明显。最后一个关键性的原因就是管线化会导致队首阻塞（Head-of-line blocking, HOL）。</p><p>从本质上讲，发生 HOL 的根本原因是由于 HTTP 请求和响应使用的是 FIFO 的队列机制，因此不管是 HTTP&#x2F;1.0 还是 HTTP&#x2F;1.1，都会发生 HOL。在 HTTP&#x2F;1.1 中，我们假设客户端在一个连接上发送了几个连续的请求，按照规定，服务端应该按照收到请求的顺序返回结果，如果服务端在处理某个请求时花费了大量的时间，那么后面所有的请求都需要等待这个请求处理结束后才能进行。为了避免或者减少该问题，一般常见的处理方式有两种：一种是减少请求数量，这间接地催生出了很多网页设计的技巧，比如合并脚本和样式表，使用精灵图，以及将图片嵌入样式（将图片转换成 Base64 编码的形式）等等。另一种是同时打开多个持久连接，也就是所谓的域名分片。假设网站域名为 <code>www.example.com</code>，我们可以将它拆分成好几个域名，比如： <code>www1.example.com</code>、<code>www2.example.com</code> 等等，所有的域名都指向同一台服务器，这样浏览器访问网站时就可以同时开启多个 TCP 连接了。当然，这些都是无奈之举，如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。</p><h1 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h1><p>说起 HTTP&#x2F;2，就不得不提 SPDY。它是 Google 开发的一个基于 TCP 传输控制协议的应用层协议，也是 HTTP&#x2F;2 的前身。Google 最早是在 Chromium 中提出的 SPDY 协议，并于 2009 年 11 月发布了 SPDY 协议的第一份草案。</p><p>SPDY 设计之初就是为了解决 HTTP&#x2F;1.1 效率不高的问题。如果以提高效率为目的，那么不光应用层的 HTTP 协议，甚至传输层的 TCP 协议都有调整的空间，但是由于 TCP 作为更底层的协议已经存在了长达几十年之久，其实现已根植于全球网络的基础设施当中，可谓是牵一发而动全身，业界响应的积极性必然不高，所以 SPDY 一开始瞄准的就是 HTTP。</p><p>为了兼容现有的协议，减少甚至避免服务端升级带来的改动，SPDY 只是修改了 HTTP 请求和响应在网络上传输的方式，这就意味着只需在 HTTP 之下，TCP 和 SSL 之上增加一个 SPDY 传输层，这样就可以轻松兼容老版本的 HTTP 协议（将 HTTP&#x2F;1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能，现有的服务端应用几乎不用做任何修改。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/KKA.png" alt="SPDY"></p><p>2015 年 5 月，作为 HTTP 协议的第二个主要版本，HTTP&#x2F;2 标准的 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 规范发布，SPDY 协议最终只成为了一个<a href="https://tools.ietf.org/html/draft-mbelshe-httpbis-spdy-00">互联网草案</a>，但是 SPDY 开发组的成员全程参与了 HTTP&#x2F;2 的制定，HTTP&#x2F;2 的很多关键功能都来自于 SPDY，也就是说，SPDY 的成果被采纳并最终演变成了 HTTP&#x2F;2。</p><h2 id="消息帧"><a href="#消息帧" class="headerlink" title="消息帧"></a>消息帧</h2><p>HTTP&#x2F;2 与 HTTP&#x2F;1.1 相比，其中一个最大的变化就是：HTTP&#x2F;2 变成了一个二进制协议，消息头和消息体都被封装为更小的采用二进制编码的帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>在 HTTP&#x2F;1.x 中，报文不是基于帧的，而是以文本分隔的，比如这样一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1 &lt;crlf&gt;</span><br><span class="line">Host: www.example.com &lt;crlf&gt; </span><br><span class="line">Connection: keep-alive &lt;crlf&gt; </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9... &lt;crlf&gt; </span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4)... &lt;crlf&gt; </span><br><span class="line">Accept-Encoding: gzip, deflate, sdch &lt;crlf&gt; </span><br><span class="line">Accept-Language: en-US,en;q=0.8 &lt;crlf&gt; </span><br><span class="line">Cookie: pfy_cbc_lb=p-browse-w; customerZipCode=99912|N; ltc=%20;...&lt;crlf&gt; </span><br><span class="line">&lt;crlf&gt;</span><br></pre></td></tr></table></figure><p>解析这种数据只需不断读入字节，直到遇到分隔符为止。由于一次只能处理一个请求或响应，并且解析在完成之前不能停止，所以往往速度慢且容易出错，同时也无法预测解析需要多少内存。这就带来了一系列的问题：该把一行读到多大的缓冲区里？如果行太长会发生什么，是应该增加并重新分配内存，还是返回 400 错误？</p><p>比较 HTTP&#x2F;1.x，你会发现 HTTP&#x2F;2 的帧格式定义更接近 TCP 层的方式。其中 length 是帧载荷的大小，type 是当前帧的类型（一共 10 种），flags 是具体帧类型的标识，stream id 作为每个流的唯一 ID，用于流控制，payload 是消息的正文，长度在 length 中设定。因为规范严格且明确，所以解析的逻辑可以像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loop </span><br><span class="line"> Read 9 bytes off the wire // 读前 9 字节</span><br><span class="line"> Length = the first three bytes // 长度值为前 3 字节 </span><br><span class="line"> Read the payload based on the length. // 基于长度读载荷</span><br><span class="line"> Take the appropriate action based on the frame type. // 根据帧类型采取对应操作</span><br><span class="line">end loop</span><br></pre></td></tr></table></figure><p>这样一来，实现和维护都会简单很多。虽然看上去协议的格式完全不同了，但是实际上 HTTP&#x2F;2 并没有改变 HTTP&#x2F;1.x 的语义，只是把原来 HTTP&#x2F;1.x 的 header 和 body 部分用 frame 重新封装了一层而已。调试的时候浏览器甚至会把 HTTP&#x2F;2 的 frame 自动还原成 HTTP&#x2F;1.x 的格式。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/gkw.png" alt="帧"></p><p>值得一提的是，HTTP&#x2F;2 将 HTTP&#x2F;1.x 中的请求行变成了魔法伪首部，即所谓的<strong>一切都是 Header</strong>。举个例子，HTTP&#x2F;1.1 的请求和响应可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1 </span><br><span class="line">Host: www.example.com </span><br><span class="line">User-agent: Next-Great-h2-browser-1.0.0 </span><br><span class="line">Accept-Encoding: compress, gzip</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Content-type: text/plain </span><br><span class="line">Content-length: 2</span><br></pre></td></tr></table></figure><p>在 HTTP&#x2F;2 中，它等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:scheme: https </span><br><span class="line">:method: GET </span><br><span class="line">:path: / </span><br><span class="line">:authority: www.example.com </span><br><span class="line">User-agent: Next-Great-h2-browser-1.0.0 </span><br><span class="line">Accept-Encoding: compress, gzip</span><br><span class="line"></span><br><span class="line">:status: 200 </span><br><span class="line">content-type: text/plain</span><br></pre></td></tr></table></figure><p>同时 HTTP&#x2F;2 也没有了分块编码（chunked encoding），在基于帧的世界里，谁还需要分块？只有在无法预知数据长度的情况下向对方发送数据时，才会用到分块。</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP&#x2F;2 中，一个 TCP 连接可以存在若干个双向字节流，每个流可以承载若干条消息，每条消息都是一条逻辑 HTTP 消息，由若干最小的二进制帧（Frame）组成。帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 头、消息载荷等等。下图是流的逻辑结构，图中的流作为一种逻辑通道被划分，而实际上应该将流理解成在连接上的一系列帧。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/Qle.png" alt="流的逻辑结构"></p><p>HTTP&#x2F;2 实现了完整的请求和响应复用，用户的每个请求都分配了一个流编号（Stream Id），客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后在另一端根据流编号将它们重新组装起来。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/aEb.png" alt="多路复用"></p><p>如上图，客户端正在向服务端发送一个 DATA 帧（数据流 5），与此同时，服务端正向客户端交错发送数据流 1 和数据流 3 的一系列帧。此时一个连接上同时有三个并行的数据流。</p><p>有了多路复用，客户端就可以一次性发出所有资源的请求，服务端也可以立即着手处理这些请求。但是因此也带来了一个问题，我们假设服务端同时接收到了 100 个请求，但是请求没有标识哪个更重要，那么它将几乎同时发送每个资源，次要资源可能就会影响到关键资源的传输。因此，HTTP&#x2F;2 提供了优先级（Priority）和依赖（Dependency）的功能，每个流都可以设置优先级和依赖。依赖为客户端提供了一种能力，通过指明某些对象对另一些对象有依赖，告知服务端这些对象应该优先传输，而优先级则能够让客户端告知服务端如何确定具有共同依赖关系的对象的传输顺序。优先级和依赖都是可以动态调整的。动态调整在有些场景下很有用，比如用户在浏览商品的时候，快速的滑动到了商品列表的底部，但前面的请求先发出，如果不把后面请求的优先级调高，用户当前浏览的图片要到最后才能加载完成，体验就要差一些。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>HTTP 无状态的特性导致报文的头部一般都会携带大量的字段，有些字段是固定出现的，比如 <code>User-Agent</code>、<code>Accept</code>、<code>Host</code> 等，有些则是自定义的。这些字段有时能够多达成百上千字节，但是 Body 部分却常常只有几十字节。过大的 Header 在一定程度上增加了传输的成本，更要命的是，大量报文中的很多字段都是重复的。</p><p>为了减少此类开销和提升性能，HTTP&#x2F;2 使用了专门设计的 HPACK 算法来压缩请求和响应头的元数据，具体来说主要有两点：其一是客户端和服务端会根据 <a href="https://tools.ietf.org/html/rfc7541">RFC 7541</a> 的附录 B 中的哈夫曼编码（Huffman Coding）表，对传输的头字段和值进行编码，从而减小传输数据的大小。其二是客户端和服务端还会同时维护一份包含之前见过的头字段的索引列表。这份列表包含一个静态表和一个动态表：静态表由 RFC 7541 的附录 A 定义，其中包含常见头部名称以及常见头部名称与值的组合。动态表最初为空，根据先入先出的原则，在客户端与服务端进行数据交换时进行更新。</p><p>利用哈夫曼编码，我们可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码。<strong>对于相同的数据，不再通过每次的请求和响应发送</strong>。比如下图中的两个请求，请求一发送了所有的头部字段，请求二则只需要发送差异数据。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202103052257/2021/03/05/pZv.png" alt="头部压缩"></p><h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>提升单个对象性能的最佳方式，就是在它被用到之前就已经放到浏览器缓存当中，这也正是 HTTP&#x2F;2 服务端推送的目的，说白了就是<strong>提前发送响应</strong>。当然，服务端也不能随意就发送对象给客户端，这会带来性能和安全问题，因此它需要解决推什么、何时推以及怎么推的问题。</p><p>首先，被推送的对象必须是可被缓存的，不能被缓存也就失去了推送的意义。如果服务端决定要推送一个对象（在 RFC 中被称为“推送响应”），就会先构造一个 PUSH_PROMISE 帧。在这个帧中，流 ID 一定会对应到客户端某个已发送的请求。举个例子：假设浏览器请求一个 HTML 页面，页面中有一些 JavaScript 对象，如果要推送此页面使用的某个 JavaScript 对象，服务端就会使用请求对应的流 ID 来构造 PUSH_PROMISE 帧，与此同时，PUSH_PROMISE 帧还会指示将要发送的响应所使用的流 ID。</p><p>在理想情况下，PUSH_PROMISE 帧应该更早发送，最起码应该早于客户端可能接收到承载着推送对象的 DATA 帧之前发送。如果客户端对 PUSH_PROMISE 中的任何元素不满，都可以按照拒收原因选择重置这个流（使用 RST_STREAM），或者发送 PROTOCOL_ERROR。一般当浏览器缓存中已经有了该对象时，会选择重置流。当 PUSH_PROMISE 涉及的协议层面有问题时，比如方法不安全（不是幂等的方法），或者客户端已经在 SETTINGS 帧中表明自己不接受推送时，仍然进行了推送，此时客户端会发送 PROTOCOL_ERROR。</p><p>假如客户端不拒收推送，服务端就会继续进行推送流程，用 PUSH_PROMISE 中指明的流来发送对象。需要注意的是，客户端会从 1 开始设置流 ID，之后每新开启一个流就会增加 2，即一直使用奇数。服务端开启在 PUSH_PROMISE 中标明的流时，设置的流 ID 从 2 开始，之后一直使用偶数。这种设计避免了客户端和服务端之间的流 ID 冲突，也可以轻松地判断哪些对象是由服务端推送的。0 是保留数字，用于连接级控制消息，不能用于创建新的流。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202104071621/2021/04/07/xnq.png" alt="服务端推送"></p><p>对于不同的应用，选择要推送哪些资源的逻辑可能也有很大不同，有些逻辑可能很简单，有些则有可能异常复杂。如果服务端的选择正确，那么确实会有助于提升页面的整体性能，反之则会损耗页面性能。尽管 SPDY 在很早之前就已经引入了服务端推送的特性，但是直到如今，通用的服务端推送解决方案还是很少。</p><h2 id="关于-TLS"><a href="#关于-TLS" class="headerlink" title="关于 TLS"></a>关于 TLS</h2><p>在 HTTP&#x2F;2 的规范中并没有明确要求必须使用 TLS，也就是说 HTTP&#x2F;2 其实是支持明文通信的，但是实际上主流的浏览器都不支持基于非 TLS 的 HTTP&#x2F;2，所以从“事实上”来看，可以认为 HTTP&#x2F;2 就是加密通信的。这背后主要有两个原因。一个非常现实的原因是，从之前对 WebSocket 和 SPDY 的实验看来，使用 Upgrade 首部，通过 80 端口（明文的 HTTP 端口）通信时，通信链路上代理服务器的中断等因素会导致非常高的错误率。如果基于 443 端口（HTTPS 端口）上的 TLS 发起请求，错误率会显著降低，并且协议通信也更简洁。还有一个原因是，人们越来越相信，考虑到安全和隐私，一切都应该被加密。HTTP&#x2F;2 被视为一次推动全网加密通信发展的机会。</p><h2 id="关于-HOL"><a href="#关于-HOL" class="headerlink" title="关于 HOL"></a>关于 HOL</h2><p>我们前面说过，由于 HTTP 请求和响应使用的是 FIFO 的队列机制，因此不管是 HTTP&#x2F;1.0 还是 HTTP&#x2F;1.1，都会发生 HOL。而 HTTP&#x2F;2 引入的双向多路复用流，则直接消除了 HTTP&#x2F;1.x 请求的阻塞性质，相当于引入了一个更好的，功能完备的，完全支持的管线化机制（Pipelining）。</p><p>应当注意的是，虽然 HTTP&#x2F;2 解决了 HTTP HOL 的问题，但是由于它还是构建在 TCP 之上，所以仍然面临着 TCP 层面的 HOL 问题，并且该问题在 HTTP&#x2F;2 下会引发更严重的后果。我们知道，TCP 为了保证可靠传输，有一个“丢包重传”的机制，发生丢包时必须等待重新传输确认。由于 HTTP&#x2F;2 只有一条 TCP 连接，如果单个 TCP 数据包丢失，则 TCP 连接必须请求重新发送该数据包，并等待该数据包成功传输，然后才能处理后续的 TCP 数据包，即使这些数据包是用于其他 HTTP&#x2F;2 流的，这就导致了整个 TCP 连接中的请求都被阻塞。而在 HTTP&#x2F;1.x 中，由于可以开启多个 TCP 连接，出现这种情况时反倒只会影响其中的某个或某些连接，其他连接还可以正常传输数据。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x">HTTP&#x2F;1.x 的连接管理</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/143464334">HTTP&#x2F;3 原理实战</a></p></blockquote><blockquote><p><a href="https://hpbn.co/http2/">HTTP&#x2F;2</a></p></blockquote><blockquote><p>《HTTP&#x2F;2 基础教程》</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;1969 年诞生于美国的因特网（Internet），现如今已经发展为覆盖五大洲 150 多个国家和地区的开放型全球计算机网络系统，我们普通用户只需要一根网线，一个调制解调器与因特网服务提供商相连，便可以进入其中。当然，因特网并不是全球唯一的互联网络，比如在欧洲就存在欧盟网（Euronet），在美国也还有国际学术网（BITNET）等。一般来说，我们会将因特网看作是互联网（internet），但是严格来说互联网泛指由多个计算机网络互相连接而组成的一个大型网络，因此因特网只是互联网的一种。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="https://blog.nekolr.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="HTTP" scheme="https://blog.nekolr.com/tags/HTTP/"/>
    
    <category term="HTTPS" scheme="https://blog.nekolr.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>行为树</title>
    <link href="https://blog.nekolr.com/2020/09/27/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    <id>https://blog.nekolr.com/2020/09/27/%E8%A1%8C%E4%B8%BA%E6%A0%91/</id>
    <published>2020-09-27T23:40:00.000Z</published>
    <updated>2023-04-20T09:51:11.114Z</updated>
    
    <content type="html"><![CDATA[<p>一个决策系统或者流程控制系统，在状态较少的情况下可以使用有限状态机。如果系统存在决策日趋复杂的可能性，那么简单的有限状态机并不是一个很好的选择，在使用它的过程中，你可能会感到越来越力不从心，这是有限状态机本身的局限性造成的。</p><span id="more"></span><p>在之前的有限状态机一文中，我们提到了它的缺陷。在使用有限状态机之前，我们需要列出所有可能的状态转换并设计出一张转换表，状态越多，这张表也就越复杂，出现遗漏的可能性也就越大，很多时候由于我们考虑不周，可能会导致现有的工作需要重新检查和修改，费时费力。下图是 Behavior Designer 官方文档中列出的一个意大利面条式的有限状态机：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/29/Jv6.png" alt="意大利面条有限状态机"></p><h1 id="什么是行为树？"><a href="#什么是行为树？" class="headerlink" title="什么是行为树？"></a>什么是行为树？</h1><p>行为树（Behavior Tree），简称 BT，一般用于游戏 AI，概括来说就是一棵用于控制 AI 行为的树结构。在我们要决策当前的 AI 需要执行哪个行为时，我们就会从它的行为树的根节点开始，自顶向下（或者自左向右）一层一层地对每个节点进行检查，也就是进行树的遍历。</p><p>行为树的节点类型有很多种，常见的包括：根节点、复合节点、行为节点和修饰节点，很多成熟的行为树框架中可能还会包含条件节点。需要强调的是，节点一般会有四种状态：Success、Failure、Running 和 Error，其中 Running 状态表示该节点的执行结果还不能立刻获知，比如在游戏中角色进行“向目标移动”的动作，很显然这并不是一个瞬时动作，所以在没有最终到达目的地之前都会一直返回 Running 状态。</p><h1 id="复合节点"><a href="#复合节点" class="headerlink" title="复合节点"></a>复合节点</h1><p>复合节点（Composite Node）也可以叫做控制节点，它有一个父节点和一个或者多个子节点，它的作用是控制子节点的执行方式，比如按照一定的顺序执行或者随机执行。根据执行方式的不同，常用的复合节点有三种：选择节点（Selector Node）、顺序节点（Sequence Node）和并行节点（Parallel Node）。当然，也有一些不常用的控制节点类型，比如随机选择节点、随机顺序节点、次数限制节点、权重选择节点等等。需要注意的是，复合节点需要向上级提供执行结果，它既可以控制行为节点，同时也能控制复合节点，这样就可以做到决策的复合。</p><h2 id="顺序节点"><a href="#顺序节点" class="headerlink" title="顺序节点"></a>顺序节点</h2><p>就像它的名字一样，顺序节点会按照一定的顺序（通常是从左到右或者从上到下）执行它的子节点。只有当一个子节点执行成功并向它返回 Success 之后，下一个子节点才会开始执行，当所有的子节点都执行成功，该顺序节点才算执行成功，同时它也会向自己的父节点返回 Success；如果一个子节点执行失败并返回 Failure，那么整个迭代就会停止，这也就意味着该顺序节点执行失败，此时它会向自己的父节点返回 Failure。</p><p>顺序节点通常用于执行一连串具有前后依赖关系的行为，其中一个行为失败必然导致后续的行为失去继续执行的意义，比如“进门”这个过程：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/28/Z7A.png" alt="顺序节点"></p><p>一个正确的“进门”过程应该是这样的：顺序节点 -&gt; walk to door(Success) -&gt; 顺序节点（Running）-&gt; open door(Success) -&gt; 顺序节点（Running）-&gt; walk through door(Success) -&gt; 顺序节点（Running）-&gt; close door(Success) -&gt; 顺序节点（Running）-&gt; 向父节点返回 Success。</p><p>如果角色因为一些原因未能成功走到门前，比如被其他物体挡住去路，那么后面的这些动作也就失去了执行的意义，这时走向门的这个动作失败并返回，顺序节点会向父节点报告失败，此时父节点就可以根据这个结果进行一些处理。</p><h2 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h2><p>如果把顺序节点理解为一个“与门”，那么选择节点就是一个“或门”。与顺序节点相同，选择节点也会按照一定的顺序执行子节点，但是与顺序节点不同，只要有一个子节点执行成功，那么选择节点就算执行成功并向父节点报告成功的消息。如果有一个子节点执行失败，那么选择节点会继续执行下一个子节点，只有当所有的子节点都执行失败之后，选择节点才算执行失败，此时它会向父节点报告失败的消息。</p><p>选择节点通常用于表示一个行为会有多种实现方式，比如攻击这个行为，可能会有劈、斩、砍三种不同的实现方式，选择节点可以选择这三种方式中的任意一种执行。更进一步的，我们可以定义一个优先级，优先级高的行为会先执行。回到“进门”的那个例子，我们增加一些复杂性：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/28/7yv.png" alt="选择节点"></p><p>我们将角色开门这个动作进行了更加细化的安排，角色可以选择直接开门或者使用钥匙开门，当然如果角色脾气不太好，也有可能会选择直接把门打烂。</p><h2 id="并行节点"><a href="#并行节点" class="headerlink" title="并行节点"></a>并行节点</h2><p>并行节点意味着它会并发地执行所有的子节点，而在何种情况下向父节点报告执行结果则与并行节点所采用的具体策略有关。比如它可以是 Parallel Selector 类型的，那么只要有一个子节点执行成功就代表它执行成功；也有可能是 Parallel Sequence 类型的，那么只要有一个子节点执行失败就代表它执行失败。或者是 Parallel Hybird 类型的，那么只有在指定数量的子节点执行失败或者执行成功之后才会决定最终的执行结果。当然，还有很多其他的策略，这里就不一一列举了。</p><p>并行节点通常用于表示同一时刻一个事物会有多种行为同时执行，比如一个人物可以一边移动一边攻击。</p><h1 id="行为节点"><a href="#行为节点" class="headerlink" title="行为节点"></a>行为节点</h1><p>行为节点是叶子节点，它是具体动作的执行者，如果拿代码来做类比的话，那么复合节点和修饰节点就好比能够改变代码执行的流程控制语句：if、else、while 等等，而行为节点就是那些在控制语句范围内被调用的方法。</p><p>有些行为是可以在“瞬间”完成的，比如 2D 精灵的转身，而有些行为需要持续一段时间才能完成。因此，在这些持续行为节点中，我们需要先执行持续行为，然后挂起行为树，直到持续时间结束再恢复行为树的执行。为了实现这个目的，一般的做法是一颗行为树维护一个协程，在需要时通过协程等待持续行为的完成，从而避免阻塞当前线程。</p><h1 id="条件节点"><a href="#条件节点" class="headerlink" title="条件节点"></a>条件节点</h1><p>有些行为节点可能需要一个前提条件，只有在前提条件得到满足的情况下才能够执行，当然有的行为节点并没有前提条件。现在比较成熟的做法是将前提条件抽象分离出来作为一种新的节点类型——条件节点，将它作为叶子节点混入行为树中，提供条件的判断结果，并交给复合节点来决策。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/28/D4o.png" alt="条件节点"></p><h1 id="修饰节点"><a href="#修饰节点" class="headerlink" title="修饰节点"></a>修饰节点</h1><p>修饰节点可以有子节点，但是它只能拥有一个叶子节点。它的作用有很多，包括修改子节点的执行结果，终止子节点的执行以及重复执行子节点等等。一个比较常见的修饰节点就是逆变节点（Inverter），它可以将子节点的执行结果逆转，比如子节点返回了 Success，那么修饰节点就会向父节点返回 Failure。</p><p>还有很多其他类型的修饰节点，比如成功节点（Succeeder），它不管子节点的结果如何都会向父节点返回成功的结果，这在我们知道子节点一定会失败，而它的父节点又是顺序节点的情况下非常有用，这样我们就可以避免因为子节点失败而导致整个迭代停止。</p><h1 id="数据上下文"><a href="#数据上下文" class="headerlink" title="数据上下文"></a>数据上下文</h1><p>行为树的节点间是存在通信需求的，比如一个顺序节点，它包含两个子节点，一个是选择目标，另一个是攻击。这里就存在节点通信的需求，即攻击节点需要获取选择目标节点的结果，也就是“攻击目标”来发起攻击。那么这个“攻击目标”应该存储在哪里呢？一般情况下，我们都会选择存储在与这个行为树绑定的黑板上，也就是行为树对应的数据上下文当中。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009291727/2020/09/29/W1r.png" alt="黑板模式"></p><h1 id="有限状态机与行为树"><a href="#有限状态机与行为树" class="headerlink" title="有限状态机与行为树"></a>有限状态机与行为树</h1><p>行为树从本质上讲，是将所有的行为分离出来作为行为节点，然后使用各种控制节点、条件节点和修饰节点将这些行为组合在一起，最终形成一套 AI 的行为决策系统。这么来说，行为树与有限状态机还是有很多相似之处的，或者我们可以理解为行为树对有限状态机做了一些改进和优化。</p><p>与有限状态机相比，行为树可以方便地把复杂的 AI 知识条目组织得非常直观，复合节点迭代子节点的方式就像是在处理一个预设的优先策略队列，这与我们正常的思考模式相符合：先最优再次优。由于行为树中的行为逻辑和状态数据相互分离，因此节点的可重用性很高，几乎所有的节点都可以复用，我们可以通过重组不同的节点来实现不同的行为树，同时这也使得行为树更容易实现可视化的 AI 设计工作。</p><p>但是行为树的缺陷也很明显，由于每次都需要从根节点开始层层遍历树，所以使用行为树可能会比有限状态机消耗更多的 CPU 资源，尤其是在行为树深度较深时会更加明显。</p><p>虽然行为树与有限状态机相比有诸多优势，但是这并不代表我们应该全面抛弃有限状态机。如果我们不需要一个特别复杂的 AI，我们可以考虑继续使用状态机。很多时候我们还可以将两者结合，由状态机负责 AI 的身体状态，而行为树负责 AI 的决策，但是这样的话，行为树在做决策之前还需要考虑状态机的状态，可能会使系统变得更加复杂。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://web.stanford.edu/class/cs123/lectures/CS123_lec08_HFSM_BT.pdf">Hierarchical Finite State Machine (HFSM) &amp; Behavior Tree (BT)</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/KillerAery/p/10007887.html">游戏 AI 之决策结构-行为树</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个决策系统或者流程控制系统，在状态较少的情况下可以使用有限状态机。如果系统存在决策日趋复杂的可能性，那么简单的有限状态机并不是一个很好的选择，在使用它的过程中，你可能会感到越来越力不从心，这是有限状态机本身的局限性造成的。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://blog.nekolr.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.nekolr.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有限状态机</title>
    <link href="https://blog.nekolr.com/2020/09/21/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>https://blog.nekolr.com/2020/09/21/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2020-09-21T11:35:00.000Z</published>
    <updated>2023-04-20T09:51:11.110Z</updated>
    
    <content type="html"><![CDATA[<p>有限状态机和行为树在游戏 AI 领域比较常见，当然很多涉及到流程控制的逻辑都可以使用它们来降低复杂性并创建更具可读性的程序。</p><span id="more"></span><h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p>假如我们正在开发一款 RPG 游戏，游戏中的敌人在遇到玩家后会发起攻击，而玩家不在攻击范围内就进行巡逻。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (视野范围内有目标) &#123;</span><br><span class="line">  攻击</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  巡逻</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写不会有啥问题，并且也很容易实现。但是随着开发的深入，游戏逻辑越来越复杂，经过几次修改，游戏逻辑可能会变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (视野范围有目标) &#123;</span><br><span class="line">    if (血量 &gt; 10) &#123;</span><br><span class="line">        if (超过攻击距离) &#123;</span><br><span class="line">            追逐</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            攻击</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (没有遇到同伴) &#123;</span><br><span class="line">            逃跑</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            一起攻击</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    巡逻</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会说，这点逻辑我还能应对，但是我们不能保证后续是否还有更复杂的条件和逻辑需要添加，到时候我们还需要回到这里，继续修改和添加代码逻辑。随着时间的推移，这里的代码可以预见的会越来越复杂，难以维护。现在，是时候思考应该怎样拆分它了。</p><p>在上面的这个例子中，像攻击、追逐、逃跑等，可以抽象为<strong>状态</strong>，而视野范围内有目标、血量小于 10 等这些都是进入某个状态的<strong>触发条件</strong>，所以在这些逻辑当中，真正不断发生变化的是状态、触发条件以及它们之间的对应关系。通过分析，我们可以把上面例子中的逻辑（有些逻辑没有使用）总结为一个<strong>状态转换表</strong>：</p><table><thead><tr><th>当前状态</th><th>触发条件</th><th>目标状态</th></tr></thead><tbody><tr><td>巡逻</td><td>血量为 0</td><td>死亡</td></tr><tr><td>巡逻</td><td>发现目标</td><td>追逐</td></tr><tr><td>追逐</td><td>血量为 0</td><td>死亡</td></tr><tr><td>追逐</td><td>目标进入攻击范围</td><td>攻击</td></tr><tr><td>追逐</td><td>丢失目标</td><td>巡逻</td></tr><tr><td>攻击</td><td>血量为 0</td><td>死亡</td></tr><tr><td>攻击</td><td>目标离开攻击范围</td><td>追逐</td></tr><tr><td>攻击</td><td>目标血量为 0</td><td>巡逻</td></tr><tr><td>死亡</td><td></td><td></td></tr></tbody></table><p>根据当前逻辑，在罗列了所有可能的状态以及状态切换的触发条件之后，我们可以为每个状态和每个触发条件都创建一个对应的类，比如攻击状态就是 AttackState，血量为 0 的条件类就是 HPIsZero，它们都有一个对应的父类（或者接口），比如 AbstractState 和 AbstractCondition。状态接口主要提供进入状态、在状态中以及退出状态时需要执行的函数，而条件接口主要提供的是一个检测触发条件是否满足的函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在状态中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 进入状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Enter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 退出状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractCondition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检测条件是否满足</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">bool</span> <span class="title">Predicate</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些状态类和条件类，接下来的工作就是将它们组合起来，覆盖上述状态转换表，形成完整的逻辑。为此，我们还需要创建一个容器，这个容器负责存储和管理所有的状态、条件以及它们之间的映射关系，同时还需要提供进行状态切换的函数。这个容器就是我们所说的有限状态机（Finite State Machine）。当然，状态机的实现方式多种多样，有的会把映射关系维护到状态中。有的可能不会将触发条件独立出来，而是选择放到状态内部。</p><p>这大概就是实现一个有限状态机的完整过程，到这里，我们应该都对有限状态机是什么有了一个自己的答案。对于我来说，有限状态机就是一个能够在有限的状态内实现状态转换的数学计算模型。通过有限状态机，我们可以实现类似流程控制的逻辑，但是与一般的流程控制不同，使用有限状态机可以将流程控制语句与对应的处理逻辑分离，从而使程序的可读性和可维护性更好。</p><p>当然，有限状态机也是有缺陷的。首先它的可维护性并不好，添加或删除一个状态时，所有之前定义的状态、条件和映射关系可能都需要重新检查和修改。然后可扩展性也不高，当状态特别多的时候，可以想象应该需要一张很大的状态转换表，尤其是在 Unity 中，Animator 控制器的大量状态盒子和箭头就是一个噩梦。最后，对于当前状态来说，我并不能知道我的转换历史，也就是说，我很难知道我为什么会在这个状态里，这也是为什么现在主流的 AI 选择使用行为树的原因之一。</p><h1 id="并发状态机"><a href="#并发状态机" class="headerlink" title="并发状态机"></a>并发状态机</h1><p>关于有限状态机，它有一个隐含的特点就是：同一时刻只能处于一个状态中。然而很多时候，使用有限状态机的事物需要在同一时刻处于多种不同的状态中。比如一个角色，我们定义了静止、奔跑、跳跃等状态，同时我们赋予了角色使用枪支的能力，我们需要它在射击的时候能够自由选择静止、奔跑或者跳跃。如果我们坚持只使用一个状态机，那么我们需要再添加一些状态：静止射击、奔跑射击、跳跃射击等，对于每个现有的状态，我们都需要再添加一个状态来在它射击的时候做同样的事。这样状态数量会迅速膨胀，同时会有大量的冗余代码。</p><p>此时，一个很明显的解决方案就是：保留原有的状态机，然后为它携带的枪支提供一个单独的状态机。这样角色将持有两个状态机的引用，在同一时刻，玩家的操作都会传入两个状态机中，两个状态机会根据玩家的行为做出相应的响应动作，比如一边奔跑一边射击。</p><p>当两组状态大部分都是互不相关的时候，这种实现方式很合适。但是在实际开发中，两组状态确实可能会出现相互影响的情况，比如角色不能在跳跃的时候进行射击。一个不太优雅的解决方法就是在状态类（或者条件类）中对另一个状态机的当前状态进行判断。</p><h1 id="分层状态机"><a href="#分层状态机" class="headerlink" title="分层状态机"></a>分层状态机</h1><p>很多时候，把一个事物具象化以后，可能会有很多“相似”的状态。比如一个玩家角色，它可能有站立、步行、奔跑和滑行等状态，当处在这些状态中的任何一个状态时，玩家都可以进行跳跃和下蹲的操作。如果使用常规的有限状态机，我们就需要给每个状态都添加这部分代码，一种常规的改进方式就是使用继承。我们可以将具有“相似”之处的状态分为一类，总结为一种新的状态，比如这里的站立、步行、奔跑和滑行等可以定义为“在地面上”这个新状态，然后之前的这些状态都继承它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">OnTheGroundState</span> : <span class="title">IState</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleInput</span>(<span class="params">Player player, Input input</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == PRESS_JUMP) &#123;</span><br><span class="line">      <span class="comment">// change state to jump</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input == PRESS_DOWN) &#123;</span><br><span class="line">      <span class="comment">// change state to duck</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">RunState</span> : <span class="title">OnTheGroundState</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">handleInput</span>(<span class="params">Player player, Input input</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == PRESS_RUN) &#123;</span><br><span class="line">      <span class="comment">// change state to run</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      OnTheGroundState::handleInput(player, input);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子就用到了分层状态机的思想。我们再来列举一个例子，这个例子是从别处看到的，是一个决策小狗行为的例子。我们对小狗定义了很多状态，比如吃饭、睡觉、奔跑、咆哮、撒娇和摇尾巴等，如果使用常规的状态机，我们就需要考量每个状态之间的关系，定义所有可能的转换。但是如果使用分层状态机，我们可以对小狗的行为进一步“分类”，比如我们定义疲劳、开心和愤怒三个状态，然后在这些状态中再定义一些小状态。比如在开心的状态中，就有撒娇、摇尾巴等小状态。这样在外部我们只需要关心三个大状态的转换，在每个大状态的内部则只需要关心自己的小状态的转换即可。这就大大降低了状态机的复杂度，状态之间的转换数量也就相应地减少了。</p><p>从上面的两个例子可以看出，在分层状态机中会有一些超级状态，超级状态间也可以进行转换。利用超级状态，我们可以实现仅仅将状态转换应用到超级状态一次，而不用分别为每个状态应用一次状态转换。需要注意的是，分层状态机中每一层都是一个状态机，这意味着超级状态的内部也是一个独立的状态机。只要满足某一层（某个超级状态）的转移触发条件，就可以不用管其内部的子状态，直接进行状态切换，但是在退出该层之前需要依次执行每个子状态的退出逻辑。</p><p>使用分层状态机，我们可以重用部分代码（本质上是重用状态转换），从而减少状态转换的数量，但是它仍然不是一种比较理想的解决方案，因为重用转换并不容易，为此我们需要进行大量的思考。</p><h1 id="下推状态机"><a href="#下推状态机" class="headerlink" title="下推状态机"></a>下推状态机</h1><p>简单来说就是通过栈结构来存储一系列的状态对象。比如在一个射击游戏中，玩家角色处于站立的状态，那么栈顶的状态就是站立，执行的也是站立的逻辑。突然遇到敌人，玩家选择开火攻击，于是入栈一个射击的状态，此时会执行射击的逻辑。当敌人死亡，开火结束，为了恢复到开火前的上一个状态，选择弹出栈顶状态，此时就恢复到了之前的站立状态。总的来说，下推状态机适用于那些需要记忆状态的状态机。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://gameprogrammingpatterns.com/state.html">State</a></p></blockquote><blockquote><p><a href="http://www.aisharing.com/archives/393">层次化状态机的讨论</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/31845498">状态机编程思想？</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;有限状态机和行为树在游戏 AI 领域比较常见，当然很多涉及到流程控制的逻辑都可以使用它们来降低复杂性并创建更具可读性的程序。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://blog.nekolr.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.nekolr.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 执行计划</title>
    <link href="https://blog.nekolr.com/2020/09/08/MySQL%20%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <id>https://blog.nekolr.com/2020/09/08/MySQL%20%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</id>
    <published>2020-09-08T12:50:00.000Z</published>
    <updated>2023-04-20T09:51:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>一条查询语句在经过 MySQL 的查询优化器分析后，会生成一个所谓的执行计划，这个计划能够告诉我们接下来的查询的一些信息，比如单表采用哪种访问方法，多表连接的顺序，预估需要读取的记录数等等。</p><span id="more"></span><p>我们平常使用的查询语句，甚至是增删改的语句，都可以在前面加上 <code>EXPLAIN</code> 关键字列出该条语句的执行计划，不过一般存在性能瓶颈的都是查询语句，所以我们主要关注的也是查询语句。下面先简单说明一下 EXPLAIN 语句输出的各个列的含义。</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>SELECT 标识符，每个 SELECT 关键字都对应一个唯一的 id</td></tr><tr><td>select_type</td><td>查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区，不使用分区表时，默认为 NULL</td></tr><tr><td>type</td><td>单表访问的方法</td></tr><tr><td>possible_keys</td><td>可能使用的索引</td></tr><tr><td>key</td><td>实际使用的索引</td></tr><tr><td>key_len</td><td>实际使用索引的字段长度</td></tr><tr><td>ref</td><td>使用索引列等值查询时，与索引列进行等值匹配的对象，可以是一个常数或者某个列</td></tr><tr><td>rows</td><td>预估需要扫描的行数，也就是结果集的行数</td></tr><tr><td>filtered</td><td>通过条件过滤出的行数的百分比估值</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>不管我们的查询语句有多复杂，最终都会分解成一个个的单表查询，所以 EXPLAIN 输出的每条记录都对应着某个单表的访问，该条记录的 table 列就代表这张表的名称。比如一个简单的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12286</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure><p>然后再看看一个连接查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested Loop)<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br></pre></td></tr></table></figure><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p>一般情况下的查询只有一个 SELECT 关键字，比如普通的单表查询或者连接查询，但是有时候也会有多个 SELECT 关键字，比如包含子查询语句以及 UNION 查询等。在整个查询语句中，每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id。</p><p>对于连接查询来说，有一个比较重要的规则就是，在连接查询的执行计划中，每个表都会对应一条记录，它们的 id 值都相同，但是出现在前面的表是驱动表，而出现在后面的表是被驱动表。</p><p>对于子查询来说，一般会包含多个 SELECT 关键字，每个关键字都会对应一个唯一的 id 值，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">or</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>    <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>  <span class="operator">|</span>idx_username <span class="operator">|</span><span class="keyword">NULL</span>    <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>SUBQUERY   <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>但是有时候查询优化器可能会对涉及子查询的查询语句进行重写并转换为连接查询，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+------------+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>         <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+------------+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>        <span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>demo.user.id<span class="operator">|</span><span class="number">1</span>     <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+------------+------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>对于 UNION 查询来说，由于还需要去重，所以执行计划可能会有点不一样，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+----------+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span>id  <span class="operator">|</span>select_type <span class="operator">|</span><span class="keyword">table</span>     <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+----------+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="keyword">PRIMARY</span>     <span class="operator">|</span>t1        <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span>   <span class="operator">|</span><span class="keyword">UNION</span>       <span class="operator">|</span>t2        <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">UNION</span> <span class="keyword">RESULT</span><span class="operator">|</span><span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span><span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>  <span class="operator">|</span><span class="keyword">NULL</span>    <span class="operator">|</span><span class="keyword">Using</span> temporary<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+----------+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br></pre></td></tr></table></figure><p>为了将 id 为 1 的查询和 id 为 2 的查询结果集合并起来并去重，需要创建一个临时表，也就是上面的 <code>&lt;union1,2&gt;</code>，而由于 UNION ALL 不需要去重，所以执行计划里没有 id 为 NULL 的记录。</p><p>总的来说，一般情况下，id 值相同时，按照从上到下的顺序执行；id 值不同时，id 值大的先执行。</p><h1 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单查询，不包含子查询或者 UNION 查询</td></tr><tr><td>PRIMARY</td><td>最外层的那个查询</td></tr><tr><td>UNION</td><td>UNION 后面的查询</td></tr><tr><td>UNION RESULT</td><td>UNION 去重时使用的临时表的查询</td></tr><tr><td>SUBQUERY</td><td>不依赖外部查询的子查询</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>依赖外部查询的子查询</td></tr><tr><td>DERIVED</td><td>采用物化的方式执行包含派生表的查询</td></tr><tr><td>MATERIALIZED</td><td>查询优化器选择将子查询物化后与外层查询进行连接查询时</td></tr></tbody></table><h2 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h2><p>查询中不包含子查询或者 UNION 查询的都算作 SIMPLE 类型的查询，当然，连接查询也是 SIMPLE 类型的，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested Loop)<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------------+</span></span><br></pre></td></tr></table></figure><h2 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h2><p>对于包含子查询或者 UNION 查询的大查询来说，它是由几个小的查询组成的，其中最左边也就是最外层的那个小查询就是 PRIMARY 类型的。</p><h2 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h2><p>如果包含子查询的查询语句不能转换为对应的 semi-join 的形式，并且该子查询不依赖外部的查询，同时查询优化器决定将子查询进行物化，此时子查询的第一个 SELECT 关键字代表的那个查询就是 SUBQUERY 类型的，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">or</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>    <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>  <span class="operator">|</span>idx_username <span class="operator">|</span><span class="keyword">NULL</span>    <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>SUBQUERY   <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p><strong>由于 SUBQUERY 类型的子查询会被物化，所以它只需要执行一遍即可。</strong></p><h2 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h2><p>如果包含子查询的查询语句不能转换为对应的 semi-join 的形式，并且该子查询依赖于外部的查询，那么子查询的第一个 SELECT 关键字代表的那个查询就是 DEPENDENT SUBQUERY 类型的，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> t2 <span class="keyword">where</span> t1.id <span class="operator">=</span> t2.id) <span class="keyword">or</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------------+-----+----------+------+-------------+-------+-------+----------+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type       <span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>       <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------------+-----+----------+------+-------------+-------+-------+----------+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>           <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span>idx_username <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>DEPENDENT SUBQUERY<span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>demo.t1.id<span class="operator">|</span><span class="number">1</span>     <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------------+-----+----------+------+-------------+-------+-------+----------+------+--------+------------------------+</span></span><br></pre></td></tr></table></figure><p><strong>与 SUBQUERY 不同，查询类型为 DEPENDENT SUBQUERY 的查询可能会执行多次。</strong></p><h2 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h2><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询就是 DERIVED 类型的，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> province, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> province) <span class="keyword">as</span> derived_t;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+----------+----------+-----+-------------+-----------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span>     <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+----------+----------+-----+-------------+-----------+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span><span class="keyword">PRIMARY</span>    <span class="operator">|</span><span class="operator">&lt;</span>derived2<span class="operator">&gt;</span><span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>  <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>DERIVED    <span class="operator">|</span><span class="keyword">user</span>      <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">909</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+----------+----------+-----+-------------+-----------+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure><h2 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a>MATERIALIZED</h2><p>查询优化器在执行子查询时，如果选择将子查询物化后与外层查询进行连接查询时，该子查询就是 MATERIALIZED 类型的，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> post);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------+-----------+----------+------+-------------+-------+-------+-------------------+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type <span class="operator">|</span><span class="keyword">table</span>      <span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>                <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------+-----------+----------+------+-------------+-------+-------+-------------------+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE      <span class="operator">|</span><span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span><span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>               <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE      <span class="operator">|</span><span class="keyword">user</span>       <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span><span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span>.user_id<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">2</span> <span class="operator">|</span>MATERIALIZED<span class="operator">|</span>post       <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>               <span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+------------+-----------+----------+------+-------------+-------+-------+-------------------+----+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>最后一条记录的 id 为 2，查询类型是 MATERIALIZED，说明查询优化器对它进行了物化，而前两条记录的 id 为 1，说明这两条记录对应的表进行了连接查询，<code>&lt;subquery2&gt;</code> 对应的就是物化表。</p><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>对应的是单表的访问方法，除了之前讲过的那些，还有一些比较特殊的访问方法，比如 system、eq_ref、fulltext 等。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、Memory 等，那么该表的访问方法就是 system。</p><h2 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h2><p>在进行连接查询时，如果被驱动表是通过主键或者唯一二级索引等值匹配的方式进行访问的话，那么对该被驱动表的访问方法就是 eq_ref，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> t2 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+----------+------+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type  <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>       <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+----------+------+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t1   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span>   <span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span>t2   <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>eq_ref<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>demo.t1.id<span class="operator">|</span><span class="number">1</span>     <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+------+-------------+-------+-------+----------+------+--------+-----+</span></span><br></pre></td></tr></table></figure><h1 id="possible-keys-和-key"><a href="#possible-keys-和-key" class="headerlink" title="possible_keys 和 key"></a>possible_keys 和 key</h1><p>possible_keys 表示可能会用到的索引，而 key 代表的是实际用到的索引，比如下面的查询语句可能用到的索引为 ids_code 和 idx_username，但是在计算成本之后，还是选择了 idx_username。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">and</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+---------------------+------------+-------+-----+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys        <span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+---------------------+------------+-------+-----+----+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_code,idx_username<span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1724</span><span class="operator">|</span><span class="number">50</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+---------------------+------------+-------+-----+----+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在使用 index 访问方法时，possible_keys 的值为 NULL，但是 key 是有值的。另外 possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算各个索引的查询成本时就要花费更多的时间。</p><h1 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h1><p>在一般情况下，key_len 代表当查询优化器决定使用某个索引时，该索引列的最大长度。对于使用固定长度类型的索引列来说，它实际占用的存储空间就是该固定值；对于变长类型的字段来说，比如 VARCHAR(100)，使用 UTF8 字符集，那么它实际占用的最大存储空间就是 100 * 3 &#x3D; 300 个字节，同时还需要 2 个字节的空间来存储变长字段的实际长度值。如果索引列可以存储 NULL 值，那么 key_len 会比不能为空时多一个字节。比如下面这个例子，code 列是 int 类型的，并且可以存储 NULL 值，所以 key_len 的大小为 5。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code  <span class="operator">=</span> <span class="number">122</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure><p>当然有时候，key_len 代表的是实际用到的索引列的长度，比如在使用联合索引时，只用到一个索引列和两个索引列，key_len 的值是不一样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东省&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----+-----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span> <span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----+-----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">95924</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----+-----+--------+-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东省&#x27;</span> <span class="keyword">and</span> city <span class="operator">=</span> <span class="string">&#x27;青岛市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>        <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">606</span>    <span class="operator">|</span>const,const<span class="operator">|</span><span class="number">6000</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br></pre></td></tr></table></figure><h1 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h1><p>这个还是举例子比较清楚，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">and</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+---------------------+--------+-------+----+----+--------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys        <span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+---------------------+--------+-------+----+----+--------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_code,idx_username<span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">999</span> <span class="operator">|</span><span class="number">0.17</span>    <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+---------------------+--------+-------+----+----+--------+----------------------------------+</span></span><br></pre></td></tr></table></figure><p>在这个例子中，通过索引条件 code &lt; 1000，查询优化器估算出了需要扫描的行数为 999，而这 999 行中，经过条件过滤，最终只有一条结果，也就是估算出有 0.17 % 的行满足剩下的条件（<code>username = &#39;Bob&#39;</code>）。</p><h1 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h1><p>Extra 可以提供一些额外的信息，使我们能够更加准确地理解查询优化器到底会如何执行给定的查询语句。</p><ul><li><p>No tables used<br>查询语句没有 FROM 子句，比如 SELECT 1，或者 SELECT 1 FROM dual。</p></li><li><p>Impossible WHERE<br>查询语句的 WHERE 子句永远为 FALSE 时，比如 SELECT * FROM user WHERE 1 !&#x3D; 1。</p></li><li><p>Using index<br>当使用覆盖索引时，比如 <code>SELECT province, city, county FROM user WHERE province = &#39;上海市&#39;</code>。</p></li><li><p>Using index condition<br>在查询语句的执行过程中使用了<strong>索引条件下推（Index Condition Pushdown）</strong>这个特性。举个例子，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">and</span> username <span class="keyword">like</span> <span class="string">&#x27;%ce&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">3516</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>username &gt; &#39;z&#39;</code> 可以通过索引列使用 range 访问方法，但是 <code>username like &#39;%ce&#39;</code> 不行，在以前的 MySQL 中，此时需要回表获取完整的用户记录，然后再检查记录是否符合条件；在 5.6 以后的版本中，此时先不急着回表，而是直接检查是否满足条件，如果没有满足就没必要回表，这样就可以省去好多回表的 I&#x2F;O 成本。</p></li><li><p>Using where<br>当使用全表扫描的访问方法查询某个表，同时语句中有对应的 where 条件时。或者当使用索引查询，并且该查询的 where 子句中还使用了其他非索引的列作为搜索条件。</p></li><li><p>Zero limit<br>当 limit 子句的参数为 0 时，这意味着根本不打算从表中读出任何记录。</p></li><li><p>Using filesort<br>有时候排序操作无法使用索引，这时只能在内存中（记录较少时）或者磁盘中（记录较多时）进行排序，这种排序方式称为文件排序（filesort）。</p></li><li><p>Using temporary<br>在很多查询中，MySQL 可能需要借助临时表来完成一些功能，比如使用 UNION、DISTINCT 去重、使用 GROUP BY 排序等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="keyword">DISTINCT</span> avatar <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> temporary<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+---------------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> avatar, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> avatar;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span><span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span> <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">991800</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> temporary; <span class="keyword">Using</span> filesort<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+-----+----------+----+-------------+----+-------+----+------+--------+-------------------------------+</span></span><br></pre></td></tr></table></figure><p>由于 MySQL 默认会在 GROUP BY 子句中添加 ORDER BY 子句，所以这里的分组还出现了 Using filesort，如果我们不想进行排序，可以显式地使用 ORDER BY NULL 来指定。</p></li></ul><h1 id="查询成本"><a href="#查询成本" class="headerlink" title="查询成本"></a>查询成本</h1><p>通过 EXPLAIN 输出的执行计划缺少了一个衡量执行计划“好坏”的重要因素，那就是<strong>成本</strong>。从 MySQL 5.6 版本开始，我们可以通过在 EXPLAIN 后面加上 FORMAT&#x3D;JSON 来得到一个 json 格式的执行计划，里面包含了查询成本。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">explain FORMAT<span class="operator">=</span>JSON <span class="keyword">select</span> avatar, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> avatar;</span><br><span class="line"></span><br><span class="line">&quot;&#123;</span><br><span class="line">  &quot;&quot;query_block&quot;&quot;: &#123;</span><br><span class="line">    &quot;&quot;select_id&quot;&quot;: 1,</span><br><span class="line">    &quot;&quot;cost_info&quot;&quot;: &#123;</span><br><span class="line">      &quot;&quot;query_cost&quot;&quot;: &quot;&quot;1200635.00&quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;&quot;grouping_operation&quot;&quot;: &#123;</span><br><span class="line">      &quot;&quot;using_temporary_table&quot;&quot;: true,</span><br><span class="line">      &quot;&quot;using_filesort&quot;&quot;: true,</span><br><span class="line">      &quot;&quot;cost_info&quot;&quot;: &#123;</span><br><span class="line">        &quot;&quot;sort_cost&quot;&quot;: &quot;&quot;991800.00&quot;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;&quot;table&quot;&quot;: &#123;</span><br><span class="line">        &quot;&quot;table_name&quot;&quot;: &quot;&quot;user&quot;&quot;,</span><br><span class="line">        &quot;&quot;access_type&quot;&quot;: &quot;&quot;ALL&quot;&quot;,</span><br><span class="line">        &quot;&quot;rows_examined_per_scan&quot;&quot;: 991800,</span><br><span class="line">        &quot;&quot;rows_produced_per_join&quot;&quot;: 991800,</span><br><span class="line">        &quot;&quot;filtered&quot;&quot;: &quot;&quot;100.00&quot;&quot;,</span><br><span class="line">        &quot;&quot;cost_info&quot;&quot;: &#123;</span><br><span class="line">          &quot;&quot;read_cost&quot;&quot;: &quot;&quot;10475.00&quot;&quot;,</span><br><span class="line">          &quot;&quot;eval_cost&quot;&quot;: &quot;&quot;198360.00&quot;&quot;,</span><br><span class="line">          &quot;&quot;prefix_cost&quot;&quot;: &quot;&quot;208835.00&quot;&quot;,</span><br><span class="line">          &quot;&quot;data_read_per_join&quot;&quot;: &quot;&quot;1G&quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;&quot;used_columns&quot;&quot;: [</span><br><span class="line">          &quot;&quot;id&quot;&quot;,</span><br><span class="line">          &quot;&quot;avatar&quot;&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&quot;</span><br></pre></td></tr></table></figure><p>这里需要关注的重点就是 cost_info，其中 read_cost 包含 IO 成本以及扫描 <code>rows * (1 - filtered)</code> 条记录的 CPU 成本，而 eval_cost 是扫描 rows * filtered 条记录的成本，而 prefix_cost &#x3D; read_cost + eval_cost。data_read_per_join 表示此次查询中需要读取的数据量。如果觉得这样还是不够详细，可以直接修改 MySQL 的参数来启动查询优化器的追踪。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一条查询语句在经过 MySQL 的查询优化器分析后，会生成一个所谓的执行计划，这个计划能够告诉我们接下来的查询的一些信息，比如单表采用哪种访问方法，多表连接的顺序，预估需要读取的记录数等等。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.nekolr.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://blog.nekolr.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 连接的原理</title>
    <link href="https://blog.nekolr.com/2020/09/07/MySQL%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.nekolr.com/2020/09/07/MySQL%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2020-09-07T11:56:00.000Z</published>
    <updated>2023-04-20T09:51:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>连接有内连接和外连接之分，而外连接又分为左外连接和右外连接，这些我们都很熟悉。提到连接就不得不提到驱动表和被驱动表的概念，因为是多表联查，肯定需要先查询一张表，然后拿着查询到的记录分别到另一张表中去匹配，这个过程中，首先查询的那张表就是驱动表，而另一张表就是被驱动表。而内连接与外连接的区别，本质就是驱动表中的记录即使在被驱动表中没有与之相匹配的记录时，我们是否仍要将其加入到最终的结果集当中。</p><span id="more"></span><p>对于左外连接来说，驱动表就是连接符号左侧的那张表，而被驱动表就是连接符号右侧的那张表，右外连接与之相反。对于内连接来说，谁是驱动表，谁是被驱动表，并不会对最终结果产生影响。在一般情况下，MySQL 会将数据量比较小的表作为驱动表，而数据量相对较大的表作为被驱动表。至于为什么会这么做，这就涉及到连接的原理了。</p><h1 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested-Loop Join）"></a>嵌套循环连接（Nested-Loop Join）</h1><p>对于使用连接的两张表来说，驱动表只会访问一遍，而被驱动表却要访问很多遍，具体多少遍取决于对驱动表执行单表查询后结果集的大小，之所以这么说，主要与连接的原理有关。我们以两张表 t1 和 t2 进行内连接查询为例，简单说一下连接的查询过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.f1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> t1.f2 <span class="operator">=</span> t2.m1 <span class="keyword">AND</span> t2.m2 <span class="operator">&lt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>首先需要选取一个驱动表，我们假设选择 t1 为驱动表，那么就需要使用与驱动表 t1 相关的过滤条件，选取代价最低的单表访问方法（access method）对驱动表进行单表查询，然后每查询到一条匹配的记录，就拿着它到被驱动表中去寻找相匹配的记录。需要强调的是，这种方式中的 MySQL 并不存储驱动表的查询结果，而是查到一条就操作一条。假设结果集中某条记录的 f2 &#x3D; 2，那么就相当于执行 <code>SELECT * FROM t2 WHERE t2.m1 = 2 AND t2.m2 &lt; 12</code>。整个过程如果用伪代码表示，大概类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 &#123;</span><br><span class="line">  for each row in t2 &#123;</span><br><span class="line">    if row match, send to client</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果有三张表进行连接的话，会将前两张表得到的结果集作为新的驱动表，第三张表作为被驱动表，重复上面的步骤，以此类推，我们可以知道 N 张表进行连接的查询过程。整个过程就像是一个嵌套的循环，这也解释了为什么驱动表只会访问一次，而被驱动表却会访问多次。这种连接执行的查询方式称为嵌套循环连接，这是一种最笨拙但也是最简单的连接查询方式。有人可能会说，被驱动表访问这么多次，会不会影响查询性能啊，与普通的单表查询相比，连接查询肯定是要更慢的，并且这在被驱动表数据量大且没有使用索引的情况下会更加严重。</p><p>现在回到一开始我们提出的那个问题，即为什么在进行内连接查询时，MySQL 会选择数据量相对较少的那张表作为驱动表，而选择数据量相对较大的那张表作为被驱动表。原因很简单，前面也说了，连接就是一个嵌套循环，驱动表是外循环，被驱动表是内循环。如果驱动表是那张大表，那么外循环的次数会变多，这也就导致了加载被驱动表数据页的 I&#x2F;O 次数增多；如果驱动表是小表，那么外循环的次数会变少，加载被驱动表数据页的 I&#x2F;O 次数也会减少。</p><p>我们假设被驱动表在数据量大的时候执行单表查询需要 3 次 I&#x2F;O，那么可能在数据量较小的时候需要 2 次 I&#x2F;O，驱动表在数据量较大时的结果集为 100 万条，数据量较小时的结果集为 2 万条，我们可以计算得出：在选择大表为驱动表，小表为被驱动表时的 I&#x2F;O 次数为 100 w * 2 &#x3D; 200 w；而选择小表为驱动表，大表为被驱动表时的 I&#x2F;O 次数为 2 w * 3 &#x3D; 6 w。</p><h1 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="基于块的嵌套循环连接（Block Nested-Loop Join）"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h1><p>嵌套循环的方式虽然简单，但是明显还有很大的优化空间。由于在驱动表中每查询到一条匹配的记录就要再到被驱动表中去查询，所以最终驱动表匹配的记录有多少条，就需要查询几次被驱动表，如果我们将驱动表查询到的结果先存起来，等达到一定的量之后，再一次性地到被驱动表中去查询，这样不就可以减少加载被驱动表的 I&#x2F;O 次数了吗？（将多条驱动表记录合并在一起作为条件到被驱动表中进行查询，很大概率会出现符合条件的记录在一个数据页中）这就是基于块的嵌套循环连接所采用的思想，它提供了一个称为 join buffer 的缓存，用来存储驱动表查询得到的部分记录，该缓存的大小可以通过参数 <code>join_buffer_size</code> 设置，默认大小为 256 KB。当缓存已满或者是最后一条记录的时候，才一次性地和被驱动表进行匹配，这样就可以显著减少加载被驱动表的 I&#x2F;O 次数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;连接有内连接和外连接之分，而外连接又分为左外连接和右外连接，这些我们都很熟悉。提到连接就不得不提到驱动表和被驱动表的概念，因为是多表联查，肯定需要先查询一张表，然后拿着查询到的记录分别到另一张表中去匹配，这个过程中，首先查询的那张表就是驱动表，而另一张表就是被驱动表。而内连接与外连接的区别，本质就是驱动表中的记录即使在被驱动表中没有与之相匹配的记录时，我们是否仍要将其加入到最终的结果集当中。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.nekolr.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://blog.nekolr.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 的单表查询</title>
    <link href="https://blog.nekolr.com/2020/09/04/MySQL%20%E7%9A%84%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <id>https://blog.nekolr.com/2020/09/04/MySQL%20%E7%9A%84%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-09-04T14:09:00.000Z</published>
    <updated>2023-04-20T09:51:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>从最简单的单表查询开始，能够更加简单直接地接触到 MySQL 中最基础的一些访问方法，结合 MySQL 的行记录、数据页以及索引结构的知识，在出现性能问题时才可以更有底气地应对。</p><span id="more"></span><p>在开始之前，首先我们创建一张表，其中 id 列创建聚簇索引，username 和 email 列创建二级索引，code 列创建唯一的二级索引，而 province、city 和 county 这三列创建一个联合索引。接着通过程序插入随机数据 100 万条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id         <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    username   <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    code       <span class="type">int</span>          <span class="keyword">null</span>,</span><br><span class="line">    email      <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    avatar     <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    province   <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    city       <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    county     <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,</span><br><span class="line">    key idx_username (username),</span><br><span class="line">    <span class="keyword">unique</span> key idx_code (code),</span><br><span class="line">    key idx_email (email),</span><br><span class="line">    key idx_address (province, city, county)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><h1 id="访问方法（access-method）"><a href="#访问方法（access-method）" class="headerlink" title="访问方法（access method）"></a>访问方法（access method）</h1><p>对于单表来说，MySQL 查询能够执行的方式大致有两种，一种是使用全表扫描，即扫描表的每一行记录，把符合条件的记录加入到结果集中。另一种就是使用索引查询，但是针对索引的查询也细分为很多种，比如针对主键或者唯一二级索引的等值查询，普通二级索引的等值查询，索引列的范围查询等等，这些都是 MySQL 执行查询时的访问方法。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>通过主键或者唯一二级索引进行等值查询时使用的就是 const，意为常数级别的访问方法，它的代价几乎可以忽略。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12286</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key    <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="keyword">PRIMARY</span>      <span class="operator">|</span><span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">4</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">=</span> <span class="number">12286</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>const<span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure><p>与主键不同的是，使用唯一二级索引作为查询条件时，如果没有覆盖索引，那么就需要回表。同时由于唯一二级索引并不限制 NULL（没有填充数据）的数量，所以在进行判空查询时无法使用 const，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+--------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+--------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span>const<span class="operator">|</span><span class="number">4</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+--------+-------+-----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>通过二级索引进行等值查询时使用的就是 ref，由于索引列的值相同的记录基本上是连续的，因此这种访问方式也是比较快的。但是二级索引的等值查询不是一定使用 ref 的访问方式，这取决于查询条件所匹配到的记录条数，如果匹配到的记录较少，那么回表的代价还是比较低的，此时可以使用 ref 的方式；如果匹配到的记录较多，那么 MySQL 可能会选择使用全表扫描的方式执行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+------------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+------------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1724</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+------------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure><p>对于包含多个索引列的二级索引（也叫联合索引）来说，只要符合最左匹配原则就可能采用 ref 的访问方式。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----+----+--------+-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> province <span class="operator">=</span> <span class="string">&#x27;山东省&#x27;</span> <span class="keyword">and</span> city <span class="operator">=</span> <span class="string">&#x27;济南市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>        <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span>idx_address  <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">606</span>    <span class="operator">|</span>const,const<span class="operator">|</span><span class="number">1</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+-----------+-------+-----------+----+--------+-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;济南市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">989489</span><span class="operator">|</span><span class="number">10</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure><h2 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h2><p>有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列值为 NULL 的记录也找出来，此时使用的就是 ref_or_null 的访问方法，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span> <span class="keyword">or</span> username <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+-------------+------------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span>  <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+-------------+------------+-------+-----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>ref_or_null<span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span>const<span class="operator">|</span><span class="number">1725</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+-------------+------------+-------+-----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure><p>上面的查询相当于分别从索引树中找出 username is null 和 username &#x3D; ‘Bob’ 的两个连续的记录范围，然后根据记录中的主键值回表查询完整的用户记录。</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>如果使用索引列进行范围查询，一般会使用 range 访问方法。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">in</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key         <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_username <span class="operator">|</span>idx_username<span class="operator">|</span><span class="number">303</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">3425</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+------------+-------+----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> code <span class="operator">&gt;=</span> <span class="number">122</span> <span class="keyword">and</span> code <span class="operator">&lt;=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key     <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+----+----+--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">range</span><span class="operator">|</span>idx_code     <span class="operator">|</span>idx_code<span class="operator">|</span><span class="number">5</span>      <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">179</span> <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> index <span class="keyword">condition</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+--------+-------+----+----+--------+---------------------+</span></span><br></pre></td></tr></table></figure><p>从上面的例子看，范围一般有单点区间和连续区间，单点区间只要多次使用索引的等值查询即可，而连续区间则只要找到区间的起始点，之后沿着该点向后顺序查询即可，速度也是比较快的。</p><p>总的来说，只要索引列和常数使用比较符号（等于、不等于、大于等于等等），<code>in</code> 和 <code>not in</code>，<code>is null</code> 和 <code>is not null</code>，以及 <code>between</code> 和 <code>like</code> 连接起来就可以产生一个区间，就可以使用 range 访问方法，但是 like 比较特殊，只有符合最左前缀匹配原则时才可以。</p><h2 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h2><p>有些特殊的查询会在一个查询中使用到多个索引，这种查询使用的访问方法就是 index_merge，即索引合并。索引合并的算法一般有三种：Intersection、Union、Sort-Union。</p><h3 id="Intersection"><a href="#Intersection" class="headerlink" title="Intersection"></a>Intersection</h3><p>所谓交集合并就是将从多个索引中查询到的结果取交集，比如下面这个：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span> <span class="keyword">and</span> email <span class="operator">=</span> <span class="string">&#x27;orghxctxih@cxmxz.gmz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys         <span class="operator">|</span>key                   <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span>idx_username,idx_email<span class="operator">|</span>idx_email,idx_username<span class="operator">|</span><span class="number">303</span>,<span class="number">303</span><span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">2</span>   <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">intersect</span>(idx_email,idx_username); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>整个过程就是分别将根据索引列查询得出的结果，然后根据结果中的主键值取交集，最后回表查询。这里我们可能会疑惑为什么不先拿到一个根据索引列查询的结果，然后在它的基础上进行回表查询并过滤第二个条件呢？这其实就要比较两种方式的成本。我们知道，读取二级索引是顺序 I&#x2F;O，而回表有很大可能是随机 I&#x2F;O，虽然使用交集合并的方式需要读取多个二级索引，但是多个索引合并后，交集的记录数一定要比只读取一个索引的记录数要少，需要回表的记录数也少，所以成本更低。</p><blockquote><p>一个查询使用多个索引列，有时候可能并不会像我们预料的那样使用索引合并，这取决于索引列能够匹配到的记录个数，如果记录数比较少，可能只是单纯的使用 ref 访问方式。</p></blockquote><p>一般只有在多个二级索引进行等值匹配（联合索引需要每个列都进行匹配，不能只匹配部分列）时才会使用 Intersection 索引合并，但是有些特殊的情况也可以使用，比如在主键列使用范围匹配的时候：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">12205</span> <span class="keyword">and</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+--------------------+--------------------+-------+----+----+--------+--------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys       <span class="operator">|</span>key                 <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+--------------------+--------------------+-------+----+----+--------+--------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span><span class="keyword">PRIMARY</span>,idx_username<span class="operator">|</span>idx_username,<span class="keyword">PRIMARY</span><span class="operator">|</span><span class="number">307</span>,<span class="number">4</span>  <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">852</span> <span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">intersect</span>(idx_username,<span class="keyword">PRIMARY</span>); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+--------------------+--------------------+-------+----+----+--------+--------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>对于这种特殊情况，我们只要记住一点，即：<strong>二级索引的索引列相同的记录是按照主键排序的</strong>。因此使用主键进行范围查询的结果可以很容易地跟二级索引的等值查询的结果进行取交集。</p><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>与 Intersection 类似的，只不过不再使用 and 取交集，而是使用 or 取并集。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;Bob&#x27;</span> <span class="keyword">or</span> email <span class="operator">=</span> <span class="string">&#x27;orghxctxih@cxmxz.gmz&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys         <span class="operator">|</span>key                   <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span>idx_username,idx_email<span class="operator">|</span>idx_username,idx_email<span class="operator">|</span><span class="number">303</span>,<span class="number">303</span><span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">3317</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">union</span>(idx_username,idx_email); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+----------------------+----------------------+-------+----+----+--------+------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>在拿到两个结果集之后，由于这两个结果集都是按照主键排序的，因此按照主键值进行合并也是比较容易的，只有合并后的结果集也是按照主键排序，回表时才能够降低成本。</p><h3 id="Sort-Union"><a href="#Sort-Union" class="headerlink" title="Sort-Union"></a>Sort-Union</h3><p>一般使用 Union 索引合并的条件太苛刻，必须保证每个二级索引都是等值匹配，比如下面这种就无法使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">in</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>) <span class="keyword">or</span> code <span class="operator">&lt;</span> <span class="number">2205</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+---------------------+---------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type       <span class="operator">|</span>possible_keys        <span class="operator">|</span>key                  <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span><span class="operator">|</span>filtered<span class="operator">|</span>Extra                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+---------------------+---------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index_merge<span class="operator">|</span>idx_code,idx_username<span class="operator">|</span>idx_username,idx_code<span class="operator">|</span><span class="number">303</span>,<span class="number">5</span>  <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">5628</span><span class="operator">|</span><span class="number">100</span>     <span class="operator">|</span><span class="keyword">Using</span> sort_union(idx_username,idx_code); <span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----------+---------------------+---------------------+-------+----+----+--------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>这是因为通过这两个索引列匹配到的结果集并不是按照主键排序的，但是我们可以将查询的结果再根据主键进行一次排序，这样就可以使用 Union 的方式进行索引合并。这种将多个根据索引列查询到的结果集进行再次排序，最后取并集的方式就是 Sort-Union。</p><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>当我们使用索引覆盖，但需要扫描全部的索引记录时，使用的就是 index 访问方法。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> province, city, county <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;青岛市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-----------+-------+----+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type <span class="operator">|</span>possible_keys<span class="operator">|</span>key        <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-----------+-------+----+------+--------+------------------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span>index<span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span>idx_address<span class="operator">|</span><span class="number">909</span>    <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">989489</span><span class="operator">|</span><span class="number">10</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+-----+-------------+-----------+-------+----+------+--------+------------------------+</span></span><br></pre></td></tr></table></figure><p>查询的字段都是索引列，因此可以使用覆盖索引，但是由于查询条件不符合最左前缀原则，所以只能对整个索引树（联合索引树）进行扫描，不过这颗树要比聚簇索引“小”很多，所以性能要比直接遍历聚簇索引（全表扫描）要好一些。</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>all 就是全表扫描，也就是直接遍历聚簇索引，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> avatar <span class="operator">=</span> <span class="string">&#x27;https://avatar.github.com/cjFQDo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span>id<span class="operator">|</span>select_type<span class="operator">|</span><span class="keyword">table</span> <span class="operator">|</span>partitions<span class="operator">|</span>type<span class="operator">|</span>possible_keys<span class="operator">|</span>key <span class="operator">|</span>key_len<span class="operator">|</span><span class="keyword">ref</span> <span class="operator">|</span><span class="keyword">rows</span>  <span class="operator">|</span>filtered<span class="operator">|</span>Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">1</span> <span class="operator">|</span>SIMPLE     <span class="operator">|</span><span class="keyword">user</span>  <span class="operator">|</span><span class="keyword">NULL</span>      <span class="operator">|</span><span class="keyword">ALL</span> <span class="operator">|</span><span class="keyword">NULL</span>         <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">NULL</span>   <span class="operator">|</span><span class="keyword">NULL</span><span class="operator">|</span><span class="number">989489</span><span class="operator">|</span><span class="number">10</span>      <span class="operator">|</span><span class="keyword">Using</span> <span class="keyword">where</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--+-----------+------+----------+----+-------------+----+-------+----+------+--------+-----------+</span></span><br></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>很多时候查询优化器并不会按照我们预想的方式进行查询，这都是基于查询成本考量下的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从最简单的单表查询开始，能够更加简单直接地接触到 MySQL 中最基础的一些访问方法，结合 MySQL 的行记录、数据页以及索引结构的知识，在出现性能问题时才可以更有底气地应对。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.nekolr.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://blog.nekolr.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>GC 日志分析</title>
    <link href="https://blog.nekolr.com/2020/09/03/GC%20%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>https://blog.nekolr.com/2020/09/03/GC%20%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</id>
    <published>2020-09-03T16:41:00.000Z</published>
    <updated>2023-04-20T09:51:11.102Z</updated>
    
    <content type="html"><![CDATA[<p>阅读和分析 GC 日志是处理 Java 虚拟机内存问题的一项基础手段，GC 日志是一些人为定义的规则，每一种收集器的日志形式可能都不太相同，但是虚拟机的设计者为了方便用户阅读，将各个收集器的日志都维持了一定的共性。本文是日志分析的一般流程描述。</p><span id="more"></span><p>遇到 Java 虚拟机进程的 CPU 占用率很高甚至达到百分之百，一般有两种情况：一种是大量地创建对象，导致频繁触发 GC，比如 OOM 导致频繁地 Full GC。另一种就是代码中有死循环或者接近死循环的操作。此时首先要拿到 Java 进程的进程号，我们可以 JDK 提供的工具，比如运行 <code>jps -l</code> 或者 <code>jcmd -l</code> 命令，也可以使用系统自带的命令，比如 <code>ps -ef | grep java</code>。</p><p>在拿到进程号以后，接下来就需要找出进程内占用 CPU 时间最多的线程，能够达到这个目的的命令有很多，比如使用 <code>top -Hp pid</code>，找到占用最多的那一条对应的 PID 即为线程 ID。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/znY.png" alt="top"></p><p>或者利用 ps 命令，比如使用 <code>ps -mp pid -o THREAD,tid,lwp,time</code>，查看占用 CPU 时间最多的线程。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/VAW.png" alt="ps"></p><p>接下来我们要使用 jstack 查看线程快照，这里需要注意的是，jstack 输出的线程信息包含一个 tid 和一个 nid，其中 tid 代表的是 Java 中的线程 ID，通过 <code>Thread.getId()</code> 可以得到。nid 意为 Native Thread Id，它在不同平台中的含义会有所不同，在 Linux 系统中，它代表的是线程的 pid，即 light-weight process id。由于 jstack 中的 ID 使用的是十六进制，因此我们使用 <code>printf &quot;%x\n&quot; pid</code> 将该线程号转换成十六进制，比如这里 13165 会被转换成 336d，然后使用 <code>jstack -l pid &gt; jstack.txt</code> 命令将线程快照输出到文件中，接着查找 tid 为 336d 的线程信息即可。</p><p>一般到这里，基本就可以判断出是 GC 线程繁忙还是业务线程繁忙，如果是业务线程繁忙，那么就需要定位具体的代码查找原因；如果是 GC 线程繁忙，此时就可以进入下一个环节，即 GC 日志分析。</p><p>Java 虚拟机提供的关于 GC 日志的参数有很多，常用的包括：<code>-XX:+PrintGC</code>（输出 GC 日志）、<code>-XX:+PrintGCDetails</code>（输出 GC 详细日志）、<code>-XX:+PrintGCTimeStamps</code>（输出 GC 的时间戳）、<code>-Xloggc:./gc.log</code>（输出 GC 日志到 gc.log 文件）。一般出现问题的 Java 进程并没有开启输出 GC 日志，此时需要不停机的设置参数，具体来说就是通过 <code>jinfo</code> 命令来动态添加参数，比如 <code>jinfo -flag +PrintGCDetails pid</code>。</p><p>这里使用 <code>-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</code> 参数，可以看到具体的 GC 内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/AN5.png" alt="GC 日志"></p><p>最前面的是虚拟机自启动以来到当前的秒数，对应的是 GC 发生的时间。GC 日志开头的“[ GC ”说明了此次垃圾收集的停顿类型，如果有“Full”，则表示此次发生了 Stop The World。接下来的 PSYoungGen 是与 Parallel Scavenge 收集器配套的新生代的称呼。接下来方括号内，箭头前代表的是 GC 前该内存区域已使用的容量，箭头后代表的是 GC 后该内存区域已使用的容量，圆括号中代表的是该内存区域的总容量。方括号之外的，180892K-&gt;64366K(210944K) 表示“GC 前 Java 堆已经使用的容量 -&gt; GC 后 Java 堆已使用的容量（Java 堆的总容量）”。再往后的 0.0032464 secs 表示此次 GC 的耗时，单位是秒。后面的 Times 中给出了更具体的时间信息，其中 user、sys 和 real 分别代表用户态消耗的 CPU 时间、内核态消耗的 CPU 时间、以及操作从开始到结束经过的墙上时间（Wall Clock Time）。</p><p>图中的例子可以看出，新生代在进行频繁的 GC 活动，我们也可以通过 <code>jstat -gc pid interval count</code> 命令来查看各个区的占用以及垃圾回收情况。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202009032223/2020/09/03/1ko.png" alt="jstat"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;阅读和分析 GC 日志是处理 Java 虚拟机内存问题的一项基础手段，GC 日志是一些人为定义的规则，每一种收集器的日志形式可能都不太相同，但是虚拟机的设计者为了方便用户阅读，将各个收集器的日志都维持了一定的共性。本文是日志分析的一般流程描述。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://blog.nekolr.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.nekolr.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器简介</title>
    <link href="https://blog.nekolr.com/2020/08/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://blog.nekolr.com/2020/08/28/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2020-08-28T16:45:00.000Z</published>
    <updated>2023-04-20T09:51:11.110Z</updated>
    
    <content type="html"><![CDATA[<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对于垃圾收集器应该如何实现并没有规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都有可能不同。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/6E7.png" alt="垃圾收集器汇总"></p><p>图中是 HotSpot 虚拟机中的垃圾收集器，它们作用于不同分代，如果两个收集器之间存在连线，那么就代表它们可以搭配使用。在 JDK 8 中，它们常见的搭配组合如下：</p><table><thead><tr><th>新生代</th><th>老年代</th><th>JVM Options</th></tr></thead><tbody><tr><td>Serial</td><td>Serial Old</td><td>-XX:+UseSerialGC</td></tr><tr><td>Parallel New</td><td>CMS</td><td>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</td></tr><tr><td>Parallel Scavenge</td><td>Parallel Old</td><td>-XX:+UseParallelGC -XX:+UseParallelOldGC</td></tr><tr><td>G1</td><td>G1</td><td>-XX:+UseG1GC</td></tr></tbody></table><h1 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h1><p>Serial 是最基本、发展历史最长的垃圾收集器，在 JDK 1.3.1 之前是新生代垃圾收集的唯一选择。它是一个单线程的收集器，同时它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/3Je.png" alt="Serial"></p><p>虽然 Serial 是一个串行的收集器，但是它简单而高效（相对于其他收集器的单线程来说），对于单个 CPU 的环境来说，Serial 收集器由于没有线程切换的开销，专心做垃圾收集可以获得较高的收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择。</p><h1 id="Parallel-New"><a href="#Parallel-New" class="headerlink" title="Parallel New"></a>Parallel New</h1><p>ParNew 垃圾收集器其实就是 Serial 垃圾收集器的多线程版本，除此之外并没有太多创新之处，很多运行在 Server 模式的虚拟机选择使用它作为新生代垃圾收集器的一个很重要的原因就是，除了 Serial 收集器外，只有它能够与 CMS 收集器配合工作。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/ooa.png" alt="ParNew"></p><p>ParNew 收集器在单 CPU 环境中比 Serial 收集器效果差，但是当 CPU 数量增加时，它可以在 GC 时更有效地利用系统资源。它默认开启的收集线程数与 CPU 的数量相当，当然也可以通过参数 <code>-XX:ParallelGCThreads</code> 自定义垃圾收集的线程数。</p><h1 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h1><p>Parallel Scavenge 也是新生代的垃圾收集器，它同样使用的是复制算法，同时也是并行的多线程收集器，但是它的关注点与其他收集器不同，像 CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 的目的则是为了达到一个可控制的吞吐量（Throughout）。所谓吞吐量是指 CPU 用于运行用户代码的时间与 CPU 总的消耗时间的比值，即吞吐量 &#x3D; 运行用户代码的时间 &#x2F; (运行用户代码的时间 + 垃圾收集的时间)，如果虚拟机总共运行了 100 分钟，其中垃圾收集花费了 1 分钟，那么吞吐量就是 99 %。</p><p>它提供了两个参数用于精确控制吞吐量，一个是用于控制最大垃圾收集停顿时间（<code>-XX:MaxGCPauseMillis</code>）的参数和一个直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数。MaxGCPauseMillis 可以是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过该值，但是我们需要明白 GC 停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的，比如我们把新生代设置的小一点，将原先的 500 MB 设置为 300 MB，这样垃圾收集的速度肯定快了，但是这也可能导致新生代由于内存空间不足而垃圾收集更加频繁，原来 10 秒收集一次，每次停顿 100 毫秒，现在变成了 5 秒收集一次，每次停顿 70 毫秒，停顿时间是下降了，但是吞吐量也跟着下降了。</p><p>GCTimeRatio 参数应当是一个大于 0 且小于 100 的整数 N，它将垃圾回收时间与应用程序运行的总时间的比率设置为 1 &#x2F; (1 + N)，所以当 N 为 19 时，表示垃圾回收的时间占总时间的比率为 5 %。N 的默认值为 99，即只有 1 % 的时间用于垃圾收集。</p><p>除了这两个参数外，还有一个 <code>-XX:UseAdaptiveSizePolicy</code> 参数，当该参数开启时，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 的比例（-XX:SurvivorRatio）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态地调整这些参数，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。</p><h1 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h1><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程的收集器，使用“标记-整理”算法，它对于运行在 Client 模式下的虚拟机的来说是一个很好的选择，而在 Server 模式下，它可以在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，或者作为 CMS 收集器的后备预案。</p><h1 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h1><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用“标记-整理”算法，在 JDK 1.6 才开始提供，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态，因为它除了和 Serial Old 收集器搭配外别无选择。由于老年代的 Serial Old 收集器在服务端性能上的“拖累”，使得即使是使用了 Parallel Scavenge 收集器也未必能在整体上获得吞吐量最大化的效果。</p><h1 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h1><p>CMS（Concurrent Mark Sweep）是一种以获取最短回收停顿时间为目标的收集器，它基于“标记-清除”算法实现，它的运作过程相对于前面的几种收集器来说更为复杂，整个过程分为四个步骤：初始标记（CMS initial mark）、并发标记（CMS concurrent mark）、重新标记（CMS remark）和并发清除（CMS concurrent sweep），其中初始标记和重新标记都需要“Stop The World”。</p><p>初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing 的过程，而重新标记则是为了修正并发标记期间因用户程序继续执行而导致标记产生变动的哪些对象的标记，这个阶段停顿的时间一般比初始标记要稍长，但又远比并发标记时间短。整个过程中，并发标记和并发清除阶段的收集器线程都可以与用户线程同时运行，所以总体上来说，CMS 收集器的内存回收过程几乎是与用户线程一起并发执行的。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/28/B7e.png" alt="CMS"></p><p>CMS 是一款优秀的垃圾收集器，它可以并发收集，能够做到低停顿，但是它有几个明显的缺点，比如对于 CPU 资源非常敏感（面向并发设计的程序对于 CPU 资源都比较敏感）。CMS 默认启动的回收线程数为(CPU 数 + 3) &#x2F; 4，在并发阶段，它虽然不会导致用户线程停顿，但是有可能会因为占用了一部分 CPU 资源而导致用户程序变慢。</p><p>还有就是它无法处理浮动垃圾（Floating Garbage），可能会导致出现 Concurrent Mode Failure 从而引发一次 Full GC。由于在 CMS 在并发清除阶段用户线程还在运行，自然就会有新的垃圾不断产生，这部分垃圾出现在标记过程之后，CMS 无法在当次集中回收它们，只好等待下一次 GC。因此，CMS 收集器不能像其他收集器那样在老年代快要填满时才进行收集，它需要预留一部分空间给并发收集期间的用户线程使用。通过 <code>-XX:CMSInitiatingOccupancyFraction</code> 参数可以调整触发收集时老年代的使用比例。在 JDK 1.5 中，该阈值为 68 %，而在 JDK 1.6 中则提高到了 92 %，并且如果 CMS 运行期间预留的内存无法满足需要时，会出现 Concurrent Mode Failure 并启动预备方案：临时启动 Serial Old 重新进行老年代的垃圾收集。</p><p>由于 CMS 是基于“标记-清除”算法实现的，这就意味着垃圾收集后可能会产生大量的内存空间碎片，这会给后来的大对象内存分配带来麻烦，可能老年代还有很大的内存空间剩余，但是却无法找到足够大的连续空间进行分配，从而不得不提前触发一次 Full GC。为了解决这个问题，CMS 提供了内存碎片合并整理的功能，但是整理的过程是无法并发的，碎片问题没有了，但是停顿时间也增加了。</p><h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>G1 在 JDK 1.7 中正式发布，它的使命是替换掉 JDK 1.5 中发布的 CMS 收集器。G1（Garbage First）是一款分代、增量、并行、大部分时间并发的垃圾收集器，从整体上看它是基于“标记-整理”算法。</p><p>G1 中虽然还有分代的概念，但是它进行垃圾收集的范围却是整个堆，它将堆划分为多个大小相等的独立区域（Region），每个 Region 内都是一些连续的虚拟内存。Region 是进行内存分配和回收的基本单位，在某个特定的时间点，一个 Region 可能是空闲的（图中浅灰色区域），也有可能被分配到了某个分代（generation）中，可能是新生代或者老年代。当收到内存分配的请求时，内存管理器就会将空闲的 Region 分配给某个分代，然后将它们作为可分配自身的可用空间返回给应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/30/lV9.png" alt="G1 Heap Layout"></p><p>图中的红色区域和标有 S 的红色区域分别为新生代的 Eden 区和 Survivor 区，这些 Region 在内存中通常是物理上不连续的。浅蓝色的 Region 组成了老年代，标有 H 的浅蓝色区域代表的是大对象（Humongous）Region，这些对象可以横跨多个 Region。</p><p>G1 进行垃圾收集的生命周期可以分为两个阶段：Young-only 阶段和 Space-reclamation 阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008312103/2020/08/30/jjL.png" alt="G1 垃圾收集的生命周期"></p><p>Young-only 阶段从新生代的一些 Young GC 开始。Young GC 采用复制算法，并行收集，垃圾收集时会发生 STW 暂停，活跃的对象被复制到 Survivor 区域，如果达到晋升的阈值，对象会晋升到老年代的区域。与其他垃圾收集器不同的是，G1 会根据预测的停顿时间动态地调整新生代的大小。当老年代空间的占用率达到一个阈值时（具体来说是整个堆的空间占用达到一个阈值，该阈值通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 参数控制，默认为 45，即 45 %）就会开始 Young-only 阶段到 space-reclamation 阶段的转换，这个过程的第一个子阶段就是 Concurrent Start。</p><p>在 Concurrent Start 阶段，G1 除了会进行 Young GC 外，还会根据新生代 Survivor 区以及老年代的 Remembered Set（记录对象的引用关系，加快活跃对象的遍历）开始并发标记的过程，此时会启动多个并发的标记线程，每个线程每次只扫描一个 Region，标记出存活对象。这个过程不需要 STW，因此用户线程可以与标记线程并发执行。</p><blockquote><p>这里需要说明的是，在并发标记之前的 Young GC 其实也是初始标记的过程，因为在 Young GC 的过程中，首先会查找直接可达的一些根对象（栈对象、全局对象、JNI 对象等），然后暂停用户线程进行初始标记并进行内存回收。其实混合回收（Mixed GC）就是借用了新生代回收的结果，即将新生代进行垃圾回收后的 Survivor 区作为根。</p></blockquote><p>接下来就是 Remark 阶段，在这个阶段中 G1 需要 STW，找出所有未被访问的存活对象，做全局的引用处理和类卸载，回收全空的 Region 并清理内部的数据结构，计算老年代可回收的空间，最终结束并发标记的过程。然后就是清理阶段（Cleanup），该阶段也需要 STW，并在该停顿中决定是否要开始 Space-reclamation 阶段。</p><p>Space-reclamation 阶段由多个 Mixed GC 组成，Mixed GC 不光回收新生代的 Region，同时也会回收老年代的 Region。当 G1 发现无法回收更多的老年代内存时，该阶段就结束了，接着会重新回到 Young-only 阶段开始一个新的回收周期。同时为了以防万一，在收集存活对象的时候，如果应用内存耗尽了，G1 也会像其他收集器那样进行整个堆的 STW 压缩，即 Full GC。</p><h1 id="ZGC-和-Shenandoah"><a href="#ZGC-和-Shenandoah" class="headerlink" title="ZGC 和 Shenandoah"></a>ZGC 和 Shenandoah</h1><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><table><thead><tr><th>JDK 版本</th><th>默认的垃圾收集器</th></tr></thead><tbody><tr><td>JDK 7</td><td>Parallel Scavenge + Parallel Old</td></tr><tr><td>JDK 8</td><td>Parallel Scavenge + Parallel Old</td></tr><tr><td>JDK 9</td><td>G1</td></tr><tr><td>JDK 11</td><td>G1</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep">GC Algorithms: Implementations</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/aspirant/p/8663872.html">G1 垃圾收集器架构和如何做到可预测的停顿</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对于垃圾收集器应该如何实现并没有规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都有可能不同。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://blog.nekolr.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.nekolr.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 性能分析之火焰图</title>
    <link href="https://blog.nekolr.com/2020/08/27/Java%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8B%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    <id>https://blog.nekolr.com/2020/08/27/Java%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8B%E7%81%AB%E7%84%B0%E5%9B%BE/</id>
    <published>2020-08-27T12:44:00.000Z</published>
    <updated>2023-04-20T09:51:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>在程序运行期间，可能会因为某段代码大量占用 CPU 时间而拖累整个应用的执行，能够快速定位这类热点代码的性能分析工具有很多，这里介绍的火焰图比较特殊，它可以将很多性能分析工具的采样结果以一种更加直观的方式展现出来，从而快速定位热点问题。</p><span id="more"></span><p>网上很多关于火焰图的讲解最初来自于 Brendan Gregg 的博客文章：<a href="http://www.brendangregg.com/flamegraphs.html">Flame Graphs</a>，火焰图的效果大致如下图：</p><embed src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008271727/2020/08/27/RjK.svg" width="900" height="563.4" type="image/svg+xml" /><p>该火焰图是一个 SVG 格式的文件，由开源工具：<a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> 生成。图中的每个色块代表的是一个线程栈帧，色块中是该栈帧加载执行的函数以及一些采样信息。Y 轴代表调用栈的深度，调用从底部开始向上进行，顶部是正在执行的函数，下面是它的父函数，调用栈越深，火焰就越高。X 轴代表抽样数，如果一个函数在 X 轴占据的宽度越大，表示它被抽取到的次数越多，也就意味着它占用的 CPU 时间越长。</p><blockquote><p>需要注意的是，图中的颜色并不重要，只用于区分不同的函数，同时 X 轴的从左到右的顺序也不重要，默认按照字典顺序排序。</p></blockquote><p>我们可以简单举个例子来理解。一般在使用性能分析工具时，我们会选取一个合适的时机启动分析采样，然后等待一段时间后停止采样。假设采样时间为 20 秒，每秒采样 100 次，那么共采样 2000 次，在这 2000 次中，共有 1800 次执行的是 main 方法，其余 200 次执行的是 run 方法，同时 main 方法又调用了很多其他方法，run 方法也是，这就形成了一个从下往上的调用链，在这些调用链中，又同时会收集到每个方法采样的次数，最终形成一张火焰图。</p><p>火焰图是可以互动的，点击某个色块，该色块会被放大并占据所有的宽度，这样可以方便地查看某个函数内部的调用链信息。一般观察火焰图，就是看顶层函数占用的宽度，如果有些函数占用的宽度很大，形成了“平顶”，那么就代表该函数可能存在性能问题。当然，有时候直接观察平顶并不能快速定位问题，因为很多时候顶部的函数都是一些底层的库函数，这时候就应该先观察业务代码在火焰图中的宽度，然后再往上观察顶部的库函数来缩小范围。</p><p>IDEA 集成了 <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> 和 Java Flight Recorder（JFR），可以通过它们来生成火焰图。由于 JFR 是商用工具，因此在启动 JVM 的时候需要添加解锁商业 feature 的参数：<code>-XX:+UnlockCommercialFeatures</code>。而 async-profiler 不能在 windows 平台使用，更多信息可以查看 IDEA 官方文档：<a href="https://www.jetbrains.com/help/idea/async-profiler.html">https://www.jetbrains.com/help/idea/async-profiler.html</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://www.brendangregg.com/blog/2014-06-12/java-flame-graphs.html">Java Flame Graphs</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在程序运行期间，可能会因为某段代码大量占用 CPU 时间而拖累整个应用的执行，能够快速定位这类热点代码的性能分析工具有很多，这里介绍的火焰图比较特殊，它可以将很多性能分析工具的采样结果以一种更加直观的方式展现出来，从而快速定位热点问题。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://blog.nekolr.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.nekolr.com/tags/JVM/"/>
    
    <category term="性能分析" scheme="https://blog.nekolr.com/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Raft 共识算法</title>
    <link href="https://blog.nekolr.com/2020/08/15/Raft%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.nekolr.com/2020/08/15/Raft%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-15T10:47:00.000Z</published>
    <updated>2023-04-20T09:51:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>Paxos 算法偏向于理论，对于如何应用到工程实践上较少提及，同时 Paxos 算法较难理解且复杂性很高，目前能够真正在生产环境中独立使用的成品很少，已知的基础库，比如 Tencent 的 <a href="https://github.com/Tencent/phxpaxos">phxpaxos</a> 早在 2016 年开源，并在很久之前就停止维护了。阿里的 X-Paxos 只有文章介绍，并不开源。</p><span id="more"></span><p>Raft 在 2013 年提出，为了更容易理解和实施，Raft 将分布式问题分解和具化，由一个强有力（比 Paxos 的 leader 更强）的 leader 统一处理变更请求，使用 term 作为逻辑时钟来保证时序，一致性具化为保证节点间的操作日志副本（log replication）一致。</p><h1 id="Raft-算法的目标：日志复制同步"><a href="#Raft-算法的目标：日志复制同步" class="headerlink" title="Raft 算法的目标：日志复制同步"></a>Raft 算法的目标：日志复制同步</h1><p>Raft 算法的目标是将日志完整地复制到集群所有的节点中，这些复制日志会被状态机（可以理解为一个函数）所使用，只要我们能够保证各个节点上的日志是相同的，那么各个节点上的状态机就能以相同的顺序执行相同的命令，得到一致的结果。</p><p>Raft 算法允许服务器崩溃，不过它更希望是 fail-stop 式的崩溃，也就是说，节点只是停止工作或者停止工作又恢复了，但是要求只要节点处于运行状态，那么它们的行为就必须是正确的，这就意味着节点不能有拜占庭式的故障。同时 Raft 算法还允许网络通信中断，消息延迟或者丢失，甚至消息无序，网络分化。</p><h1 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h1><p>任何时候，节点只会有以下三种状态或角色：</p><ul><li>领导者（Leader）<br>Leader 负责处理客户端的请求，同时还负责处理日志的复制同步。任何时候只会有一个 Leader。</li><li>跟随者（Follower）<br>绝大多数节点在大部分时间下都是 Follower 状态，同时 Follower 不会主动发起任何 RPC 调用，它们只能被动地接收请求并响应。</li><li>候选者（Candidate）<br>处于领导者和跟随者之间的状态，只会在选举新 Leader 的过程中临时出现。</li></ul><h1 id="领导者任期（term）"><a href="#领导者任期（term）" class="headerlink" title="领导者任期（term）"></a>领导者任期（term）</h1><p>在 Raft 中，时序被分割为领导者任期。每段领导者任期都有一个序号，这些序号随着任期数的增加会自动增长，不会重复使用。任期由选举开始（选举开始前，term 先自增），成功当选的领导者会服务至本任期结束。也有可能存在任期内没有领导者的情况，比如出现分票（Split Vote），即不存在获得大多数投票的领导者，当发生这种情况时，系统会马上进入下一个新的任期（term 增长）并尝试重新选举。在 Raft 中，所有的节点都会保持一个当前任期的值，同时该值还会被持久化到本地磁盘中，以保证节点崩溃后能够恢复。</p><h1 id="心跳检测及超时处理"><a href="#心跳检测及超时处理" class="headerlink" title="心跳检测及超时处理"></a>心跳检测及超时处理</h1><p>跟随者是被动的，为了让它们一直处于跟随者状态，需要集群中有一个领导者始终与它们保持通信，如果领导者没有主动发起日志复制的请求，那么领导者就必须定时向它们发送心跳检测消息，在 Raft 中，这些心跳检测消息只是一些不含有任何数据信息的 AppendEntries 远程调用。如果在一段时间内，跟随者没有收到任何的远程调用，那么它会认为集群中没有可达或者可用的领导者，因此它就会开始发起选举，看它是否有必要称为新的领导者。这段时间被称为选举超时（election timeout），通常这个时间为 100 ms 到 500 ms。</p><h1 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h1><p>当集群启动时，所有的节点都是跟随者，它们会等待选举超时结束后开始选举。节点在开始选举时，首先会增加当前的任期号，然后会将自己的状态转换为候选者状态，此时候选者会先给自己投票，然后再向其他所有的节点发送投票请求（Request Vote），如果该请求没有得到响应，它会持续发送重试的请求，知道获得响应为止。接下来可能会出现三种情况：</p><ul><li>第一种，就是大多数情况，获选者获得了大多数选票，然后它会将自己的状态改为领导者并持续向集群的其他节点发送心跳检测。</li><li>第二种，可能同时还有其他候选者在运行，或许它们有可能获得大多数选票成为领导者，此时如果候选者收到来自领导者的 RPC 调用，那么它会立刻从候选者状态转换为跟随者状态。</li><li>第三种，可能没有任何节点获胜，如果存在多个节点同时成为候选者，它们会导致分票，没有节点能够获得大多数投票。为了检测这种情况，随着时间的推移，如果一个候选者既没能成为领导者，也没有获得到来自领导者的请求或心跳，那么它就会假定出现了分票，此时它会简单地增加任期号，重新进行选举。</li></ul><h2 id="选举的-safety-和-liveness"><a href="#选举的-safety-和-liveness" class="headerlink" title="选举的 safety 和 liveness"></a>选举的 safety 和 liveness</h2><p>为了保证选举的 safety，每个节点只会给一个候选者投票，一旦它投出选票，那么它就会拒绝来自其他候选者的任何请求。为了实现这种机制，节点会将自己的投票信息持久化到磁盘。</p><p>在理论上，可能会出现反复分票的情况，多个获选者在同一任期内同时开始选举，在超时时间后，新一轮的选举再次出现分票，如此循环。为了保证选举的 liveness，每个节点会随机地计算下次超时时间间隔，这个时间间隔在 [T, 2T] 之间，其中 T 代表选举的超时时间。通过将超时时间分散，可以降低两个节点同时开始选举的几率，先开始的节点有充足的时间向其他节点发送投票请求，并在其他节点参与竞争之前就完成选举过程。</p><blockquote><p>当选举超时时间（election timeout）远大于广播投票的时间（一个节点与其他所有节点通信所需的时间）时，Raft 的这个策略就会非常有效。</p></blockquote><h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><p>日志由有序序号（log index）标记的条目组成，每个条目都包含创建时的任期号（term）和一个状态机需要执行的指令。客户端的每一个请求都包含一条被复制状态机执行的指令，领导者会将这个指令作为一条新的日志条目附加到日志中，然后并行地向其他节点发送附加日志条目（AppendEntries）的请求，当过半的节点成功复制并响应请求后，该日志条目就是<strong>已提交</strong>的，此时领导者会将该日志条目应用到状态机中，并把状态机执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，或者网络丢包，领导者会不断重复尝试发送附加日志条目的请求（尽管已经达到了多数派并将结果返回给了客户端），直到所有的跟随者都最终存储了所有的日志条目。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008241748/2020/08/21/YNE.png" alt="日志复制"></p><h2 id="日志的一致性检查"><a href="#日志的一致性检查" class="headerlink" title="日志的一致性检查"></a>日志的一致性检查</h2><p>Raft 的日志机制维护着以下特性：如果在不同的日志中，两个条目拥有相同的索引和任期号，那么它们存储了相同的指令，同时它们之前的所有日志条目也全部相同。</p><p>为了维护以上特性，领导者在一个任期内，一个索引位置只会创建一个日志条目，并且日志条目一旦创建，位置就不会改变。同时在发送附加日志请求时，领导者会把新日志条目紧挨着的前一个日志条目的索引位置和任期号也一并发送，如果跟随者在它本地的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝接受新的日志条目，这就是日志的一致性检查。</p><h2 id="领导者变更"><a href="#领导者变更" class="headerlink" title="领导者变更"></a>领导者变更</h2><p>在正常的操作中，领导者和跟随者的日志保持一致，所以这种一致性检查不会失败。然而，当领导者崩溃就有可能使得日志处于不一致的状态（新的领导者可能还没有完全复制所有的日志条目），并且这种不一致会在领导者和跟随者的一系列崩溃下加剧。下图展示了跟随者的日志可能和新的领导者不同的几种方式。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008241748/2020/08/21/MPg.png" alt="不一致"></p><p>当一个领导者成功当选时，跟随者可能是任何情况，比如图中的 a 到 f。图中的每个格子代表一条日志条目，其中的数字是任期号。此时新领导者的任期号是 8，跟随者可能会缺少一些条目，比如 a 和 b。也有可能会有一些未被提交的日志条目，比如 c 和 d。还有可能两种情况都存在，比如 e 和 f。在 f 中，该机器在任期号为 2 时是领导者，同时附加了一些日志条目到自己的日志中，但是在提交之前就崩溃了，然后该机器很快就重启了，并在任期号为 3 时再次当选，同时又附加了一些日志条目到自己的日志中，而在任期号为 2 和 3 的日志被提交之前，该机器又崩溃了，并在接下来的几个任期里一直处于宕机状态。</p><p><strong>在 Raft 算法中，领导者处理不一致是通过强制跟随者复制自己的日志来解决的，这就意味着在跟随者中的冲突日志条目会被领导者的日志覆盖</strong>。</p><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>前面描述了 Raft 算法是如何实现选举和日志复制的，但是通过目前描述的机制是不能充分保证每一个状态机都会按照相同的顺序执行相同的指令。比如，一个跟随者可能进入了不可用状态，而此时的领导者已经提交了若干的日志条目，如果这个跟随者在之后被选举成了领导者并覆盖了这部分日志条目，就会造成不同的状态机可能会执行不同的指令序列。因此，需要我们在进行领导者选举时增加一些限制，来保证对于任意给定的任期号，被成功选举出的领导者都拥有之前任期的所有被提交的日志条目。同时增加这条限制，也使得我们在提交时的规则更加清晰。</p><h2 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h2><p>在选举时，候选者为了胜选必须联系集群中大部分的节点，这就意味着每一个已经提交的日志条目肯定存在于这些节点中的至少一个节点上。如果候选者的日志至少和大多数节点一样新，那么它一定持有了所有已经提交的日志条目。选举的投票请求（Request Vote）中会包含候选者最后一条日志条目的索引值和任期号，接收到该请求的投票者会比较这两个值，如果任期号不同，那么任期号大的更新；如果任期号相同，那么索引号大的日志更新。当候选者的日志没有投票者的新时，投票者会拒绝该投票请求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Paxos 算法偏向于理论，对于如何应用到工程实践上较少提及，同时 Paxos 算法较难理解且复杂性很高，目前能够真正在生产环境中独立使用的成品很少，已知的基础库，比如 Tencent 的 &lt;a href=&quot;https://github.com/Tencent/phxpaxos&quot;&gt;phxpaxos&lt;/a&gt; 早在 2016 年开源，并在很久之前就停止维护了。阿里的 X-Paxos 只有文章介绍，并不开源。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Paxos 共识算法</title>
    <link href="https://blog.nekolr.com/2020/08/13/Paxos%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.nekolr.com/2020/08/13/Paxos%20%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2020-08-13T13:59:00.000Z</published>
    <updated>2023-04-20T09:51:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>共识算法的主要目的是屏蔽掉故障节点产生的噪音，从而让系统能够正常运行下去，常用于选举和状态机复制（state machine replication）。在保证 liveness 的同时，对 agreement 条件放宽了要求，它接受不一致是常态的事实，既然无法知道某些节点是 crash 还是消息延迟，那么只关心能够正确响应的节点，只要它们能够表决过半即可。过半表决意味着虽然没有达成完全一致，但是投票结果已经被过半的节点所继承，这样任何两个 quorum 一定会存在交集（比如 A、B、C 三个节点，两个 quorum 比如 AB 和 BC 一定会有交集 B），所以它们最终一定能通过消息交互而达成一致。</p><span id="more"></span><p>Paxos 算法由 Lamport 提出，他为了描述该算法，虚拟出了一个叫做 Paxos 的希腊城邦，这个城邦按照民主投票的方式制定法令，但是没有人愿意将自己的全部时间和精力放在这上面，无论是提议者还是接收者亦或是信使，他们只会不定时地来参加提议。Paxos 算法的目的就是让他们按照少数服从多数的方式达成一致的意见。在他的论文中，Paxos 共有三种不同的变种：Basic Paxos、Multi Paxos 和 Fast Paxos。</p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul><li><p>Client<br>客户端，可以理解为普通民众，他们不直接参与提议，但是他们会希望通过一个对自己有利的法令。</p></li><li><p>Proposer<br>提议者，可以理解为议员，他们接收 Client 的请求，代表民众向议会中的其他议员提出提议（Proposal），并在发生冲突时起到调节的作用。</p></li><li><p>Acceptor<br>提议接收者，可以理解为议会中的其他议员，他们接收提议者提出的提议，只有接收到提议的成员达成法定人数（quorum，一般为 majority 多数派）时，提议才会形成法令。</p></li><li><p>Learner<br>同样也是提议接收者，只不过他们并不参与提议过程，有点像议会记录人员，只负责记录已经通过的法令。</p></li></ul><h1 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h1><p>Basic Paxos 分为两个大的阶段，同时每个大的阶段又分为两个小的阶段。</p><ol><li><p>Phase 1a：Prepare</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br></pre></td></tr></table></figure><p>proposer 向任意一个多数派 acceptor 集合发起一个编号 number 为 n 的预请求（prepare request）。</p></li><li><p>Phase 1b: Promise</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |  &lt;ok, null, null&gt;  |</span><br><span class="line">   |&lt;-------------------|</span><br></pre></td></tr></table></figure><p>如果一个 acceptor 接收到了预请求，并且预请求的编号 n 大于任何它之前已经回复过的请求（包含 prepare request 和 accept request），那么它将承诺不再接受任何编号小于 n 的提议（proposal），并回复已经接受的编号最大的提议（如果有的话）。</p></li><li><p>Phase 2a: Accept</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |  &lt;ok, null, null&gt;  |</span><br><span class="line">   |&lt;-------------------|</span><br><span class="line">   |                    |</span><br><span class="line">   |    accept(n, v)    |</span><br><span class="line">   |-------------------&gt;|</span><br></pre></td></tr></table></figure><p>如果 proposer 接收到了来自 acceptor 对它预请求的回复，那么接下来它就可以向多数派 acceptor 集合（可以不是回复预请求的那个集合）发送一个 number 为 n，value 为 v 的提议（proposal）。其中的 v 要么是 proposer 自定义的值，要么就是预请求响应中的 value 值。我们将这样的一个请求称为 accept request。</p></li><li><p>Phase 2b: Accepted</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">proposer             acceptor</span><br><span class="line">   |                    |</span><br><span class="line">   |     prepare(n)     |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |  &lt;ok, null, null&gt;  |</span><br><span class="line">   |&lt;-------------------|</span><br><span class="line">   |                    |</span><br><span class="line">   |    accept(n, v)    |</span><br><span class="line">   |-------------------&gt;|</span><br><span class="line">   |                    |</span><br><span class="line">   |     &lt;ok, n, v&gt;     |</span><br><span class="line">   |&lt;-------------------|</span><br></pre></td></tr></table></figure><p>如果 acceptor 接收到了 number 为 n 的 accept request，并且它没有对 number 大于 n 的 prepare request 进行过回复，那么就接受这个 accept request。</p></li></ol><p>Basic Paxos 算法中还有很多细节，可能通过上述步骤并没有很好地展现出来，这里简单列举一下：</p><ul><li><p>acceptor 必须接受它收到的第一个 proposal。并且通过上述步骤可以发现，如果一个 value 为 v 的 proposal 被选中，那么所有被选中的拥有更大编号的 proposal 的 value 值也都是 v。</p></li><li><p>acceptor 本地主要存储两个值，一个是已经接受的 proposal，另一个就是回复过的 prepare request 中最大的编号。</p></li><li><p>acceptor 总是能够对 prepare request 进行回复，除非 acceptor 还没有接受一个 proposal，同时这个 prepare request 的编号小于 acceptor 已经回复过的 prepare request 中最大的编号。</p></li><li><p>与我们的常识不同，每个 proposer 并不会执着于自己的提议通过，而是会努力让一个提议尽快达成一致。</p></li><li><p>上面没有画出 learner，但是在 acceptor 接受了一个 proposal 之后，需要 acceptor 将这个 proposal 发送给所有的 learner，由 learner 来确定是否有一个 proposal 已经被多数派接受了，之后 learner 会将最终结果发送给 Client。</p></li></ul><h2 id="Basic-Paxos-的潜在问题"><a href="#Basic-Paxos-的潜在问题" class="headerlink" title="Basic Paxos 的潜在问题"></a>Basic Paxos 的潜在问题</h2><p>在 prepare request 阶段可能会出现活锁，即多个 proposer 不断拿着比其他人更大的 number 来发起 prepare request，导致算法一直停留在第一阶段，可以看出，这是一个关于 liveness 的问题。目前工业界的解决方案很简单，就是在发生冲突时，加入随机等待时间，在 timeout 之后再发起 prepare request。</p><p>Basic Paxos 还有一些其他问题，比如可能比较难以实现，同时由于需要两轮 RPC，导致效率较低。</p><h1 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h1><p>Basic Paxos 通过多轮的 prepare&#x2F;accept 过程来确定一个值，我们可以称这整个过程为一个 instance。而如果需要确定很多个值，那么每个值的确定都需要经过一个 instance，显然效率不是很高。而 Multi Paxos 就是通过改变 promise 的生效范围至全局的 instance，使得我们之后可以省略第一阶段的工作（即使不 prepare 就直接 accept 也是安全的，因为 accept 已经被其中某个节点 promise 过了）。</p><p>上面的说法有些抽象，具体来说就是：首先也是有一些 proposer，但是依靠某种机制（比如 Raft 中的随机超时时间），proposer 集合中的某一个 proposer 自发地想成为 leader，此时它需要向 acceptor 集合中发起与 Basic Paxos 类似的两轮 RPC，在形成了多数派之后，此 proposer 才会正式成为 leader。接下来就通过 leader 来发起提议，并且不需要向 acceptor 集合发起 prepare request，直接发起 accept request 即可。</p><p>需要注意的是，Multi Paxos 是允许并行提交的，这就意味着可以不通过 leader 发起提议，但是这种情况下效率就会降低。比如在有一个 leader 的情况下，另一个 proposer 发起提议，就会导致 leader 的 accept 不被接受，此时就退化成了 Basic Paxos。因此我们希望大部分时间只有一个节点在提交，这样才能发挥 Multi Paxos 的优化效果。那么为了避免或者说是降低这种情况的发生，就需要一些控制：如果一个节点向其他节点发送 accept request，并且最后收到了来自其他节点的 accepted 回复，那么这个节点会认为自己是 leader，它会在一段时间内，拒绝其他节点的 prepare 请求。如果一个节点收到了来自其他节点的 accept request，那么它会认为请求方是 leader，并承诺在一段时间内不会发起 prepare request。正是这种“默契”才间接地说明了 leader 的存在，所以说在 Multi Paxos 中，leader 不是靠选举产生的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/21466932">Paxos 理论介绍(2): Multi-Paxos 与 Leader</a></p></blockquote><blockquote><p>《Paxos Made Simple》</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;共识算法的主要目的是屏蔽掉故障节点产生的噪音，从而让系统能够正常运行下去，常用于选举和状态机复制（state machine replication）。在保证 liveness 的同时，对 agreement 条件放宽了要求，它接受不一致是常态的事实，既然无法知道某些节点是 crash 还是消息延迟，那么只关心能够正确响应的节点，只要它们能够表决过半即可。过半表决意味着虽然没有达成完全一致，但是投票结果已经被过半的节点所继承，这样任何两个 quorum 一定会存在交集（比如 A、B、C 三个节点，两个 quorum 比如 AB 和 BC 一定会有交集 B），所以它们最终一定能通过消息交互而达成一致。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统相关概念</title>
    <link href="https://blog.nekolr.com/2020/08/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://blog.nekolr.com/2020/08/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2020-08-10T15:43:00.000Z</published>
    <updated>2023-04-20T09:51:11.110Z</updated>
    
    <content type="html"><![CDATA[<p>主要简单概括一下分布式系统中的网络和故障模型、共识问题、拜占庭将军问题、FLP 定理等等。</p><span id="more"></span><h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p>更确切的说是<strong>交互模型</strong>。在分布式系统中，很难对进程执行、消息传递以及时钟漂移的时间设置限制，所以两种截然相反的观点提供了一对简单的模型：同步分布式系统和异步分布式系统。</p><p>Hadzilacos 和 Toueg 在 1994 年定义了一个同步分布式系统，它满足以下约束：</p><ul><li>进程执行的每一步操作都有时间上限和下限。</li><li>消息会在一个已知的时间范围内被接收到。</li><li>每个进程的本地时钟与实际时间的偏移率在一个已知的范围内。</li></ul><p>在同步分布式系统中，由于所有的节点的时间偏移有上限，消息的传输延迟也有上限，节点会在指定的时间内完成计算，所以一旦超过一定的时间还没有收到消息的应答，我们就可以断定要么网络中断，要么节点 crash。与同步分布式系统相反，异步分布式系统中进程的执行速度是变化的，消息的传递延迟无上限，进程内时钟的漂移不可预知，在这种模型中，发送给一个节点的消息很久都没有接收到应答，可能是因为这个节点的计算比较慢、也有可能是节点宕机、也有可能是网络延迟或网络中断，很难判断到底是发生了什么故障。因此，可以简单将同步分布式系统和异步分布式系统的最大区别理解为故障是否可以检测。</p><h1 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h1><p>在分布式系统中，故障可能发生在节点或者通信链路上，按照出现的范围和困难程度可以将故障模型划分为以下几个类型：</p><ol><li><p><strong>byzantine failure（拜占庭故障，随机故障）</strong><br>这是最难处理的情况，它可能出现在进程中，也可能出现在网络上，此时可能发生任何类型的错误。进程的随机故障是指进程随机地省略一些必要的步骤或者执行一些不需要的步骤，即进程根本不按照程序的逻辑执行，对它的调用会返回随意的或者错误的结果。进程的随机故障不能通过查看进程是否应答调用来检测，因为它可能会随机地遗漏应答。网络也会出现随机故障，比如消息内容被破坏、传递不存在的消息，也有可能多次传递同一个消息。网络的随机故障通常很少，因为通信软件能够识别这类故障并拒绝出错的消息。</p></li><li><p><strong>crash-recovery failure（崩溃-恢复）</strong><br>对拜占庭故障增加了一个限制，那就是节点总是会按照程序逻辑执行，进程结果是正确的，但是不保证消息返回的时间。原因可能是节点 crash 后又重新拉起了，或者网络中断了，或者网络延迟很高。而对于 crash 还要分为健忘的和非健忘的两种。健忘的是指 crash 的节点丢失了之前的状态；而非健忘的是指节点在 crash 之前已经将状态持久化了，重启后会恢复之前的状态。比如 Basic Paxos 中要求节点必须把 ballot number 持久化，一旦 crash，重启后可以恢复。</p></li><li><p><strong>omission failure（遗漏故障）</strong><br>它比 crash-recovery 多了一个限制，就是发生故障后，消息不会恢复。典型的就是由于网络故障造成的消息丢失。</p></li><li><p><strong>crash-stop failure（崩溃-停止）</strong><br>也可以认为是 crash failure 或者 fail-stop failure，它比 omission failure 更容易处理，因为这种就是 crash 故障，且故障后不会恢复。比如一个节点 crash 后立即停止接收和发送消息。</p></li></ol><p>分布式系统中的故障模型还有其他分类的方式，有的还会加入 performance failure，有的则把 crash 与 fail-stop 分开，这里提供的只是其中一种使用较为广泛的分类方式，它们的关系如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008131351/2020/08/11/PBq.png" alt="故障模型"></p><h1 id="liveness-和-safety"><a href="#liveness-和-safety" class="headerlink" title="liveness 和 safety"></a>liveness 和 safety</h1><p>liveness 和 safety 的概念最早由 Lamport 提出，这两个属性是分布式系统中非常基础的属性，其他属性都可以被分解为这两个属性。</p><ul><li>safety: something “bad” will never happen</li><li>liveness: something “good” will must happen (but we don’t know when)</li></ul><p>用更加通俗的话来说，safety 属性是指程序不会进入非预期的状态，而 liveness 属性是指程序预期的状态一定会达到。比如最终一致性就是 liveness 的，如果算法能在有限的步骤内完成，那么系统一定是 liveness 的。虽然它们俩是正交的概念，但是在设计分布式系统的时候，我们需要同时考虑这两个属性，只具备其中之一属性的系统是没有意义的。</p><h1 id="Consensus"><a href="#Consensus" class="headerlink" title="Consensus"></a>Consensus</h1><p>共识问题是分布式系统中最基础也是最重要的问题之一，而关于共识的定义主要包含三个部分：</p><ul><li>终止性（termination）：每个进程最终会在有限的步骤中结束并决定一个值，算法不会无尽地执行下去。</li><li>协定性（agreement）：所有的非故障进程决定的值都相同。</li><li>完整性或有效性（validity）：如果所有非故障的进程都提议一个值，那么最终所有非故障进程都会选择该值。</li></ul><p>根据应用的不同，完整性的定义也会有所变化。比如，一种较弱的完整性是决定值等于某些非故障进程提议的值，而不必是所有进程提议的值。在这共识问题的三要素中，termination 是 liveness 的保证，agreement 和 validity 则是 safety 的保证，liveness 和 safety 就像一对死对头。</p><p>一般来说，很多在拜占庭故障模型下的共识算法都是在同步网络的假设下设计的，因为同步网络使得故障检测成为了可能。而在异步网络中，想要同时保证 liveness 和 safety 是很困难的，如果是拜占庭式的故障，Paxos 和 Raft 是没有办法解决的，直到 PBFT（Practical Byzantine Fault Tolerance）的提出，我们才可以在放松 liveness 的情况下来解决此类问题。对于一般的应用来说，出现拜占庭故障的概率太低但是解决的成本却过高，所以我们通常不考虑拜占庭式的故障，我们主要关注的是 crash-recovery failure 模型下的异步网络，此时根据 FLP 理论，只要有一个故障节点，Paxos 和 Raft 都是有可能进入无限循环而无法结束，但是如果我们放松 liveness 的要求，这个问题还是可以解决的。</p><h1 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h1><p>1982 年 Lamport 和另外两位科学家发表了名为：<a href="http://lamport.azurewebsites.net/pubs/byz.pdf">The Byzantine Generals Problem</a> 的论文，文中提供了一个共识问题的情景化的描述：拜占庭帝国的几个师在攻打敌军，每个师都有一个将军，将军们只能通过信使沟通。他们的行动计划有两种：进攻和撤退，并且只有在超过半数以上的将军发起进攻时才能取得最终胜利。然而，其中的一些将军可能是叛徒，为了阻止其他将军达成一致的行动计划，可能会传递错误的消息。更糟糕的是，负责传递消息的信使也有可能是叛徒，他们也有可能篡改或伪造消息，也可能丢失消息。</p><p>我们将这个场景放到分布式系统中来看，这种情况意味着不仅网络会出故障，节点本身也可能不会按照逻辑执行。完整的拜占庭将军问题比较复杂，必须加上一些特定的假设才能解决，比如同步网络，即：<strong>在同步网络中，如果有 m 个故障节点，那么至少需要 3m + 1 个节点才能最终达成一致的行动方案</strong>。</p><p>我们可以考虑一种最基本的情况，假设有三个将军，只有一个是叛徒，比如 C，那么 C 可能会给 B 发送进攻指令，给 A 发送撤退指令，这个时候 A 收到了足够多的撤退指令，而 B 收到了足够多的进攻指令，从而导致 B 选择进攻，最终战败。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008131351/2020/08/13/9lo.png" alt="拜占庭将军问题"></p><h1 id="FLP-定理"><a href="#FLP-定理" class="headerlink" title="FLP 定理"></a>FLP 定理</h1><p>1985 年，一篇名为 <a href="https://dl.acm.org/doi/10.1145/3149.214121">Impossibility of distributed consensus with one faulty process</a> 的论文告诉了我们一个重要的事实，即：</p><blockquote><p>No completely asynchronous consensus protocol can tolerate even a single unannounced process death.</p></blockquote><p>用简单的话来说就是，在异步网络环境中，即使只有一个进程出现故障，也无法实现任何安全的共识算法。这里的 unannounced process death 是指一个进程停止工作了，但是其他节点并不知道，其他节点认为可能是消息延迟或者这个进程计算较慢。FLP 定理假设节点的故障只限于 crash failure，并不考虑拜占庭故障（do not consider Byzantine failures），同时假定消息通道是可靠的，消息可能延迟但不会丢失，且只会被传递一次（the message system is reliable, it delivers all messages correctly and exactly once）。</p><p>FLP 中假定的模型是一个比现实情况更加可靠的模型，因此，如果连相对可靠的模型下都做不到一致性，那么在现实中就更加不可能了。因此这个定理的重要性不言而喻，他终止了多年的争论，现在已经没有必要再去试图设计一个能在异步网络环境下能够容忍各种故障同时又能保证一致性的系统了。</p><h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><p>这里简单将共识算法分为两大类：一类是故障容错算法（Crash Fault Tolerance），也就是非拜占庭容错算法；另一类是拜占庭容错算法。</p><p>非拜占庭容错算法解决的是分布式系统中存在故障（crash failure），但是不存在恶意攻击等场景下的共识问题，也就是说，消息可能丢失或者重复，但是消息不会被篡改或者伪造。一般用于局域网场景下的分布式系统，比如分布式数据库等。常见的此类算法有：Paxos、Raft 和 ZAB 等。</p><p>拜占庭容错算法可以解决分布式系统中即存在故障，有存在恶意攻击的场景下的共识问题，一般用于互联网场景下的分布式系统，比如数字货币中的区块链技术。常见的此类算法有：PBFT、PoW 等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要简单概括一下分布式系统中的网络和故障模型、共识问题、拜占庭将军问题、FLP 定理等等。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统与一致性模型</title>
    <link href="https://blog.nekolr.com/2020/08/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://blog.nekolr.com/2020/08/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-06T15:57:00.000Z</published>
    <updated>2023-04-20T09:51:11.110Z</updated>
    
    <content type="html"><![CDATA[<p>对于一致性模型的研究从共享内存的多核并行计算就开始了，然后又顺理成章的推广到了基于网络通信的多节点协同系统中。</p><span id="more"></span><p>一致性的定义应该来源于并行系统，而我们平常所关注的分布式系统其实只是并行系统的一部分。当然，关于分布式系统的定义众说纷纭。Lamport 在 1983 年的 PODC 会议上指出，广义上的分布式系统是一个相对的概念，不同的实体所看到的会有所不同。</p><p>由于分布式系统存在多个节点或多个副本的特点，因此会有一致性的问题。从系统的角度来看，一致性关注的是不同节点之间的数据或状态的一致程度；而从使用者的角度来看，一致性反映的是系统对外提供的服务所表现出来的特征，同时一致性也不光是各个节点最终对一个值的结果保持一致，很多时候还需要对这个值的变化历史在各个节点上保持一致。</p><h1 id="线性一致性（Linearizability）"><a href="#线性一致性（Linearizability）" class="headerlink" title="线性一致性（Linearizability）"></a>线性一致性（Linearizability）</h1><p>Herlihy 和 Wing 在 1990 年发表的一篇论文：<a href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">Linearizability: A Correctness Condition for Concurrent Objects</a> 中提出了线性一致性的概念。论文中的线性一致性是一个单对象（single-object）模型，但是对象的范围可能有所不同，比如对象是整个分布式系统，也可以是键值存储系统中的各个键。</p><p>比如在一个分布式数据库中，我们可以把整个系统看作一个对象，如果该系统支持线性一致性，那么客户端对于该数据库的单个读写操作就需要满足：每个客户端的每个读操作都必须返回最近一次写操作的值。其中的最近一次表明读写的先后顺序是由一个统一的实际事件来决定的。比如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/07/5JM.png" alt="线性一致性1"></p><p>其中 Inv(W) 代表 W 操作的开始，Res(W) 代表 W 操作的结束。P1 和 P2 两个进程都是先调用 W 操作来写变量 x，然后再调用 R 操作读 x。P1 与 P2 的操作在时间上彼此互不重叠，因此“最近的一次操作”一目了然。</p><p>但在真实的系统中，不同进程间并发的读写操作必然会出现时间上的重叠，针对这种情况又该如何定义“最近”这个概念呢？我们首先要知道一点就是：任何读操作或者写操作必然在操作开始和结束的之间某个点生效，在写操作生效后的读操作必然会读到该写操作的值。因此对于所有的客户端而言，这就好像采用了某种顺序来串行地（并非通过锁形成的串行）执行所有进程的读写操作。比如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/07/kzQ.png" alt="线性一致性2"></p><p>线性一致性总结起来就是要求系统表现的如同一个单一的副本，然后按照某种时间顺序来串行地执行所有进程的读写操作。需要注意的是，这里的操作并没有使用锁等方式来限制并发，但是所有的操作最终会在时间轴上连成一串。</p><h1 id="顺序一致性（Sequential-Consistency）"><a href="#顺序一致性（Sequential-Consistency）" class="headerlink" title="顺序一致性（Sequential Consistency）"></a>顺序一致性（Sequential Consistency）</h1><p>早在 1979 年，Lamport 就在一篇论文：<a href="http://lamport.azurewebsites.net/pubs/multi.pdf">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Program</a> 中提出了顺序一致性的概念：</p><blockquote><p>A multiprocessor system is sequentially consistent if the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p></blockquote><p>上述定义基于共享内存的多处理器系统，但是我们可以将这种系统理解成一个同步分布式模型，从而扩展该定义到分布式领域。用通俗的语言来说，这个定义包含两部分：<strong>第一是事件的历史在各个进程来看是全局一致的，即各个进程对于事件的历史观点一致；第二是单个进程的事件历史在全局历史上应符合编程的顺序（program order），即单个进程上发生的事件放到全局来看也应该保持相同的顺序。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/08/Eqd.png" alt="顺序一致性1"></p><p>在上图中，明显例子 A 是符合顺序一致性定义的，不过例子 B 也同样符合顺序一致性的定义。虽然在例子 B 中进程 P2 和 P3 对于 x 历史顺序的认知与真实时间发生的不一致，但是至少它们“错”的一致，这是符合定义的。如果对于 x 的两次写入都发生在同一个进程，比如 P0，那么例子 B 中出现的顺序不符合定义的第二条，即它不满足顺序一致性。而对于下图中的例子，明显不符合顺序一致性的定义。</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008081237/2020/08/08/ekQ.png" alt="顺序一致性2"></p><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>顺序一致性与线性一致性相比，最大的不同就是它放松了对于一致性的要求，不再要求操作的顺序严格按照时间进行，只要求存在一致的全序关系即可。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://jepsen.io/consistency">Consistency Models</a></p></blockquote><blockquote><p><a href="http://www.bailis.org/blog/linearizability-versus-serializability/">Linearizability versus Serializability</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于一致性模型的研究从共享内存的多核并行计算就开始了，然后又顺理成章的推广到了基于网络通信的多节点协同系统中。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单理解分布式系统与时钟</title>
    <link href="https://blog.nekolr.com/2020/08/04/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%97%B6%E9%92%9F/"/>
    <id>https://blog.nekolr.com/2020/08/04/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%97%B6%E9%92%9F/</id>
    <published>2020-08-04T15:10:00.000Z</published>
    <updated>2023-04-20T09:51:11.114Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统中，不同节点的物理时钟很难实现完全一致，即使我们给所有节点一个相同的起始时间，在经过一段时间后，节点之间的物理时钟也有很大可能会出现不一致。导致这种问题的根本原因是由于计算机的时钟是通过晶体振荡器实现的。晶体振荡器在通电后，内部的石英晶体会产生谐振，这种震荡的频率是稳定和精确的，比如为 10 MHz，处理器可以根据晶振的波形（震荡的次数）来计算时间。但是由于晶振的频率会受到温度变化的影响，因此机器工作时的温度变化会导致时钟过快或过慢，从而影响时钟的准确性。</p><span id="more"></span><p>选用高精度的晶振固然可以减缓这个问题，但是高精度的晶振同样成本也高。而采用 NTP 时钟同步虽然可以矫正时间，但是由于网络延迟、同步频率等因素的影响，各个节点的物理时钟还是很难保持精确一致。</p><p>当应用程序需要协作时，它们通过交换信息来协调它们的动作，而密切的协作通常取决于对程序动作发生时间的共识，达成共识的前提是我们需要知道一个事件发生的时间，也就是时间序列或者时间戳。在单体应用中，时间序列的获取是很容易的，即使计算机的时间与真实时间有出入，但是只要在一个计算机内，不同的进程获取的时间序列之间的顺序性是可以保证的（不考虑时钟回拨）；而在分布式应用中，不同机器的时钟很可能不同，并且我们也很难通过普通的手段实现多节点之间的时钟同步，这样也就无法确定系统中事件发生的顺序。</p><p>然而实际在很多应用中，机器不一定要求跟实际时间相一致，只需要所有的机器具有相同的时间就够了。或者更进一步来说，分布式应用中节点的交互只要在事件发生的顺序上达成共识即可，不需要对事件发生的时间达成共识。</p><h1 id="Lamport-逻辑时钟"><a href="#Lamport-逻辑时钟" class="headerlink" title="Lamport 逻辑时钟"></a>Lamport 逻辑时钟</h1><p>1978 年 Lamport 在《Time, Clocks and the Ordering of Events in a Distributed System》中提出了逻辑时钟的概念，通过判断事件的因果关系来决定事件的先后顺序。</p><h2 id="偏序（Partial-Ordering）"><a href="#偏序（Partial-Ordering）" class="headerlink" title="偏序（Partial Ordering）"></a>偏序（Partial Ordering）</h2><p>在论文中，作者将事件序列分为了两种：偏序事件序列和全序事件序列。所谓偏序指的是只为系统中的部分事件定义先后顺序，这里的部分事件指的是具有因果关系的事件，这种因果关系可以理解为在分布式系统中节点是否存在交互，同时根据这种因果关系可以将事件分为三类，一类发生在节点（或者进程）内部的事件，一类是发送消息的事件，一类是接收消息的事件。同时作者还定义了一种叫做 happened before 的偏序关系，这种关系具有以下几个规则：</p><ol><li>如果事件 a 和事件 b 在同一个进程中发生，并且 a 在 b 之前发生，那么记作 <code>a -&gt; b</code>。</li><li>如果事件 a 是发送消息，事件 b 是接收该消息，那么 a 在 b 之前发生（消息的传递需要时间），记作 <code>a -&gt; b</code>。</li><li>如果 <code>a -&gt; b</code>，并且 <code>b -&gt; c</code>，那么 <code>a -&gt; c</code>。另外如果两个事件 a 和 b 既不满足 <code>a -&gt; b</code>，也不满足 <code>b -&gt; a</code>，那么可以说两个事件是并发（concurrent）的。</li></ol><p>实际上，在分布式系统中，只有两个发生关联（进行过数据交换）的事件，我们才会去关心两者发生的先后顺序，而对于不存在交互的并发事件，我们可以不用考虑它们的时序问题。</p><h2 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h2><p>Lamport 逻辑时钟是一个单调增长的软件计数器，它的值与任何物理时钟无关。这个逻辑时钟的规则如下：</p><ol><li>每个节点在本地维护一个 logic clock 记作 LC<sub>i</sub>，每个事件对应一个 Lamport Timestamp，初始值为 0。</li><li>如果事件在节点内发生，则本地时间戳加 1，即 LC<sub>i</sub> &#x3D; LC<sub>i</sub> + 1。</li><li>如果事件是发送事件，那么本地时间戳加 1，并在消息中带上该时间戳。</li><li>如果事件是接收事件，那么在收到消息后 LC<sub>j</sub> &#x3D; max(LC<sub>j</sub>, 消息中的时间戳) + 1。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008061549/2020/08/05/qEO.png" alt="逻辑时钟，来源于 wikipedia"></p><p>通过这种算法，可以保证如果 a -&gt; b，那么 C(a) &lt; C(b)，但是无法通过比较两个逻辑时钟的大小来得到 a 和 b 的先后顺序，比如下面这种：</p><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008061549/2020/08/05/4q6.png" alt="逆命题不成立"></p><p>逻辑时间为 56 的事件向另一个事件发送消息，从而得到另一个事件的逻辑时间为 62，尽管它的逻辑时间小于 61，但是它却是在逻辑时间为 61 的事件之后发生的。</p><h2 id="全序（Total-ordering）"><a href="#全序（Total-ordering）" class="headerlink" title="全序（Total ordering）"></a>全序（Total ordering）</h2><p>通过定义，我们知道如果 a -&gt; b，那么 C(a) &lt; C(b)，但是如果 C(a) &#x3D; C(b) 的时候，a 与 b 应该是什么先后顺序呢？由于它们肯定不是因果关系，所以它们之间的先后顺序其实并不会影响结果，我们只需要给出一种确定的方式来定义它们之间的先后顺序，就可以得到一个全序关系。一种可行的方式是给进程编号，并根据进程编号的大小来排序。在上图中我们假设进程 A、B、C 的编号分别为 1、2、3，那么虽然 C(B4) &#x3D; C(C3)，但是由于 B 的编号小于 C，所以它们的先后顺序是 B4 -&gt; C3。但是从上图还会发现，从时间轴来看 B5 应该早于 A3 发生，但是我们给出的全序关系中 A3 却是早于 B5 的，<strong>这是因为 Lamport 逻辑时钟只能保证因果关系的正确性，无法保证时序的正确性。同时全序关系也不是唯一的，与选定的方式有关。</strong></p><h1 id="向量时钟（Vector-Clock）"><a href="#向量时钟（Vector-Clock）" class="headerlink" title="向量时钟（Vector Clock）"></a>向量时钟（Vector Clock）</h1><p>Vector Clock 是在 Lamport 逻辑时钟的基础上演进的另一种逻辑时钟算法，它使用 Vector 结构不光记录本节点的 Lamport 时间戳，同时还会记录其他节点的 Lamport 时间戳。具体来说，每个节点都维护一个向量 VC，同时在这个向量中：VC<sub>i</sub>[i] 是到目前为止节点 i 上发生的事件的个数，而 VC<sub>i</sub>[k] 则为节点 i 知道节点 k 中发生的事件的个数。向量时钟通过以下算法进行更新：</p><ol><li>节点 i 本地发生的事件会将 VC<sub>i</sub> 加 1。</li><li>节点 i 给节点 j 发送消息时，会将整个 VC<sub>i</sub> 存在消息中。</li><li>节点 j 收到消息后，VC<sub>j</sub>[k] &#x3D; max(VC<sub>j</sub>[k], VC<sub>i</sub>[k])，同时 VC<sub>j</sub>[j] 加 1。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202008061549/2020/08/06/xdq.png" alt="Vector Clock"></p><h2 id="为什么使用向量时钟"><a href="#为什么使用向量时钟" class="headerlink" title="为什么使用向量时钟"></a>为什么使用向量时钟</h2><p>对于一个数据库系统（或者存储系统）来说，需要一种机制来界定事务或者操作的先后顺序，如果是单机数据库，可以在事务提交时通过获取时间戳作为事务 ID，时间戳小的事务即为更早提交的事务。而到了分布式系统中，如果是单点写，则同样可以沿用这种方式；但是如果是一个支持多点写的系统，那么机器之间必然存在时钟误差，如果多个节点对同一条记录进行修改，那么就有可能出现在 wall time 上先提交的事务的 ID 反而更小，此时就可以通过向量时钟来处理这种冲突。</p><p>2007 年亚马逊的一篇论文：<a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf">Dynamo: Amazon’s Highly Available Key-value Store</a> 提到了亚马逊的 Dynamo 使用了 Vector Clock（Version Clock），但似乎在很早的时候就已经摒弃了这种做法。原因可能与向量时钟的缺陷有关，首先每次请求都要先向对方获取一次版本，这在性能上不好接受。向量时钟只能帮助发现冲突，但无法解决冲突。Cassandra 之前就发表过一篇文章：<a href="https://www.datastax.com/blog/2013/09/why-cassandra-doesnt-need-vector-clocks">Why Cassandra doesn’t need vector clocks</a> 说明了他们为何没有使用向量时钟。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">《Time, Clocks and the Ordering of Events in a Distributed System》</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/foxmailed/p/4985848.html">Vector Clock&#x2F;Version Clock</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/19994133">分布式数据库中为什么要使用 Vector Clock？</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式系统中，不同节点的物理时钟很难实现完全一致，即使我们给所有节点一个相同的起始时间，在经过一段时间后，节点之间的物理时钟也有很大可能会出现不一致。导致这种问题的根本原因是由于计算机的时钟是通过晶体振荡器实现的。晶体振荡器在通电后，内部的石英晶体会产生谐振，这种震荡的频率是稳定和精确的，比如为 10 MHz，处理器可以根据晶振的波形（震荡的次数）来计算时间。但是由于晶振的频率会受到温度变化的影响，因此机器工作时的温度变化会导致时钟过快或过慢，从而影响时钟的准确性。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://blog.nekolr.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
